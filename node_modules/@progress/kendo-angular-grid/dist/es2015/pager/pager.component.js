/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { Component, Input, EventEmitter, Output, HostBinding, ElementRef, Renderer2, HostListener, NgZone, Optional, Inject } from '@angular/core';
import { normalize } from './pager-settings';
import { PagerTemplateDirective } from './pager-template.directive';
import { anyChanged, replaceMessagePlaceholder } from '../utils';
import { PagerContextService } from './pager-context.service';
import { Subscription } from 'rxjs';
import { RESPONSIVE_BREAKPOINT_LARGE, RESPONSIVE_BREAKPOINT_MEDIUM } from '../constants';
import { NavigationService } from '../navigation/navigation.service';
import { take } from 'rxjs/operators';
import { CELL_CONTEXT } from '../rendering/common/cell-context';
import { FocusGroup } from '../navigation/focus-group';
import { FocusRoot, FOCUS_ROOT_ACTIVE } from '../navigation/focus-root';
import { findFocusableChild, findLastFocusableChild } from '../rendering/common/dom-queries';
/**
 * @hidden
 */
let PagerComponent = class PagerComponent {
    constructor(pagerContext, navigationService, element, renderer, zone, localizationService, cellContext, focusRoot, focusGroup) {
        this.pagerContext = pagerContext;
        this.navigationService = navigationService;
        this.element = element;
        this.renderer = renderer;
        this.zone = zone;
        this.localizationService = localizationService;
        this.cellContext = cellContext;
        this.focusRoot = focusRoot;
        this.focusGroup = focusGroup;
        this.total = 0;
        this.skip = 1;
        this.pageChange = new EventEmitter();
        this.pagerWrapClass = true;
        this.gridPagerClass = true;
        this.settings = normalize({});
        this.subscriptions = new Subscription();
        this._templateContext = {};
        this._isFocused = false;
        this.resizeHandler = () => {
            const element = this.element.nativeElement;
            if (this.template || !element) {
                return;
            }
            const width = element.offsetWidth;
            if (width < RESPONSIVE_BREAKPOINT_MEDIUM) {
                this.renderer.removeClass(element, 'k-pager-md');
                this.renderer.addClass(element, 'k-pager-sm');
            }
            else if (width >= RESPONSIVE_BREAKPOINT_MEDIUM && width < RESPONSIVE_BREAKPOINT_LARGE) {
                this.renderer.addClass(element, 'k-pager-md');
                this.renderer.removeClass(element, 'k-pager-sm');
            }
            else {
                this.clearResponsiveClasses();
            }
        };
    }
    set options(value) {
        this.settings = normalize(value);
    }
    get isFocused() {
        return this._isFocused;
    }
    get pagerAriaLabel() {
        return this.navigationService.enabled ? this.pagerLabel : undefined;
    }
    /**
     * @hidden
     */
    get pagerLabel() {
        const localizationMsg = this.localizationService.get('pagerLabel') || '';
        return replaceMessagePlaceholder(replaceMessagePlaceholder(localizationMsg, 'currentPage', this.currentPage.toString()), 'totalPages', this.totalPages.toString());
    }
    get focusTrapTabIndex() {
        return this.focusGroup.isActive ? '0' : '-1';
    }
    onFocusIn(event) {
        if (this.navigationService.enabled) {
            const shouldFocusPager = event.target === this.element.nativeElement;
            if (shouldFocusPager) {
                this._isFocused = true;
                this.focusRoot.deactivate();
            }
            else {
                this.focusRoot.activate();
            }
        }
    }
    onFocusOut() {
        if (this.navigationService.enabled) {
            this._isFocused = false;
        }
    }
    onEscape() {
        if (this.navigationService.enabled) {
            this.focusRoot.deactivate();
            this.element.nativeElement.focus();
        }
    }
    onEnter(event) {
        if (this.navigationService.enabled && event.target === this.element.nativeElement) {
            this.focusRoot.activate();
            this.focusFirstElement();
        }
    }
    navigateToPreviousPage(e) {
        if (this.shouldTriggerPageChange(e.target, this.currentPage > 1)) {
            this.pagerContext.prevPage();
        }
    }
    navigateToNextPage(e) {
        if (this.shouldTriggerPageChange(e.target, this.currentPage < this.totalPages)) {
            this.pagerContext.nextPage();
        }
    }
    navigateToFirstPage(e) {
        if (this.shouldTriggerPageChange(e.target, this.currentPage > 1)) {
            this.pagerContext.changePage(0);
        }
    }
    navigateToLastPage(e) {
        if (this.shouldTriggerPageChange(e.target, this.currentPage < this.totalPages)) {
            this.pagerContext.changePage(this.totalPages - 1);
        }
    }
    get totalPages() {
        return Math.ceil((this.total || 0) / this.pageSize);
    }
    get currentPage() {
        return Math.floor((this.skip || 0) / this.pageSize) + 1;
    }
    get templateContext() {
        const context = this._templateContext;
        context.totalPages = this.totalPages;
        context.total = this.total;
        context.skip = this.skip;
        context.pageSize = this.pageSize;
        context.currentPage = this.currentPage;
        return context;
    }
    ngOnInit() {
        this.subscriptions.add(this.pagerContext.pageChange.subscribe(this.changePage.bind(this)));
        if (this.navigationService.enabled) {
            this.focusRoot.deactivate();
        }
    }
    ngDoCheck() {
        this.updateCellContext();
    }
    ngOnChanges(changes) {
        if (anyChanged(['pageSize', 'skip', 'total'], changes, false)) {
            this.pagerContext.notifyChanges({
                pageSize: this.pageSize,
                skip: this.skip,
                total: this.total
            });
        }
        if (changes.template) {
            changes.template.currentValue ? this.clearResponsiveClasses() : this.resizeHandler();
        }
        if (changes.options) {
            this.settings.responsive ? this.resizeHandler() : this.clearResponsiveClasses();
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    changePage(event) {
        this.pageChange.emit(event);
    }
    onInnerFocusIn(event, position) {
        this.zone.onStable.pipe(take(1)).subscribe(() => {
            if (position === 'start') {
                if (event.relatedTarget === this.element.nativeElement) {
                    this.focusFirstElement();
                }
                else {
                    this.focusLastElement();
                }
            }
            else {
                this.focusFirstElement();
            }
        });
    }
    clearResponsiveClasses() {
        const element = this.element.nativeElement;
        this.renderer.removeClass(element, 'k-pager-sm');
        this.renderer.removeClass(element, 'k-pager-md');
    }
    shouldTriggerPageChange(target, condition) {
        return this.navigationService.enabled &&
            target === this.element.nativeElement &&
            condition;
    }
    focusFirstElement() {
        const first = findFocusableChild(this.element.nativeElement, true);
        if (first) {
            first.focus();
        }
    }
    focusLastElement() {
        const last = findLastFocusableChild(this.element.nativeElement, true);
        if (last) {
            last.focus();
        }
    }
    updateCellContext() {
        if (this.cellContext) {
            this.cellContext.focusGroup = this.focusGroup;
        }
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], PagerComponent.prototype, "total", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], PagerComponent.prototype, "skip", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], PagerComponent.prototype, "pageSize", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], PagerComponent.prototype, "options", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", PagerTemplateDirective)
], PagerComponent.prototype, "template", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], PagerComponent.prototype, "pageChange", void 0);
tslib_1.__decorate([
    HostBinding('class.k-pager-wrap'),
    tslib_1.__metadata("design:type", Boolean)
], PagerComponent.prototype, "pagerWrapClass", void 0);
tslib_1.__decorate([
    HostBinding('class.k-grid-pager'),
    tslib_1.__metadata("design:type", Boolean)
], PagerComponent.prototype, "gridPagerClass", void 0);
tslib_1.__decorate([
    HostBinding('class.k-state-focused'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], PagerComponent.prototype, "isFocused", null);
tslib_1.__decorate([
    HostBinding('attr.aria-label'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [])
], PagerComponent.prototype, "pagerAriaLabel", null);
tslib_1.__decorate([
    HostListener('focusin', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], PagerComponent.prototype, "onFocusIn", null);
tslib_1.__decorate([
    HostListener('focusout'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PagerComponent.prototype, "onFocusOut", null);
tslib_1.__decorate([
    HostListener('keydown.escape'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PagerComponent.prototype, "onEscape", null);
tslib_1.__decorate([
    HostListener('keydown.enter', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], PagerComponent.prototype, "onEnter", null);
tslib_1.__decorate([
    HostListener('keydown.arrowleft', ['$event']),
    HostListener('keydown.pageup', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], PagerComponent.prototype, "navigateToPreviousPage", null);
tslib_1.__decorate([
    HostListener('keydown.arrowright', ['$event']),
    HostListener('keydown.pagedown', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], PagerComponent.prototype, "navigateToNextPage", null);
tslib_1.__decorate([
    HostListener('keydown.home', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], PagerComponent.prototype, "navigateToFirstPage", null);
tslib_1.__decorate([
    HostListener('keydown.end', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], PagerComponent.prototype, "navigateToLastPage", null);
PagerComponent = tslib_1.__decorate([
    Component({
        selector: 'kendo-pager',
        providers: [{
                provide: FOCUS_ROOT_ACTIVE,
                useValue: true
            }, {
                provide: FocusRoot,
                deps: [FOCUS_ROOT_ACTIVE],
                useClass: FocusRoot
            }, {
                provide: FocusGroup,
                deps: [FocusRoot],
                useClass: FocusGroup
            }],
        template: `
        <div
            *ngIf="navigationService.enabled"
            class="k-sr-only"
            [tabindex]="focusTrapTabIndex"
            [attr.aria-hidden]="true"
            (focusin)="onInnerFocusIn($event, 'start')">
        </div>
        <ng-container
            *ngIf="template?.templateRef"
            [ngTemplateOutlet]="template.templateRef"
            [ngTemplateOutletContext]="templateContext">
        </ng-container>
        <ng-container *ngIf="!template?.templateRef">
            <kendo-pager-prev-buttons *ngIf="settings.previousNext"></kendo-pager-prev-buttons>
            <kendo-pager-numeric-buttons
                *ngIf="settings.type === 'numeric'"
                [buttonCount]="settings.buttonCount">
            </kendo-pager-numeric-buttons>
            <kendo-pager-input *ngIf="settings.type === 'input'"></kendo-pager-input>
            <kendo-pager-next-buttons *ngIf="settings.previousNext"></kendo-pager-next-buttons>
            <kendo-pager-info *ngIf='settings.info'></kendo-pager-info>
            <kendo-pager-page-sizes
                *ngIf="settings.pageSizes"
                [pageSizes]="settings.pageSizes"
                #pageSizes
            ></kendo-pager-page-sizes>
        </ng-container>
        <div
            *ngIf="navigationService.enabled"
            class="k-sr-only"
            [tabindex]="focusTrapTabIndex"
            [attr.aria-hidden]="true"
            (focusin)="onInnerFocusIn($event, 'end')">
        </div>
        <kendo-resize-sensor *ngIf="settings.responsive" (resize)="resizeHandler()"></kendo-resize-sensor>
  `
    }),
    tslib_1.__param(6, Optional()), tslib_1.__param(6, Inject(CELL_CONTEXT)),
    tslib_1.__metadata("design:paramtypes", [PagerContextService,
        NavigationService,
        ElementRef,
        Renderer2,
        NgZone,
        LocalizationService, Object, FocusRoot,
        FocusGroup])
], PagerComponent);
export { PagerComponent };
