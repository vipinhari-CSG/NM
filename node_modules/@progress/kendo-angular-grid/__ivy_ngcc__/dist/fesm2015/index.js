/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { InjectionToken, HostBinding, Input, Component, EventEmitter, Injectable, Optional, Inject, Directive, SkipSelf, ElementRef, Renderer2, NgZone, ChangeDetectorRef, TemplateRef, QueryList, isDevMode, ContentChildren, ContentChild, forwardRef, Host, Output, SecurityContext, ViewChild, ViewChildren, ViewEncapsulation, Self, ViewContainerRef, Pipe, NgModule, ComponentFactoryResolver, HostListener, ChangeDetectionStrategy } from '@angular/core';
import { isDocumentAvailable, Keys, DraggableDirective, isChanged, anyChanged, hasObservers, ResizeSensorComponent, KendoInput, DraggableModule, EventsModule, ResizeSensorModule, guid } from '@progress/kendo-angular-common';
import { merge, of, Subject, Subscription, from, interval, fromEvent, zip, BehaviorSubject, Observable } from 'rxjs';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { switchMap, take, filter, takeUntil, map, switchMapTo, delay, auditTime, distinctUntilChanged, tap, throttleTime, debounceTime, bufferCount } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { FormControl, FormGroup, NG_VALUE_ACCESSOR, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { validatePackage } from '@progress/kendo-licensing';
import { orderBy, process, isCompositeFilterDescriptor, filterBy } from '@progress/kendo-data-query';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import { DomSanitizer } from '@angular/platform-browser';
import { getter } from '@progress/kendo-common';
import { DropDownListComponent, DropDownListModule, AutoCompleteModule, DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { InputsModule, NumericTextBoxComponent, NumericTextBoxModule } from '@progress/kendo-angular-inputs';
import { DatePickerModule } from '@progress/kendo-angular-dateinputs';
import { IntlService } from '@progress/kendo-angular-intl';
import { LabelModule } from '@progress/kendo-angular-label';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { Button } from '@progress/kendo-angular-buttons';
import { PDFExportMarginComponent, PDFExportTemplateDirective, PDFExportComponent } from '@progress/kendo-angular-pdf-export';
import { saveAs } from '@progress/kendo-file-saver';
import { workbookOptions, toDataURL, ColumnBase, ExcelExportModule } from '@progress/kendo-angular-excel-export';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@progress/kendo-angular-common';
import * as ɵngcc3 from '@progress/kendo-angular-popup';
import * as ɵngcc4 from '@angular/platform-browser';
import * as ɵngcc5 from '@angular/common';
import * as ɵngcc6 from '@progress/kendo-angular-inputs';
import * as ɵngcc7 from '@angular/forms';
import * as ɵngcc8 from '@progress/kendo-angular-dropdowns';
import * as ɵngcc9 from '@progress/kendo-angular-dateinputs';
import * as ɵngcc10 from '@progress/kendo-angular-intl';
import * as ɵngcc11 from '@progress/kendo-angular-label';

const _c0 = ["lockedHeader"];
const _c1 = ["header"];
const _c2 = ["ariaRoot"];
const _c3 = ["footer"];
function GridComponent_kendo_grid_toolbar_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-toolbar", 11);
} }
function GridComponent_kendo_pager_3_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-pager", 12);
    ɵngcc0.ɵɵlistener("pageChange", function GridComponent_kendo_pager_3_Template_kendo_pager_pageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.notifyPageChange("pager", $event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabindex", ctx_r1.navigable ? "0" : "-1")("template", ctx_r1.pagerTemplate)("pageSize", ctx_r1.pageSize)("total", ctx_r1.view.total)("skip", ctx_r1.skip)("options", ctx_r1.pageable);
    ɵngcc0.ɵɵattribute("role", ctx_r1.navigable ? "navigation" : undefined);
} }
function GridComponent_kendo_grid_group_panel_4_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-grid-group-panel", 13);
    ɵngcc0.ɵɵlistener("change", function GridComponent_kendo_grid_group_panel_4_Template_kendo_grid_group_panel_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.groupChange.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("text", ctx_r2.groupableEmptyText)("groups", ctx_r2.group);
} }
function GridComponent_ng_template_7_div_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 25, 26)(2, "table", 27);
    ɵngcc0.ɵɵelement(3, "colgroup", 22)(4, "thead", 28);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵstyleProp("width", ctx_r15.lockedWidth, "px");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r15.lockedWidth, "px");
    ɵngcc0.ɵɵproperty("locked", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r15.lockedLeafColumns)("groups", ctx_r15.group)("detailTemplate", ctx_r15.detailTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("resizable", ctx_r15.resizable)("scrollable", true)("columns", ctx_r15.lockedColumns)("totalColumnLevels", ctx_r15.totalColumnLevels)("sort", ctx_r15.sort)("groups", ctx_r15.group)("filter", ctx_r15.filter)("filterable", ctx_r15.filterable)("groupable", ctx_r15.showGroupPanel)("reorderable", ctx_r15.reorderable)("sortable", ctx_r15.sortable)("columnMenu", ctx_r15.columnMenuOptions)("columnMenuTemplate", ctx_r15.columnMenuTemplate)("totalColumnsCount", ctx_r15.leafColumns.length)("detailTemplate", ctx_r15.detailTemplate)("tabIndex", ctx_r15.navigable ? "-1" : "0");
} }
function GridComponent_ng_template_7_div_0_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 29);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", ctx_r17.columnsContainer.unlockedWidth, "px");
} }
const _c142 = function () { return []; };
function GridComponent_ng_template_7_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtemplate(1, GridComponent_ng_template_7_div_0_div_1_Template, 5, 24, "div", 18);
    ɵngcc0.ɵɵelementStart(2, "div", 19, 20)(4, "table", 21);
    ɵngcc0.ɵɵelement(5, "colgroup", 22)(6, "thead", 23);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(7, GridComponent_ng_template_7_div_0_div_7_Template, 2, 2, "div", 24);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("padding", ctx_r13.headerPadding);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r13.isLocked);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("kendoGridResizableContainer", ctx_r13.lockedLeafColumns.length)("lockedWidth", ctx_r13.lockedWidth + ctx_r13.scrollbarWidth + 2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r13.nonLockedWidth, "px");
    ɵngcc0.ɵɵproperty("virtualColumns", ctx_r13.virtualColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r13.headerLeafColumns)("groups", ctx_r13.isLocked ? ɵngcc0.ɵɵpureFunction0(29, _c142) : ctx_r13.group)("detailTemplate", ctx_r13.detailTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("resizable", ctx_r13.resizable)("scrollable", true)("columns", ctx_r13.headerColumns)("totalColumnLevels", ctx_r13.totalColumnLevels)("sort", ctx_r13.sort)("filter", ctx_r13.filter)("filterable", ctx_r13.filterable)("groupable", ctx_r13.showGroupPanel)("reorderable", ctx_r13.reorderable)("groups", ctx_r13.isLocked ? ɵngcc0.ɵɵpureFunction0(30, _c142) : ctx_r13.group)("sortable", ctx_r13.sortable)("columnMenu", ctx_r13.columnMenuOptions)("columnMenuTemplate", ctx_r13.columnMenuTemplate)("lockedColumnsCount", ctx_r13.lockedLeafColumns.length)("totalColumnsCount", ctx_r13.leafColumns.length)("detailTemplate", ctx_r13.detailTemplate)("tabIndex", ctx_r13.navigable ? "-1" : "0");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r13.virtualColumns);
} }
function GridComponent_ng_template_7_div_2_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 37)(1, "table", 27);
    ɵngcc0.ɵɵelement(2, "colgroup", 35)(3, "tfoot", 38);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵstyleProp("width", ctx_r19.lockedWidth, "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", ctx_r19.lockedWidth, "px");
    ɵngcc0.ɵɵproperty("locked", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r19.lockedLeafColumns)("groups", ctx_r19.group)("detailTemplate", ctx_r19.detailTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("scrollable", true)("groups", ctx_r19.group)("columns", ctx_r19.lockedLeafColumns)("detailTemplate", ctx_r19.detailTemplate)("logicalRowIndex", ctx_r19.ariaRowCount);
} }
function GridComponent_ng_template_7_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 30);
    ɵngcc0.ɵɵtemplate(1, GridComponent_ng_template_7_div_2_div_1_Template, 4, 13, "div", 31);
    ɵngcc0.ɵɵelementStart(2, "div", 32, 33)(4, "table", 34);
    ɵngcc0.ɵɵelement(5, "colgroup", 35)(6, "tfoot", 36);
    ɵngcc0.ɵɵelementEnd()()();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("padding", ctx_r14.headerPadding);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r14.lockedLeafColumns.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("kendoGridResizableContainer", ctx_r14.lockedLeafColumns.length)("lockedWidth", ctx_r14.lockedWidth + ctx_r14.scrollbarWidth + 3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r14.nonLockedWidth, "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r14.nonLockedLeafColumns)("groups", ctx_r14.isLocked ? ɵngcc0.ɵɵpureFunction0(16, _c142) : ctx_r14.group)("detailTemplate", ctx_r14.detailTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r14.ariaRowCount)("scrollable", true)("groups", ctx_r14.isLocked ? ɵngcc0.ɵɵpureFunction0(17, _c142) : ctx_r14.group)("columns", ctx_r14.nonLockedLeafColumns)("lockedColumnsCount", ctx_r14.lockedLeafColumns.length)("detailTemplate", ctx_r14.detailTemplate);
} }
function GridComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, GridComponent_ng_template_7_div_0_Template, 8, 31, "div", 14);
    ɵngcc0.ɵɵelementStart(1, "kendo-grid-list", 15);
    ɵngcc0.ɵɵlistener("pageChange", function GridComponent_ng_template_7_Template_kendo_grid_list_pageChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.notifyPageChange("list", $event); })("scrollBottom", function GridComponent_ng_template_7_Template_kendo_grid_list_scrollBottom_1_listener() { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r23 = ɵngcc0.ɵɵnextContext(); return ctx_r23.notifyScrollBottom(); })("contentScroll", function GridComponent_ng_template_7_Template_kendo_grid_list_contentScroll_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r24 = ɵngcc0.ɵɵnextContext(); return ctx_r24.contentScroll.emit($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, GridComponent_ng_template_7_div_2_Template, 7, 18, "div", 16);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r4.hideHeader);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("data", ctx_r4.view)("rowHeight", ctx_r4.rowHeight)("detailRowHeight", ctx_r4.detailRowHeight)("total", ctx_r4.totalCount)("take", ctx_r4.pageSize)("groups", ctx_r4.group)("groupable", ctx_r4.groupable)("skip", ctx_r4.skip)("trackBy", ctx_r4.trackBy)("columns", ctx_r4.columnsContainer)("selectable", ctx_r4.selectable)("filterable", ctx_r4.filterable)("detailTemplate", ctx_r4.detailTemplate)("noRecordsTemplate", ctx_r4.noRecordsTemplate)("rowClass", ctx_r4.rowClass)("rowSticky", ctx_r4.rowSticky)("loading", ctx_r4.loading)("isVirtual", ctx_r4.isVirtual)("cellLoadingTemplate", ctx_r4.cellLoadingTemplate == null ? null : ctx_r4.cellLoadingTemplate.templateRef)("loadingTemplate", ctx_r4.loadingTemplate == null ? null : ctx_r4.loadingTemplate.templateRef)("virtualColumns", ctx_r4.virtualColumns)("enableDrag", ctx_r4.marqueeSelection);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.showFooter);
} }
function GridComponent_ng_template_8_thead_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "thead", 42);
} if (rf & 2) {
    const ctx_r25 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("resizable", ctx_r25.resizable)("scrollable", false)("columns", ctx_r25.visibleColumns)("totalColumnLevels", ctx_r25.totalColumnLevels)("groups", ctx_r25.group)("groupable", ctx_r25.showGroupPanel)("reorderable", ctx_r25.reorderable)("sort", ctx_r25.sort)("sortable", ctx_r25.sortable)("filter", ctx_r25.filter)("filterable", ctx_r25.filterable)("columnMenu", ctx_r25.columnMenuOptions)("columnMenuTemplate", ctx_r25.columnMenuTemplate)("detailTemplate", ctx_r25.detailTemplate)("tabIndex", ctx_r25.navigable ? "-1" : "0");
} }
function GridComponent_ng_template_8_tfoot_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "tfoot", 43);
} if (rf & 2) {
    const ctx_r26 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("scrollable", false)("logicalRowIndex", ctx_r26.ariaRowCount)("groups", ctx_r26.group)("columns", ctx_r26.leafColumns)("detailTemplate", ctx_r26.detailTemplate);
} }
function GridComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "table");
    ɵngcc0.ɵɵelement(1, "colgroup", 35);
    ɵngcc0.ɵɵtemplate(2, GridComponent_ng_template_8_thead_2_Template, 1, 15, "thead", 39);
    ɵngcc0.ɵɵelement(3, "tbody", 40);
    ɵngcc0.ɵɵtemplate(4, GridComponent_ng_template_8_tfoot_4_Template, 1, 5, "tfoot", 41);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("table-layout", ctx_r5.resizable ? "fixed" : null);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r5.leafColumns)("groups", ctx_r5.group)("detailTemplate", ctx_r5.detailTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r5.hideHeader);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("isLoading", ctx_r5.loading)("groups", ctx_r5.group)("data", ctx_r5.view)("skip", ctx_r5.skip)("columns", ctx_r5.leafColumns)("selectable", ctx_r5.selectable)("filterable", ctx_r5.filterable)("noRecordsTemplate", ctx_r5.noRecordsTemplate)("detailTemplate", ctx_r5.detailTemplate)("showGroupFooters", ctx_r5.showGroupFooters)("trackBy", ctx_r5.trackBy)("rowClass", ctx_r5.rowClass)("enableDrag", ctx_r5.marqueeSelection);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.showFooter);
} }
function GridComponent_div_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 44);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("loadingTemplate", ctx_r6.loadingTemplate);
} }
function GridComponent_kendo_pager_10_Template(rf, ctx) { if (rf & 1) {
    const _r28 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-pager", 45);
    ɵngcc0.ɵɵlistener("pageChange", function GridComponent_kendo_pager_10_Template_kendo_pager_pageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r28); const ctx_r27 = ɵngcc0.ɵɵnextContext(); return ctx_r27.notifyPageChange("pager", $event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabindex", ctx_r7.navigable ? "0" : "-1")("template", ctx_r7.pagerTemplate)("pageSize", ctx_r7.pageSize)("total", ctx_r7.view.total)("skip", ctx_r7.skip)("options", ctx_r7.pageable);
    ɵngcc0.ɵɵattribute("role", ctx_r7.navigable ? "navigation" : undefined);
} }
function GridComponent_kendo_grid_toolbar_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-toolbar", 46);
} }
const _c143 = ["container"];
const _c144 = ["lockedContainer"];
const _c145 = ["lockedTable"];
const _c146 = ["table"];
const _c147 = function (a0, a1, a2, a3) { return { keydown: a0, scroll: a1, mousewheel: a2, DOMMouseScroll: a3 }; };
function ListComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11, 12)(2, "div", 3)(3, "table", 13, 14);
    ɵngcc0.ɵɵelement(5, "colgroup", 6)(6, "tbody", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(7, "kendo-resize-sensor");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "div", 9);
    ɵngcc0.ɵɵelement(9, "div");
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction4(28, _c147, ctx_r0.lockedKeydown, ctx_r0.lockedScroll, ctx_r0.lockedMousewheel, ctx_r0.lockedMousewheel))("scope", ctx_r0);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵngcc0.ɵɵproperty("locked", true);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("groups", ctx_r0.groups)("columns", ctx_r0.lockedLeafColumns)("detailTemplate", ctx_r0.detailTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("groups", ctx_r0.groups)("isLocked", true)("data", ctx_r0.data)("noRecordsText", "")("columns", ctx_r0.lockedLeafColumns)("totalColumnsCount", ctx_r0.leafColumns.length)("detailTemplate", ctx_r0.detailTemplate)("showGroupFooters", ctx_r0.showFooter)("skip", ctx_r0.skip)("selectable", ctx_r0.selectable)("trackBy", ctx_r0.trackBy)("filterable", ctx_r0.filterable)("rowClass", ctx_r0.rowClass)("isLoading", ctx_r0.loading)("isVirtual", ctx_r0.isVirtual)("cellLoadingTemplate", ctx_r0.cellLoadingTemplate);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵstyleProp("height", ctx_r0.totalHeight, "px");
} }
function ListComponent_kendo_resize_sensor_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-resize-sensor");
} }
function ListComponent_kendo_resize_sensor_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-resize-sensor");
} }
function ListComponent_div_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 16);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", ctx_r5.totalWidth, "px");
} }
const _c148 = ["kendoGridFilterRow", ""];
function FilterRowComponent_td_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 3);
} if (rf & 2) {
    ɵngcc0.ɵɵclassProp("k-group-cell", true);
} }
function FilterRowComponent_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 3);
} if (rf & 2) {
    ɵngcc0.ɵɵclassProp("k-hierarchy-cell", true);
} }
function FilterRowComponent_td_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 4);
} if (rf & 2) {
    const column_r4 = ctx.$implicit;
    const columnIndex_r5 = ctx.index;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-grid-header-sticky", column_r4.sticky);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r2.addStickyStyles(column_r4))("ngClass", column_r4.filterClass)("column", column_r4)("filter", ctx_r2.filter)("logicalRowIndex", ctx_r2.logicalRowIndex)("logicalColIndex", ctx_r2.lockedColumnsCount + columnIndex_r5);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.filterLabel(column_r4));
} }
const _c149 = ["kendoGridFilterCell", ""];
function FilterCellComponent_ng_template_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementContainer(1, 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("column", ctx_r1.column)("filter", ctx_r1.filter);
} }
function FilterCellComponent_ng_template_0_ng_container_2_1_ng_template_0_Template(rf, ctx) { }
function FilterCellComponent_ng_template_0_ng_container_2_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, FilterCellComponent_ng_template_0_ng_container_2_1_ng_template_0_Template, 0, 0, "ng-template", 5);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.column.filterCellTemplateRef)("ngTemplateOutletContext", ctx_r3.templateContext);
} }
function FilterCellComponent_ng_template_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FilterCellComponent_ng_template_0_ng_container_2_1_Template, 1, 2, null, 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.column.filterCellTemplateRef);
} }
function FilterCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 1);
    ɵngcc0.ɵɵtemplate(1, FilterCellComponent_ng_template_0_ng_container_1_Template, 2, 2, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, FilterCellComponent_ng_template_0_ng_container_2_Template, 2, 1, "ng-container", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r0.hasTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", true);
} }
const _c150 = ["*"];
const _c151 = ["dropdown"];
const _c152 = function () { return { width: "auto" }; };
function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 2, 3);
    ɵngcc0.ɵɵlistener("valueChange", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onChange($event); })("keydown", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.dropdownKeydown($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", ctx_r0.operators)("value", ctx_r0.value)("valuePrimitive", true)("popupSettings", ɵngcc0.ɵɵpureFunction0(4, _c152));
} }
function FilterCellOperatorsComponent_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function FilterCellOperatorsComponent_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.clearClick(); })("keydown", function FilterCellOperatorsComponent_button_1_Template_button_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.clearKeydown($event); });
    ɵngcc0.ɵɵelement(1, "span", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r1.clearText);
} }
const _c153 = ["kendoGridColGroup", ""];
function ColGroupComponent_ng_template_0_col_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "col");
} if (rf & 2) {
    ɵngcc0.ɵɵclassProp("k-group-col", true);
} }
function ColGroupComponent_ng_template_0_col_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "col");
} if (rf & 2) {
    ɵngcc0.ɵɵclassProp("k-hierarchy-col", true);
} }
function ColGroupComponent_ng_template_0_col_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "col");
} if (rf & 2) {
    const column_r5 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("width", column_r5.width, "px");
} }
function ColGroupComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ColGroupComponent_ng_template_0_col_0_Template, 1, 2, "col", 1);
    ɵngcc0.ɵɵtemplate(1, ColGroupComponent_ng_template_0_col_1_Template, 1, 2, "col", 2);
    ɵngcc0.ɵɵtemplate(2, ColGroupComponent_ng_template_0_col_2_Template, 1, 2, "col", 3);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.groups);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.columnsToRender)("ngForTrackBy", ctx_r0.trackBy);
} }
const _c154 = ["kendoGridLoading", ""];
function LoadingComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 1);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "div", 2)(4, "div", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.loadingText);
} }
function LoadingComponent_1_ng_template_0_Template(rf, ctx) { }
function LoadingComponent_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, LoadingComponent_1_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.loadingTemplate == null ? null : ctx_r1.loadingTemplate.templateRef);
} }
function PagerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵlistener("focusin", function PagerComponent_div_0_Template_div_focusin_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.onInnerFocusIn($event, "start"); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabindex", ctx_r0.focusTrapTabIndex);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
function PagerComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 5);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.template.templateRef)("ngTemplateOutletContext", ctx_r1.templateContext);
} }
function PagerComponent_ng_container_2_kendo_pager_prev_buttons_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-pager-prev-buttons");
} }
function PagerComponent_ng_container_2_kendo_pager_numeric_buttons_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-pager-numeric-buttons", 8);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("buttonCount", ctx_r8.settings.buttonCount);
} }
function PagerComponent_ng_container_2_kendo_pager_input_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-pager-input");
} }
function PagerComponent_ng_container_2_kendo_pager_next_buttons_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-pager-next-buttons");
} }
function PagerComponent_ng_container_2_kendo_pager_info_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-pager-info");
} }
function PagerComponent_ng_container_2_kendo_pager_page_sizes_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-pager-page-sizes", 9, 10);
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("pageSizes", ctx_r12.settings.pageSizes);
} }
function PagerComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PagerComponent_ng_container_2_kendo_pager_prev_buttons_1_Template, 1, 0, "kendo-pager-prev-buttons", 2);
    ɵngcc0.ɵɵtemplate(2, PagerComponent_ng_container_2_kendo_pager_numeric_buttons_2_Template, 1, 1, "kendo-pager-numeric-buttons", 6);
    ɵngcc0.ɵɵtemplate(3, PagerComponent_ng_container_2_kendo_pager_input_3_Template, 1, 0, "kendo-pager-input", 2);
    ɵngcc0.ɵɵtemplate(4, PagerComponent_ng_container_2_kendo_pager_next_buttons_4_Template, 1, 0, "kendo-pager-next-buttons", 2);
    ɵngcc0.ɵɵtemplate(5, PagerComponent_ng_container_2_kendo_pager_info_5_Template, 1, 0, "kendo-pager-info", 2);
    ɵngcc0.ɵɵtemplate(6, PagerComponent_ng_container_2_kendo_pager_page_sizes_6_Template, 2, 1, "kendo-pager-page-sizes", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.settings.previousNext);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.settings.type === "numeric");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.settings.type === "input");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.settings.previousNext);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.settings.info);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.settings.pageSizes);
} }
function PagerComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵlistener("focusin", function PagerComponent_div_3_Template_div_focusin_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.onInnerFocusIn($event, "end"); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabindex", ctx_r3.focusTrapTabIndex);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
function PagerComponent_kendo_resize_sensor_4_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-resize-sensor", 11);
    ɵngcc0.ɵɵlistener("resize", function PagerComponent_kendo_resize_sensor_4_Template_kendo_resize_sensor_resize_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.resizeHandler(); });
    ɵngcc0.ɵɵelementEnd();
} }
const _c155 = function (a2) { return { "k-link": true, "k-pager-nav": true, "k-state-disabled": a2, "k-pager-first": true }; };
const _c156 = function () { return { "k-icon": true, "k-i-seek-w": true }; };
const _c157 = function (a2) { return { "k-link": true, "k-pager-nav": true, "k-state-disabled": a2, "": true }; };
const _c158 = function () { return { "k-icon": true, "k-i-arrow-w": true }; };
const _c159 = function () { return { "k-icon": true, "k-i-arrow-e": true }; };
const _c160 = function (a2) { return { "k-link": true, "k-pager-nav": true, "k-state-disabled": a2, "k-pager-last": true }; };
const _c161 = function () { return { "k-icon": true, "k-i-seek-e": true }; };
function PagerNumericButtonsComponent_option_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 7);
    ɵngcc0.ɵɵtext(1, "... ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0.pageLabel(ctx_r0.start - 1));
} }
const _c162 = function (a1) { return { "k-link": true, "k-state-selected": a1 }; };
function PagerNumericButtonsComponent_option_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const num_r6 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", num_r6.toString())("ngClass", ɵngcc0.ɵɵpureFunction1(5, _c162, ctx_r1.currentPage == num_r6));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.pageLabel(num_r6))("aria-current", ctx_r1.currentPage == num_r6 ? "page" : undefined);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", num_r6, " ");
} }
function PagerNumericButtonsComponent_option_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 9);
    ɵngcc0.ɵɵtext(1, "... ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.pageLabel(ctx_r2.end + 1));
} }
function PagerNumericButtonsComponent_li_5_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li")(1, "span", 10);
    ɵngcc0.ɵɵlistener("click", function PagerNumericButtonsComponent_li_5_Template_span_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.changePage(ctx_r7.start - 2); })("keydown.enter", function PagerNumericButtonsComponent_li_5_Template_span_keydown_enter_1_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.changePage(ctx_r9.start - 2); });
    ɵngcc0.ɵɵtext(2, "...");
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r3.pageLabel(ctx_r3.start - 1));
} }
const _c163 = function (a1) { return { "k-link": true, "k-state-selected": a1, "k-pager-nav": true }; };
function PagerNumericButtonsComponent_li_6_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li")(1, "span", 11);
    ɵngcc0.ɵɵlistener("click", function PagerNumericButtonsComponent_li_6_Template_span_click_1_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r12); const num_r10 = restoredCtx.$implicit; const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.changePage(num_r10 - 1); })("keydown.enter", function PagerNumericButtonsComponent_li_6_Template_span_keydown_enter_1_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r12); const num_r10 = restoredCtx.$implicit; const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.changePage(num_r10 - 1); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const num_r10 = ctx.$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c163, ctx_r4.currentPage == num_r10));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r4.pageLabel(num_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", num_r10, " ");
} }
function PagerNumericButtonsComponent_li_7_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li")(1, "span", 10);
    ɵngcc0.ɵɵlistener("click", function PagerNumericButtonsComponent_li_7_Template_span_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.changePage(ctx_r14.end); })("keydown.enter", function PagerNumericButtonsComponent_li_7_Template_span_keydown_enter_1_listener() { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.changePage(ctx_r16.end); });
    ɵngcc0.ɵɵtext(2, "...");
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r5.pageLabel(ctx_r5.end + 1));
} }
const _c164 = function () { return { "k-pager-numbers": true, "k-reset": true }; };
const _c165 = function () { return { "k-pager-input": true, "k-label": true }; };
const _c166 = function (a0, a1) { return { keydown: a0, focusout: a1 }; };
const _c167 = ["kendoGridGroupHeader", ""];
function GroupHeaderComponent_ng_template_0_td_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 4);
} }
function GroupHeaderComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, GroupHeaderComponent_ng_template_0_td_0_Template, 1, 0, "td", 3);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.prefixGroupCell(ctx_r0.item));
} }
function GroupHeaderComponent_td_1_ng_template_2_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
    ɵngcc0.ɵɵpipe(1, "valueOf");
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵtextInterpolate2(" ", ctx_r6.groupTitle(ctx_r6.item), ": ", ɵngcc0.ɵɵpipeBind3(1, 2, ctx_r6.item.data, "value", ctx_r6.formatForGroup(ctx_r6.item)), " ");
} }
function GroupHeaderComponent_td_1_ng_template_2_ng_template_2_Template(rf, ctx) { }
const _c168 = function (a0, a1) { return { "k-i-collapse": a0, "k-i-expand": a1 }; };
const _c169 = function (a0, a1, a2, a3, a4, a5, a6, a7) { return { templateRef: a0, group: a1, aggregates: a2, value: a3, field: a4, index: a5, expanded: a6, $implicit: a7 }; };
function GroupHeaderComponent_td_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 7);
    ɵngcc0.ɵɵlistener("click", function GroupHeaderComponent_td_1_ng_template_2_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(2); return ctx_r8.toggleGroup(ctx_r8.item); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(1, GroupHeaderComponent_td_1_ng_template_2_ng_template_1_Template, 2, 6, "ng-template", 0);
    ɵngcc0.ɵɵtemplate(2, GroupHeaderComponent_td_1_ng_template_2_ng_template_2_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(5, _c168, ctx_r5.isExpanded, !ctx_r5.isExpanded));
    ɵngcc0.ɵɵattribute("title", ctx_r5.groupButtonTitle)("aria-label", ctx_r5.groupButtonTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r5.groupHeaderTemplate(ctx_r5.item));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction8(8, _c169, ctx_r5.groupHeaderTemplate(ctx_r5.item), ctx_r5.item.data, ctx_r5.item.data == null ? null : ctx_r5.item.data.aggregates, ctx_r5.item.data == null ? null : ctx_r5.item.data.value, ctx_r5.item.data == null ? null : ctx_r5.item.data.field, ctx_r5.item.index, ctx_r5.isExpanded, ctx_r5.item.data));
} }
function GroupHeaderComponent_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 5)(1, "p", 6);
    ɵngcc0.ɵɵtemplate(2, GroupHeaderComponent_td_1_ng_template_2_Template, 3, 17, "ng-template", 0);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r1.logicalRowIndex)("logicalColIndex", 0)("logicalSlaveCell", ctx_r1.skipGroupDecoration)("groupItem", ctx_r1.item)("colSpan", ctx_r1.logicalColSpan());
    ɵngcc0.ɵɵattribute("colspan", ctx_r1.groupSpan(ctx_r1.item))("role", ctx_r1.ariaRole())("aria-expanded", ctx_r1.isExpanded);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.skipGroupDecoration);
} }
const _c170 = function (a0, a1, a2, a3, a4, a5) { return { group: a0, aggregates: a1, value: a2, field: a3, index: a4, $implicit: a5 }; };
function GroupHeaderComponent_ng_container_2_td_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 12);
} if (rf & 2) {
    const column_r11 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", column_r11.groupHeaderColumnTemplateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction6(2, _c170, ctx_r13.item.data, ctx_r13.item.data == null ? null : ctx_r13.item.data.aggregates, ctx_r13.item.data == null ? null : ctx_r13.item.data.value, ctx_r13.item.data == null ? null : ctx_r13.item.data.field, ctx_r13.item.index, ctx_r13.item.data));
} }
function GroupHeaderComponent_ng_container_2_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 10);
    ɵngcc0.ɵɵtemplate(1, GroupHeaderComponent_ng_container_2_td_1_ng_container_1_Template, 1, 9, "ng-container", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r11 = ctx.$implicit;
    const index_r12 = ctx.index;
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r10.logicalRowIndex)("logicalColIndex", index_r12 + 1)("logicalSlaveCell", false)("groupItem", ctx_r10.item)("colSpan", 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", column_r11.groupHeaderColumnTemplateRef);
} }
function GroupHeaderComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, GroupHeaderComponent_ng_container_2_td_1_Template, 2, 6, "td", 9);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r2.groupHeaderColumns);
} }
const _c171 = function () { return { lastTarget: true }; };
function GroupPanelComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("context", ɵngcc0.ɵɵpureFunction0(2, _c171));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.text, " ");
} }
const _c172 = function (a0) { return { field: a0 }; };
const _c173 = function (a0, a2) { return { field: a0, type: "groupIndicator", hint: a2 }; };
function GroupPanelComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 3)(1, "div", 4);
    ɵngcc0.ɵɵlistener("directionChange", function GroupPanelComponent_div_1_Template_div_directionChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.directionChange($event); })("remove", function GroupPanelComponent_div_1_Template_div_remove_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.remove($event); });
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const group_r3 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("context", ɵngcc0.ɵɵpureFunction1(5, _c172, group_r3.field));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("enableDrag", true)("context", ɵngcc0.ɵɵpureFunction2(7, _c173, group_r3.field, ctx_r1.groupTitles[index_r4]))("group", group_r3)("groupTitle", ctx_r1.groupTitles[index_r4]);
} }
function GroupPanelComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵtext(1, "\u00A0");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("context", ɵngcc0.ɵɵpureFunction0(1, _c171));
} }
const _c174 = ["kendoGroupIndicator", ""];
const _c175 = ["anchor"];
const _c176 = ["template"];
function FilterMenuComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-menu-container", 4);
    ɵngcc0.ɵɵlistener("close", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_close_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.close(); })("keydown.escape", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_escape_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.close(); })("keydown.enter", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_enter_0_listener($event) { return $event.stopImmediatePropagation(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", ctx_r2.column)("filter", ctx_r2.filter);
} }
const _c177 = function (a1) { return { "k-grid-filter": true, "k-state-active": a1 }; };
const _c178 = function (a0, a1) { return { service: a0, column: a1 }; };
function ColumnMenuComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 5);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.column.columnMenuTemplateRef || ctx_r2.columnMenuTemplate || _r3)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c178, ctx_r2.service, ctx_r2.column));
} }
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_sort_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-columnmenu-sort", 10, 11);
} if (rf & 2) {
    const _r11 = ɵngcc0.ɵɵreference(1);
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("kendoGridColumnMenuItem", _r11)("service", ctx_r5.service);
} }
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_lock_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-columnmenu-lock", 10, 12);
} if (rf & 2) {
    const _r12 = ɵngcc0.ɵɵreference(1);
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("kendoGridColumnMenuItem", _r12)("service", ctx_r6.service);
} }
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_stick_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-columnmenu-stick", 10, 13);
} if (rf & 2) {
    const _r13 = ɵngcc0.ɵɵreference(1);
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("kendoGridColumnMenuItem", _r13)("service", ctx_r7.service);
} }
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_position_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-columnmenu-position", 14, 15);
} if (rf & 2) {
    const _r14 = ɵngcc0.ɵɵreference(1);
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("showLock", ctx_r8.hasLock)("showStick", ctx_r8.hasStick)("kendoGridColumnMenuItem", _r14)("service", ctx_r8.service)("expanded", ctx_r8.expandedPosition);
} }
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_chooser_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-columnmenu-chooser", 16, 17);
} if (rf & 2) {
    const _r15 = ɵngcc0.ɵɵreference(1);
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("kendoGridColumnMenuItem", _r15)("service", ctx_r9.service)("expanded", ctx_r9.expandedColumns);
} }
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_filter_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-columnmenu-filter", 16, 18);
} if (rf & 2) {
    const _r16 = ɵngcc0.ɵɵreference(1);
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("kendoGridColumnMenuItem", _r16)("service", ctx_r10.service)("expanded", ctx_r10.expandedFilter);
} }
function ColumnMenuComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    const _r18 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnmenu-container", 6);
    ɵngcc0.ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.close(); })("keydown.enter", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) { return $event.stopImmediatePropagation(); });
    ɵngcc0.ɵɵtemplate(1, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_sort_1_Template, 2, 2, "kendo-grid-columnmenu-sort", 7);
    ɵngcc0.ɵɵtemplate(2, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_lock_2_Template, 2, 2, "kendo-grid-columnmenu-lock", 7);
    ɵngcc0.ɵɵtemplate(3, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_stick_3_Template, 2, 2, "kendo-grid-columnmenu-stick", 7);
    ɵngcc0.ɵɵtemplate(4, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_position_4_Template, 2, 5, "kendo-grid-columnmenu-position", 8);
    ɵngcc0.ɵɵtemplate(5, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_chooser_5_Template, 2, 3, "kendo-grid-columnmenu-chooser", 9);
    ɵngcc0.ɵɵtemplate(6, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_filter_6_Template, 2, 3, "kendo-grid-columnmenu-filter", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasSort);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasLock && !ctx_r4.hasPosition);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasStick && !ctx_r4.hasPosition);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasPosition);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasColumnChooser);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasFilter);
} }
const _c179 = function (a0) { return { "k-state-active": a0 }; };
const _c180 = ["kendoGridHeader", ""];
function HeaderComponent_ng_template_0_tr_0_th_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "th", 7);
} }
function HeaderComponent_ng_template_0_tr_0_th_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "th", 8);
} if (rf & 2) {
    const levelIndex_r4 = ɵngcc0.ɵɵnextContext().index;
    ɵngcc0.ɵɵproperty("logicalRowIndex", levelIndex_r4)("logicalColIndex", 0);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_kendo_grid_filter_menu_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-filter-menu", 16);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(3).$implicit;
    const ctx_r19 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("column", column_r10)("filter", ctx_r19.filter)("tabIndex", ctx_r19.tabIndex);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_kendo_grid_column_menu_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-column-menu", 17);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(3).$implicit;
    const ctx_r20 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("standalone", false)("settings", ctx_r20.columnMenu)("column", column_r10)("columnMenuTemplate", ctx_r20.columnMenuTemplate)("sort", ctx_r20.sort)("filter", ctx_r20.filter)("sortable", ctx_r20.sortable)("tabIndex", ctx_r20.tabIndex);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_ng_template_2_Template(rf, ctx) { }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵtextInterpolate(column_r10.displayTitle);
} }
const _c181 = function (a0, a1, a2, a3) { return { templateRef: a0, columnIndex: a1, column: a2, $implicit: a3 }; };
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_kendo_grid_filter_menu_0_Template, 1, 3, "kendo-grid-filter-menu", 13);
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_kendo_grid_column_menu_1_Template, 1, 8, "kendo-grid-column-menu", 14);
    ɵngcc0.ɵɵtemplate(2, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_ng_template_2_Template, 0, 0, "ng-template", 15);
    ɵngcc0.ɵɵtemplate(3, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_ng_template_3_Template, 1, 1, "ng-template", 0);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r15 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r15.showFilterMenu && ctx_r15.isFilterable(column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r15.showColumnMenu(column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction4(4, _c181, column_r10.headerTemplateRef, column_r10.leafIndex, column_r10, column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !column_r10.headerTemplateRef);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_ng_template_3_Template(rf, ctx) { }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 24);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(column_r10.displayTitle);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 25);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(3).$implicit;
    const ctx_r30 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r30.sortOrder(column_r10.field));
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_kendo_grid_filter_menu_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-filter-menu", 16);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(3).$implicit;
    const ctx_r31 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("column", column_r10)("filter", ctx_r31.filter)("tabIndex", ctx_r31.tabIndex);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_kendo_grid_column_menu_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-column-menu", 17);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(3).$implicit;
    const ctx_r32 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("standalone", false)("settings", ctx_r32.columnMenu)("column", column_r10)("columnMenuTemplate", ctx_r32.columnMenuTemplate)("sort", ctx_r32.sort)("filter", ctx_r32.filter)("sortable", ctx_r32.sortable)("tabIndex", ctx_r32.tabIndex);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r39 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 18)(1, "span", 19, 20);
    ɵngcc0.ɵɵlistener("click", function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_Template_span_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r39); const _r27 = ɵngcc0.ɵɵreference(2); const column_r10 = ɵngcc0.ɵɵnextContext(2).$implicit; const ctx_r37 = ɵngcc0.ɵɵnextContext(3); return ctx_r37.onSortClick(column_r10, $event, _r27); });
    ɵngcc0.ɵɵtemplate(3, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_ng_template_3_Template, 0, 0, "ng-template", 15);
    ɵngcc0.ɵɵtemplate(4, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_ng_template_4_Template, 2, 1, "ng-template", 0);
    ɵngcc0.ɵɵelement(5, "span", 21);
    ɵngcc0.ɵɵtemplate(6, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_span_6_Template, 2, 1, "span", 22);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(7, "span", 23);
    ɵngcc0.ɵɵtemplate(8, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_kendo_grid_filter_menu_8_Template, 1, 3, "kendo-grid-filter-menu", 13);
    ɵngcc0.ɵɵtemplate(9, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_kendo_grid_column_menu_9_Template, 1, 8, "kendo-grid-column-menu", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r16 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction4(8, _c181, column_r10.headerTemplateRef, column_r10.leafIndex, column_r10, column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !column_r10.headerTemplateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r16.sortIcon(column_r10.field));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r16.sortableLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r16.showSortNumbering(column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHtml", ctx_r16.sortStatus(column_r10), ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r16.showFilterMenu && ctx_r16.isFilterable(column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r16.showColumnMenu(column_r10));
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "input", 26);
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(5);
    ɵngcc0.ɵɵattribute("id", ctx_r17.selectAllCheckboxId())("aria-label", ctx_r17.selectAllCheckboxLabel);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 27);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r18 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("column", column_r10)("columns", ctx_r18.columns);
} }
const _c182 = function (a0, a2, a3, a4) { return { field: a0, type: "column", column: a2, hint: a3, lastColumn: a4 }; };
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_Template(rf, ctx) { if (rf & 1) {
    const _r44 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "th", 11);
    ɵngcc0.ɵɵlistener("keydown", function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_Template_th_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r44); const column_r10 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r42 = ɵngcc0.ɵɵnextContext(3); return ctx_r42.onHeaderKeydown(column_r10, $event); });
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_1_Template, 4, 9, "ng-template", 0);
    ɵngcc0.ɵɵtemplate(2, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_2_Template, 10, 13, "ng-template", 0);
    ɵngcc0.ɵɵtemplate(3, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_ng_template_3_Template, 1, 2, "ng-template", 0);
    ɵngcc0.ɵɵtemplate(4, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_span_4_Template, 1, 2, "span", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r45 = ɵngcc0.ɵɵnextContext();
    const column_r10 = ctx_r45.$implicit;
    const columnIndex_r11 = ctx_r45.index;
    const last_r12 = ctx_r45.last;
    const levelIndex_r4 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp("k-filterable", ctx_r13.showFilterMenu && ctx_r13.isFilterable(column_r10) || ctx_r13.showColumnMenu(column_r10))("k-first", ctx_r13.isFirstOnRow(column_r10, columnIndex_r11))("k-grid-header-sticky", column_r10.sticky);
    ɵngcc0.ɵɵproperty("logicalRowIndex", levelIndex_r4)("logicalColIndex", ctx_r13.logicalColumnIndex(column_r10))("headerLabelText", column_r10.title || column_r10.field)("colSpan", column_r10.colspan)("rowSpan", column_r10.rowspan(ctx_r13.totalColumnLevels))("enableDrag", ctx_r13.shouldActivate(column_r10))("context", ɵngcc0.ɵɵpureFunction4(22, _c182, column_r10.field, column_r10, column_r10.title || column_r10.field, last_r12 && columnIndex_r11 === 0))("ngClass", column_r10.headerClass)("ngStyle", column_r10.sticky ? ctx_r13.addStickyStyles(column_r10) : column_r10.headerStyle);
    ɵngcc0.ɵɵattribute("aria-sort", ctx_r13.sortState(column_r10))("rowspan", column_r10.rowspan(ctx_r13.totalColumnLevels))("colspan", column_r10.colspan);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r13.isSortable(column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r13.isSortable(column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r13.isCheckboxColumn(column_r10) && !column_r10.headerTemplateRef && column_r10.showSelectAll);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r13.resizable);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_kendo_grid_column_menu_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-column-menu", 30);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r47 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("standalone", false)("settings", ctx_r47.columnMenu)("column", column_r10)("columnMenuTemplate", ctx_r47.columnMenuTemplate);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_ng_template_2_Template(rf, ctx) { }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵtextInterpolate(column_r10.displayTitle);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 27);
} if (rf & 2) {
    const column_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r50 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("column", column_r10)("columns", ctx_r50.columns);
} }
const _c183 = function (a1, a2, a3) { return { type: "columnGroup", column: a1, hint: a2, lastColumn: a3 }; };
function HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th", 28);
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_kendo_grid_column_menu_1_Template, 1, 4, "kendo-grid-column-menu", 29);
    ɵngcc0.ɵɵtemplate(2, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_ng_template_2_Template, 0, 0, "ng-template", 15);
    ɵngcc0.ɵɵtemplate(3, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_ng_template_3_Template, 1, 1, "ng-template", 0);
    ɵngcc0.ɵɵtemplate(4, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_span_4_Template, 1, 2, "span", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r54 = ɵngcc0.ɵɵnextContext();
    const column_r10 = ctx_r54.$implicit;
    const columnIndex_r11 = ctx_r54.index;
    const last_r12 = ctx_r54.last;
    const levelIndex_r4 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp("k-first", ctx_r14.isFirstOnRow(column_r10, columnIndex_r11))("k-filterable", ctx_r14.showColumnMenu(column_r10))("k-grid-content-sticky", column_r10.sticky);
    ɵngcc0.ɵɵproperty("logicalRowIndex", levelIndex_r4)("logicalColIndex", ctx_r14.logicalColumnIndex(column_r10))("rowSpan", column_r10.rowspan(ctx_r14.totalColumnLevels))("colSpan", column_r10.colspan)("headerLabelText", column_r10.title || column_r10.field)("enableDrag", ctx_r14.shouldActivate(column_r10))("context", ɵngcc0.ɵɵpureFunction3(21, _c183, column_r10, column_r10.title, last_r12 && columnIndex_r11 === 0))("ngClass", column_r10.headerClass)("ngStyle", column_r10.headerStyle);
    ɵngcc0.ɵɵattribute("rowspan", column_r10.rowspan(ctx_r14.totalColumnLevels))("colspan", column_r10.colspan);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r14.showColumnMenu(column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction4(25, _c181, column_r10.headerTemplateRef, ctx_r14.lockedColumnsCount + columnIndex_r11, column_r10, column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !column_r10.headerTemplateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r14.resizable);
} }
function HeaderComponent_ng_template_0_tr_0_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_0_Template, 5, 27, "th", 9);
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_ng_template_0_tr_0_ng_template_3_th_1_Template, 5, 30, "th", 10);
} if (rf & 2) {
    const column_r10 = ctx.$implicit;
    const ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r7.isColumnGroupComponent(column_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.isColumnGroupComponent(column_r10));
} }
function HeaderComponent_ng_template_0_tr_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 3);
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_ng_template_0_tr_0_th_1_Template, 1, 0, "th", 4);
    ɵngcc0.ɵɵtemplate(2, HeaderComponent_ng_template_0_tr_0_th_2_Template, 1, 2, "th", 5);
    ɵngcc0.ɵɵtemplate(3, HeaderComponent_ng_template_0_tr_0_ng_template_3_Template, 2, 2, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const levelIndex_r4 = ctx.index;
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("logicalRowIndex", levelIndex_r4)("logicalSlaveRow", ctx_r1.lockedColumnsCount > 0)("logicalCellsCount", ctx_r1.columns.length)("logicalSlaveCellsCount", ctx_r1.unlockedColumnsCount);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.groups);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.detailTemplate == null ? null : ctx_r1.detailTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.columnsForLevel(levelIndex_r4))("ngForTrackBy", ctx_r1.trackByIndex);
} }
function HeaderComponent_ng_template_0_tr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "tr", 31);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("columns", ctx_r2.leafColumns)("filter", ctx_r2.filter)("groups", ctx_r2.groups)("detailTemplate", ctx_r2.detailTemplate)("lockedColumnsCount", ctx_r2.lockedColumnsCount)("logicalRowIndex", ctx_r2.totalColumnLevels + 1)("logicalSlaveRow", ctx_r2.lockedColumnsCount > 0)("logicalCellsCount", ctx_r2.columns.length)("logicalSlaveCellsCount", ctx_r2.unlockedColumnsCount);
} }
function HeaderComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, HeaderComponent_ng_template_0_tr_0_Template, 4, 8, "tr", 1);
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_ng_template_0_tr_1_Template, 1, 9, "tr", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.columnLevels);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showFilterRow);
} }
const _c184 = ["resetButton"];
const _c185 = ["filterButton"];
function FilterMenuContainerComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementContainer(1, 9);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("filterService", ctx_r0.childService)("column", ctx_r0.column)("filter", ctx_r0.childFilter)("menuTabbingService", ctx_r0.menuTabbingService);
} }
function FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template(rf, ctx) { }
function FilterMenuContainerComponent_ng_container_4_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template, 0, 0, "ng-template", 11);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.column.filterMenuTemplateRef)("ngTemplateOutletContext", ctx_r4.templateContext);
} }
function FilterMenuContainerComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FilterMenuContainerComponent_ng_container_4_1_Template, 1, 2, null, 10);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.column.filterMenuTemplateRef);
} }
function StringFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵngcc0.ɵɵlistener("valueChange", function StringFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.logicChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("filterMenuDropDownLabel", ctx_r0.filterMenuDropDownLabel)("data", ctx_r0.logicOperators)("valuePrimitive", true)("value", ctx_r0.filter == null ? null : ctx_r0.filter.logic);
} }
function StringFilterMenuComponent_kendo_grid_string_filter_menu_input_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-string-filter-menu-input", 4);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("menuTabbingService", ctx_r1.menuTabbingService);
} }
function NumericFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵngcc0.ɵɵlistener("valueChange", function NumericFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.logicChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("filterMenuDropDownLabel", ctx_r0.filterMenuDropDownLabel)("data", ctx_r0.logicOperators)("valuePrimitive", true)("value", ctx_r0.filter == null ? null : ctx_r0.filter.logic);
} }
function NumericFilterMenuComponent_kendo_grid_numeric_filter_menu_input_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-numeric-filter-menu-input", 4);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("format", ctx_r1.format)("decimals", ctx_r1.decimals)("spinners", ctx_r1.spinners)("min", ctx_r1.min)("max", ctx_r1.max)("step", ctx_r1.step)("menuTabbingService", ctx_r1.menuTabbingService);
} }
function DateFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵngcc0.ɵɵlistener("valueChange", function DateFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.logicChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("filterMenuDropDownLabel", ctx_r0.filterMenuDropDownLabel)("data", ctx_r0.logicOperators)("valuePrimitive", true)("value", ctx_r0.filter == null ? null : ctx_r0.filter.logic);
} }
function DateFilterMenuComponent_kendo_grid_date_filter_menu_input_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-grid-date-filter-menu-input", 4);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("activeView", ctx_r1.activeView)("bottomView", ctx_r1.bottomView)("topView", ctx_r1.topView)("format", ctx_r1.format)("formatPlaceholder", ctx_r1.formatPlaceholder)("placeholder", ctx_r1.placeholder)("min", ctx_r1.min)("max", ctx_r1.max)("weekNumber", ctx_r1.weekNumber)("menuTabbingService", ctx_r1.menuTabbingService);
} }
function BooleanFilterMenuComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li")(1, "input", 2, 3);
    ɵngcc0.ɵɵlistener("change", function BooleanFilterMenuComponent_li_1_Template_input_change_1_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r4); const item_r1 = restoredCtx.$implicit; const _r2 = ɵngcc0.ɵɵreference(2); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onChange(item_r1.value, _r2); })("keydown.shift.tab", function BooleanFilterMenuComponent_li_1_Template_input_keydown_shift_tab_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.onShiftTab($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "label", 4);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columnLabel", ctx_r0.columnLabel)("name", ctx_r0.idPrefix)("checked", ctx_r0.isSelected(item_r1.value));
    ɵngcc0.ɵɵattribute("id", ctx_r0.radioId(item_r1.value));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("for", ctx_r0.radioId(item_r1.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(item_r1.text);
} }
const _c186 = ["applyButton"];
function ColumnListComponent_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 3);
    ɵngcc0.ɵɵelement(1, "input", 4);
    ɵngcc0.ɵɵelementStart(2, "span", 5);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const index_r3 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("checked", !column_r2.hidden)("disabled", ctx_r0.isDisabled(column_r2));
    ɵngcc0.ɵɵattribute("data-index", index_r3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(column_r2.displayTitle);
} }
function ColumnListComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 6)(1, "button", 7);
    ɵngcc0.ɵɵlistener("click", function ColumnListComponent_div_2_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.cancelChanges(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "button", 8, 9);
    ɵngcc0.ɵɵlistener("keydown.tab", function ColumnListComponent_div_2_Template_button_keydown_tab_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onTab($event); })("click", function ColumnListComponent_div_2_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.applyChanges(); });
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.actionsClass);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.resetText);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.applyText);
} }
function ColumnChooserComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "kendo-grid-columnlist", 5);
    ɵngcc0.ɵɵlistener("apply", function ColumnChooserComponent_ng_template_3_Template_kendo_grid_columnlist_apply_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onApply($event); })("columnChange", function ColumnChooserComponent_ng_template_3_Template_kendo_grid_columnlist_columnChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.onChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.localization.get("columns"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r2.columns)("applyText", ctx_r2.localization.get("columnsApply"))("resetText", ctx_r2.localization.get("columnsReset"))("autoSync", ctx_r2.autoSync)("allowHideAll", ctx_r2.allowHideAll);
} }
function ColumnMenuChooserComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnlist", 2);
    ɵngcc0.ɵɵlistener("apply", function ColumnMenuChooserComponent_ng_template_1_Template_kendo_grid_columnlist_apply_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.onApply($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("applyText", ctx_r0.localization.get("columnsApply"))("resetText", ctx_r0.localization.get("columnsReset"))("columns", ctx_r0.columns)("autoSync", false)("allowHideAll", false)("actionsClass", ctx_r0.actionsClass)("isLast", ctx_r0.isLast)("isExpanded", ctx_r0.expanded)("service", ctx_r0.service);
} }
function ColumnMenuFilterComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-menu-container", 2);
    ɵngcc0.ɵɵlistener("keydown.shift.tab", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) { return $event.stopImmediatePropagation(); })("close", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_close_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.close(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", ctx_r0.service.column)("menuTabbingService", ctx_r0.service.menuTabbingService)("filter", ctx_r0.service.filter)("actionsClass", ctx_r0.actionsClass)("isLast", ctx_r0.isLast)("isExpanded", ctx_r0.expanded);
} }
function ColumnMenuItemComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 3);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.iconClass);
} }
function ColumnMenuItemComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementContainer(1, 5);
    ɵngcc0.ɵɵelement(2, "div");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@state", ctx_r1.contentState);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.contentTemplate.templateRef);
} }
function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnmenu-lock", 3);
    ɵngcc0.ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template_kendo_grid_columnmenu_lock_keydown_tab_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(2); return ctx_r3.onTab($event, !ctx_r3.showStick); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("service", ctx_r1.service);
} }
function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnmenu-stick", 3);
    ɵngcc0.ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template_kendo_grid_columnmenu_stick_keydown_tab_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.onTab($event, true); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("service", ctx_r2.service);
} }
function ColumnMenuPositionComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template, 1, 1, "kendo-grid-columnmenu-lock", 2);
    ɵngcc0.ɵɵtemplate(1, ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template, 1, 1, "kendo-grid-columnmenu-stick", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showLock);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showStick);
} }
const _c187 = ["kendoGridTableBody", ""];
function TableBodyComponent_ng_template_0_ng_template_1_td_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 8);
} }
function TableBodyComponent_ng_template_0_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TableBodyComponent_ng_template_0_ng_template_1_td_0_Template, 1, 0, "td", 7);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.groups);
} }
function TableBodyComponent_ng_template_0_td_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 9);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r5.addRowLogicalIndex())("logicalColIndex", 0);
} }
function TableBodyComponent_ng_template_0_td_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 10);
} if (rf & 2) {
    const column_r9 = ctx.$implicit;
    const columnIndex_r10 = ctx.index;
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("left", column_r9.sticky ? "0" : undefined);
    ɵngcc0.ɵɵclassProp("k-grid-content-sticky", column_r9.sticky);
    ɵngcc0.ɵɵproperty("rowIndex", -1)("columnIndex", ctx_r6.lockedColumnsCount + columnIndex_r10)("isNew", true)("column", column_r9)("dataItem", ctx_r6.newDataItem)("ngClass", column_r9.cssClass)("ngStyle", column_r9.sticky ? ctx_r6.addStickyColumnStyles(column_r9) : column_r9.style)("logicalRowIndex", ctx_r6.addRowLogicalIndex())("logicalColIndex", ctx_r6.logicalColIndex(column_r9))("colSpan", column_r9.colspan);
    ɵngcc0.ɵɵattribute("colspan", column_r9.colspan);
} }
function TableBodyComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 4);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_template_0_ng_template_1_Template, 1, 1, "ng-template", 0);
    ɵngcc0.ɵɵtemplate(2, TableBodyComponent_ng_template_0_td_2_Template, 1, 2, "td", 5);
    ɵngcc0.ɵɵtemplate(3, TableBodyComponent_ng_template_0_td_3_Template, 1, 15, "td", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skipGroupDecoration);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.columns)("ngForTrackBy", ctx_r0.trackByColumns);
} }
function TableBodyComponent_tr_1_ng_template_2_Template(rf, ctx) { }
function TableBodyComponent_tr_1_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r12.noRecordsText, " ");
} }
const _c188 = function (a0) { return { templateRef: a0 }; };
function TableBodyComponent_tr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 11)(1, "td");
    ɵngcc0.ɵɵtemplate(2, TableBodyComponent_tr_1_ng_template_2_Template, 0, 0, "ng-template", 12);
    ɵngcc0.ɵɵtemplate(3, TableBodyComponent_tr_1_ng_container_3_Template, 2, 1, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("colspan", ctx_r1.colSpan);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.noRecordsTemplate == null ? null : ctx_r1.noRecordsTemplate.templateRef)("templateContext", ɵngcc0.ɵɵpureFunction1(4, _c188, ctx_r1.noRecordsTemplate == null ? null : ctx_r1.noRecordsTemplate.templateRef));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r1.noRecordsTemplate == null ? null : ctx_r1.noRecordsTemplate.templateRef));
} }
function TableBodyComponent_ng_template_2_tr_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "tr", 18);
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext();
    const item_r13 = ctx_r19.$implicit;
    const rowIndex_r14 = ctx_r19.index;
    const ctx_r15 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("columns", ctx_r15.columns)("groups", ctx_r15.groups)("item", item_r13)("hasDetails", ctx_r15.detailTemplate == null ? null : ctx_r15.detailTemplate.templateRef)("skipGroupDecoration", ctx_r15.skipGroupDecoration)("hasGroupHeaderColumn", ctx_r15.hasGroupHeaderColumn)("groupHeaderColumns", ctx_r15.groupHeaderColumns)("rowIndex", rowIndex_r14 + 1)("totalColumnsCount", ctx_r15.totalColumnsCount)("logicalRowIndex", ctx_r15.logicalRowIndex(rowIndex_r14))("logicalSlaveRow", ctx_r15.lockedColumnsCount > 0)("logicalCellsCount", ctx_r15.columns.length)("logicalSlaveCellsCount", ctx_r15.groupHeaderSlaveCellsCount);
} }
function TableBodyComponent_ng_template_2_tr_1_ng_template_1_td_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 8);
} }
function TableBodyComponent_ng_template_2_tr_1_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TableBodyComponent_ng_template_2_tr_1_ng_template_1_td_0_Template, 1, 0, "td", 7);
} if (rf & 2) {
    const ctx_r20 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r20.groups);
} }
function TableBodyComponent_ng_template_2_tr_1_td_2_a_1_Template(rf, ctx) { if (rf & 1) {
    const _r28 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 24);
    ɵngcc0.ɵɵlistener("click", function TableBodyComponent_ng_template_2_tr_1_td_2_a_1_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r28); const item_r13 = ɵngcc0.ɵɵnextContext(3).$implicit; const ctx_r26 = ɵngcc0.ɵɵnextContext(); return ctx_r26.toggleRow(item_r13.index, item_r13.data); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r13 = ɵngcc0.ɵɵnextContext(3).$implicit;
    const ctx_r25 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r25.detailButtonStyles(item_r13));
    ɵngcc0.ɵɵattribute("title", ctx_r25.detailButtonTitle(item_r13))("aria-label", ctx_r25.detailButtonTitle(item_r13));
} }
function TableBodyComponent_ng_template_2_tr_1_td_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 22);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_template_2_tr_1_td_2_a_1_Template, 1, 3, "a", 23);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r30 = ɵngcc0.ɵɵnextContext(2);
    const rowIndex_r14 = ctx_r30.index;
    const item_r13 = ctx_r30.$implicit;
    const ctx_r21 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r21.logicalRowIndex(rowIndex_r14))("logicalColIndex", 0)("dataRowIndex", item_r13.index)("dataItem", item_r13.data)("detailExpandCell", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r21.detailTemplate.showIf(item_r13.data, item_r13.index));
} }
function TableBodyComponent_ng_template_2_tr_1_td_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 25);
} if (rf & 2) {
    const column_r31 = ctx.$implicit;
    const columnIndex_r32 = ctx.index;
    const ctx_r33 = ɵngcc0.ɵɵnextContext(2);
    const item_r13 = ctx_r33.$implicit;
    const rowIndex_r14 = ctx_r33.index;
    const ctx_r22 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-grid-content-sticky", column_r31.sticky)("k-touch-action-none", ctx_r22.isSelectable() && ctx_r22.selectable.drag)("k-touch-action-auto", !(ctx_r22.isSelectable() && ctx_r22.selectable.drag))("k-grid-edit-cell", ctx_r22.isEditingCell(item_r13.index, column_r31))("k-state-selected", ctx_r22.isSelectable && ctx_r22.cellSelectionService.isCellSelected(item_r13, column_r31));
    ɵngcc0.ɵɵproperty("rowIndex", item_r13.index)("columnIndex", ctx_r22.lockedColumnsCount + columnIndex_r32)("column", column_r31)("dataItem", item_r13.data)("isLoading", ctx_r22.isLoading)("isVirtual", ctx_r22.isVirtual)("loadingTemplate", ctx_r22.cellLoadingTemplate)("logicalRowIndex", ctx_r22.logicalRowIndex(rowIndex_r14))("logicalColIndex", ctx_r22.logicalColIndex(column_r31))("dataRowIndex", item_r13.index)("dataItem", item_r13.data)("colIndex", columnIndex_r32)("colSpan", column_r31.colspan)("ngClass", column_r31.cssClass)("ngStyle", column_r31.sticky ? ctx_r22.addStickyColumnStyles(column_r31) : column_r31.style);
    ɵngcc0.ɵɵattribute("data-kendo-grid-column-index", ctx_r22.lockedColumnsCount + columnIndex_r32)("aria-selected", ctx_r22.isSelectable() ? ctx_r22.isAriaSelected(item_r13, column_r31) : undefined)("colspan", column_r31.colspan);
} }
const _c189 = function (a0, a1) { return { dataItem: a0, index: a1 }; };
function TableBodyComponent_ng_template_2_tr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 19);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_template_2_tr_1_ng_template_1_Template, 1, 1, "ng-template", 0);
    ɵngcc0.ɵɵtemplate(2, TableBodyComponent_ng_template_2_tr_1_td_2_Template, 2, 6, "td", 20);
    ɵngcc0.ɵɵtemplate(3, TableBodyComponent_ng_template_2_tr_1_td_3_Template, 1, 28, "td", 21);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r34 = ɵngcc0.ɵɵnextContext();
    const item_r13 = ctx_r34.$implicit;
    const rowIndex_r14 = ctx_r34.index;
    const ctx_r16 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-grid-row-sticky", ctx_r16.rowSticky ? ctx_r16.rowSticky(ɵngcc0.ɵɵpureFunction2(22, _c189, item_r13.data, item_r13.index)) : false)("k-alt", ctx_r16.isOdd(item_r13))("k-master-row", ctx_r16.detailTemplate == null ? null : ctx_r16.detailTemplate.templateRef)("k-grid-edit-row", ctx_r16.isEditingRow(item_r13.index))("k-state-selected", ctx_r16.isSelectable() && ctx_r16.isRowSelected(item_r13));
    ɵngcc0.ɵɵproperty("dataRowIndex", item_r13.index)("dataItem", item_r13.data)("logicalRowIndex", ctx_r16.logicalRowIndex(rowIndex_r14))("logicalSlaveRow", ctx_r16.lockedColumnsCount > 0)("logicalCellsCount", ctx_r16.columns.length)("logicalSlaveCellsCount", ctx_r16.unlockedColumnsCount)("ngClass", ctx_r16.rowClass(ɵngcc0.ɵɵpureFunction2(25, _c189, item_r13.data, item_r13.index)));
    ɵngcc0.ɵɵattribute("data-kendo-grid-item-index", item_r13.index);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r16.skipGroupDecoration);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r16.detailTemplate == null ? null : ctx_r16.detailTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r16.columns)("ngForTrackBy", ctx_r16.trackByColumns);
} }
function TableBodyComponent_ng_template_2_tr_2_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 31);
} }
function TableBodyComponent_ng_template_2_tr_2_ng_template_4_Template(rf, ctx) { }
const _c190 = function (a0, a1, a2) { return { dataItem: a0, rowIndex: a1, $implicit: a2 }; };
function TableBodyComponent_ng_template_2_tr_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 26);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_template_2_tr_2_td_1_Template, 1, 0, "td", 27);
    ɵngcc0.ɵɵelement(2, "td", 28);
    ɵngcc0.ɵɵelementStart(3, "td", 29);
    ɵngcc0.ɵɵtemplate(4, TableBodyComponent_ng_template_2_tr_2_ng_template_4_Template, 0, 0, "ng-template", 30);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r38 = ɵngcc0.ɵɵnextContext();
    const item_r13 = ctx_r38.$implicit;
    const rowIndex_r14 = ctx_r38.index;
    const ctx_r17 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-alt", ctx_r17.isOdd(item_r13));
    ɵngcc0.ɵɵproperty("dataRowIndex", item_r13.index)("dataItem", item_r13.data)("logicalRowIndex", ctx_r17.logicalRowIndex(rowIndex_r14) + 1)("logicalSlaveRow", false)("logicalCellsCount", 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r17.groups);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r17.logicalRowIndex(rowIndex_r14) + 1)("logicalColIndex", 0)("dataRowIndex", item_r13.index)("dataItem", item_r13.data)("colIndex", 0)("colSpan", ctx_r17.allColumnsSpan + 1);
    ɵngcc0.ɵɵattribute("colspan", ctx_r17.columnsSpan);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r17.detailTemplate.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction3(17, _c190, item_r13.data, item_r13.index, item_r13.data));
} }
function TableBodyComponent_ng_template_2_tr_3_ng_template_1_td_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 31);
} }
function TableBodyComponent_ng_template_2_tr_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TableBodyComponent_ng_template_2_tr_3_ng_template_1_td_0_Template, 1, 0, "td", 27);
} if (rf & 2) {
    const ctx_r39 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r39.groups);
} }
function TableBodyComponent_ng_template_2_tr_3_td_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 9);
} if (rf & 2) {
    const rowIndex_r14 = ɵngcc0.ɵɵnextContext(2).index;
    const ctx_r40 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r40.logicalRowIndex(rowIndex_r14))("logicalColIndex", 0);
} }
function TableBodyComponent_ng_template_2_tr_3_td_3_ng_template_1_Template(rf, ctx) { }
const _c191 = function (a0, a1, a2, a3, a4, a5) { return { templateRef: a0, group: a1, field: a2, column: a3, aggregates: a4, $implicit: a5 }; };
function TableBodyComponent_ng_template_2_tr_3_td_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 34);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_template_2_tr_3_td_3_ng_template_1_Template, 0, 0, "ng-template", 35);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r45 = ctx.$implicit;
    const ctx_r48 = ɵngcc0.ɵɵnextContext(2);
    const rowIndex_r14 = ctx_r48.index;
    const item_r13 = ctx_r48.$implicit;
    const ctx_r41 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r41.logicalRowIndex(rowIndex_r14))("logicalColIndex", ctx_r41.logicalColIndex(column_r45));
    ɵngcc0.ɵɵattribute("data-skip", ctx_r41.skipGroupDecoration);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction6(4, _c191, column_r45.groupFooterTemplateRef, item_r13.data, column_r45.field, column_r45, item_r13.data == null ? null : item_r13.data.aggregates, item_r13.data == null ? null : item_r13.data.aggregates));
} }
function TableBodyComponent_ng_template_2_tr_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 32);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_template_2_tr_3_ng_template_1_Template, 1, 1, "ng-template", 0);
    ɵngcc0.ɵɵtemplate(2, TableBodyComponent_ng_template_2_tr_3_td_2_Template, 1, 2, "td", 5);
    ɵngcc0.ɵɵtemplate(3, TableBodyComponent_ng_template_2_tr_3_td_3_Template, 2, 11, "td", 33);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const rowIndex_r14 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r18 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r18.logicalRowIndex(rowIndex_r14))("logicalSlaveRow", ctx_r18.lockedColumnsCount > 0)("logicalCellsCount", ctx_r18.columns.length)("logicalSlaveCellsCount", ctx_r18.unlockedColumnsCount);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r18.skipGroupDecoration);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r18.detailTemplate == null ? null : ctx_r18.detailTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r18.footerColumns)("ngForTrackBy", ctx_r18.trackByColumns);
} }
function TableBodyComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TableBodyComponent_ng_template_2_tr_0_Template, 1, 13, "tr", 14);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_template_2_tr_1_Template, 4, 28, "tr", 15);
    ɵngcc0.ɵɵtemplate(2, TableBodyComponent_ng_template_2_tr_2_Template, 5, 21, "tr", 16);
    ɵngcc0.ɵɵtemplate(3, TableBodyComponent_ng_template_2_tr_3_Template, 4, 8, "tr", 17);
} if (rf & 2) {
    const item_r13 = ctx.$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.isGroup(item_r13) && ctx_r2.isParentGroupExpanded(item_r13) && ctx_r2.showGroupHeader(item_r13));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.isDataItem(item_r13) && (!item_r13.group || ctx_r2.isDataItemInExpandedGroup(item_r13)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.isDataItem(item_r13) && (!item_r13.group || ctx_r2.isDataItemInExpandedGroup(item_r13)) && (ctx_r2.detailTemplate == null ? null : ctx_r2.detailTemplate.templateRef) && ctx_r2.detailTemplate.showIf(item_r13.data, item_r13.index) && ctx_r2.isExpanded(item_r13));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.isFooter(item_r13) && item_r13.group && (ctx_r2.isFooterItemInExpandedGroup(item_r13) || ctx_r2.showGroupFooters && ctx_r2.isParentGroupExpanded(item_r13.group)) && !item_r13.data.hideFooter);
} }
function TableBodyComponent_kendo_resize_sensor_3_Template(rf, ctx) { if (rf & 1) {
    const _r51 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-resize-sensor", 36);
    ɵngcc0.ɵɵlistener("resize", function TableBodyComponent_kendo_resize_sensor_3_Template_kendo_resize_sensor_resize_0_listener() { ɵngcc0.ɵɵrestoreView(_r51); const ctx_r50 = ɵngcc0.ɵɵnextContext(); return ctx_r50.resizeHandler(); });
    ɵngcc0.ɵɵelementEnd();
} }
const _c192 = ["kendoGridCell", ""];
function CellComponent_ng_container_1_ng_container_1_ng_template_1_Template(rf, ctx) { }
function CellComponent_ng_container_1_ng_container_1_ng_template_2_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
    ɵngcc0.ɵɵpipe(1, "valueOf");
} if (rf & 2) {
    const childColumn_r10 = ctx.$implicit;
    const ctx_r9 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind3(1, 1, ctx_r9.dataItem, childColumn_r10.field, childColumn_r10.format), " ");
} }
function CellComponent_ng_container_1_ng_container_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, CellComponent_ng_container_1_ng_container_1_ng_template_2_ng_template_0_Template, 2, 5, "ng-template", 6);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r6.childColumns);
} }
function CellComponent_ng_container_1_ng_container_1_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
    ɵngcc0.ɵɵpipe(1, "valueOf");
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind3(1, 1, ctx_r7.dataItem, ctx_r7.column.field, ctx_r7.column.format));
} }
function CellComponent_ng_container_1_ng_container_1_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "input", 7);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("kendoGridSelectionCheckbox", ctx_r8.rowIndex);
    ɵngcc0.ɵɵattribute("id", ctx_r8.selectionCheckboxId)("aria-label", ctx_r8.selectionCheckboxLabel);
} }
function CellComponent_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_ng_template_1_Template, 0, 0, "ng-template", 4);
    ɵngcc0.ɵɵtemplate(2, CellComponent_ng_container_1_ng_container_1_ng_template_2_Template, 1, 1, "ng-template", 5);
    ɵngcc0.ɵɵtemplate(3, CellComponent_ng_container_1_ng_container_1_ng_template_3_Template, 2, 5, "ng-template", 5);
    ɵngcc0.ɵɵtemplate(4, CellComponent_ng_container_1_ng_container_1_ng_template_4_Template, 1, 3, "ng-template", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.column.templateRef)("ngTemplateOutlet", ctx_r2.column.templateRef)("ngTemplateOutletContext", ctx_r2.templateContext);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.isSpanColumn);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.isBoundColumn);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.isCheckboxColumn && !ctx_r2.isNew);
} }
function CellComponent_ng_container_1_ng_template_2_0_ng_template_0_Template(rf, ctx) { }
const _c193 = function (a0) { return { $implicit: a0 }; };
function CellComponent_ng_container_1_ng_template_2_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, CellComponent_ng_container_1_ng_template_2_0_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r11.loadingTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c193, ctx_r11.column));
} }
function CellComponent_ng_container_1_ng_template_2_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 11);
} }
function CellComponent_ng_container_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, CellComponent_ng_container_1_ng_template_2_0_Template, 1, 4, null, 8);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_template_2_div_1_Template, 1, 0, "div", 9);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.loadingTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r4.loadingTemplate);
} }
function CellComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_Template, 5, 6, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, CellComponent_ng_container_1_ng_template_2_Template, 2, 2, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r3 = ɵngcc0.ɵɵreference(3);
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.showLoading)("ngIfElse", _r3);
} }
function CellComponent_ng_container_2_1_ng_template_0_Template(rf, ctx) { }
function CellComponent_ng_container_2_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, CellComponent_ng_container_2_1_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r14.column.editTemplateRef)("ngTemplateOutletContext", ctx_r14.editTemplateContext);
} }
function CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-numerictextbox", 16);
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("format", ctx_r17.format)("formControl", ctx_r17.formGroup.get(ctx_r17.column.field));
} }
function CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-datepicker", 16);
} if (rf & 2) {
    const ctx_r18 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("format", ctx_r18.format)("formControl", ctx_r18.formGroup.get(ctx_r18.column.field));
} }
function CellComponent_ng_container_2_ng_container_2_input_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "input", 17);
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("formControl", ctx_r19.formGroup.get(ctx_r19.column.field));
} }
function CellComponent_ng_container_2_ng_container_2_input_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "input", 18);
} if (rf & 2) {
    const ctx_r20 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("formControl", ctx_r20.formGroup.get(ctx_r20.column.field));
} }
function CellComponent_ng_container_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 0);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template, 1, 2, "kendo-numerictextbox", 13);
    ɵngcc0.ɵɵtemplate(2, CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template, 1, 2, "kendo-datepicker", 13);
    ɵngcc0.ɵɵtemplate(3, CellComponent_ng_container_2_ng_container_2_input_3_Template, 1, 1, "input", 14);
    ɵngcc0.ɵɵtemplate(4, CellComponent_ng_container_2_ng_container_2_input_4_Template, 1, 1, "input", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r15.column.editor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "numeric");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "date");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "boolean");
} }
function CellComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_2_1_Template, 1, 2, null, 8);
    ɵngcc0.ɵɵtemplate(2, CellComponent_ng_container_2_ng_container_2_Template, 5, 4, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.column.editTemplateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.column.editTemplateRef);
} }
const _c194 = ["kendoGridFooter", ""];
function FooterComponent_ng_template_0_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 5);
} if (rf & 2) {
    ɵngcc0.ɵɵclassProp("k-group-cell", true);
} }
function FooterComponent_ng_template_0_td_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 5);
} if (rf & 2) {
    ɵngcc0.ɵɵclassProp("k-hierarchy-cell", true);
} }
function FooterComponent_ng_template_0_td_3_ng_template_1_Template(rf, ctx) { }
function FooterComponent_ng_template_0_td_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 6);
    ɵngcc0.ɵɵtemplate(1, FooterComponent_ng_template_0_td_3_ng_template_1_Template, 0, 0, "ng-template", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r5 = ctx.$implicit;
    const columnIndex_r6 = ctx.index;
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp("k-grid-footer-sticky", column_r5.sticky);
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r3.logicalRowIndex)("logicalColIndex", ctx_r3.logicalColumnIndex(column_r5))("ngClass", column_r5.footerClass)("ngStyle", column_r5.sticky ? ctx_r3.addStickyStyles(column_r5) : column_r5.footerStyle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction4(7, _c181, column_r5.footerTemplateRef, ctx_r3.lockedColumnsCount + columnIndex_r6, column_r5, column_r5));
} }
function FooterComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 1);
    ɵngcc0.ɵɵtemplate(1, FooterComponent_ng_template_0_td_1_Template, 1, 2, "td", 2);
    ɵngcc0.ɵɵtemplate(2, FooterComponent_ng_template_0_td_2_Template, 1, 2, "td", 3);
    ɵngcc0.ɵɵtemplate(3, FooterComponent_ng_template_0_td_3_Template, 2, 12, "td", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-footer-template", true);
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.columns.length - ctx_r0.lockedColumnsCount);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.groups);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.columnsToRender);
} }
function ToolbarComponent_0_ng_template_0_Template(rf, ctx) { }
function ToolbarComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ToolbarComponent_0_ng_template_0_Template, 0, 0, "ng-template", 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.toolbarTemplateRef)("ngTemplateOutletContext", ctx_r0.context);
} }
const EMPTY_REGEX = /^\s*$/;
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const isBlank = (value) => value === null || value === undefined;
/**
 * @hidden
 */
const isArray = (value) => Array.isArray(value);
/**
 * @hidden
 */
const isTruthy = (value) => !!value;
/**
 * @hidden
 */
const isNullOrEmptyString = (value) => isBlank(value) || EMPTY_REGEX.test(value);
/**
 * @hidden
 */
const observe = (list) => merge(of(list), list.changes);
/**
 * @hidden
 */
const isUniversal = () => typeof document === 'undefined';
/**
 * @hidden
 */
const isString = (value) => typeof value === 'string';
/**
 * @hidden
 */
const isNumber = (value) => typeof value === "number" && !isNaN(value);
/**
 * @hidden
 */
const extractFormat = (format) => {
    if (isString(format) && !isNullOrEmptyString(format) && format.startsWith('{0:')) {
        return format.slice(3, format.length - 1);
    }
    return format;
};
/**
 * @hidden
 */
const not = (fn) => (...args) => !fn.apply(null, args);
/**
 * @hidden
 */
const or = (...conditions) => (value) => conditions.reduce((acc, x) => acc || x(value), false);
/**
 * @hidden
 */
const and = (...conditions) => (value) => conditions.reduce((acc, x) => acc && x(value), true);
/**
 * @hidden
 */
const Skip = new InjectionToken("Skip"); // tslint:disable-line:variable-name
/**
 * @hidden
 */
const createPromise = () => {
    let resolveFn, rejectFn;
    const promise = new Promise((resolve, reject) => {
        resolveFn = (data) => {
            resolve(data);
            return promise;
        };
        rejectFn = (data) => {
            reject(data);
            return promise;
        };
    });
    promise.resolve = resolveFn;
    promise.reject = rejectFn;
    return promise;
};
/** @hidden */
const iterator = getIterator();
// TODO: Move to kendo-common
function getIterator() {
    if (typeof Symbol === 'function' && Symbol.iterator) {
        return Symbol.iterator;
    }
    const keys = Object.getOwnPropertyNames(Map.prototype);
    const proto = Map.prototype;
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key !== 'entries' && key !== 'size' && proto[key] === proto.entries) {
            return key;
        }
    }
}
const FRAME_DURATION = 1000 / 60;
const wnd = typeof window !== 'undefined' ? window : {};
/** @hidden */
const requestAnimationFrame = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || (callback => setTimeout(callback, FRAME_DURATION));
/** @hidden */
const cancelAnimationFrame = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;
/**
 * @hidden
 */
const detectIE = () => {
    if (!isDocumentAvailable()) {
        return;
    }
    const ua = window.navigator.userAgent;
    const msie = ua.indexOf('MSIE ');
    const trident = ua.indexOf('Trident/');
    return msie > 0 || trident > 0;
};
/**
 * @hidden
 */
const nodesToArray = (nodes) => [].slice.call(nodes);
/**
 * @hidden
 */
const replaceMessagePlaceholder = (message, name, value) => message.replace(new RegExp(`\{\\s*${name}\\s*\}`, 'g'), value);

/**
 * Represents the Kendo UI GridSpacer component for Angular.
 * Used to give additional white space between the Pager inner elements,
 * and provides a way for customizing the spacer width.
 * It can also be used in any flex container within the Grid.
 */
let GridSpacerComponent = class GridSpacerComponent {
    /**
     * Represents the Kendo UI GridSpacer component for Angular.
     * Used to give additional white space between the Pager inner elements,
     * and provides a way for customizing the spacer width.
     * It can also be used in any flex container within the Grid.
     */
    constructor() {
        this.hostClass = true;
    }
    get sizedClass() {
        return isPresent(this.width);
    }
    get flexBasisStyle() {
        return this.width;
    }
};
GridSpacerComponent.ɵfac = function GridSpacerComponent_Factory(t) { return new (t || GridSpacerComponent)(); };
GridSpacerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GridSpacerComponent, selectors: [["kendo-grid-spacer"], ["kendo-pager-spacer"]], hostVars: 6, hostBindings: function GridSpacerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("flex-basis", ctx.flexBasisStyle);
        ɵngcc0.ɵɵclassProp("k-spacer", ctx.hostClass)("k-spacer-sized", ctx.sizedClass);
    } }, inputs: { width: "width" }, decls: 0, vars: 0, template: function GridSpacerComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-spacer'),
    __metadata("design:type", Boolean)
], GridSpacerComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-spacer-sized'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], GridSpacerComponent.prototype, "sizedClass", null);
__decorate([
    HostBinding('style.flexBasis'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], GridSpacerComponent.prototype, "flexBasisStyle", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], GridSpacerComponent.prototype, "width", void 0);

/**
 * @hidden
 */
let DomEventsService = class DomEventsService {
    /**
     * @hidden
     */
    constructor() {
        this.cellClick = new EventEmitter();
        this.cellMousedown = new EventEmitter();
        this.cellMouseup = new EventEmitter();
        this.click = new EventEmitter();
        this.keydown = new EventEmitter();
        this.focus = new EventEmitter();
        this.focusIn = new EventEmitter();
        this.focusOut = new EventEmitter();
        this.windowBlur = new EventEmitter();
    }
};
DomEventsService.ɵfac = function DomEventsService_Factory(t) { return new (t || DomEventsService)(); };
DomEventsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DomEventsService, factory: function (t) { return DomEventsService.ɵfac(t); } });

/**
 * @hidden
 */
let LocalDataChangesService = class LocalDataChangesService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new EventEmitter();
    }
};
LocalDataChangesService.ɵfac = function LocalDataChangesService_Factory(t) { return new (t || LocalDataChangesService)(); };
LocalDataChangesService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: LocalDataChangesService, factory: function (t) { return LocalDataChangesService.ɵfac(t); } });

/**
 * @hidden
 */
const FOCUS_ROOT_ACTIVE = new InjectionToken('focus-root-initial-active-state');
/**
 * @hidden
 */
let FocusRoot = class FocusRoot {
    constructor(active = false) {
        this.active = active;
        this.groups = new Set();
    }
    registerGroup(group) {
        if (this.active) {
            this.groups.add(group);
        }
    }
    unregisterGroup(group) {
        if (this.active) {
            this.groups.delete(group);
        }
    }
    activate() {
        if (this.active) {
            this.groups.forEach(f => f.activate());
        }
    }
    deactivate() {
        if (this.active) {
            this.groups.forEach(f => f.deactivate());
        }
    }
};
FocusRoot.ɵfac = function FocusRoot_Factory(t) { return new (t || FocusRoot)(ɵngcc0.ɵɵinject(FOCUS_ROOT_ACTIVE, 8)); };
FocusRoot.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FocusRoot, factory: function (t) { return FocusRoot.ɵfac(t); } });
FocusRoot = __decorate([ __param(0, Optional()), __param(0, Inject(FOCUS_ROOT_ACTIVE)),
    __metadata("design:paramtypes", [Boolean])
], FocusRoot);

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const NODE_NAME_PREDICATES = {};
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClasses = (element, classNames) => {
    const namesList = toClassList(classNames);
    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
/**
 * @hidden
 */
const matchesClasses = (classNames) => (element) => hasClasses(element, classNames);
/**
 * @hidden
 */
const matchesNodeName = (nodeName) => {
    if (!NODE_NAME_PREDICATES[nodeName]) {
        NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();
    }
    return NODE_NAME_PREDICATES[nodeName];
};
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const closestInScope = (node, predicate, scope) => {
    while (node && node !== scope && !predicate(node)) {
        node = node.parentNode;
    }
    if (node !== scope) {
        return node;
    }
};
/**
 * @hidden
 */
const contains = (parent, node, matchSelf = false) => {
    const outside = !closest(node, (child) => child === parent);
    if (outside) {
        return false;
    }
    const el = closest(node, (child) => child === node);
    return el && (matchSelf || el !== parent);
};
/**
 * @hidden
 */
const isVisible = (element) => {
    const rect = element.getBoundingClientRect();
    const hasSize = rect.width > 0 && rect.height > 0;
    const hasPosition = rect.x !== 0 && rect.y !== 0;
    // Elements can have zero size due to styling, but they will still count as visible.
    // For example, the selection checkbox has no size, but is made visible through styling.
    return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';
};
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (!element.tagName) {
        return false;
    }
    const tagName = element.tagName.toLowerCase();
    const hasTabIndex = Boolean(element.getAttribute('tabIndex'));
    const focusable = !element.disabled && focusableRegex.test(tagName);
    return focusable || hasTabIndex;
};
/**
 * @hidden
 */
const isFocusableWithTabKey = (element, checkVisibility = true) => {
    if (!isFocusable(element)) {
        return false;
    }
    const visible = !checkVisibility || isVisible(element);
    const ariaHidden = element.getAttribute('aria-hidden') === 'true';
    const tabIndex = element.getAttribute('tabIndex');
    return visible && !ariaHidden && tabIndex !== '-1';
};
/**
 * @hidden
 */
const findElement = (node, predicate, matchSelf = true) => {
    if (!node) {
        return;
    }
    if (matchSelf && predicate(node)) {
        return node;
    }
    node = node.firstChild;
    while (node) {
        if (node.nodeType === 1) {
            const element = findElement(node, predicate);
            if (element) {
                return element;
            }
        }
        node = node.nextSibling;
    }
};
/**
 * @hidden
 */
const findLastElement = (node, predicate, matchSelf = true) => {
    let last = null;
    findElement(node, (node) => {
        if (predicate(node)) {
            last = node;
        }
        return false;
    }, matchSelf);
    return last;
};
/**
 * @hidden
 */
const findFocusable = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));
};
/**
 * @hidden
 */
const findFocusableChild = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
/**
 * @hidden
 */
const findLastFocusableChild = (element, checkVisibility = true) => {
    return findLastElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
/**
 * @hidden
 */
function rtlScrollPosition(position, element, initial) {
    let result = position;
    if (initial < 0) {
        result = -position;
    }
    else if (initial > 0) {
        result = element.scrollWidth - element.offsetWidth - position;
    }
    return result;
}

const isButton = matchesNodeName('button');
const isInputTag = matchesNodeName('input');
const navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;
const isNavigableInput = element => isInputTag(element) && navigableRegex.test(element.type);
const isNavigable = element => !element.disabled && (isButton(element) || isNavigableInput(element));
/**
 * @hidden
 */
class DefaultFocusableElement {
    constructor(host, renderer) {
        this.renderer = renderer;
        this.element = host.nativeElement;
        this.focusable = findFocusable(this.element, false) || this.element;
    }
    get enabled() {
        return this.focusable && !this.focusable.disabled;
    }
    get visible() {
        return this.focusable && isVisible(this.focusable);
    }
    isNavigable() {
        return this.canFocus() && isNavigable(this.element);
    }
    toggle(active) {
        this.renderer.setAttribute(this.focusable, 'tabIndex', active ? '0' : '-1');
    }
    focus() {
        if (this.focusable) {
            this.focusable.focus();
        }
    }
    canFocus() {
        return this.visible && this.enabled;
    }
    hasFocus() {
        return document.activeElement !== this.element && closest(document.activeElement, e => e === this.element);
    }
}

/**
 * @hidden
 */
const CELL_CONTEXT = new InjectionToken('grid-cell-context');
/**
 * @hidden
 */
const EMPTY_CELL_CONTEXT = {};

/**
 * A directive that controls the way focusable elements receive
 * [focus in a navigable Grid]({% slug keyboard_navigation_grid %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *      <input type="text" placeholder="Tab stop #0" style="margin-bottom: 8px;" />
 *      <kendo-grid [data]="data" [navigable]="true">
 *          <kendo-grid-column field="ProductID" title="Product ID" width="100">
 *          </kendo-grid-column>
 *          <kendo-grid-column field="ProductName" title="Product Name" width="150">
 *          </kendo-grid-column>
 *          <kendo-grid-column>
 *              <ng-template kendoGridCellTemplate let-dataItem>
 *                  <!-- The first focusable element will be focused when pressing Enter on the cell -->
 *                  <input type="text" kendoGridFocusable [value]="dataItem.ProductName" style="margin-right: 8px;" />
 *                  <button kendoGridFocusable>Update</button>
 *              </ng-template>
 *          </kendo-grid-column>
 *          <kendo-grid-column width="100">
 *              <ng-template kendoGridCellTemplate>
 *                  <!-- A single focusable element will be focused during navigation -->
 *                  <button kendoGridFocusable>Delete</button>
 *              </ng-template>
 *          </kendo-grid-column>
 *      </kendo-grid>
 *      <input type="text" placeholder="Tab stop #2" style="margin-top: 8px;" />
 *    `
 * })
 *
 * class AppComponent {
 *     public readonly data: any = [{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": true
 *     }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": false
 *     }];
 * }
 * ```
 */
let FocusableDirective = class FocusableDirective {
    constructor(cellContext, hostElement, renderer) {
        this.cellContext = cellContext;
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.active = true;
        this._enabled = true;
        if (this.cellContext) {
            this.group = this.cellContext.focusGroup;
        }
        if (this.group) {
            this.group.registerElement(this);
        }
    }
    /**
     * @hidden
     */
    set enabled(value) {
        if (value === '') {
            value = true;
        }
        else {
            value = Boolean(value);
        }
        if (value !== this.enabled) {
            this._enabled = value;
            if (this.element) {
                this.element.toggle(this.active && value);
            }
        }
    }
    get enabled() {
        return this._enabled;
    }
    ngAfterViewInit() {
        if (!this.element) {
            this.element = new DefaultFocusableElement(this.hostElement, this.renderer);
        }
        if (this.group && this.element) {
            this.toggle(this.group.isActive);
        }
    }
    ngOnDestroy() {
        if (this.group) {
            this.group.unregisterElement(this);
        }
    }
    /**
     * @hidden
     */
    toggle(active) {
        if (this.element && active !== this.active) {
            this.element.toggle(this.enabled && active);
            this.active = active;
        }
    }
    /**
     * @hidden
     */
    canFocus() {
        return this.enabled && this.element && this.element.canFocus();
    }
    /**
     * @hidden
     */
    isNavigable() {
        return this.enabled && this.element && this.element.isNavigable();
    }
    /**
     * @hidden
     */
    focus() {
        if (this.enabled && this.element) {
            this.element.focus();
        }
    }
    /**
     * @hidden
     */
    hasFocus() {
        return this.enabled && this.element && this.element.hasFocus();
    }
    /**
     * @hidden
     */
    registerElement(element) {
        this.element = element;
    }
};
FocusableDirective.ɵfac = function FocusableDirective_Factory(t) { return new (t || FocusableDirective)(ɵngcc0.ɵɵdirectiveInject(CELL_CONTEXT, 12), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FocusableDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FocusableDirective, selectors: [["", "kendoGridFocusable", ""], ["", "kendoGridEditCommand", ""], ["", "kendoGridRemoveCommand", ""], ["", "kendoGridSaveCommand", ""], ["", "kendoGridCancelCommand", ""], ["", "kendoGridSelectionCheckbox", ""]], inputs: { enabled: ["kendoGridFocusable", "enabled"] } });
__decorate([
    Input('kendoGridFocusable'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], FocusableDirective.prototype, "enabled", null);
FocusableDirective = __decorate([ __param(0, Optional()), __param(0, Inject(CELL_CONTEXT)), __param(0, SkipSelf()),
    __metadata("design:paramtypes", [Object, ElementRef,
        Renderer2])
], FocusableDirective);

/**
 * @hidden
 */
class GridFocusableElement {
    constructor(navigationService) {
        this.navigationService = navigationService;
    }
    focus() {
        this.navigationService.focusCell();
    }
    toggle(active) {
        this.navigationService.toggle(active);
    }
    canFocus() {
        return true;
    }
    hasFocus() {
        return this.navigationService.hasFocus();
    }
    isNavigable() {
        return false;
    }
}

/**
 * @hidden
 */
class NavigationCursor {
    constructor(model) {
        this.model = model;
        this.changes = new Subject();
        this.activeRow = 0;
        this.activeCol = 0;
        this.virtualCol = 0;
        this.virtualRow = 0;
    }
    get row() {
        return this.model.findRow(this.activeRow);
    }
    get cell() {
        const row = this.row;
        if (row) {
            return this.model.findCell(this.activeCol, row);
        }
    }
    get dataRowIndex() {
        const row = this.row;
        if (row) {
            return row.dataRowIndex;
        }
        return -1;
    }
    /**
     * Assumes and announces a new cursor position.
     */
    reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {
        if (this.activate(rowIndex, colIndex, force)) {
            this.virtualRow = rowIndex;
            this.virtualCol = colIndex;
        }
    }
    activate(rowIndex, colIndex, force) {
        if (!force && this.isActiveRange(rowIndex, colIndex)) {
            return false;
        }
        const prevColIndex = this.activeCol;
        const prevRowIndex = this.activeRow;
        this.activeCol = colIndex;
        this.activeRow = rowIndex;
        this.changes.next({
            colIndex,
            prevColIndex,
            prevRowIndex,
            rowIndex
        });
        return true;
    }
    isActiveRange(rowIndex, colIndex) {
        if (this.activeRow !== rowIndex) {
            return false;
        }
        const cell = this.cell;
        const { start, end } = this.model.cellRange(cell);
        return !Boolean(cell) || (start <= colIndex && colIndex <= end);
    }
    /**
     * Assumes a new cursor position without announcing it.
     */
    assume(rowIndex = this.activeRow, colIndex = this.activeCol) {
        this.virtualRow = rowIndex;
        this.virtualCol = colIndex;
        this.activeCol = colIndex;
        this.activeRow = rowIndex;
    }
    /**
     * Announces a current cursor position to subscribers.
     */
    announce() {
        this.changes.next({
            colIndex: this.activeCol,
            prevColIndex: this.activeCol,
            prevRowIndex: this.activeRow,
            rowIndex: this.activeRow
        });
    }
    activateVirtualCell(cell) {
        const rowRange = this.model.rowRange(cell);
        const cellRange = this.model.cellRange(cell);
        const activeCol = this.activeCol;
        const activeRow = this.activeRow;
        if (rowRange.start <= activeRow && activeRow <= rowRange.end &&
            cellRange.start <= activeCol && activeCol <= cellRange.end) {
            this.activeRow = cell.rowIndex;
            this.activeCol = cell.colIndex;
            return true;
        }
    }
    isActive(rowIndex, colIndex) {
        return this.activeCol === colIndex && this.activeRow === rowIndex;
    }
    moveUp(offset = 1) {
        return this.offsetRow(-offset);
    }
    moveDown(offset = 1) {
        return this.offsetRow(offset);
    }
    moveLeft(offset = 1) {
        return this.offsetCol(-offset);
    }
    moveRight(offset = 1) {
        return this.offsetCol(offset);
    }
    lastCellIndex(row) {
        return this.metadata.columns.leafColumnsToRender.length - 1 +
            (this.metadata.hasDetailTemplate && (!row || !row.groupItem) ? 1 : 0);
    }
    offsetCol(offset) {
        const prevRow = this.model.findRow(this.virtualRow);
        const lastIndex = this.lastCellIndex(prevRow);
        const virtualCol = this.virtualCol;
        this.virtualCol = Math.max(0, Math.min(virtualCol + offset, lastIndex));
        let nextColIndex = this.virtualCol;
        let nextRowIndex = this.virtualRow;
        let cell = this.model.findCell(this.virtualCol, prevRow);
        if (!cell && this.metadata.virtualColumns) {
            return this.activate(nextRowIndex, nextColIndex);
        }
        if (cell.colSpan > 1 && cell.colIndex <= virtualCol && virtualCol < cell.colIndex + cell.colSpan) {
            nextColIndex = offset > 0 ? Math.min(cell.colIndex + cell.colSpan, lastIndex) : Math.max(0, cell.colIndex + offset);
            const nextCell = this.model.findCell(nextColIndex, prevRow);
            if (cell !== nextCell) {
                cell = nextCell;
                this.virtualCol = cell.colIndex;
            }
            else {
                this.virtualCol = virtualCol;
            }
        }
        return this.activate(cell.rowIndex, cell.colIndex);
    }
    offsetRow(offset) {
        let nextColIndex = this.virtualCol;
        if (this.metadata && this.metadata.isVirtual) {
            const maxIndex = this.metadata.maxLogicalRowIndex;
            let nextIndex = Math.max(0, Math.min(this.activeRow + offset, maxIndex));
            if (this.metadata.hasDetailTemplate && !this.model.findRow(nextIndex)) {
                nextIndex = offset > 0 ? nextIndex + 1 : nextIndex - 1;
                nextIndex = Math.max(0, Math.min(nextIndex, maxIndex));
            }
            if (this.metadata.hasDetailTemplate && nextIndex === maxIndex) {
                if (this.model.lastRow.index !== maxIndex) {
                    // Don't attempt to navigate past the last collapsed row.
                    nextIndex--;
                }
            }
            const nextRow = this.model.findRow(nextIndex);
            if (nextRow) {
                // remove duplication
                let cell = this.model.findCell(this.virtualCol, nextRow);
                if (cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) {
                    cell = this.model.findCell(this.virtualCol, this.model.findRow(cell.rowIndex + cell.rowSpan - 1 + offset));
                }
                nextIndex = cell.rowIndex;
                nextColIndex = cell.colIndex;
            }
            this.virtualRow = nextIndex;
            return this.activate(nextIndex, nextColIndex);
        }
        const nextRow = this.model.findRow(this.virtualRow + offset) || this.model.nextRow(this.virtualRow, offset);
        if (!nextRow) {
            return false;
        }
        let cell = this.model.findCell(this.virtualCol, nextRow);
        if (cell && cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) { // spanned cell go to next
            const nextPos = cell.rowIndex + cell.rowSpan - 1 + offset;
            cell = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));
        }
        if (!cell && this.metadata.virtualColumns) {
            return this.activate(this.virtualRow + offset, this.virtualCol);
        }
        this.virtualRow = cell.rowIndex;
        return this.activate(this.virtualRow, cell.colIndex);
    }
}

/**
 * @hidden
 */
class ItemMap {
    constructor() {
        this.count = 0;
        this.items = {};
    }
    get first() {
        if (this.count > 0) {
            let result;
            this.forEach(item => {
                result = item;
                return true;
            });
            return result;
        }
    }
    get last() {
        if (this.count > 0) {
            const keys = Object.keys(this.items);
            return this.items[keys[keys.length - 1]];
        }
    }
    removeItem(key) {
        if (this.items[key]) {
            delete this.items[key];
            this.count--;
        }
    }
    setItem(key, item) {
        if (!this.items[key]) {
            this.count++;
        }
        this.items[key] = item;
    }
    getItem(key) {
        return this.items[key];
    }
    toArray() {
        const result = [];
        this.forEach(item => {
            result.push(item);
        });
        return result;
    }
    forEach(callback) {
        for (let key in this.items) {
            if (this.items.hasOwnProperty(key) && callback(this.items[key])) {
                return this.items[key];
            }
        }
    }
    find(callback) {
        return this.forEach(callback);
    }
}

/**
 * @hidden
 *
 * Contains information for the currently rendered rows and cells.
 */
class NavigationModel {
    constructor() {
        this.rows = new ItemMap();
    }
    get firstRow() {
        return this.rows.first;
    }
    get lastRow() {
        return this.rows.last;
    }
    registerCell(cell) {
        const row = this.rows.getItem(cell.logicalRowIndex);
        if (!row) {
            return;
        }
        const colIndex = cell.logicalColIndex;
        const modelCell = {
            uid: cell.uid,
            colIndex,
            rowIndex: row.index,
            colSpan: cell.colSpan,
            rowSpan: cell.rowSpan,
            detailExpandCell: cell.detailExpandCell,
            dataItem: row.dataItem,
            dataRowIndex: row.dataRowIndex,
            focusGroup: cell.focusGroup
        };
        row.cells.setItem(colIndex, modelCell);
        if (cell.groupItem) {
            row.groupItem = cell.groupItem;
        }
        return modelCell;
    }
    unregisterCell(index, rowIndex, cell) {
        const row = this.rows.getItem(rowIndex);
        if (row) {
            const match = row.cells.getItem(index);
            if (match && match.uid === cell.uid) {
                row.cells.removeItem(index);
            }
        }
    }
    registerRow(row) {
        const modelRow = {
            uid: row.uid,
            index: row.logicalRowIndex,
            dataItem: row.dataItem,
            dataRowIndex: row.dataRowIndex,
            cells: new ItemMap()
        };
        this.rows.setItem(row.logicalRowIndex, modelRow);
    }
    updateRow(row) {
        const current = this.rows.getItem(row.logicalRowIndex);
        if (current) {
            Object.assign(current, {
                dataItem: row.dataItem,
                dataRowIndex: row.dataRowIndex
            });
        }
    }
    unregisterRow(index, row) {
        const match = this.rows.getItem(index);
        if (match && match.uid === row.uid) {
            this.rows.removeItem(index);
        }
    }
    cellRange(cell) {
        if (cell) {
            const start = cell.colIndex;
            const end = cell.colIndex + (cell.colSpan || 1) - 1;
            return {
                start,
                end
            };
        }
        return {};
    }
    rowRange(cell) {
        if (cell) {
            const start = cell.rowIndex;
            const end = cell.rowIndex + (cell.rowSpan || 1) - 1;
            return {
                start,
                end
            };
        }
        return {};
    }
    nextRow(rowIndex, offset) {
        const rows = this.rows.toArray();
        const row = this.rows.getItem(rowIndex);
        const position = rows.indexOf(row);
        const next = rows[position + offset];
        return next;
    }
    findRow(index) {
        return this.rows.getItem(index);
    }
    findCell(index, row) {
        if (!row) {
            return;
        }
        const rowIndex = row.index;
        let cell = row.cells.getItem(index);
        let currentIndex = rowIndex;
        while (!cell && row) {
            row = this.rows.getItem(currentIndex);
            cell = this.rowCell(index, row);
            currentIndex--;
        }
        if (cell && rowIndex <= row.index + (cell.rowSpan || 1) - 1) {
            return cell;
        }
    }
    rowCell(index, row) {
        if (!row || !row.cells.count) {
            return;
        }
        const firstCell = row.cells.first;
        let cell, currentIndex = index;
        while (!cell && currentIndex >= firstCell.colIndex) {
            cell = row.cells.getItem(currentIndex);
            currentIndex--;
        }
        if (cell && index <= cell.colIndex + (cell.colSpan || 1) - 1) {
            return cell;
        }
    }
}

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `cellClose` event.
 */
class CellCloseEvent extends PreventableEvent {
    constructor(options) {
        super();
        /**
         * @hidden
         */
        this.action = 'cellClose';
        Object.assign(this, options);
    }
}

/**
 * @hidden
 */
const isEqual = (index) => (item) => item.index === index;
/**
 * @hidden
 */
const isNotEqual = (index) => (item) => item.index !== index;
/**
 * @hidden
 */
const isNewRow = (index) => index === -1 || index === undefined;
/**
 * @hidden
 */
let EditService = class EditService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.changes = new EventEmitter();
        this.editedIndices = [];
        this.keepEditCell = false;
        this.closingCell = false;
        this.changedSource = new Subject();
        this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));
    }
    editRow(index, group = undefined) {
        this.editedIndices.push({ index, group });
        this.onChanged();
    }
    addRow(group) {
        this.newItemGroup = { group };
        this.onChanged();
    }
    editCell(rowIndex, column, group) {
        if (isNewRow(rowIndex) || column.editable === false || !(column.editTemplate || column.field)) {
            return;
        }
        this.preventCellClose();
        if (!this.closeCell()) {
            this.editRow(rowIndex, group);
            this.column = column;
            this.onChanged();
        }
    }
    isEditing() {
        return this.editedIndices.length > 0;
    }
    isEditingCell() {
        return this.isEditing() && this.column !== undefined;
    }
    get hasNewItem() {
        return isPresent(this.newItemGroup);
    }
    get newDataItem() {
        if (this.hasNewItem) {
            return this.newItemGroup.group.value;
        }
        return {};
    }
    close(index) {
        if (isNewRow(index)) {
            this.newItemGroup = undefined;
            return;
        }
        this.editedIndices = this.editedIndices.filter(isNotEqual(index));
        delete this.column;
        this.onChanged();
    }
    closeCell(originalEvent) {
        if (this.column && !this.closingCell) {
            return this.ngZone.run(() => {
                const { index, group } = this.editedIndices[0];
                const args = new CellCloseEvent({
                    column: this.column,
                    formGroup: group,
                    originalEvent: originalEvent,
                    rowIndex: index
                });
                this.closingCell = true;
                this.changes.emit(args);
                this.closingCell = false;
                if (!args.isDefaultPrevented()) {
                    this.cancelCell();
                }
                return args.isDefaultPrevented();
            });
        }
    }
    cancelCell() {
        if (this.column) {
            this.editedIndices = [];
            delete this.column;
            this.onChanged();
        }
    }
    shouldCloseCell() {
        return this.column && !this.keepEditCell;
    }
    preventCellClose() {
        this.ngZone.runOutsideAngular(() => {
            window.clearTimeout(this.keepCellTimeout);
            this.keepEditCell = true;
            this.keepCellTimeout = window.setTimeout(() => {
                this.keepEditCell = false;
            }, 0); // tslint:disable-line:align
        });
    }
    context(index) {
        if (isNewRow(index)) {
            return this.newItemGroup;
        }
        return this.findByIndex(index);
    }
    columnContext(index, column) {
        if (isNewRow(index)) {
            return this.newItemGroup;
        }
        if (!this.column || column === this.column) {
            return this.findByIndex(index);
        }
    }
    isEdited(index) {
        if (isNewRow(index) && isPresent(this.newItemGroup)) {
            return true;
        }
        return !this.column && isPresent(this.findByIndex(index));
    }
    hasEdited(index) {
        return isPresent(this.context(index));
    }
    isEditedColumn(index, column) {
        if (this.column && this.column === column) {
            return isPresent(this.findByIndex(index));
        }
        return false;
    }
    beginEdit(rowIndex) {
        this.changes.emit({ action: 'edit', rowIndex });
    }
    beginAdd() {
        this.changes.emit({ action: 'add' });
    }
    endEdit(rowIndex) {
        const { group: formGroup } = this.context(rowIndex);
        this.changes.emit({ action: 'cancel', rowIndex, formGroup, isNew: isNewRow(rowIndex) });
    }
    save(rowIndex) {
        const { group: formGroup } = this.context(rowIndex);
        this.changes.emit({ action: 'save', rowIndex, formGroup, isNew: isNewRow(rowIndex) });
    }
    remove(rowIndex) {
        this.changes.emit({ action: 'remove', rowIndex });
    }
    findByIndex(index) {
        return this.editedIndices.find(isEqual(index));
    }
    onChanged() {
        this.ngZone.runOutsideAngular(() => {
            this.changedSource.next();
        });
    }
};
EditService.ɵfac = function EditService_Factory(t) { return new (t || EditService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
EditService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: EditService, factory: function (t) { return EditService.ɵfac(t); } });
EditService = __decorate([ __metadata("design:paramtypes", [NgZone])
], EditService);

/**
 * @hidden
 */
const getGroupRowArgs = (groupItem) => {
    if (!isPresent(groupItem)) {
        return null;
    }
    return { group: groupItem.data, groupIndex: groupItem.index, parentGroup: getGroupRowArgs(groupItem.parentGroup) };
};

const isChildIndex = (targetIndex, parentIndex) => parentIndex !== targetIndex && targetIndex.startsWith(parentIndex);
/**
 * @hidden
 */
let GroupsService = class GroupsService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new Subject();
        this.rowState = new Set();
    }
    reset() {
        this.rowState.clear();
    }
    ngOnDestroy() {
        this.reset();
    }
    isExpanded(groupArgs) {
        if (this.userCallback) {
            return this.userCallback(groupArgs);
        }
        return !this.rowState.has(groupArgs.groupIndex);
    }
    isInExpandedGroup(groupItem) {
        let expanded = true;
        while (groupItem && expanded) {
            expanded = this.isExpanded({
                group: groupItem.data,
                groupIndex: groupItem.index,
                parentGroup: getGroupRowArgs(groupItem.parentGroup)
            });
            groupItem = groupItem.parentGroup;
        }
        return expanded;
    }
    toggleRow(groupItem) {
        const parentGroup = getGroupRowArgs(groupItem.parentGroup);
        const expand = !this.isExpanded({ group: groupItem.data, groupIndex: groupItem.index, parentGroup });
        this.changes.next({ group: groupItem.data, expand, groupIndex: groupItem.index, parentGroup });
        // if usercallback is given, the rowState should be ignored
        if (this.userCallback) {
            return;
        }
        if (expand) {
            this.rowState.delete(groupItem.index);
        }
        else {
            this.rowState.add(groupItem.index);
        }
    }
    expandChildren(parentIndex) {
        this.rowState.forEach(index => isChildIndex(index, parentIndex) && this.rowState.delete(index));
    }
};
GroupsService.ɵfac = function GroupsService_Factory(t) { return new (t || GroupsService)(); };
GroupsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: GroupsService, factory: function (t) { return GroupsService.ɵfac(t); } });

/**
 * @hidden
 */
class PagerContextService {
    constructor() {
        this.changes = new Subject();
        this.pageChange = new Subject();
    }
    get currentPage() {
        return this.skip / this.pageSize;
    }
    notifyChanges(changes) {
        this.total = changes.total;
        this.pageSize = changes.pageSize;
        this.skip = changes.skip;
        this.changes.next(changes);
    }
    changePage(page) {
        this.pageChange.next({ skip: page * this.pageSize, take: this.pageSize });
    }
    changePageSize(value) {
        this.pageChange.next({ skip: 0, take: value });
    }
    nextPage() {
        const nextPage = this.currentPage + 1;
        if (nextPage * this.pageSize < this.total) {
            this.changePage(nextPage);
        }
    }
    prevPage() {
        const prevPage = this.currentPage - 1;
        if (prevPage * this.pageSize >= 0) {
            this.changePage(prevPage);
        }
    }
}
PagerContextService.ɵfac = function PagerContextService_Factory(t) { return new (t || PagerContextService)(); };
PagerContextService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: PagerContextService, factory: PagerContextService.ɵfac });

/**
 * Arguments for the `detailCollapse` event.
 */
class DetailCollapseEvent extends PreventableEvent {
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `detailExpand` event.
 */
class DetailExpandEvent extends PreventableEvent {
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * @hidden
 */
let DetailsService = class DetailsService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new Subject();
        this.rowState = new Set();
    }
    ngOnDestroy() {
        this.rowState.clear();
    }
    isExpanded(index, dataItem) {
        if (this.userCallback) {
            return this.userCallback({ index, dataItem });
        }
        return this.rowState.has(index);
    }
    toggleRow(index, dataItem) {
        if (this.isExpanded(index, dataItem)) {
            this.collapseRow(index, dataItem);
        }
        else {
            this.expandRow(index, dataItem);
        }
    }
    expandRow(index, dataItem) {
        const prevented = this.emitEvent({ dataItem, index, expand: true });
        if (!prevented && !this.userCallback) {
            this.rowState.add(index);
        }
    }
    collapseRow(index, dataItem) {
        const prevented = this.emitEvent({ dataItem, index, expand: false });
        if (!prevented && !this.userCallback) {
            this.rowState.delete(index);
        }
    }
    emitEvent(args) {
        const eventArg = new (args.expand ? DetailExpandEvent : DetailCollapseEvent)(args);
        this.changes.next(eventArg);
        return eventArg.isDefaultPrevented();
    }
};
DetailsService.ɵfac = function DetailsService_Factory(t) { return new (t || DetailsService)(); };
DetailsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DetailsService, factory: function (t) { return DetailsService.ɵfac(t); } });

/**
 * @hidden
 */
let ScrollRequestService = class ScrollRequestService {
    /**
     * @hidden
     */
    constructor() {
        this.requests = new Subject();
    }
    scrollTo(request) {
        this.requests.next(request);
    }
};
ScrollRequestService.ɵfac = function ScrollRequestService_Factory(t) { return new (t || ScrollRequestService)(); };
ScrollRequestService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ScrollRequestService, factory: function (t) { return ScrollRequestService.ɵfac(t); } });

const isInSameGrid = (element, gridElement) => closest(element, matchesNodeName('kendo-grid')) === gridElement;
const matchHeaderCell = matchesNodeName('th');
const matchDataCell = matchesNodeName('td');
const matchFooterCell = matchesNodeName('.k-grid-footer td');
const matchCell = (element) => matchDataCell(element) || matchHeaderCell(element) || matchFooterCell(element);
const gridCell = (element, gridElement) => {
    let target = closest(element, matchCell);
    while (target && !isInSameGrid(target, gridElement)) {
        target = closest(target.parentElement, matchCell);
    }
    return target;
};
const targetCell = (target, gridElement) => {
    const cell = gridCell(target, gridElement);
    const row = closest(cell, matchesNodeName('tr'));
    if (cell && row) {
        let rowIndex = row.getAttribute('aria-rowindex');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;
        let colIndex = cell.getAttribute('aria-colindex');
        colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;
        if (rowIndex !== null && colIndex !== null) {
            return { colIndex, rowIndex, element: cell };
        }
    }
};
const isArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight ||
    keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
const isNavigationKey = keyCode => isArrowKey(keyCode) ||
    keyCode === Keys.PageUp || keyCode === Keys.PageDown ||
    keyCode === Keys.Home || keyCode === Keys.End;
const isInput = matchesNodeName('input');
const isTextInput = element => element && isInput(element) && element.type.toLowerCase() === 'text';
const isPrintableCharacter = (str) => str.length === 1 && str.match(/\S/);
/**
 * @hidden
 */
class NavigationViewport {
    constructor(firstItemIndex, lastItemIndex) {
        this.firstItemIndex = firstItemIndex;
        this.lastItemIndex = lastItemIndex;
    }
    containsRow(dataRowIndex) {
        const headerRow = dataRowIndex < 0;
        return headerRow || (dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex);
    }
    intersects(start, end) {
        return (start <= this.firstItemIndex && this.lastItemIndex <= end) ||
            (this.firstItemIndex <= start && start <= this.lastItemIndex) ||
            (this.firstItemIndex <= end && end <= this.lastItemIndex);
    }
}
/**
 * @hidden
 */
let NavigationService = class NavigationService {
    constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, detailsService, focusRoot, editService, cd, localization, focusableParent) {
        this.zone = zone;
        this.domEvents = domEvents;
        this.pagerContextService = pagerContextService;
        this.scrollRequestService = scrollRequestService;
        this.groupsService = groupsService;
        this.detailsService = detailsService;
        this.focusRoot = focusRoot;
        this.editService = editService;
        this.cd = cd;
        this.localization = localization;
        this.focusableParent = focusableParent;
        this.cellKeydown = new EventEmitter();
        this.activeRowIndex = 0;
        this.alive = false;
        this.active = true;
        this.mode = 0 /* Standby */;
        this.model = new NavigationModel();
        this.cursor = new NavigationCursor(this.model);
        this.changes = this.cursor.changes;
    }
    set metadata(value) {
        this.meta = value;
        this.cursor.metadata = value;
    }
    get metadata() {
        return this.meta;
    }
    get enabled() {
        return this.alive;
    }
    get activeCell() {
        if (this.mode !== 0 /* Standby */) {
            return this.cursor.cell;
        }
    }
    get activeRow() {
        if (this.mode !== 0 /* Standby */) {
            return Object.assign({}, this.cursor.row, {
                cells: this.cursor.row.cells.toArray()
            });
        }
    }
    get activeDataRow() {
        return Math.max(0, this.activeRowIndex - this.meta.headerRows);
    }
    init(meta) {
        this.alive = true;
        this.focusRoot.active = true;
        this.metadata = meta;
        const onStableSubscriber = (...operators) => (args) => this.zone.isStable ?
            from([true]).pipe(map(() => args)) :
            this.zone.onStable.pipe(take(1), map(() => args), ...operators);
        const onStable = onStableSubscriber();
        this.subs = new Subscription();
        this.subs.add(this.cursor.changes
            .subscribe(args => this.onCursorChanges(args)));
        this.subs.add(this.domEvents.focus.pipe(switchMap(onStable))
            .subscribe((args) => this.navigateTo(args.target)));
        this.subs.add(this.domEvents.focusOut.pipe(filter(() => this.mode !== 0 /* Standby */), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus))))
            .subscribe(args => this.onFocusOut(args)));
        this.subs.add(this.domEvents.windowBlur.pipe(filter(() => this.mode !== 0 /* Standby */))
            .subscribe(() => this.onWindowBlur()));
        this.subs.add(
        // Closing the editor will not always trigger focusout in Firefox.
        // To get around this, we ensure that the cell is closed after editing.
        this.editService.changes.pipe(filter(e => e.action !== 'edit' && this.mode === 2 /* Content */), filter((e) => e.action === 'cellClose' && !e.prevented), switchMap(onStable))
            .subscribe(() => this.leaveCell()));
        this.subs.add(this.pagerContextService.pageChange
            .subscribe(() => this.cursor.reset(0, 0)));
        this.subs.add(this.domEvents.keydown
            .subscribe(args => this.onKeydown(args)));
        this.subs.add(this.domEvents.keydown.pipe(filter(args => args.keyCode === Keys.Tab && this.mode === 2 /* Content */), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(
        // Timeout if focusOut doesn't fire very soon
        interval(0).pipe(take(1))))))
            .subscribe(() => this.onTabout()));
        if (this.focusableParent) {
            const element = new GridFocusableElement(this);
            this.focusableParent.registerElement(element);
        }
        this.deactivateElements();
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
        this.alive = false;
    }
    registerCell(cell) {
        if (cell.logicalRowIndex !== this.pendingRowIndex) {
            const modelCell = this.model.registerCell(cell);
            if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {
                this.virtualCell = false;
            }
        }
    }
    registerCellOnCurrentRow(cell) {
        if (cell.logicalRowIndex === this.pendingRowIndex) {
            this.model.registerCell(cell);
        }
    }
    unregisterCell(index, rowIndex, cell) {
        this.model.unregisterCell(index, rowIndex, cell);
    }
    registerRow(row) {
        this.model.registerRow(row);
        this.pendingRowIndex = row.logicalRowIndex;
    }
    updateRow(row) {
        this.model.updateRow(row);
    }
    unregisterRow(index, row) {
        this.model.unregisterRow(index, row);
        const lastRow = this.model.lastRow;
        if (lastRow && this.mode === 0 /* Standby */) {
            const maxIndex = (this.needsViewport() && this.viewport) ? this.viewport.lastItemIndex : lastRow.index;
            if (this.activeRowIndex > maxIndex) {
                this.cursor.reset(0, 0);
            }
        }
    }
    isCellFocusable(cell) {
        return this.alive &&
            this.active &&
            this.mode !== 2 /* Content */ &&
            this.cursor.isActive(cell.logicalRowIndex, cell.logicalColIndex);
    }
    isCellFocused(cell) {
        return this.mode === 1 /* Cursor */ && this.isCellFocusable(cell);
    }
    navigateTo(el) {
        if (!this.alive) {
            return;
        }
        const cell = targetCell(el, this.meta.gridElement.nativeElement);
        if (!cell) {
            return;
        }
        const oldMode = this.mode;
        const focusInCell = contains(cell.element, document.activeElement);
        const focusInActiveRowContent = this.mode === 2 /* Content */ &&
            this.activeRowIndex === cell.rowIndex &&
            el !== cell.element;
        if (focusInCell) {
            this.mode = 2 /* Content */;
            this.cursor.reset(cell.rowIndex, cell.colIndex);
            this.activateRow();
        }
        else if (!focusInActiveRowContent) {
            this.mode = 1 /* Cursor */;
            this.deactivateElements();
            const alreadyActive = this.cursor.isActive(cell.rowIndex, cell.colIndex);
            const isCursor = oldMode === 1 /* Cursor */ && alreadyActive;
            if (!isCursor) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
            }
        }
    }
    tryFocus(el) {
        this.activateElements();
        const focusable = findFocusableChild(el);
        if (focusable) {
            const cell = targetCell(focusable, this.meta.gridElement.nativeElement);
            if (cell) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
                this.deactivateElements();
                this.enterCell();
            }
            focusable.focus();
        }
        else {
            this.deactivateElements();
        }
        return !!focusable;
    }
    needsViewport() {
        return this.meta && this.meta.isVirtual;
    }
    setViewport(firstItemIndex, lastItemIndex) {
        this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);
        if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
            const dataRowIndex = this.activeDataRow;
            const ahead = firstItemIndex - dataRowIndex;
            const behind = dataRowIndex - lastItemIndex;
            if (ahead > 0) {
                this.cursor.reset(firstItemIndex + this.meta.headerRows);
            }
            else if (behind > 0) {
                this.cursor.reset(lastItemIndex - this.meta.headerRows);
            }
        }
    }
    setColumnViewport(firstItemIndex, lastItemIndex) {
        this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);
    }
    focusCell(rowIndex = undefined, colIndex = undefined) {
        this.mode = 1 /* Cursor */;
        this.cursor.reset(rowIndex, colIndex);
        return this.activeCell;
    }
    focusCellByElement(el) {
        const cell = targetCell(el, this.meta.gridElement.nativeElement);
        if (cell) {
            return this.focusCell(cell.rowIndex, cell.colIndex);
        }
    }
    focusNextCell(wrap = true) {
        return this.focusAdjacentCell(true, wrap);
    }
    focusPrevCell(wrap = true) {
        return this.focusAdjacentCell(false, wrap);
    }
    toggle(active) {
        this.active = active;
        this.cursor.announce();
    }
    hasFocus() {
        return this.mode === 1 /* Cursor */ || this.mode === 2 /* Content */;
    }
    autoFocusCell(start, end) {
        return !this.meta.virtualColumns || end < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end);
    }
    focusAdjacentCell(fwd, wrap) {
        this.focusCell();
        let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();
        if (wrap && !success) {
            success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);
            if (success) {
                const row = this.cursor.row;
                const colIdx = fwd ? 0 : this.cursor.lastCellIndex(row);
                this.cursor.reset(row.index, colIdx);
            }
        }
        if (success) {
            return this.activeCell;
        }
        else {
            this.mode = 0 /* Standby */;
            this.cursor.announce();
        }
        return null;
    }
    enterCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        this.mode = focusable ? 2 /* Content */ : 1 /* Cursor */;
        this.cursor.announce();
        if (focusable) {
            this.activateRow();
            group.focus();
        }
    }
    leaveCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        if (!focusable) {
            this.deactivateElements();
        }
        this.mode = 1 /* Cursor */;
        this.cursor.announce();
    }
    activateElements() {
        this.focusRoot.activate();
    }
    deactivateElements() {
        this.focusRoot.deactivate();
    }
    activateRow() {
        this.cursor.row.cells
            .forEach(cell => cell.focusGroup && cell.focusGroup.activate());
    }
    moveCursorFwd() {
        return this.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();
    }
    moveCursorBwd() {
        return this.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();
    }
    onCursorKeydown(args) {
        let preventDefault = false;
        const modifier = args.ctrlKey || args.metaKey;
        const step = modifier ? 5 : 1;
        if (!this.onCellKeydown(args)) {
            return;
        }
        const row = this.cursor.row;
        switch (args.keyCode) {
            case Keys.ArrowDown:
                preventDefault = this.cursor.moveDown(step);
                break;
            case Keys.ArrowUp:
                preventDefault = this.cursor.moveUp(step);
                break;
            case Keys.ArrowRight:
                preventDefault = this.moveCursorFwd();
                break;
            case Keys.ArrowLeft:
                preventDefault = this.moveCursorBwd();
                break;
            case Keys.PageDown:
                if (this.metadata.isVirtual && this.viewport) {
                    let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;
                    if (this.metadata.hasDetailTemplate) {
                        nextItemIndex++;
                    }
                    nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);
                    this.cursor.reset(nextItemIndex);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.nextPage());
                    preventDefault = true;
                }
                break;
            case Keys.PageUp:
                if (this.metadata.isVirtual && this.viewport) {
                    let viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;
                    let firstItemIndex = this.viewport.firstItemIndex;
                    let nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);
                    this.cursor.reset(nextItemIndex);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.prevPage());
                    preventDefault = true;
                }
                break;
            case Keys.Home:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        this.cursor.reset(this.meta.headerRows, 0, false);
                    }
                    else {
                        this.cursor.reset(this.model.firstRow.index, 0, false);
                    }
                }
                else {
                    this.cursor.reset(row.index, 0, false);
                }
                preventDefault = true;
                break;
            case Keys.End:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        let lastRowIndex = this.meta.maxLogicalRowIndex;
                        if (this.meta.hasDetailTemplate) {
                            lastRowIndex--;
                        }
                        this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);
                    }
                    else {
                        this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(this.model.lastRow), false);
                    }
                }
                else {
                    const lastIndex = this.cursor.lastCellIndex(row);
                    const cell = this.model.findCell(lastIndex, row);
                    if (cell) {
                        this.cursor.reset(cell.rowIndex, cell.colIndex);
                    }
                    else {
                        this.cursor.reset(row.index, lastIndex);
                    }
                }
                preventDefault = true;
                break;
            case Keys.Enter:
            case Keys.F2:
                const groupItem = row.groupItem;
                if (groupItem) {
                    this.zone.run(() => this.groupsService.toggleRow(groupItem));
                }
                else if (this.cursor.cell.detailExpandCell) {
                    this.zone.run(() => this.detailsService.toggleRow(row.dataRowIndex, row.dataItem));
                }
                else {
                    this.enterCell();
                    if (!this.cursor.cell.focusGroup.isNavigable()) {
                        preventDefault = true;
                    }
                }
                break;
            default:
                if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {
                    this.enterCell();
                }
        }
        if (preventDefault) {
            args.preventDefault();
        }
    }
    onContentKeydown(args) {
        if (!this.onCellKeydown(args)) {
            return;
        }
        const confirm = !args.defaultPrevented && args.keyCode === Keys.Enter && isTextInput(args.srcElement);
        if (args.keyCode === Keys.Escape || args.keyCode === Keys.F2 || confirm) {
            this.leaveCell();
            this.cursor.reset();
            args.stopPropagation();
        }
        else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {
            this.onCursorKeydown(args);
            if (args.defaultPrevented) {
                this.leaveCell();
            }
        }
    }
    onCellKeydown(args) {
        if (this.editService.isEditingCell()) {
            const confirm = args.keyCode === Keys.Enter;
            const cancel = args.keyCode === Keys.Escape;
            const navigate = isNavigationKey(args.keyCode);
            if (confirm) {
                this.editService.closeCell(args);
            }
            else if (cancel) {
                this.editService.closeCell(args);
                this.cd.detectChanges();
            }
            else if (navigate) {
                return false;
            }
        }
        this.cellKeydown.emit(args);
        return true;
    }
    onCursorChanges(args) {
        this.activeRowIndex = args.rowIndex;
        const dataRowIndex = this.activeDataRow;
        if (this.meta && (this.meta.isVirtual &&
            args.rowIndex >= this.meta.headerRows &&
            this.viewport &&
            !this.viewport.containsRow(dataRowIndex) && dataRowIndex > -1)) {
            this.scrollRequestService.scrollTo({ row: dataRowIndex });
        }
        if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {
            const cell = this.activeCell;
            const { start, end } = this.model.cellRange(cell);
            if (!cell) {
                this.virtualCell = true;
            }
            if ((!cell && this.mode !== 0 /* Standby */) || (cell && !this.columnViewport.intersects(start, end))) {
                this.scrollRequestService.scrollTo({ column: args.colIndex - (this.metadata.hasDetailTemplate ? 1 : 0) });
            }
        }
    }
    onFocusOut(args) {
        if (isVisible(args.target)) {
            this.mode = 0 /* Standby */;
        }
        else {
            // Focused target is no longer visible,
            // reset to cursor mode and recapture focus.
            this.mode = 1 /* Cursor */;
        }
        this.deactivateElements();
        this.cursor.announce();
    }
    onWindowBlur() {
        this.mode = 0 /* Standby */;
        this.deactivateElements();
        this.cursor.announce();
    }
    onKeydown(args) {
        if (this.mode === 1 /* Cursor */) {
            this.onCursorKeydown(args);
        }
        else if (this.mode === 2 /* Content */) {
            this.onContentKeydown(args);
        }
    }
    onTabout() {
        // Tabbed out of the last focusable content element
        // reset to cursor mode and recapture focus.
        if (this.cursor.cell.focusGroup.isNavigable()) {
            // Unless the cell has a single focusable element,
            // otherwise we'd return to Content mode and enter an endless loop
            return;
        }
        this.leaveCell();
        this.cursor.reset();
    }
};
NavigationService.ɵfac = function NavigationService_Factory(t) { return new (t || NavigationService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(DomEventsService), ɵngcc0.ɵɵinject(PagerContextService), ɵngcc0.ɵɵinject(ScrollRequestService), ɵngcc0.ɵɵinject(GroupsService), ɵngcc0.ɵɵinject(DetailsService), ɵngcc0.ɵɵinject(FocusRoot), ɵngcc0.ɵɵinject(EditService), ɵngcc0.ɵɵinject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵinject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵinject(FocusableDirective, 8)); };
NavigationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NavigationService, factory: function (t) { return NavigationService.ɵfac(t); } });
NavigationService = __decorate([ __param(10, Optional()),
    __metadata("design:paramtypes", [NgZone,
        DomEventsService,
        PagerContextService,
        ScrollRequestService,
        GroupsService,
        DetailsService,
        FocusRoot,
        EditService,
        ChangeDetectorRef,
        LocalizationService,
        FocusableDirective])
], NavigationService);

/**
 * @hidden
 */
let SelectionService = class SelectionService {
    constructor(domEvents, localDataChangesService, navigationService) {
        this.domEvents = domEvents;
        this.localDataChangesService = localDataChangesService;
        this.navigationService = navigationService;
        this.changes = new EventEmitter();
        this.lastSelectionStartIndex = 0;
        this.currentSelection = [];
        this.selectAllChecked = false;
        this.active = false;
        this.dragging = false;
        this.addSubscriptions();
    }
    get enableMarquee() {
        const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;
        if (!this.settings || checkboxOnly) {
            return false;
        }
        const selectableSettings = this.settings.selectable;
        const dragAndMultiple = typeof (selectableSettings) === 'object' &&
            isPresent(selectableSettings) &&
            selectableSettings.mode === 'multiple' &&
            selectableSettings.enabled !== false &&
            !selectableSettings.checkboxOnly &&
            selectableSettings.drag;
        return this.active && dragAndMultiple;
    }
    init(settings) {
        this.settings = settings;
        this.currentSelection = [];
        if (settings.selectable && settings.selectable.enabled !== false) {
            const iterator$$1 = this.getIterator();
            this._selectAllState = true;
            let item = iterator$$1.next();
            while (!item.done) {
                if (item.value && item.value.type === "data") {
                    const rowArgs = {
                        dataItem: item.value.data,
                        index: item.value.index
                    };
                    if (settings.rowSelected(rowArgs)) {
                        this.currentSelection[item.value.index] = rowArgs;
                    }
                    else {
                        this._selectAllState = undefined;
                    }
                }
                item = iterator$$1.next();
            }
            if (this.currentSelection.length === 0) {
                this._selectAllState = false;
            }
        }
    }
    isSelected(index) {
        if (this.settings && this.active) {
            return this.options.enabled && isPresent(this.currentSelection[index]);
        }
    }
    handleClick(item, event) {
        if (this.dragging) {
            this.dragging = false;
            return;
        }
        let ev;
        const ctrlKey = event.ctrlKey || event.metaKey;
        if (this.options.mode === "single" && ctrlKey && this.isSelected(item.index)) {
            ev = this.toggle(item);
        }
        else if (this.options.mode === "multiple") {
            if (ctrlKey && !event.shiftKey) {
                ev = this.toggle(item);
            }
            else if (event.shiftKey) {
                ev = this.addAllTo(item, ctrlKey);
            }
        }
        if (!isPresent(ev)) {
            ev = this.select(item);
            this.currentSelection[item.index] = {
                dataItem: item.data,
                index: item.index
            };
        }
        if (!ev.selectedRows.length && !ev.deselectedRows.length) {
            return;
        }
        ev.ctrlKey = ctrlKey;
        ev.shiftKey = event.shiftKey;
        this.changes.emit(ev);
    }
    toggle(item) {
        let selectedRows = [];
        let deselectedRows = [];
        this.lastSelectionStartIndex = item.index;
        const rowArgs = { dataItem: item.data, index: item.index };
        if (this.isSelected(item.index)) {
            deselectedRows.push(rowArgs);
        }
        else {
            selectedRows.push(rowArgs);
        }
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows
        };
    }
    toggleByIndex(index) {
        const iterator$$1 = this.getIterator();
        if (this.selectAllChecked && this.isSelected(index)) {
            this.selectAllChecked = false;
        }
        let item = iterator$$1.next();
        while (!item.done) {
            if (item.value && item.value.type === "data" && item.value.index === index) {
                const itemToToggle = {
                    data: item.value.data,
                    index: item.value.index
                };
                if (this.isSelected(index) || this.options.mode === "multiple") {
                    return this.toggle(itemToToggle);
                }
                else {
                    return this.select(itemToToggle);
                }
            }
            item = iterator$$1.next();
        }
    }
    select(item) {
        let deselectedRows = [];
        let selectedRows = [];
        this.lastSelectionStartIndex = item.index;
        if (!this.isSelected(item.index)) {
            selectedRows.push({ dataItem: item.data, index: item.index });
        }
        this.currentSelection.forEach((row) => {
            if (row.index !== item.index) {
                deselectedRows.push(row);
            }
        });
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows
        };
    }
    //Used to manually deselect removed items
    deselect(removedItem) {
        const iterator$$1 = this.getIterator();
        let item = iterator$$1.next();
        while (!item.done) {
            if (item.value && item.value.type === "data" && item.value.data === removedItem) {
                const rowArgs = {
                    dataItem: item.value.data,
                    index: item.value.index
                };
                if (this.isSelected(rowArgs.index)) {
                    let ev = {
                        ctrlKey: false,
                        deselectedRows: [rowArgs],
                        selectedRows: []
                    };
                    this.changes.emit(ev);
                }
            }
            item = iterator$$1.next();
        }
    }
    addAllTo(item, ctrlKey) {
        let selectedRows = [];
        let deselectedRows = [];
        const start = Math.min(this.lastSelectionStartIndex, item.index);
        const end = Math.max(this.lastSelectionStartIndex, item.index);
        const iterator$$1 = this.getIterator();
        let next = iterator$$1.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const rowArgs = { dataItem: next.value.data, index: idx };
                if ((idx < start || idx > end) && this.isSelected(idx) && !ctrlKey) {
                    deselectedRows.push(rowArgs);
                }
                if ((idx >= start && idx <= end) && !this.isSelected(idx)) {
                    selectedRows.push(rowArgs);
                }
            }
            next = iterator$$1.next();
        }
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows
        };
    }
    updateAll(selectAllChecked) {
        this.selectAllChecked = selectAllChecked;
        let selectedRows = [];
        let deselectedRows = [];
        const iterator$$1 = this.getIterator();
        let next = iterator$$1.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const rowArgs = { dataItem: next.value.data, index: idx };
                if (this.isSelected(idx) && !selectAllChecked) {
                    deselectedRows.push(rowArgs);
                }
                if (!this.isSelected(idx) && selectAllChecked) {
                    selectedRows.push(rowArgs);
                }
            }
            next = iterator$$1.next();
        }
        if (!selectedRows.length && !deselectedRows.length) {
            return;
        }
        let ev = {
            ctrlKey: true,
            deselectedRows: deselectedRows,
            selectedRows: selectedRows,
            shiftKey: true
        };
        this.changes.emit(ev);
    }
    selectRange(startIndex, endIndex) {
        let selectedRows = [];
        let deselectedRows = [];
        const start = Math.min(startIndex, endIndex);
        const end = Math.max(startIndex, endIndex);
        const iterator$$1 = this.getIterator();
        let next = iterator$$1.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const rowArgs = { dataItem: next.value.data, index: idx };
                if ((idx < start || idx > end) && this.isSelected(idx)) {
                    deselectedRows.push(rowArgs);
                }
                if ((idx >= start && idx <= end) && !this.isSelected(idx)) {
                    selectedRows.push(rowArgs);
                }
            }
            next = iterator$$1.next();
        }
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows
        };
    }
    get selectAllState() {
        return this._selectAllState;
    }
    get selected() {
        return this.currentSelection.map((item) => {
            return item.index;
        }).filter((n) => typeof n === "number");
    }
    get options() {
        const defaultOptions = {
            checkboxOnly: false,
            enabled: true,
            mode: "multiple"
        };
        if (!isPresent(this.settings)) {
            return defaultOptions;
        }
        if (typeof this.settings.selectable === 'boolean') {
            return {
                checkboxOnly: false,
                enabled: this.settings.selectable,
                mode: "multiple"
            };
        }
        else {
            return Object.assign(defaultOptions, this.settings.selectable);
        }
    }
    ngOnDestroy() {
        this.removeSubscriptions();
    }
    targetArgs() {
        return {
            index: this.mouseDownEventArgs.rowIndex,
            dataItem: this.mouseDownEventArgs.dataItem
        };
    }
    addSubscriptions() {
        if (!this.cellClickSubscription) {
            this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
                if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {
                    if (this.active) {
                        this.handleClick({ index: args.rowIndex, data: args.dataItem }, args.originalEvent);
                    }
                }
            });
        }
        if (!this.mousedownSubscription) {
            this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
                this.mouseDownEventArgs = args;
                if ((this.options.enabled && (!this.options.mode || this.options.mode === "multiple") &&
                    !this.options.checkboxOnly && args.originalEvent.shiftKey)) {
                    if (this.active) {
                        args.originalEvent.preventDefault();
                        this.navigationService.focusCellByElement(args.originalEvent.target);
                    }
                }
            });
        }
        if (this.localDataChangesService && !this.dataChangedSubscription) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
                if (this.active) {
                    if (isPresent(args.action) && args.action === 'remove') {
                        this.deselect(args.item);
                    }
                }
            });
        }
    }
    getIterator() {
        const accessor = this.settings.view.accessor();
        if (!accessor) {
            return;
        }
        return accessor[iterator]();
    }
    removeSubscriptions() {
        if (this.cellClickSubscription) {
            this.cellClickSubscription.unsubscribe();
            this.cellClickSubscription = null;
        }
        if (this.mousedownSubscription) {
            this.mousedownSubscription.unsubscribe();
            this.mousedownSubscription = null;
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
            this.dataChangedSubscription = null;
        }
    }
};
SelectionService.ɵfac = function SelectionService_Factory(t) { return new (t || SelectionService)(ɵngcc0.ɵɵinject(DomEventsService), ɵngcc0.ɵɵinject(LocalDataChangesService), ɵngcc0.ɵɵinject(NavigationService)); };
SelectionService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SelectionService, factory: function (t) { return SelectionService.ɵfac(t); } });
SelectionService = __decorate([ __metadata("design:paramtypes", [DomEventsService,
        LocalDataChangesService,
        NavigationService])
], SelectionService);

/**
 * @hidden
 */
let CellSelectionService = class CellSelectionService {
    constructor(domEvents, localDataChangesService, navigationService) {
        this.domEvents = domEvents;
        this.localDataChangesService = localDataChangesService;
        this.navigationService = navigationService;
        this.changes = new EventEmitter();
        this.mouseUpEvent = new EventEmitter();
        this.currentSelection = [];
        this.active = false;
        this.dragging = false;
        this.dragSelectDeselect = false;
        this.lastSelectionItem = { itemKey: 0, columnKey: 0 };
        this.lastSelectionItemRowIndex = 0;
        this.lastSelectionItemColIndex = 0;
        this.addSubscriptions();
    }
    get enableMarquee() {
        const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;
        if (!this.settings || checkboxOnly) {
            return false;
        }
        const selectableSettings = this.settings.selectable;
        const dragAndMultiple = typeof (selectableSettings) === 'object' &&
            isPresent(selectableSettings) &&
            selectableSettings.mode === 'multiple' &&
            selectableSettings.cell &&
            selectableSettings.enabled !== false &&
            selectableSettings.drag;
        return this.active && dragAndMultiple;
    }
    init(settings) {
        this.settings = settings;
        this.currentSelection = [];
        if (settings.selectable && settings.selectable.enabled !== false) {
            const iterator$$1 = this.getIterator();
            let item = iterator$$1.next();
            while (!item.done) {
                if (item.value && item.value.type === "data") {
                    const rowArgs = {
                        dataItem: item.value.data,
                        index: item.value.index
                    };
                    settings.columns.forEach(col => {
                        const selectedCellArgs = settings.cellSelected(rowArgs, col, col.leafIndex);
                        if (selectedCellArgs.selected) {
                            this.currentSelection.push(selectedCellArgs.item);
                        }
                    });
                }
                item = iterator$$1.next();
            }
        }
    }
    isCellSelected(item, col) {
        if (this.settings && this.active) {
            const selectedCellArgs = this.settings.cellSelected({ dataItem: item.data, index: item.index }, col, col.leafIndex);
            return this.options.enabled && selectedCellArgs.selected;
        }
        return false;
    }
    handleClick(item, event) {
        if (this.dragging) {
            this.dragging = false;
            return;
        }
        let ev;
        const ctrlKey = event.ctrlKey || event.metaKey;
        if (this.options.mode === "single" && ctrlKey && this.isCellSelected(item, item.column)) {
            ev = this.toggle(item);
        }
        else if (this.options.mode === "multiple") {
            if (ctrlKey && !event.shiftKey) {
                ev = this.toggle(item);
            }
            else if (event.shiftKey) {
                const startRowIndex = Math.min(this.lastSelectionItemRowIndex, item.index);
                const startColIndex = Math.min(this.lastSelectionItemColIndex, item.column.leafIndex);
                const endRowIndex = Math.max(this.lastSelectionItemRowIndex, item.index);
                const endColIndex = Math.max(this.lastSelectionItemColIndex, item.column.leafIndex);
                ev = this.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex);
            }
        }
        if (!isPresent(ev)) {
            ev = this.select(item);
            this.currentSelection = [this.lastSelectionItem];
        }
        if (!ev.selectedCells.length && !ev.deselectedCells.length) {
            return;
        }
        ev.ctrlKey = ctrlKey;
        ev.shiftKey = event.shiftKey;
        this.changes.emit(ev);
    }
    toggle(item) {
        let selectedCells = [];
        let deselectedCells = [];
        this.lastSelectionItem =
            this.settings.cellSelected({ dataItem: item.data, index: item.index }, item.column, item.column.leafIndex).item;
        this.lastSelectionItemRowIndex = item.index;
        this.lastSelectionItemColIndex = item.column.leafIndex;
        if (this.isCellSelected(item, item.column)) {
            deselectedCells.push(this.lastSelectionItem);
        }
        else {
            selectedCells.push(this.lastSelectionItem);
        }
        return {
            deselectedCells,
            selectedCells
        };
    }
    select(item) {
        const selectedCells = [];
        const deselectedCells = [];
        this.lastSelectionItem =
            this.settings.cellSelected({ dataItem: item.data, index: item.index }, item.column, item.column.leafIndex).item;
        this.lastSelectionItemRowIndex = item.index;
        this.lastSelectionItemColIndex = item.column.leafIndex;
        if (!this.isCellSelected(item, item.column)) {
            selectedCells.push(this.lastSelectionItem);
        }
        this.currentSelection.forEach((selectedItem) => {
            if (selectedItem.itemKey !== this.lastSelectionItem.itemKey || selectedItem.columnKey !== this.lastSelectionItem.columnKey) {
                deselectedCells.push(selectedItem);
            }
        });
        return {
            deselectedCells,
            selectedCells
        };
    }
    //Used to manually deselect removed items
    deselect(removedItem) {
        const iterator$$1 = this.getIterator();
        let item = iterator$$1.next();
        let rowArgs;
        while (!item.done) {
            if (item.value && item.value.type === "data" && item.value.data === removedItem) {
                rowArgs = {
                    dataItem: item.value.data,
                    index: item.value.index
                };
                break;
            }
            item = iterator$$1.next();
        }
        if (rowArgs) {
            const cellsToRemove = this.currentSelection.filter(selectedItem => {
                const contender = this.settings.cellSelected(rowArgs, null, null).item;
                return selectedItem.itemKey === contender.itemKey;
            });
            if (cellsToRemove.length) {
                let ev = {
                    ctrlKey: false,
                    deselectedCells: cellsToRemove,
                    selectedCells: []
                };
                this.changes.emit(ev);
            }
        }
    }
    selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex) {
        const selectedCells = [];
        const deselectedCells = [];
        const selectionStartRow = Math.min(startRowIndex, endRowIndex);
        const selectionStartCol = Math.min(startColIndex, endColIndex);
        const selectionEndRow = Math.max(startRowIndex, endRowIndex);
        const selectionEndCol = Math.max(startColIndex, endColIndex);
        const iterator$$1 = this.getIterator();
        let next = iterator$$1.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const data = next.value.data;
                const rowArgs = {
                    dataItem: data,
                    index: idx
                };
                this.settings.columns.forEach(col => {
                    const { item } = this.settings.cellSelected(rowArgs, col, col.leafIndex);
                    const selected = this.isCellSelected(next.value, col);
                    const isInRowRange = selectionStartRow <= idx && idx <= selectionEndRow;
                    const isInColRange = selectionStartCol <= col.leafIndex && col.leafIndex <= selectionEndCol;
                    const isInSelectionRect = isInRowRange && isInColRange;
                    if (!isInSelectionRect && selected) {
                        deselectedCells.push(item);
                    }
                    if (isInSelectionRect && !selected) {
                        selectedCells.push(item);
                    }
                });
            }
            next = iterator$$1.next();
        }
        return {
            deselectedCells,
            selectedCells
        };
    }
    get options() {
        const defaultOptions = {
            checkboxOnly: false,
            enabled: true,
            mode: "multiple"
        };
        if (!isPresent(this.settings)) {
            return defaultOptions;
        }
        if (typeof this.settings.selectable === 'boolean') {
            return {
                checkboxOnly: false,
                enabled: this.settings.selectable,
                mode: "multiple"
            };
        }
        else {
            return Object.assign(defaultOptions, this.settings.selectable);
        }
    }
    ngOnDestroy() {
        this.removeSubscriptions();
    }
    addSubscriptions() {
        if (!this.cellClickSubscription) {
            this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
                if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {
                    if (this.active) {
                        this.handleClick({ index: args.rowIndex, data: args.dataItem, column: args.column }, args.originalEvent);
                    }
                }
            });
        }
        if (!this.mousedownSubscription) {
            this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
                this.mouseDownEventArgs = args;
                if (this.options.enabled && (!this.options.mode || this.options.mode === "multiple") &&
                    !this.options.checkboxOnly && args.originalEvent.shiftKey) {
                    if (this.active) {
                        args.originalEvent.preventDefault();
                        this.navigationService.focusCellByElement(args.originalEvent.target);
                    }
                }
            });
        }
        if (this.localDataChangesService && !this.dataChangedSubscription) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
                if (this.active) {
                    if (isPresent(args.action) && args.action === 'remove') {
                        this.deselect(args.item);
                    }
                }
            });
        }
    }
    getIterator() {
        const accessor = this.settings.view.accessor();
        if (!accessor) {
            return;
        }
        return accessor[iterator]();
    }
    removeSubscriptions() {
        if (this.cellClickSubscription) {
            this.cellClickSubscription.unsubscribe();
            this.cellClickSubscription = null;
        }
        if (this.mousedownSubscription) {
            this.mousedownSubscription.unsubscribe();
            this.mousedownSubscription = null;
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
            this.dataChangedSubscription = null;
        }
    }
};
CellSelectionService.ɵfac = function CellSelectionService_Factory(t) { return new (t || CellSelectionService)(ɵngcc0.ɵɵinject(DomEventsService), ɵngcc0.ɵɵinject(LocalDataChangesService), ɵngcc0.ɵɵinject(NavigationService)); };
CellSelectionService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: CellSelectionService, factory: function (t) { return CellSelectionService.ɵfac(t); } });
CellSelectionService = __decorate([ __metadata("design:paramtypes", [DomEventsService,
        LocalDataChangesService,
        NavigationService])
], CellSelectionService);

const createElement = () => {
    const marquee = document.createElement("div");
    marquee.className = "k-marquee";
    const marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
    return marquee;
};
const POINTER_OFFSET = 2;
const MINIMAL_DRAG_DISTANCE = 5;
const offsets = {
    topLeft: { x: POINTER_OFFSET, y: POINTER_OFFSET },
    topRight: { x: -POINTER_OFFSET, y: POINTER_OFFSET },
    bottomLeft: { x: POINTER_OFFSET, y: -POINTER_OFFSET },
    bottomRight: { x: -POINTER_OFFSET, y: -POINTER_OFFSET }
};
/**
 * @hidden
 */
let GridMarqueeDirective = class GridMarqueeDirective {
    constructor(draggable, selection, cellSelection, domEvents) {
        this.draggable = draggable;
        this.selection = selection;
        this.cellSelection = cellSelection;
        this.domEvents = domEvents;
        this.selectionStarted = false;
    }
    get webkitUserSelection() {
        return (this.cellSelection.enableMarquee || this.selection.enableMarquee) ? 'none' : null;
    }
    get userSelection() {
        return (this.cellSelection.enableMarquee || this.selection.enableMarquee);
    }
    ngOnInit() {
        this.subscriptions = (this.draggable.kendoPress.subscribe(this.start.bind(this)));
        this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.clean();
    }
    start(args) {
        if (args.originalEvent.target.classList.contains('k-checkbox')) {
            this.pressArgs = null;
            return;
        }
        this.pressArgs = args;
        this.pressTarget = null;
    }
    moveMarquee(args) {
        if (!this.pressTarget) {
            this.pressTarget = this.cellSelection.active ? this.cellSelection.mouseDownEventArgs : this.selection.mouseDownEventArgs;
        }
        const press = this.pressArgs;
        if (!press) {
            return;
        }
        if (!this.selectionStarted) {
            const distance = Math.sqrt(Math.pow((args.pageX - press.pageX), 2) + Math.pow((args.pageY - press.pageY), 2));
            if (distance > MINIMAL_DRAG_DISTANCE) {
                this.selectionStarted = true;
                this.dragEndSubscription = merge(this.domEvents.cellMouseup.pipe(take(1)), this.draggable.kendoRelease.pipe(delay(1), take(1)))
                    .subscribe(this.endSelection.bind(this));
            }
            else {
                return;
            }
        }
        this.initMarquee();
        const element = this.marqueeElement;
        const marqueeQuadrant = this.getMarqueeQuadrant(args.pageX, args.pageY, press.pageX, press.pageY);
        let left = Math.min(args.pageX, press.pageX);
        let top = Math.min(args.pageY, press.pageY);
        const width = Math.abs(args.pageX - press.pageX);
        const height = Math.abs(args.pageY - press.pageY);
        if (marqueeQuadrant) {
            left += offsets[marqueeQuadrant].x;
            top += offsets[marqueeQuadrant].y;
        }
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;
    }
    endSelection(args) {
        if (args.type === 'mouseup' || args.type === 'touchend') {
            if (this.cellSelection.active) {
                this.cellSelection.dragging = true;
                this.cellSelection.changes.emit(this.cellSelection.selectRange(this.pressTarget.rowIndex, this.pressTarget.column.leafIndex, args.rowIndex, args.column.leafIndex));
            }
            else if (this.selection.active) {
                this.selection.dragging = true;
                this.selection.changes.emit(this.selection.selectRange(this.pressTarget.rowIndex, args.rowIndex));
            }
        }
        this.clean();
    }
    clean() {
        if (this.marqueeElement) {
            document.body.removeChild(this.marqueeElement);
            this.marqueeElement = null;
        }
        if (this.dragEndSubscription) {
            this.dragEndSubscription.unsubscribe();
        }
        this.dragEndSubscription = null;
        this.pressTarget = null;
        this.pressArgs = null;
        this.selectionStarted = false;
        this.cellSelection.active ? this.cellSelection.dragging = false : this.selection.dragging = false;
    }
    initMarquee() {
        if (!this.marqueeElement) {
            this.marqueeElement = createElement();
            document.body.appendChild(this.marqueeElement);
        }
    }
    getMarqueeQuadrant(pointerX, pointerY, startX, startY) {
        const leftHalf = pointerX < startX;
        const rightHalf = pointerX > startX;
        const topHalf = pointerY < startY;
        const bottomHalf = pointerY > startY;
        if (leftHalf && topHalf) {
            return 'topLeft';
        }
        if (leftHalf && bottomHalf) {
            return 'bottomLeft';
        }
        if (rightHalf && topHalf) {
            return 'topRight';
        }
        if (rightHalf && bottomHalf) {
            return 'bottomRight';
        }
        return null;
    }
};
GridMarqueeDirective.ɵfac = function GridMarqueeDirective_Factory(t) { return new (t || GridMarqueeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DraggableDirective), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(CellSelectionService), ɵngcc0.ɵɵdirectiveInject(DomEventsService)); };
GridMarqueeDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: GridMarqueeDirective, selectors: [["", "kendoGridSelectionMarquee", ""]], hostVars: 4, hostBindings: function GridMarqueeDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("-webkit-user-select", ctx.webkitUserSelection);
        ɵngcc0.ɵɵclassProp("user-select-none", ctx.userSelection);
    } } });
__decorate([
    HostBinding('style.-webkit-user-select'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], GridMarqueeDirective.prototype, "webkitUserSelection", null);
__decorate([
    HostBinding('class.user-select-none'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], GridMarqueeDirective.prototype, "userSelection", null);
GridMarqueeDirective = __decorate([ __metadata("design:paramtypes", [DraggableDirective,
        SelectionService,
        CellSelectionService,
        DomEventsService])
], GridMarqueeDirective);

/**
 * @hidden
 */
class ZoneAwareEventEmitter extends EventEmitter {
    constructor(ngZone, isAsync = false) {
        super(isAsync);
        this.ngZone = ngZone;
    }
    subscribe(generatorOrNext, error, complete) {
        let schedulerFn;
        let errorFn = (_) => null;
        let completeFn = () => null;
        if (generatorOrNext && typeof generatorOrNext === 'object') {
            schedulerFn = (value) => { this.ngZone.run(() => generatorOrNext.next(value)); };
            if (generatorOrNext.error) {
                errorFn = (err) => { this.ngZone.run(() => generatorOrNext.error(err)); };
            }
            if (generatorOrNext.complete) {
                completeFn = () => { this.ngZone.run(() => generatorOrNext.complete()); };
            }
        }
        else {
            schedulerFn = (value) => { this.ngZone.run(() => generatorOrNext(value)); };
            if (error) {
                errorFn = (err) => { this.ngZone.run(() => error(err)); };
            }
            if (complete) {
                completeFn = () => { this.ngZone.run(() => complete()); };
            }
        }
        return super.subscribe(schedulerFn, errorFn, completeFn);
    }
}

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-grid',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1648709578,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * Represents the column cell template of the Grid ([more information and example]({% slug templates_columns_grid %}#toc-cell-template)).
 * Helps to customize the content of the cells. To define the cell template, nest an `<ng-template>` tag
 * with the `kendoGridCellTemplate` directive inside a `<kendo-grid-column>` tag.
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `columnIndex`&mdash;The current column index. Use it as an alias for a template variable by utilizing the `let-columnIndex="columnIndex"` syntax.
 * - `rowIndex`&mdash;The current data row index. Use it as an alias for a template variable by utilizing the `let-rowIndex="rowIndex"` syntax.
 * - `dataItem`&mdash;The current data item. Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax&mdash;for example, `let-dataItem`.
 * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column="column"` syntax.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-grid [data]="gridData">
 *             <kendo-grid-column field="ProductName">
 *                 <ng-template kendoGridCellTemplate let-dataItem let-rowIndex="rowIndex">
 *                     Data Row #: {{rowIndex}} /
 *                     <strong>{{dataItem.ProductName}}</strong>
 *                     ({{dataItem.Discontinued ? "discontinued" : "active"}})
 *                 </ng-template>
 *             </kendo-grid-column>
 *         </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *     public gridData = [{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": false
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": true
 *       }
 *     ];
 * }
 *
 * ```
 */
let CellTemplateDirective = class CellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
CellTemplateDirective.ɵfac = function CellTemplateDirective_Factory(t) { return new (t || CellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
CellTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CellTemplateDirective, selectors: [["", "kendoGridCellTemplate", ""]] });
CellTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], CellTemplateDirective);

/**
 * Represents the group-header cell template of the Grid which helps to customize the content of the group header item.
 * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderTemplate`
 * directive inside `<kendo-grid-column>`.
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `group`&mdash;The current group item.
 * - `field`&mdash;The name of the field by which data is grouped.
 * - `value`&mdash;The current group value.
 * - `aggregates`&mdash;All aggregate values for the current group.
 * - `index`&mdash;The index of the current group.
 * - `expanded`&mdash;A boolean value indicating if the group is currently expanded.
 * ([see example]({% slug groupable_grid_with_aggregates %})).
 *
 * @example
 * ```ts
 * import { process } from '@progress/kendo-data-query';
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-grid [data]="gridData" [group]="groups">
 *             <kendo-grid-column field="ProductName">
 *                 <ng-template kendoGridGroupHeaderTemplate let-group let-field="field" let-value="value">
 *                    <strong>{{field}}</strong>: {{value}}
 *                 </ng-template>
 *             </kendo-grid-column>
 *         </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *     public groups = [{ field: "ProductName" }];
 *
 *     public gridData = process([{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": false
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": true
 *       }
 *     ], {
 *      group: this.groups
 *     });
 * }
 *
 * ```
 */
let GroupHeaderTemplateDirective = class GroupHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
GroupHeaderTemplateDirective.ɵfac = function GroupHeaderTemplateDirective_Factory(t) { return new (t || GroupHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupHeaderTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderTemplateDirective, selectors: [["", "kendoGridGroupHeaderTemplate", ""]] });
GroupHeaderTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], GroupHeaderTemplateDirective);

/**
 * Represents the group-header column template of the Grid which helps to customize the content of the group headers.
 * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderColumnTemplate`
 * directive inside `<kendo-grid-column>`. ([See example]({% slug groupable_grid_with_aggregates %})).
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `group`&mdash;The current group item.
 * - `field`&mdash;The name of the field by which data is grouped.
 * - `value`&mdash;The current group value.
 * - `aggregates`&mdash;All aggregate values for the current group.
 *
 * @example
 * ```ts
 * <kendo-grid-column field="ProductName" title="Product Name">
 *     <ng-template kendoGridGroupHeaderColumnTemplate let-group="group" let-aggregates="aggregates">
 *         <span title="Group Header Column Template for ProductName">
 *             Count: {{ aggregates.Discontinued.count }}
 *         </span>
 *     </ng-template>
 * </kendo-grid-column>
 * ```
 */
let GroupHeaderColumnTemplateDirective = class GroupHeaderColumnTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
GroupHeaderColumnTemplateDirective.ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) { return new (t || GroupHeaderColumnTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupHeaderColumnTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderColumnTemplateDirective, selectors: [["", "kendoGridGroupHeaderColumnTemplate", ""]] });
GroupHeaderColumnTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], GroupHeaderColumnTemplateDirective);

/**
 * Represents the column edit-cell template of the Grid ([see example]({% slug editing_template_forms_grid %})).
 * Helps to customize the content of the edited cells. To define the cell template, nest an `<ng-template>`
 * tag with the `kendoGridEditTemplate` directive inside a `<kendo-grid-column>` tag.
 *
 * The template context is set to the current form group and the following additional fields are passed:
 * - `formGroup`&mdash;The current [FormGroup]({{ site.data.urls.angular['formgroupapi'] }}).
 * Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax&mdash;for example, `let-formGroup`.
 * If you use the Grid inside [Template-Driven Forms]({{ site.data.urls.angular['forms'] }}), it will be `undefined`.
 * - `rowIndex`&mdash;The current data row index. If inside a new item row, `rowIndex` is `-1`. Use it as an alias for a template variable by utilizing the `let-rowIndex="rowIndex"` syntax.
 * - `dataItem`&mdash;The current data item. Use it as an alias for a template variable by utilizing the `let-dataItem="dataItem"` syntax.
 * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column="column"` syntax.
 * - `isNew`&mdash;The state of the current item. Use it as an alias for a template variable by utilizing the `let-isNew="isNew"` syntax.
 */
let EditTemplateDirective = class EditTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
EditTemplateDirective.ɵfac = function EditTemplateDirective_Factory(t) { return new (t || EditTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
EditTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: EditTemplateDirective, selectors: [["", "kendoGridEditTemplate", ""]] });
EditTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], EditTemplateDirective);

/**
 * Represents the column group footer cell template of the Grid which helps to customize the group footer cell for the column.
 * To define the group footer template, nest an `<ng-template>` tag with the `kendoGridGroupFooterTemplate` directive
 * inside `<kendo-grid-column>`.
 *
 * The template context is set to the current aggregates and the following additional fields are passed:
 * - `column`&mdash;Defines an instance of the `ColumnComponent` option.
 * - `field`&mdash;The current column field name.
 * - `group`&mdash;The current group data item.
 * - `aggregates`&mdash;All aggregate values for the current group.
 *
 * @example
 * ```ts-preview
 * import { process } from '@progress/kendo-data-query';
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-grid [data]="gridData" [group]="groups">
 *             <kendo-grid-column field="ProductName">
 *                 <ng-template kendoGridGroupFooterTemplate let-aggregates let-field="field">
 *                    Count: {{aggregates[field].count}}
 *                 </ng-template>
 *             </kendo-grid-column>
 *         </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *     public groups = [{ field: "ProductName", aggregates: [{ field: "ProductName", aggregate: "count" }] }];
 *
 *     public gridData = process([{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": false
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": true
 *       }
 *     ], {
 *      group: this.groups
 *     });
 * }
 * ```
 */
let GroupFooterTemplateDirective = class GroupFooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
GroupFooterTemplateDirective.ɵfac = function GroupFooterTemplateDirective_Factory(t) { return new (t || GroupFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupFooterTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: GroupFooterTemplateDirective, selectors: [["", "kendoGridGroupFooterTemplate", ""]] });
GroupFooterTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], GroupFooterTemplateDirective);

/**
 * Represents the column header cell template of the Grid
 * ([more information and example]({% slug templates_columns_grid %}#toc-header-template)).
 * Helps to customize the table header cell for the column.
 * To define a header template, nest an `<ng-template>` tag with the
 * [kendoGridHeaderTemplate]({% slug api_grid_headertemplatedirective %}) directive inside the `<kendo-grid-column>` tag.
 *
 *  The template context is set to the current column and then the following additional fields are passed:
 * * `column`&mdash;Defines an instance of the [ColumnComponent]({% slug api_grid_columncomponent %}) option.
 * * `columnIndex`&mdash;Defines the current column index.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-grid [data]="gridData">
 *             <kendo-grid-column field="ProductName">
 *                 <ng-template kendoGridHeaderTemplate let-column let-columnIndex="columnIndex">
 *                   {{column.field}}({{columnIndex}})
 *                 </ng-template>
 *             </kendo-grid-column>
 *              <kendo-grid-column field="UnitPrice">
 *                 <ng-template kendoGridHeaderTemplate let-column let-columnIndex="columnIndex">
 *                   {{column.field}}({{columnIndex}})
 *                 </ng-template>
 *             </kendo-grid-column>
 *         </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *     public gridData = [{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": false
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": true
 *       }
 *     ];
 * }
 *
 * ```
 */
let HeaderTemplateDirective = class HeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
HeaderTemplateDirective.ɵfac = function HeaderTemplateDirective_Factory(t) { return new (t || HeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
HeaderTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: HeaderTemplateDirective, selectors: [["", "kendoGridHeaderTemplate", ""]] });
HeaderTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], HeaderTemplateDirective);

/**
 * Represents the column footer cell template of the Grid
 * ([more information and example]({% slug templates_columns_grid %}#toc-footer-template)).
 * Helps to customize the table footer cell for the column.
 * To define a footer template, nest an `<ng-template>` tag with the
 * [kendoGridFooterTemplate]({% slug api_grid_footertemplatedirective %}) directive inside the `<kendo-grid-column>` tag.
 *
 * The template context is set to the current column and the following additional fields are passed:
 * * `column`&mdash;Defines an instance of the [ColumnComponent]({% slug api_grid_columncomponent %}) option.
 * * `columnIndex`&mdash;Defines the current column index.
 *
 * For more information on how to display aggregates in the footer of the Grid,
 * refer to the article on [aggregates]({% slug groupable_grid_with_aggregates %}).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-grid [data]="gridData" scrollable="none">
 *             <kendo-grid-column field="ProductName">
 *                 <ng-template kendoGridFooterTemplate let-column let-columnIndex="columnIndex">
 *                   {{column.field}}({{columnIndex}})
 *                 </ng-template>
 *             </kendo-grid-column>
 *              <kendo-grid-column field="UnitPrice">
 *                 <ng-template kendoGridFooterTemplate let-column let-columnIndex="columnIndex">
 *                   {{column.field}}({{columnIndex}})
 *                 </ng-template>
 *             </kendo-grid-column>
 *         </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *     public gridData = [{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": false
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": true
 *       }
 *     ];
 * }
 *
 * ```
 */
let FooterTemplateDirective = class FooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) { return new (t || FooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
FooterTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FooterTemplateDirective, selectors: [["", "kendoGridFooterTemplate", ""]] });
FooterTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], FooterTemplateDirective);

/* tslint:disable:max-line-length */
/**
 * Represents the template for the column menu in the Grid. Provides an option for
 * customizing the content of the column menu for all or for specific columns.
 * To define the content template, nest an `<ng-template>` tag with the
 * `kendoGridColumnMenuTemplate` directive inside the `kendo-grid` or the `<kendo-grid-column>` component.
 *
 * The template context is passes through the following fields:
 * - `service`&mdash;Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}).
 * - `column`&mdash;Represents the Grid column.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [kendoGridBinding]="data" [sortable]="true" [columnMenu]="true">
 *          <ng-template kendoGridColumnMenuTemplate let-service="service">
 *              <kendo-grid-columnmenu-sort [service]="service">
 *              </kendo-grid-columnmenu-sort>
 *          </ng-template>
 *          <kendo-grid-column field="Field1" [width]="100">
 *              <ng-template kendoGridColumnMenuTemplate let-service="service">
 *                  <kendo-grid-columnmenu-lock [service]="service">
 *                  </kendo-grid-columnmenu-lock>
 *                  <kendo-grid-columnmenu-sort [service]="service">
 *                  </kendo-grid-columnmenu-sort>
 *              </ng-template>
 *          </kendo-grid-column>
 *          <kendo-grid-column field="Field2" [width]="100"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }, { Field1: 'Foo1', Field2: 'Bar1' }];
 * }
 *
 * ```
 */
let ColumnMenuTemplateDirective = class ColumnMenuTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
ColumnMenuTemplateDirective.ɵfac = function ColumnMenuTemplateDirective_Factory(t) { return new (t || ColumnMenuTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ColumnMenuTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ColumnMenuTemplateDirective, selectors: [["", "kendoGridColumnMenuTemplate", ""]] });
ColumnMenuTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], ColumnMenuTemplateDirective);

/**
 * @hidden
 */
const isSpanColumn = column => column.isSpanColumn;
/**
 * @hidden
 */
const isCheckboxColumn = column => column.isCheckboxColumn;
const isColumnContainer = column => column.isColumnGroup || isSpanColumn(column);
/**
 * The base class for the column components of the Grid.
 */
class ColumnBase$1 {
    /**
     * @hidden
     */
    constructor(parent, idService) {
        this.parent = parent;
        /**
         * @hidden
         */
        this.matchesMedia = true;
        /**
         * The column index after reordering.
         *
         * > `orderIndex` is a read-only property. Setting this field does not affect column order.
         */
        this.orderIndex = 0;
        /**
         * @hidden
         */
        this.isColumnGroup = false;
        /**
         * @hidden
         */
        this.isSpanColumn = false;
        /**
         * Indicates whether the column is resizable.
         * @default true
         */
        this.resizable = true;
        /**
         * Indicates whether the column is reorderable.
         * @default true
         */
        this.reorderable = true;
        /**
         * The width (in pixels) below which the user is not able to resize the column by using the UI.
         */
        this.minResizableWidth = 10;
        /**
         * Toggles the locked (frozen) state of the columns ([more information and example]({% slug locked_columns_grid %})).
         *
         * @default false
         *
         * @example
         * ```ts
         * _@Component({
         *    selector: 'my-app',
         *    template: `
         *        <kendo-grid [data]="gridData" [scrollable]="scrollable" style="height: 200px">
         *          <kendo-grid-column field="ProductID" title="Product ID" width="120" [locked]="true">
         *          </kendo-grid-column>
         *          <kendo-grid-column field="ProductName" title="Product Name" width="200">
         *          </kendo-grid-column>
         *          <kendo-grid-column field="UnitPrice" title="Unit Price" width="230">
         *          </kendo-grid-column>
         *        </kendo-grid>
         *    `
         * })
         *
         * class AppComponent {
         *    public gridData: any[];
         *
         *    constructor() {
         *        this.gridData = products;
         *    }
         * }
         *
         * const products = [{
         *    "ProductID": 1,
         *    "ProductName": "Chai",
         *    "UnitPrice": 18.0000,
         *    "Discontinued": true
         *  }, {
         *    "ProductID": 2,
         *    "ProductName": "Chang",
         *    "UnitPrice": 19.0000,
         *    "Discontinued": false
         *  }
         * ];
         *
         * ```
         */
        this.locked = false;
        /**
         * Determines whether the column will be always visible when scrolling the Grid horizontally.
         *
         * @default false
         */
        this.sticky = false;
        /**
         * Specifies if the column can be locked or unlocked from the column menu or by reordering the columns.
         */
        this.lockable = true;
        /**
         * Specifies if the column can be stuck or unstuck from the column menu.
         */
        this.stickable = true;
        /**
         * Specifies if the column menu will be shown for the column.
         */
        this.columnMenu = true;
        /**
         * Specifies if the column will be included in the column-chooser list.
         */
        this.includeInChooser = true;
        /**
         * @hidden
         */
        this.headerTemplates = new QueryList();
        /**
         * @hidden
         */
        this.columnMenuTemplates = new QueryList();
        this.idService = idService;
        if (parent && idService && parent.idService.gridId() === idService.gridId() && !isColumnContainer(parent)) {
            throw new Error('Columns can be nested only inside ColumnGroupComponent');
        }
    }
    /**
     * The width of the column (in pixels).
     */
    set width(value) {
        if (typeof value === 'string') {
            const parsedValue = this._width = parseInt(value, 10);
            if (isDevMode()) {
                console.warn(`Expected numeric value for column width, but got a string "${value}". Treating as ${parsedValue}px.`);
            }
        }
        else {
            this._width = value;
        }
    }
    get width() { return this._width; }
    /**
     * @hidden
     */
    get level() {
        if (this.parent && isSpanColumn(this.parent)) {
            return this.parent.level;
        }
        return this.parent ? this.parent.level + 1 : 0;
    }
    /**
     * @hidden
     */
    get isLocked() {
        return this.parent ? this.parent.isLocked : this.locked;
    }
    /**
     * @hidden
     */
    get colspan() {
        return 1;
    }
    /**
     * @hidden
     */
    rowspan(totalColumnLevels) {
        return this.level < totalColumnLevels ? (totalColumnLevels - this.level) + 1 : 1;
    }
    /**
     * @hidden
     */
    get headerTemplateRef() {
        const template = this.headerTemplates.first;
        return template ? template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get footerTemplateRef() {
        return this.footerTemplate ? this.footerTemplate.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get columnMenuTemplateRef() {
        const template = this.columnMenuTemplates.first;
        return template ? template.templateRef : null;
    }
    /**
     * @hidden
     */
    get displayTitle() {
        return this.title;
    }
    /**
     * @hidden
     */
    get isVisible() {
        return !this.hidden && this.matchesMedia;
    }
}
ColumnBase$1.ɵfac = function ColumnBase$1_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ColumnBase$1.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ColumnBase$1, contentQueries: function ColumnBase$1_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
    } }, inputs: { resizable: "resizable", reorderable: "reorderable", minResizableWidth: "minResizableWidth", locked: "locked", sticky: "sticky", lockable: "lockable", stickable: "stickable", columnMenu: "columnMenu", includeInChooser: "includeInChooser", width: "width", title: "title", autoSize: "autoSize", hidden: "hidden", media: "media", style: "style", headerStyle: "headerStyle", filterStyle: "filterStyle", footerStyle: "footerStyle", cssClass: ["class", "cssClass"], headerClass: "headerClass", filterClass: "filterClass", footerClass: "footerClass" } });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "resizable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "reorderable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ColumnBase$1.prototype, "minResizableWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnBase$1.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ColumnBase$1.prototype, "width", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "autoSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "locked", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "sticky", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "hidden", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnBase$1.prototype, "media", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "lockable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "stickable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "columnMenu", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase$1.prototype, "includeInChooser", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnBase$1.prototype, "style", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnBase$1.prototype, "headerStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnBase$1.prototype, "filterStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnBase$1.prototype, "footerStyle", void 0);
__decorate([
    Input('class'),
    __metadata("design:type", Object)
], ColumnBase$1.prototype, "cssClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnBase$1.prototype, "headerClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnBase$1.prototype, "filterClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnBase$1.prototype, "footerClass", void 0);
__decorate([
    ContentChildren(HeaderTemplateDirective, { descendants: false }),
    __metadata("design:type", QueryList)
], ColumnBase$1.prototype, "headerTemplates", void 0);
__decorate([
    ContentChild(FooterTemplateDirective, { static: false }),
    __metadata("design:type", FooterTemplateDirective)
], ColumnBase$1.prototype, "footerTemplate", void 0);
__decorate([
    ContentChildren(ColumnMenuTemplateDirective),
    __metadata("design:type", QueryList)
], ColumnBase$1.prototype, "columnMenuTemplates", void 0);

/**
 * Represents the filter-cell template ([see example]({% slug builtinfiltertemplate_grid %}#toc-customizing-filter-rows)).
 */
let FilterCellTemplateDirective = class FilterCellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
FilterCellTemplateDirective.ɵfac = function FilterCellTemplateDirective_Factory(t) { return new (t || FilterCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
FilterCellTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilterCellTemplateDirective, selectors: [["", "kendoGridFilterCellTemplate", ""]] });
FilterCellTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], FilterCellTemplateDirective);

/**
 * Represents the filter-menu template
 * ([see example]({% slug builtinfiltertemplate_grid %}#toc-customizing-filter-menus)).
 */
let FilterMenuTemplateDirective = class FilterMenuTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
FilterMenuTemplateDirective.ɵfac = function FilterMenuTemplateDirective_Factory(t) { return new (t || FilterMenuTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
FilterMenuTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilterMenuTemplateDirective, selectors: [["", "kendoGridFilterMenuTemplate", ""]] });
FilterMenuTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], FilterMenuTemplateDirective);

// Incremented each time the service is instantiated.
let sequence = 0;
/**
 * @hidden
 */
let IdService = class IdService {
    constructor() {
        this.prefix = `k-grid${sequence++}`;
    }
    gridId() {
        return this.prefix;
    }
    cellId(rowIndex, colIndex) {
        return `${this.prefix}-r${rowIndex}c${colIndex}`;
    }
    selectionCheckboxId(itemIndex) {
        return `${this.prefix}-checkbox${itemIndex}`;
    }
    selectAllCheckboxId() {
        return `${this.prefix}-select-all`;
    }
};
IdService.ɵfac = function IdService_Factory(t) { return new (t || IdService)(); };
IdService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: IdService, factory: function (t) { return IdService.ɵfac(t); } });
IdService = __decorate([ __metadata("design:paramtypes", [])
], IdService);

var ColumnComponent_1;
/**
 * @hidden
 */
function isColumnComponent(column) {
    return isPresent(column.field);
}
/**
 * Represents the columns of the [Angular Data Grid]({% slug overview_grid %}).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-grid [data]="gridData">
 *          <kendo-grid-column field="ProductID" title="Product ID" width="120">
 *          </kendo-grid-column>
 *          <kendo-grid-column field="ProductName" title="Product Name">
 *          </kendo-grid-column>
 *          <kendo-grid-column field="UnitPrice" title="Unit Price" width="230">
 *          </kendo-grid-column>
 *          <kendo-grid-column field="Discontinued" width="120">
 *              <ng-template kendoGridCellTemplate let-dataItem>
 *                  <input type="checkbox" [checked]="dataItem.Discontinued" disabled/>
 *              </ng-template>
 *          </kendo-grid-column>
 *        </kendo-grid>
 *    `
 * })
 *
 * class AppComponent {
 *    public gridData: any[];
 *
 *    constructor() {
 *        this.gridData = products;
 *    }
 * }
 *
 * const products = [{
 *    "ProductID": 1,
 *    "ProductName": "Chai",
 *    "UnitPrice": 18.0000,
 *    "Discontinued": true
 *  }, {
 *    "ProductID": 2,
 *    "ProductName": "Chang",
 *    "UnitPrice": 19.0000,
 *    "Discontinued": false
 *  }
 * ];
 *
 * ```
 */
let ColumnComponent = ColumnComponent_1 = class ColumnComponent extends ColumnBase$1 {
    constructor(parent, idService) {
        super(parent, idService);
        /**
         * Allows the column headers to be clicked and the `sortChange` event emitted.
         * You have to handle the `sortChange` event yourself and sort the data.
         */
        this.sortable = true;
        /**
         * Determines if the column can be dragged to the group panel. The default value is `true`.
         * If set to `false`, you can group the columns by the column field by using the API of the Grid.
         */
        this.groupable = true;
        /**
         * Defines the editor type ([see example]({% slug editing_reactive_forms_grid %}#toc-setup)).
         * Used when the column enters the edit mode. The default value is `text`.
         *
         * @example
         * ```html-no-run
         * <kendo-grid>
         *    <kendo-grid-column field="UnitPrice" editor="numeric">
         *    </kendo-grid-column>
         * </kendo-grid>
         * ```
         */
        this.editor = 'text';
        /**
         * Defines the filter type that is displayed inside the filter row. The default value is `text`.
         *
         * @example
         * ```html-no-run
         * <kendo-grid>
         *    <kendo-grid-column field="UnitPrice" filter="numeric">
         *    </kendo-grid-column>
         * </kendo-grid>
         * ```
         */
        this.filter = 'text';
        /**
         * Defines if a filter UI will be displayed for this column. The default value is `true`.
         *
         * @example
         * ```html-no-run
         * <kendo-grid>
         *    <kendo-grid-column field="UnitPrice" [filterable]="false">
         *    </kendo-grid-column>
         * </kendo-grid>
         * ```
         */
        this.filterable = true;
        /**
         * Defines whether the column is editable. The default value is `true`.
         *
         * @example
         * ```html-no-run
         * <kendo-grid>
         *    <kendo-grid-column field="UnitPrice" [editable]="false">
         *    </kendo-grid-column>
         * </kendo-grid>
         * ```
         */
        this.editable = true;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    get groupHeaderTemplateRef() {
        return this.groupHeaderTemplate ? this.groupHeaderTemplate.templateRef : undefined;
    }
    get groupHeaderColumnTemplateRef() {
        return this.groupHeaderColumnTemplate ? this.groupHeaderColumnTemplate.templateRef : undefined;
    }
    get groupFooterTemplateRef() {
        return this.groupFooterTemplate ? this.groupFooterTemplate.templateRef : undefined;
    }
    get editTemplateRef() {
        return this.editTemplate ? this.editTemplate.templateRef : undefined;
    }
    get filterCellTemplateRef() {
        return this.filterCellTemplate ? this.filterCellTemplate.templateRef : undefined;
    }
    get filterMenuTemplateRef() {
        return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : undefined;
    }
    get displayTitle() {
        return this.title === undefined ? this.field : this.title;
    }
};
ColumnComponent.ɵfac = function ColumnComponent_Factory(t) { return new (t || ColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13), ɵngcc0.ɵɵdirectiveInject(IdService, 8)); };
ColumnComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnComponent, selectors: [["kendo-grid-column"]], contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, EditTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FilterCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FilterMenuTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterMenuTemplate = _t.first);
    } }, inputs: { sortable: "sortable", groupable: "groupable", editor: "editor", filter: "filter", filterable: "filterable", editable: "editable", field: "field", format: "format" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => ColumnComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnComponent.prototype, "field", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnComponent.prototype, "sortable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnComponent.prototype, "groupable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnComponent.prototype, "editor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnComponent.prototype, "filterable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnComponent.prototype, "editable", void 0);
__decorate([
    ContentChild(CellTemplateDirective, { static: false }),
    __metadata("design:type", CellTemplateDirective)
], ColumnComponent.prototype, "template", void 0);
__decorate([
    ContentChild(GroupHeaderTemplateDirective, { static: false }),
    __metadata("design:type", GroupHeaderTemplateDirective)
], ColumnComponent.prototype, "groupHeaderTemplate", void 0);
__decorate([
    ContentChild(GroupHeaderColumnTemplateDirective, { static: false }),
    __metadata("design:type", GroupHeaderColumnTemplateDirective)
], ColumnComponent.prototype, "groupHeaderColumnTemplate", void 0);
__decorate([
    ContentChild(GroupFooterTemplateDirective, { static: false }),
    __metadata("design:type", GroupFooterTemplateDirective)
], ColumnComponent.prototype, "groupFooterTemplate", void 0);
__decorate([
    ContentChild(EditTemplateDirective, { static: false }),
    __metadata("design:type", EditTemplateDirective)
], ColumnComponent.prototype, "editTemplate", void 0);
__decorate([
    ContentChild(FilterCellTemplateDirective, { static: false }),
    __metadata("design:type", FilterCellTemplateDirective)
], ColumnComponent.prototype, "filterCellTemplate", void 0);
__decorate([
    ContentChild(FilterMenuTemplateDirective, { static: false }),
    __metadata("design:type", FilterMenuTemplateDirective)
], ColumnComponent.prototype, "filterMenuTemplate", void 0);
ColumnComponent = ColumnComponent_1 = __decorate([ __param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()), __param(1, Optional()),
    __metadata("design:paramtypes", [ColumnBase$1, IdService])
], ColumnComponent);

var SpanColumnComponent_1;
/**
 * @hidden
 */
function isSpanColumnComponent(column) {
    return column.isSpanColumn;
}
/**
 * Represents a column which can be spanned over multiple data cells while the individual
 * header and footer cells are retained ([see example]({% slug spanned_columns_grid %})).
 * Enables you to achieve more flexible layout while keeping the built-in UI element for
 * [sorting]({% slug sorting_grid %}), [filtering]({% slug filtering_grid %}), and
 * [grouping]({% slug groupingbasics_grid %}). Wrap the columns that will be
 * merged inside the `<kendo-grid-span-column>` tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-grid
 *              [sortable]="true"
 *              [filterable]="true"
 *              [kendoGridBinding]="products">
 *          <kendo-grid-column field="ProductID" title="Product ID" width="120">
 *          </kendo-grid-column>
 *          <kendo-grid-span-column>
 *              <kendo-grid-column field="ProductName" title="Product Name">
 *              </kendo-grid-column>
 *              <kendo-grid-column field="UnitPrice" title="Unit Price" filter="numeric" width="180" format="{0:c}">
 *              </kendo-grid-column>
 *          </kendo-grid-span-column>
 *          <kendo-grid-column field="Discontinued" width="120" filter="boolean">
 *              <ng-template kendoGridCellTemplate let-dataItem>
 *                  <input type="checkbox" [checked]="dataItem.Discontinued" disabled/>
 *              </ng-template>
 *          </kendo-grid-column>
 *        </kendo-grid>
 *    `
 * })
 *
 * class AppComponent {
 *   public products = [{
 *      "ProductID": 1,
 *      "ProductName": "Chai",
 *      "UnitPrice": 18.0000,
 *      "Discontinued": true
 *    }, {
 *      "ProductID": 2,
 *      "ProductName": "Chang",
 *      "UnitPrice": 19.0000,
 *      "Discontinued": false
 *    }
 *   ];
 * }
 *
 * ```
 *
 * By default, the data cell displays the data for the specified fields. To further customize
 * the span-column functionality, use a [cell template]({% slug api_grid_celltemplatedirective %}).
 *
 * ```html-no-run
 * <kendo-grid-span-column>
 *  <kendo-grid-column field="field1" title="Field 1"></kendo-grid-column>
 *  <kendo-grid-column field="field2" title="Field 2"></kendo-grid-column>
 *    <ng-template kendoGridCellTemplate let-dataItem>
 *        <h5>{{ dataItem.field1 }}</h5>
 *        <p>{{ dataItem.field2 }}</p>
 *    </ng-template>
 *  </kendo-grid-span-column>
 * ```
 */
let SpanColumnComponent = SpanColumnComponent_1 = class SpanColumnComponent extends ColumnBase$1 {
    constructor(parent, idService) {
        super(parent, idService);
        /*
         * @hidden
         */
        this.isSpanColumn = true;
        this.template = new QueryList();
        this.editTemplate = new QueryList();
        /**
         * @hidden
         */
        this.childColumns = new QueryList();
        /**
         * @hidden
         */
        this.includeInChooser = false;
        this._editable = true;
        this._locked = false;
        if (parent && parent.isSpanColumn) {
            throw new Error('SpanColumn cannot be nested inside another SpanColumn');
        }
    }
    /**
     * Defines whether the edit template of the column will be rendered. The default value is `false`.
     *
     * > To enable the editing functionality for a spanned column, set an edit template for it.
     *
     * @example
     * ```html-no-run
     * <kendo-grid>
     *    <kendo-grid-span-column [editable]="false">
     *      <kendo-grid-column field="UnitPrice">
     *      </kendo-grid-column>
     *      <kendo-grid-column field="ProductName">
     *      </kendo-grid-column>
     *      <ng-template kendoGridEditTemplate>
     *         .....
     *      </ng-template>
     *    </kendo-grid-span-column>
     * </kendo-grid>
     * ```
     */
    set editable(value) {
        this._editable = value;
    }
    get editable() {
        return isPresent(this.editTemplateRef) && this._editable;
    }
    /**
     * @hidden
     * added for backwards compitability
     */
    set width(_value) {
    }
    get width() {
        return this.childColumns.reduce((total, column) => total + column.width, 0);
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this.childColumns.first.leafIndex;
    }
    /**
     * @hidden
     */
    get templateRef() {
        const template = this.template.first;
        return template ? template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get editTemplateRef() {
        const editTemplate = this.editTemplate.first;
        return editTemplate ? editTemplate.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get colspan() {
        return this.childColumns.filter(c => c.isVisible).length;
    }
    /**
     * Toggles the locked (frozen) state of the columns. Locked columns are visible
     * at all times during the horizontal scrolling of the Grid.
     *
     * For the option to work properly, make sure that:
     * - Scrolling is enabled.
     * - The `height` option of the Grid is set.
     * - The widths of all Grid columns are explicitly set in pixels. In this way,
     * the Grid adjusts the layout of the locked and unlocked columns.
     *
     * @default false
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-grid [data]="gridData" [scrollable]="scrollable" style="height: 200px">
     *          <kendo-grid-span-column [locked]="true">
     *             <kendo-grid-column field="ProductID" title="Product ID" width="120">
     *             </kendo-grid-column>
     *             <kendo-grid-column field="ProductName" title="Product Name" width="200">
     *             </kendo-grid-column>
     *          </kendo-grid-span-column>
     *          <kendo-grid-column field="UnitPrice" title="Unit Price" width="230">
     *          </kendo-grid-column>
     *        </kendo-grid>
     *    `
     * })
     *
     * class AppComponent {
     *    public gridData: any[];
     *
     *    constructor() {
     *        this.gridData = products;
     *    }
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     *
     * ```
     */
    set locked(value) {
        this._locked = value;
    }
    get locked() {
        return this._locked || this.childColumns.some(c => c.locked);
    }
    get childrenArray() {
        return this.childColumns.toArray();
    }
    get hasChildren() {
        return this.childColumns.length > 0;
    }
};
SpanColumnComponent.ɵfac = function SpanColumnComponent_Factory(t) { return new (t || SpanColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13), ɵngcc0.ɵɵdirectiveInject(IdService, 8)); };
SpanColumnComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SpanColumnComponent, selectors: [["kendo-grid-span-column"]], contentQueries: function SpanColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, EditTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnComponent, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childColumns = _t);
    } }, inputs: { editable: "editable", locked: "locked" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => SpanColumnComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SpanColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChildren(CellTemplateDirective, { descendants: false }),
    __metadata("design:type", QueryList)
], SpanColumnComponent.prototype, "template", void 0);
__decorate([
    ContentChildren(EditTemplateDirective, { descendants: false }),
    __metadata("design:type", QueryList)
], SpanColumnComponent.prototype, "editTemplate", void 0);
__decorate([
    ContentChildren(ColumnComponent),
    __metadata("design:type", QueryList)
], SpanColumnComponent.prototype, "childColumns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], SpanColumnComponent.prototype, "editable", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], SpanColumnComponent.prototype, "locked", null);
SpanColumnComponent = SpanColumnComponent_1 = __decorate([ __param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()), __param(1, Optional()),
    __metadata("design:paramtypes", [ColumnBase$1, IdService])
], SpanColumnComponent);

/**
 * @hidden
 */
const expandColumns = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []) // tslint:disable-line:align
);
/**
 * @hidden
 */
const expandColumnsWithSpan = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ?
    [column].concat(column.childrenArray) :
    [column]), []) // tslint:disable-line:align
);
/**
 * @hidden
 */
const columnsToRender = (columns) => (expandColumns(columns).filter(x => x.isVisible));
const sumProp = (prop) => (array) => (array || []).reduce((prev, curr) => prev + (curr[prop] || 0), 0);
/**
 * @hidden
 */
const sumColumnWidths = sumProp('width');
/**
 * @hidden
 */
const columnsSpan = sumProp('colspan');
// tslint:disable-next-line:max-line-length
const validField = new RegExp(`^[$A-Z\_a-z][$A-Z\_a-z0-9\\.]*$`);
/**
 * @hidden
 */
const isValidFieldName = (fieldName) => !isNullOrEmptyString(fieldName) && validField.test(fieldName) &&
    fieldName[0] !== "." && fieldName[fieldName.length - 1] !== ".";
/**
 * @hidden
 */
const children = column => column.children.filter(child => child !== column);
/**
 * @hidden
 */
const leafColumns = columns => {
    return columns.reduce((acc, column) => {
        if (column.isColumnGroup) {
            acc = acc.concat(leafColumns(children(column)));
        }
        else if (column.isSpanColumn) {
            acc = acc.concat(column.childrenArray);
        }
        else {
            acc.push(column);
        }
        return acc;
    }, []).filter(x => x.isVisible); // tslint:disable-line:align
};
/**
 * @hidden
 */
const someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);
/**
 * @hidden
 */
const resizableColumns = columns => columns.filter(column => isTruthy(column.resizable) && column.isVisible);
/**
 * @hidden
 */
const sortColumns = (columns) => orderBy(columns, [{ field: 'orderIndex', dir: 'asc' }]);
/**
 * @hidden
 */
const isInSpanColumn = (column) => isTruthy(column.parent) && isSpanColumnComponent(column.parent);

var ColumnGroupComponent_1;
/**
 * @hidden
 */
function isColumnGroupComponent(column) {
    return column.isColumnGroup;
}
/**
 * Represents the column group header of the Grid
 * ([more information and examples]({% slug multicolumnheaders_columns_grid %})).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *     <kendo-grid [data]="gridData">
 *       <kendo-grid-column-group title="Product Info">
 *         <ng-template kendoGridHeaderTemplate let-columnIndex="columnIndex" let-column="column">
 *               Column index: {{columnIndex}} / column title: {{column.title}}
 *         </ng-template>
 *         <kendo-grid-column field="ProductID" title="Product ID" width="120">
 *         </kendo-grid-column>
 *         <kendo-grid-column field="ProductName" title="Product Name">
 *         </kendo-grid-column>
 *       </kendo-grid-column-group>
 *       <kendo-grid-column field="UnitPrice" title="Unit Price" width="230">
 *       </kendo-grid-column>
 *       <kendo-grid-column field="Discontinued" width="120">
 *           <ng-template kendoGridCellTemplate let-dataItem>
 *               <input type="checkbox" [checked]="dataItem.Discontinued" disabled/>
 *           </ng-template>
 *       </kendo-grid-column>
 *     </kendo-grid>
 *    `
 * })
 *
 * class AppComponent {
 *    public gridData: any[];
 *
 *    constructor() {
 *        this.gridData = products;
 *    }
 * }
 *
 * const products = [{
 *    "ProductID": 1,
 *    "ProductName": "Chai",
 *    "UnitPrice": 18.0000,
 *    "Discontinued": true
 *  }, {
 *    "ProductID": 2,
 *    "ProductName": "Chang",
 *    "UnitPrice": 19.0000,
 *    "Discontinued": false
 *  }
 * ];
 *
 * ```
 */
let ColumnGroupComponent = ColumnGroupComponent_1 = class ColumnGroupComponent extends ColumnBase$1 {
    constructor(parent, idService) {
        super(parent, idService);
        this.parent = parent;
        /**
         * @hidden
         */
        this.includeInChooser = false;
        /**
         * @hidden
         */
        this.isColumnGroup = true;
        /**
         * @hidden
         */
        this.minResizableWidth = 10;
        if (parent && parent.isSpanColumn) {
            throw new Error('ColumnGroupComponent cannot be nested inside SpanColumnComponent');
        }
    }
    /**
     * @hidden
     */
    rowspan() {
        return 1;
    }
    /**
     * @hidden
     */
    get colspan() {
        if (!this.children || this.children.length === 1) {
            return 1;
        }
        return columnsSpan(this.children
            .filter(child => child !== this && child.isVisible));
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this.children ? (this.firstChild || {}).leafIndex : -1;
    }
    get childrenArray() {
        return this.children.filter(c => c !== this);
    }
    get hasChildren() {
        return Boolean(this.firstChild);
    }
    get firstChild() {
        return this.children.find(column => column !== this);
    }
};
ColumnGroupComponent.ɵfac = function ColumnGroupComponent_Factory(t) { return new (t || ColumnGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13), ɵngcc0.ɵɵdirectiveInject(IdService, 8)); };
ColumnGroupComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnGroupComponent, selectors: [["kendo-grid-column-group"]], contentQueries: function ColumnGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase$1, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => ColumnGroupComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnGroupComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChildren(ColumnBase$1),
    __metadata("design:type", QueryList)
], ColumnGroupComponent.prototype, "children", void 0);
ColumnGroupComponent = ColumnGroupComponent_1 = __decorate([ __param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()), __param(1, Optional()),
    __metadata("design:paramtypes", [ColumnBase$1, IdService])
], ColumnGroupComponent);

/**
 * Represents the detail template of the Grid ([more information and examples]({% slug detailrowtemplate_grid %})).
 * To define the detail template, nest an `<ng-template>` tag with the `kendoGridDetailTemplate` directive inside a `<kendo-grid>` tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *       <kendo-grid
 *         [data]="data"
 *         selectable="true"
 *         style="height: 160px"
 *         >
 *         <kendo-grid-column field="ProductID"></kendo-grid-column>
 *         <kendo-grid-column field="ProductName"></kendo-grid-column>
 *         <kendo-grid-column field="UnitPrice"></kendo-grid-column>
 *         <ng-template kendoGridDetailTemplate let-dataItem>
 *           <div *ngIf="dataItem.Category">
 *             <header>{{dataItem.Category?.CategoryName}}</header>
 *             <span>{{dataItem.Category?.Description}}</span>
 *           </div>
 *         </ng-template>
 *       </kendo-grid>
 *   `
 * })
 *
 * class AppComponent {
 *     public data = [{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": false,
 *         "Category": {
 *             "CategoryID": 1,
 *             "CategoryName": "Beverages",
 *             "Description": "Soft drinks, coffees, teas, beers, and ales"
 *         }
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": false,
 *         "Category": {
 *             "CategoryID": 1,
 *             "CategoryName": "Beverages",
 *             "Description": "Soft drinks, coffees, teas, beers, and ales"
 *         }
 *       }, {
 *         "ProductID": 3,
 *         "ProductName": "Aniseed Syrup",
 *         "UnitPrice": 10.0000,
 *         "Discontinued": false,
 *         "Category": {
 *             "CategoryID": 2,
 *             "CategoryName": "Condiments",
 *             "Description": "Sweet and savory sauces, relishes, spreads, and seasonings"
 *         }
 *     }];
 *
 * }
 *
 * ```
 *
 */
let DetailTemplateDirective = class DetailTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
        this._condition = () => true;
    }
    /**
     * Defines the function that indicates if a given detail row and the associated **Expand** or **Collapse** button will be displayed.
     */
    set showIf(fn) {
        if (typeof fn !== 'function') {
            throw new Error(`showIf must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this._condition = fn;
    }
    get showIf() {
        return this._condition;
    }
};
DetailTemplateDirective.ɵfac = function DetailTemplateDirective_Factory(t) { return new (t || DetailTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DetailTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DetailTemplateDirective, selectors: [["", "kendoGridDetailTemplate", ""]], inputs: { showIf: ["kendoGridDetailTemplateShowIf", "showIf"] } });
__decorate([
    Input("kendoGridDetailTemplateShowIf"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], DetailTemplateDirective.prototype, "showIf", null);
DetailTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], DetailTemplateDirective);

const canCreateElement = () => isDocumentAvailable() && document.createElement;
let cachedScrollbarWidth = null;
let cachedPixelRatio;
let cachedRtlScrollLeft = null;
function scrollbarWidth() {
    if (cachedScrollbarWidth === null && canCreateElement()) {
        cachedPixelRatio = window.devicePixelRatio || 1;
        const div = document.createElement("div");
        div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
        div.innerHTML = "&nbsp;";
        document.body.appendChild(div);
        cachedScrollbarWidth = div.offsetWidth - div.scrollWidth;
        document.body.removeChild(div);
    }
    return cachedScrollbarWidth;
}
function rtlScrollLeft() {
    if (cachedRtlScrollLeft === null && canCreateElement()) {
        const div = document.createElement("div");
        div.style.cssText = "overflow:scroll;zoom:1;clear:both;display:block;width:100px;visibility:hidden;position:absolute;left:-10000px;direction:rtl;";
        div.innerHTML = "<div style='width:200px;height:1px;'</div>";
        document.body.appendChild(div);
        const initial = div.scrollLeft;
        div.scrollLeft = -1;
        cachedRtlScrollLeft = div.scrollLeft < 0 ? div.scrollLeft : initial;
        document.body.removeChild(div);
    }
    return cachedRtlScrollLeft;
}
/**
 * @hidden
 * move to kendo-common
 */
let BrowserSupportService = class BrowserSupportService {
    constructor(zone, changeDetector) {
        this.zone = zone;
        this.changeDetector = changeDetector;
        this.changes = new EventEmitter();
        if (typeof window === 'undefined') {
            return;
        }
        this.zone.runOutsideAngular(() => {
            this.subscriptions = fromEvent(window, 'resize').pipe(auditTime(100)).subscribe(() => {
                if (cachedPixelRatio !== window.devicePixelRatio) {
                    zone.run(() => {
                        cachedScrollbarWidth = null;
                        this.changes.emit();
                        this.changeDetector.markForCheck();
                    });
                }
            });
        });
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
            this.subscriptions = null;
        }
    }
    get scrollbarWidth() {
        return scrollbarWidth();
    }
    get rtlScrollLeft() {
        return rtlScrollLeft();
    }
};
BrowserSupportService.ɵfac = function BrowserSupportService_Factory(t) { return new (t || BrowserSupportService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.ChangeDetectorRef)); };
BrowserSupportService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: BrowserSupportService, factory: function (t) { return BrowserSupportService.ɵfac(t); } });
BrowserSupportService = __decorate([ __metadata("design:paramtypes", [NgZone, ChangeDetectorRef])
], BrowserSupportService);

/* tslint:disable:use-life-cycle-interface */
const isGroupItem = (source) => {
    return source.items !== undefined &&
        source.field !== undefined;
};
const isVirtualGroupItem = (source) => {
    return source.offset !== undefined &&
        source.skipHeader !== undefined;
};
const flattenGroups = (groups) => (groups.reduce((acc, curr) => {
    if (isGroupItem(curr)) {
        return acc.concat(flattenGroups(curr.items));
    }
    return acc.concat([curr]);
}, []) // tslint:disable-line:align
);
/**
 * @hidden
 */
const itemAt = (data, index) => {
    const first = data[0];
    if (isPresent(first) && isGroupItem(first)) {
        return flattenGroups(data)[index];
    }
    return data[index];
};
/**
 * @hidden
 */
const getIterator$1 = (data, { footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup }) => {
    const first = data[0];
    if (isPresent(first) && isGroupItem(first)) {
        if (isVirtualGroupItem(first)) {
            groupIndex = isPresent(first.offset) ? first.offset : groupIndex;
        }
        //tslint:disable-next-line:no-use-before-declare
        return new GroupIterator(data, footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup);
    }
    //tslint:disable-next-line:no-use-before-declare
    return new ItemIterator(data, dataIndex, parentGroupIndex, parentGroup);
};
class ArrayIterator {
    constructor(arr, idx = 0) {
        this.arr = arr;
        this.idx = idx;
        this.arr = arr || [];
    }
    [iterator]() {
        return this;
    }
    next() {
        return this.idx < this.arr.length ? {
            done: false,
            value: this.arr[this.idx++]
        } : { done: true, value: undefined };
    }
}
/**
 * @hidden
 */
class Iterator {
    constructor(arr, dataIndex = 0, resultMap = (x) => x) {
        this.dataIndex = dataIndex;
        this.resultMap = resultMap;
        const iter = arr[iterator];
        this._innerIterator = iter ? arr[iterator]() : new ArrayIterator(arr);
    }
    [iterator]() {
        return this;
    }
    next() {
        return this.resultMap(this._innerIterator.next(), this.dataIndex++);
    }
}
/**
 * @hidden
 */
class ItemIterator extends Iterator {
    constructor(arr, dataIndex, groupIndex, group) {
        super(arr, dataIndex, (x, idx) => ({
            done: x.done,
            value: {
                data: x.value,
                groupIndex: groupIndex,
                index: idx,
                type: 'data',
                group
            }
        }));
    }
    /**
     * The index of the next record.
     * @readonly
     * @type {number}
     */
    get index() {
        return this.dataIndex;
    }
}
const prefix = (s, n) => {
    const p = s ? s + "_" : s;
    return `${p}${n}`;
};
/**
 * @hidden
 */
class GroupIterator {
    constructor(arr, outputFooters = false, level = 0, dataIndex = 0, parentIndex = "", groupIndex = 0, parentGroup = undefined) {
        this.arr = arr;
        this.outputFooters = outputFooters;
        this.level = level;
        this.dataIndex = dataIndex;
        this.parentIndex = parentIndex;
        this.groupIndex = groupIndex;
        this.parentGroup = parentGroup;
        this.currentGroupIndex = "";
        this.arr = arr || [];
        this._iterator = new Iterator(this.arr, this.dataIndex);
    }
    [iterator]() {
        return this;
    }
    nextGroupItem() {
        this.current = this._iterator.next().value;
        this._innerIterator = null;
        if (this.current) {
            this.currentGroupIndex = prefix(this.parentIndex, this.groupIndex++);
            return {
                done: false,
                value: {
                    data: this.current,
                    index: this.currentGroupIndex,
                    level: this.level,
                    type: 'group',
                    parentGroup: this.parentGroup
                }
            };
        }
        else {
            this.current = null;
            return { done: true, value: undefined };
        }
    }
    footerItem() {
        if (this.current) {
            const group = this.current;
            this.current = null;
            return {
                done: false,
                value: {
                    data: group,
                    groupIndex: this.currentGroupIndex,
                    level: this.level,
                    type: 'footer',
                    group: {
                        data: group,
                        index: this.currentGroupIndex,
                        level: this.level,
                        type: 'group',
                        parentGroup: this.parentGroup
                    }
                }
            };
        }
        else {
            this.current = null;
            return { done: true, value: undefined };
        }
    }
    innerIterator(group) {
        if (!this._innerIterator) {
            this._innerIterator = getIterator$1(group.items, {
                dataIndex: this.dataIndex,
                footers: this.outputFooters,
                level: this.level + 1,
                parentGroupIndex: this.currentGroupIndex,
                parentGroup: {
                    data: this.current,
                    index: this.currentGroupIndex,
                    level: this.level,
                    type: 'group',
                    parentGroup: this.parentGroup
                }
            });
        }
        return this._innerIterator;
    }
    nextDataItem(group) {
        const iterator$$1 = this.innerIterator(group);
        const result = iterator$$1.next();
        if (isPresent(result.value) && !result.done && result.value.type === "data") {
            this.dataIndex = result.value.index + 1;
        }
        return !result.done ? result : undefined;
    }
    next() {
        if (!isPresent(this.current)) {
            return this.nextGroupItem();
        }
        const item = this.nextDataItem(this.current);
        return item ? item : (this.outputFooters ? this.footerItem() : this.nextGroupItem());
    }
    /**
     * The index of the last iterated data record.
     * @readonly
     * @type {number}
     */
    get index() {
        return this.dataIndex + 1;
    }
}

/**
 * @hidden
 */
class DataResultIterator {
    constructor(source, skip = 0, groupFooters = false) {
        this.source = source;
        this.skip = skip;
        this.groupFooters = groupFooters;
        this.source = this.source ? this.source : [];
        this.isObject = this.isGridDataResult(this.source);
    }
    isGridDataResult(source) {
        return source.total !== undefined && source.data !== undefined;
    }
    get total() {
        return this.isObject ? this.source.total : this.source.length;
    }
    get data() {
        return this.isObject ? this.source.data : this.source;
    }
    map(fn) {
        return this.data.map(fn);
    }
    filter(fn) {
        return this.data.filter(fn);
    }
    reduce(fn, init) {
        return this.data.reduce(fn, init);
    }
    forEach(fn) {
        this.data.forEach(fn);
    }
    some(fn) {
        return this.data.some(fn);
    }
    [iterator]() {
        return getIterator$1(this.data, {
            dataIndex: this.skip,
            footers: this.groupFooters,
            groupIndex: this.skip
        });
    }
    toString() { return this.data.toString(); }
}
/**
 * @hidden
 */
class DataCollection {
    constructor(accessor) {
        this.accessor = accessor;
    }
    get total() { return this.accessor().total; }
    get length() { return this.accessor().data.length; }
    get first() { return this.accessor().data[0]; }
    get last() { return this.accessor().data[this.length - 1]; }
    at(index) {
        return itemAt(this.accessor().data, index);
    }
    map(fn) { return this.accessor().map(fn); }
    filter(fn) {
        return this.accessor().filter(fn);
    }
    reduce(fn, init) {
        return this.accessor().reduce(fn, init);
    }
    forEach(fn) {
        this.accessor().forEach(fn);
    }
    some(fn) {
        return this.accessor().some(fn);
    }
    [iterator]() {
        return this.accessor()[iterator]();
    }
    toString() { return this.accessor().toString(); }
}

/**
 * @hidden
 *
 * Quick look-up structure for combinations of keys.
 * Similar to the native JS Set, however, working with a couple of keys instead of with a single key.
 * Supports both primitive keys and object keys (compared by reference).
 */
class PairSet {
    constructor(items, keyXField, keyYField) {
        /**
         * Holds a set of Y keys for each defined X key.
         * Each X key creates a map which holds a set of Y keys.
         *
         * Map { 1 => Set { 1, 2, 3 } } // pairs: [1, 1], [1, 2], [1, 3]
         */
        this.keysX = new Map();
        /**
         * Count the each added or deleted key manually to avoid iterating over all items when calling `this.size`.
         */
        this.totalKeysCount = 0;
        if (items && keyXField && keyYField) {
            items.forEach(item => this.add(item[keyXField], item[keyYField]));
        }
    }
    /**
     * Gets the total number of X/Y key pairs.
     */
    get size() {
        return this.totalKeysCount;
    }
    /**
     * Adds a couple of items identified as a combination.
     */
    add(keyX, keyY) {
        if (!this.keysX.has(keyX)) {
            this.keysX.set(keyX, new Set());
        }
        if (!this.has(keyX, keyY)) {
            this.keysX.get(keyX).add(keyY);
            this.totalKeysCount += 1;
        }
    }
    /**
     * Adds a combination of a couple of items identified together.
     */
    delete(keyX, keyY) {
        if (this.has(keyX, keyY)) {
            this.keysX.get(keyX).delete(keyY);
            this.totalKeysCount -= 1;
        }
    }
    /**
     * Checks whether the defined combination is stored.
     */
    has(keyX, keyY) {
        return this.keysX.has(keyX) && this.keysX.get(keyX).has(keyY);
    }
    /**
     * Clears all key combinations.
     */
    clear() {
        this.keysX.clear();
        this.totalKeysCount = 0;
    }
    /**
     * Converts the persisted data structure to an array of objects,
     * using the provided field names for the object props.
     */
    toArray(keyXField, keyYField) {
        return Array.from(this.keysX).reduce((pairs, pair) => {
            // Array.from(mapInstance) returns an array of arrays [[itemKey1, columnKeysSet1], [itemKey2, columnKeysSet2]]
            const [keyX, keysY] = pair;
            Array.from(keysY).forEach(keyY => pairs.push({ [keyXField]: keyX, [keyYField]: keyY }));
            return pairs;
        }, []);
    }
}

/**
 * @hidden
 */
class Selection {
    constructor(grid, cd) {
        this.grid = grid;
        this.cd = cd;
        /**
         * Defines the collection that will store the selected item keys.
         */
        this.selectedKeys = [];
        /**
         * Fires when the `selectedKeys` collection has been updated.
         */
        this.selectedKeysChange = new EventEmitter();
        this.rowSelectionState = new Set();
        this.cellSelectionState = new PairSet();
        this.init();
    }
    get isCellSelectionMode() {
        return isPresent(this.grid.selectable) && this.grid.selectable['cell'];
    }
    ngOnChanges(changes) {
        // skip reinitialization if the user data is the same as the last state change
        if (isPresent(changes.selectedKeys) && this.lastSelectionState !== this.selectedKeys) {
            this.setState(this.selectedKeys);
        }
    }
    init() {
        if (!isPresent(this.grid.rowSelected)) {
            this.grid.rowSelected = (row) => this.rowSelectionState.has(this.getItemKey(row));
        }
        if (!isPresent(this.grid.cellSelected)) {
            this.grid.cellSelected = (row, column, colIndex) => {
                const contender = this.getSelectionItem(row, column, colIndex);
                return {
                    selected: this.cellSelectionState.has(contender.itemKey, contender.columnKey),
                    item: contender
                };
            };
        }
        this.selectionChangeSubscription = this.grid
            .selectionChange
            .subscribe(this.onSelectionChange.bind(this));
    }
    /**
     * @hidden
     */
    destroy() {
        this.selectionChangeSubscription.unsubscribe();
    }
    /**
     * @hidden
     */
    reset() {
        this.rowSelectionState.clear();
        this.cellSelectionState.clear();
    }
    getItemKey(row) {
        if (this.selectionKey) {
            if (typeof this.selectionKey === "string") {
                return row.dataItem[this.selectionKey];
            }
            if (typeof this.selectionKey === "function") {
                return this.selectionKey(row);
            }
        }
        return row.index;
    }
    getSelectionItem(row, col, colIndex) {
        const itemIdentifiers = {};
        itemIdentifiers.itemKey = this.getItemKey(row);
        if (!isPresent(col) && !isPresent(colIndex)) {
            return itemIdentifiers;
        }
        if (this.columnKey) {
            if (typeof this.columnKey === "string") {
                itemIdentifiers.columnKey = row.dataItem[this.columnKey];
            }
            if (typeof this.columnKey === "function") {
                itemIdentifiers.columnKey = this.columnKey(col, colIndex);
            }
        }
        return {
            itemKey: itemIdentifiers.itemKey,
            columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex
        };
    }
    onSelectionChange(selection) {
        if (selection.selectedRows) {
            selection.deselectedRows.forEach((item) => {
                const itemKey = this.getItemKey(item);
                this.rowSelectionState.delete(itemKey);
            });
            if (this.grid.selectableSettings.mode === "single" && this.rowSelectionState.size > 0) {
                this.reset();
            }
            selection.selectedRows.forEach((item) => {
                const itemKey = this.getItemKey(item);
                this.rowSelectionState.add(itemKey);
            });
        }
        else {
            selection.deselectedCells.forEach(({ itemKey, columnKey }) => {
                this.cellSelectionState.delete(itemKey, columnKey);
            });
            if (this.grid.selectableSettings.mode === "single" && this.cellSelectionState.size > 0) {
                this.reset();
            }
            selection.selectedCells.forEach(({ itemKey, columnKey }) => {
                this.cellSelectionState.add(itemKey, columnKey);
            });
        }
        this.cd.markForCheck();
        this.notifyChange();
    }
    notifyChange() {
        this.lastSelectionState = this.stateToArray();
        this.selectedKeysChange.emit(this.lastSelectionState);
    }
    setState(selectedKeys) {
        this.reset();
        if (this.isCellSelectionMode) {
            this.cellSelectionState = new PairSet(selectedKeys, 'itemKey', 'columnKey');
        }
        else {
            this.rowSelectionState = new Set(selectedKeys);
        }
    }
    stateToArray() {
        return this.isCellSelectionMode ?
            this.cellSelectionState.toArray('itemKey', 'columnKey') :
            Array.from(this.rowSelectionState);
    }
}
Selection.ɵfac = function Selection_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
Selection.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: Selection, inputs: { selectedKeys: "selectedKeys", selectionKey: ["kendoGridSelectBy", "selectionKey"], columnKey: "columnKey" }, outputs: { selectedKeysChange: "selectedKeysChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Array)
], Selection.prototype, "selectedKeys", void 0);
__decorate([
    Input("kendoGridSelectBy"),
    __metadata("design:type", Object)
], Selection.prototype, "selectionKey", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], Selection.prototype, "columnKey", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], Selection.prototype, "selectedKeysChange", void 0);

const reset = (...lists) => {
    let diff = false;
    for (let idx = 0; idx < lists.length; idx++) {
        const [list, columns] = lists[idx];
        diff = diff || list.length !== columns.length;
        list.reset(columns);
    }
    return diff;
};
/**
 * @hidden
 */
class ColumnsContainer {
    constructor(columns) {
        this.columns = columns;
        this.allColumns = new QueryList();
        this.leafColumns = new QueryList();
        this.lockedColumns = new QueryList();
        this.nonLockedColumns = new QueryList();
        this.lockedLeafColumns = new QueryList();
        this.nonLockedLeafColumns = new QueryList();
        this.totalLevels = 0;
        this.changes = new EventEmitter();
        this.leafColumnsToRender = [];
        this.lockedColumnsToRender = [];
        this.nonLockedColumnsToRender = [];
        this.hasGroupHeaderColumn = false;
        this.hasGroupFooter = false;
        this.hasFooter = false;
        this.unlockedWidth = 0;
    }
    refresh() {
        const currentLevels = this.totalLevels;
        const leafColumns$$1 = new Array();
        const lockedLeafColumns = new Array();
        const nonLockedLeafColumns = new Array();
        const lockedColumns = new Array();
        const nonLockedColumns = new Array();
        const allColumns = new Array();
        const leafColumnsToRender = new Array();
        const lockedColumnsToRender = new Array();
        const nonLockedColumnsToRender = new Array();
        let hasGroupHeaderColumn = false;
        let hasGroupFooter = false;
        let hasFooter = false;
        let unlockedWidth = 0;
        let leafIndex = 0;
        this.totalLevels = 0;
        this.columns().forEach(column => {
            const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;
            const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;
            const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;
            if (!isColumnGroupComponent(column)) {
                containerLeafColumns.push(column);
                leafColumns$$1.push(column);
                leafColumnsToRender.push.apply(leafColumnsToRender, columnsToRender([column]));
                toRenderContainer.push.apply(toRenderContainer, columnsToRender([column]));
                hasGroupHeaderColumn = hasGroupHeaderColumn || someLeafColumn(leaf => Boolean(leaf.groupHeaderColumnTemplateRef), column);
                hasGroupFooter = hasGroupFooter || someLeafColumn(leaf => Boolean(leaf.groupFooterTemplateRef), column);
                hasFooter = hasFooter || someLeafColumn(leaf => Boolean(leaf.footerTemplateRef), column);
                if (!column.isLocked) {
                    unlockedWidth += column.width || 0;
                }
                if (column.isSpanColumn) {
                    column.childColumns.forEach(c => {
                        c.leafIndex = leafIndex++;
                    });
                }
                else {
                    column.leafIndex = leafIndex++;
                }
            }
            containerColumns.push(column);
            allColumns.push(column);
            this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;
        });
        this.hasGroupHeaderColumn = hasGroupHeaderColumn;
        this.hasGroupFooter = hasGroupFooter;
        this.hasFooter = hasFooter;
        this.leafColumnsToRender = leafColumnsToRender;
        this.lockedColumnsToRender = lockedColumnsToRender;
        this.nonLockedColumnsToRender = nonLockedColumnsToRender;
        this.unlockedWidth = unlockedWidth;
        const changes = reset([this.leafColumns, leafColumns$$1], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;
        if (changes) {
            this.changes.emit();
        }
        return changes;
    }
}

const forEachColumn = (list, callback) => {
    list.forEach((column) => {
        callback(column);
        if (column.isColumnGroup && column.hasChildren) {
            forEachColumn(column.childrenArray, callback);
        }
    });
};
const forEachLevel = (list, callback) => {
    sortColumns(list)
        .forEach((column) => {
        callback(column);
        if (column.isColumnGroup && column.hasChildren) {
            forEachLevel(column.childrenArray, callback);
        }
    });
};
const filterHierarchy = (list, predicate) => {
    const result = [];
    sortColumns(list)
        .forEach((column) => {
        if (predicate(column)) {
            if (column.isColumnGroup) {
                const children$$1 = filterHierarchy(column.childrenArray, predicate);
                if (children$$1.length) {
                    result.push(column, ...children$$1);
                }
            }
            else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {
                result.push(column);
            }
        }
    });
    return result;
};
/**
 * @hidden
 */
class ColumnList {
    constructor(columns) {
        this.columns = columns;
    }
    static empty() {
        return new ColumnList(new QueryList());
    }
    forEach(callback) {
        forEachColumn(this.columns, callback);
    }
    filter(callback) {
        const result = [];
        forEachColumn(this.columns, (column) => {
            if (callback(column)) {
                result.push(column);
            }
        });
        return result;
    }
    filterHierarchy(predicate) {
        return filterHierarchy(this.columns.toArray(), predicate);
    }
    filterSort(callback) {
        const result = [];
        forEachLevel(this.columns.toArray(), (column) => {
            if (callback(column)) {
                result.push(column);
            }
        });
        return result;
    }
    toArray() {
        const result = [];
        forEachColumn(this.columns, (column) => {
            result.push(column);
        });
        return result;
    }
    rootColumns() {
        return this.columns.toArray();
    }
    totalColumnLevels() {
        let totalLevels = 0;
        this.forEach(column => {
            totalLevels = Math.max(column.level, totalLevels);
        });
        return totalLevels;
    }
}

/**
 * @hidden
 */
class GroupInfoService {
    constructor() {
        this._columnList = ColumnList.empty;
    }
    get columns() {
        return expandColumns(this._columnList().toArray()).filter(isColumnComponent);
    }
    registerColumnsContainer(columns) {
        this._columnList = columns;
    }
    formatForGroup(item) {
        const column = this.columnForGroup(item);
        return column ? column.format : "";
    }
    isGroupable(groupField) {
        const [column] = this.columns.filter(x => x.field === groupField);
        return column ? column.groupable : true;
    }
    groupTitle(item) {
        const column = this.columnForGroup(item);
        return column ? (column.title || column.field) : this.groupField(item);
    }
    groupHeaderTemplate(item) {
        const column = this.columnForGroup(item);
        return column ? column.groupHeaderTemplateRef || column.groupHeaderColumnTemplateRef : undefined;
    }
    groupField(group) {
        return group.data ? group.data.field : group.field;
    }
    columnForGroup(group) {
        const field = this.groupField(group);
        const [column] = this.columns.filter(x => x.field === field);
        return column;
    }
}
GroupInfoService.ɵfac = function GroupInfoService_Factory(t) { return new (t || GroupInfoService)(); };
GroupInfoService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: GroupInfoService, factory: GroupInfoService.ɵfac });

/**
 * @hidden
 */
let ChangeNotificationService = class ChangeNotificationService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.changes = new EventEmitter();
    }
    notify() {
        if (!this.subscription || this.subscription.closed) {
            this.subscription = this.ngZone.onStable
                .asObservable().pipe(take(1))
                .subscribe(() => this.changes.emit());
        }
    }
};
ChangeNotificationService.ɵfac = function ChangeNotificationService_Factory(t) { return new (t || ChangeNotificationService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ChangeNotificationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ChangeNotificationService, factory: function (t) { return ChangeNotificationService.ɵfac(t); } });
ChangeNotificationService = __decorate([ __metadata("design:paramtypes", [NgZone])
], ChangeNotificationService);

/**
 * Represents the no-records template of the Grid. Provides an option to customize the
 * appearance of the item that is displayed when no data is present. To define the no-records template,
 * nest an `<ng-template>` tag with the `kendoGridNoRecordsTemplate` directive inside `<kendo-grid>`.
 *
 * > When the locked columns of the Grid are in use, the template is displayed in the non-locked part of the content.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *       <kendo-grid [data]="data">
 *         <kendo-grid-column field="ProductID"></kendo-grid-column>
 *         <kendo-grid-column field="ProductName"></kendo-grid-column>
 *         <kendo-grid-column field="UnitPrice"></kendo-grid-column>
 *         <ng-template kendoGridNoRecordsTemplate>
 *            There are not products. <a href="#" (click)="refresh()">Click here to refresh</a>.
 *         </ng-template>
 *       </kendo-grid>
 *   `
 * })
 *
 * class AppComponent {
 *     public data = [];
 *     public refresh() {
 *       this.data = [{
 *            "ProductID": 1,
 *            "ProductName": "Chai",
 *            "UnitPrice": 18.0000,
 *            "Discontinued": false,
 *            "Category": {
 *                "CategoryID": 1,
 *                "CategoryName": "Beverages",
 *                "Description": "Soft drinks, coffees, teas, beers, and ales"
 *            }
 *          }, {
 *            "ProductID": 2,
 *            "ProductName": "Chang",
 *            "UnitPrice": 19.0000,
 *            "Discontinued": false,
 *            "Category": {
 *                "CategoryID": 1,
 *                "CategoryName": "Beverages",
 *                "Description": "Soft drinks, coffees, teas, beers, and ales"
 *            }
 *          }, {
 *            "ProductID": 3,
 *            "ProductName": "Aniseed Syrup",
 *            "UnitPrice": 10.0000,
 *            "Discontinued": false,
 *            "Category": {
 *                "CategoryID": 2,
 *                "CategoryName": "Condiments",
 *                "Description": "Sweet and savory sauces, relishes, spreads, and seasonings"
 *            }
 *        }];
 *
 *     }
 * }
 *
 * ```
 */
let NoRecordsTemplateDirective = class NoRecordsTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NoRecordsTemplateDirective.ɵfac = function NoRecordsTemplateDirective_Factory(t) { return new (t || NoRecordsTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
NoRecordsTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NoRecordsTemplateDirective, selectors: [["", "kendoGridNoRecordsTemplate", ""]] });
NoRecordsTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], NoRecordsTemplateDirective);

const set = value => pair => pair.forEach(x => x.style.height = value);
const clearHeight = pairs => pairs
    .filter(([left, right]) => left.style.height || right.style.height)
    .forEach(set(""));
const zip$1 = (arr1, arr2) => {
    const result = [];
    for (let idx = 0, len = arr1.length; idx < len; idx++) {
        if (!arr2[idx]) {
            break;
        }
        result.push([arr1[idx], arr2[idx]]);
    }
    return result;
};
const setHeight = heights => (row, idx) => set(`${heights[idx] + 1}px`)(row);
const getHeights = rows => rows.map(([left, right]) => {
    const height = left.offsetHeight;
    const offsetHeight2 = right.offsetHeight;
    if (height < offsetHeight2) {
        return offsetHeight2;
    }
    return height;
});
/**
 * @hidden
 */
const syncRowsHeight = (table1, table2) => {
    const activeElement = document.activeElement;
    const rows = zip$1(table1.rows, table2.rows);
    clearHeight(rows);
    const heights = getHeights(rows);
    [table1, table2].forEach(x => x.style.display = 'none');
    rows.forEach(setHeight(heights));
    [table1, table2].forEach(x => x.style.display = '');
    if (document.activeElement !== activeElement &&
        (table1.contains(activeElement) || table2.contains(activeElement))) {
        activeElement.focus();
    }
};

/**
 * @hidden
 */
let MenuTabbingService = class MenuTabbingService {
    /**
     * @hidden
     */
    constructor() {
        this.isColumnMenu = false;
        this.isPopupOpen = false;
    }
};
MenuTabbingService.ɵfac = function MenuTabbingService_Factory(t) { return new (t || MenuTabbingService)(); };
MenuTabbingService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MenuTabbingService, factory: function (t) { return MenuTabbingService.ɵfac(t); } });

/**
 * Represents a service to set the filter descriptor
 * ([see example]({% slug reusablecustomfilters_grid %})).
 */
let FilterService = class FilterService {
    /**
     * @hidden
     */
    constructor(menuTabbingService) {
        /**
         * Fires when the filter descriptors is set.
         */
        this.changes = new Subject();
        this.menuTabbingService = menuTabbingService;
    }
    /**
     * Sets the filter descriptor.
     *
     * @param {CompositeFilterDescriptor} value - The filter descriptor that will be set.
     */
    filter(value) {
        this.changes.next(value);
    }
};
FilterService.ɵfac = function FilterService_Factory(t) { return new (t || FilterService)(ɵngcc0.ɵɵinject(MenuTabbingService, 8)); };
FilterService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FilterService, factory: function (t) { return FilterService.ɵfac(t); } });
FilterService = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [MenuTabbingService])
], FilterService);

/**
 * Represents the pager template which helps to customize the pager appearance in the Grid. To define a pager
 * template, nest an `<ng-template>` tag with the `kendoPagerTemplate` directive inside `<kendo-grid>`.
 *
 * The template context provides the following fields:
 * * `currentPage`&mdash;The index of the displayed page.
 * * `pageSize`&mdash;The value of the current `pageSize`.
 * * `skip`&mdash;The current skip value.
 * * `total`&mdash;The total number of records.
 * * `totalPages`&mdash;The total number of available pages.
 * *  Needs to be provided as an input to inner pager components used within the template when the Grid is navigable.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *      <kendo-grid
 *        [kendoGridBinding]="gridData"
 *        [pageSize]="1"
 *        [pageable]="true"
 *      >
 *       <kendo-grid-column field="ProductID" title="ID" width="40">
 *       </kendo-grid-column>
 *       <kendo-grid-column field="ProductName" title="Name" width="250">
 *       </kendo-grid-column>
 *       <kendo-grid-column field="UnitPrice" title="Price" width="80" format="{0:c}">
 *       </kendo-grid-column>
 *
 *       <ng-template kendoPagerTemplate let-totalPages="totalPages" let-currentPage="currentPage">
 *          <kendo-pager-prev-buttons></kendo-pager-prev-buttons>
 *          <kendo-pager-numeric-buttons [buttonCount]="10"></kendo-pager-numeric-buttons>
 *          <kendo-pager-next-buttons></kendo-pager-next-buttons>
 *          <kendo-pager-info></kendo-pager-info>
 *          Current page: {{currentPage}}
 *       </ng-template>
 *
 *    </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *     public gridData = [{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": false
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": true
 *       }
 *     ];
 * }
 *
 * ```
 */
let PagerTemplateDirective = class PagerTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
PagerTemplateDirective.ɵfac = function PagerTemplateDirective_Factory(t) { return new (t || PagerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PagerTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PagerTemplateDirective, selectors: [["", "kendoPagerTemplate", ""]] });
PagerTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], PagerTemplateDirective);

/**
 * @hidden
 */
let PDFService = class PDFService {
    /**
     * @hidden
     */
    constructor() {
        this.savePDF = new EventEmitter();
        this.drawPDF = new EventEmitter();
        this.exportClick = new EventEmitter();
        this.dataChanged = new EventEmitter();
    }
    save(component) {
        this.emitEvent(this.savePDF, component);
    }
    draw(component, promise) {
        this.emitEvent(this.drawPDF, { component, promise });
    }
    emitEvent(emitter, args) {
        if (emitter.observers.length === 0) {
            if (isDevMode()) {
                throw new Error('Creating PDF requires including the PDFModule and adding the <kendo-grid-pdf> component.');
            }
        }
        else {
            emitter.emit(args);
        }
    }
};
PDFService.ɵfac = function PDFService_Factory(t) { return new (t || PDFService)(); };
PDFService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: PDFService, factory: function (t) { return PDFService.ɵfac(t); } });

/**
 * Arguments for the `pdfExport` event.
 */
class PDFExportEvent extends PreventableEvent {
}

/**
 * @hidden
 */
let SuspendService = class SuspendService {
    /**
     * @hidden
     */
    constructor() {
        this.scroll = false;
    }
};
SuspendService.ɵfac = function SuspendService_Factory(t) { return new (t || SuspendService)(); };
SuspendService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SuspendService, factory: function (t) { return SuspendService.ɵfac(t); } });

/* tslint:disable: object-literal-sort-keys */
const bootstrapToMedia = (media) => (({
    "xs": "(max-width: 576px)",
    "sm": "(min-width: 576px)",
    "md": "(min-width: 768px)",
    "lg": "(min-width: 992px)",
    "xl": "(min-width: 1200px)"
})[media] || media);
/* tslint:enable: object-literal-sort-keys */
const browserMatchMedia = (media) => window.matchMedia(media).matches;
/**
 * @hidden
 */
let ResponsiveService = class ResponsiveService {
    /**
     * @hidden
     */
    constructor() {
        /**
         * @hidden
         */
        this.matchMedia = browserMatchMedia;
    }
    /**
     * @hidden
     */
    matchesMedia(media) {
        return !media || this.matchMedia(bootstrapToMedia(media));
    }
};
ResponsiveService.ɵfac = function ResponsiveService_Factory(t) { return new (t || ResponsiveService)(); };
ResponsiveService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ResponsiveService, factory: function (t) { return ResponsiveService.ɵfac(t); } });

/**
 * @hidden
 */
let ExcelService = class ExcelService {
    /**
     * @hidden
     */
    constructor() {
        this.saveToExcel = new EventEmitter();
        this.exportClick = new EventEmitter();
    }
    save(component) {
        if (this.saveToExcel.observers.length === 0) {
            if (isDevMode()) {
                throw new Error('Saving excel requires including the ExcelModule and adding the <kendo-grid-excel> component.');
            }
        }
        else {
            this.saveToExcel.emit(component);
        }
    }
};
ExcelService.ɵfac = function ExcelService_Factory(t) { return new (t || ExcelService)(); };
ExcelService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ExcelService, factory: function (t) { return ExcelService.ɵfac(t); } });

/**
 * Represents the toolbar template of the Grid.
 *
 * The template context has the following field:
 * - `position`&mdash;The position at which the toolbar template is rendered. The possible values are "top" and "bottom".
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <div class="example-config">
 *         <input type="radio" id="top" name="position" value="top" checked (click)="positionChange($event)"/>
 *         <label class="k-radio-label" for="top">Top</label><br/>
 *         <input type="radio" id="bottom" name="position" value="bottom" (click)="positionChange($event)"/>
 *         <label class="k-radio-label" for="bottom">Bottom</label><br/>
 *         <input type="radio" id="both" name="position" value="both" (click)="positionChange($event)"/>
 *         <label class="k-radio-label" for="both">Both</label><br/>
 *       </div>
 *       <kendo-grid [data]="gridData" style="height: 200px">
 *            <ng-template kendoGridToolbarTemplate [position]="position" let-position="position">
 *                <button (click)="onClick()">Custom action</button>
 *            </ng-template>
 *            <kendo-grid-column field="ProductName">
 *            </kendo-grid-column>
 *            <kendo-grid-column field="UnitPrice">
 *            </kendo-grid-column>
 *        </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *     public position: 'top' | 'bottom' | 'both' = 'top';
 *
 *     public gridData = [{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": false
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": true
 *       }
 *     ];
 *
 *     public onClick(): void {
 *         console.log("button was clicked");
 *     }
 *
 *     public positionChange({ target }): void {
 *        this.position = target.value;
 *     }
 * }
 *
 * ```
 */
let ToolbarTemplateDirective = class ToolbarTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
        this._position = "top";
    }
    /**
     * The position of the toolbar ([see example]({% slug toolbartemplate_grid %})).
     *
     * The possible values are:
     * - `top`&mdash;Positions the toolbar above the group panel or header.
     * - `bottom`&mdash;Positions the toolbar below the pager.
     * - `both`&mdash;Displays two toolbar instances. Positions the first one above
     * the group panel or header and the second one below the pager.
     */
    set position(position) {
        this._position = position;
    }
    get position() {
        return this._position;
    }
};
ToolbarTemplateDirective.ɵfac = function ToolbarTemplateDirective_Factory(t) { return new (t || ToolbarTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ToolbarTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ToolbarTemplateDirective, selectors: [["", "kendoGridToolbarTemplate", ""]], inputs: { position: "position" } });
__decorate([
    Input("position"),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ToolbarTemplateDirective.prototype, "position", null);
ToolbarTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], ToolbarTemplateDirective);

/**
 * @hidden
 */
let ScrollSyncService = class ScrollSyncService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.changes = new Subject();
        this.elements = [];
        this.subscriptions = new Subscription();
        this.headerSubscription = new Subscription();
        this.bodySubscription = new Subscription();
        this.subscriptions.add(this.changes.subscribe(args => this.scrollLeft(args)));
    }
    registerEmitter(el, sourceType) {
        this.unregister(sourceType);
        this.elements.push({ element: el, sourceType });
        if (sourceType === "body" || sourceType === "header") {
            this.ngZone.runOutsideAngular(() => {
                const obs = fromEvent(el, "scroll").pipe(map(({ target: { scrollLeft } }) => ({
                    scrollLeft,
                    sourceType
                })));
                const subscription = obs.pipe(distinctUntilChanged((x, y) => (x.scrollLeft === y.scrollLeft)), filter(x => !this.source || this.source === x.sourceType), tap(x => this.source = x.sourceType))
                    .subscribe((x) => this.changes.next(x));
                subscription.add(obs.pipe(filter(x => this.source && this.source !== x.sourceType))
                    .subscribe(() => this.source = undefined));
                if (sourceType === "body") {
                    this.bodySubscription.add(subscription);
                }
                else {
                    this.headerSubscription.add(subscription);
                }
            });
        }
    }
    /**
     * destroy
     */
    destroy() {
        this.subscriptions.unsubscribe();
        this.headerSubscription.unsubscribe();
        this.bodySubscription.unsubscribe();
    }
    scrollLeft({ scrollLeft, sourceType }) {
        this.ngZone.runOutsideAngular(() => {
            this.elements
                .filter(x => sourceType !== x.sourceType)
                .forEach(({ element }) => element.scrollLeft = scrollLeft);
        });
    }
    unregister(sourceType) {
        const index = this.elements.findIndex(x => x.sourceType === sourceType);
        if (index > -1) {
            if (sourceType === "header") {
                this.headerSubscription.unsubscribe();
                this.headerSubscription = new Subscription();
            }
            else if (sourceType === "body") {
                this.bodySubscription.unsubscribe();
                this.bodySubscription = new Subscription();
            }
            this.elements.splice(index, 1);
        }
    }
};
ScrollSyncService.ɵfac = function ScrollSyncService_Factory(t) { return new (t || ScrollSyncService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ScrollSyncService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ScrollSyncService, factory: function (t) { return ScrollSyncService.ɵfac(t); } });
ScrollSyncService = __decorate([ __metadata("design:paramtypes", [NgZone])
], ScrollSyncService);

/**
 * @hidden
 */
let ResizeService = class ResizeService {
    /**
     * @hidden
     */
    constructor() {
        this.resizeSubscription = new Subscription(() => { });
        this.dispatcher = new Subject();
        // tslint:disable-next-line:member-ordering
        this.changes = this.dispatcher.asObservable().pipe(throttleTime(100));
    }
    connect(resizes) {
        this.resizeSubscription.add(resizes.subscribe(this.dispatcher));
    }
    destroy() {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
};
ResizeService.ɵfac = function ResizeService_Factory(t) { return new (t || ResizeService)(); };
ResizeService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ResizeService, factory: function (t) { return ResizeService.ɵfac(t); } });

/**
 * @hidden
 */
const isLocked = column => column.parent ? isLocked(column.parent) : !!column.locked;
/**
 * @hidden
 */
const resizeArgs = (column, extra) => Object.assign({
    columns: leafColumns([column]),
    locked: isLocked(column)
}, extra); // tslint:disable-line:align
/**
 * @hidden
 */
let ColumnResizingService = class ColumnResizingService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new EventEmitter();
        this.tables = [];
        this.batch = null;
    }
    start(column) {
        this.trackColumns(column);
        const columns = (this.column.isColumnGroup ? [column] : [])
            .concat(leafColumns([column]));
        this.changes.emit({
            columns: columns,
            locked: isLocked(this.column),
            type: 'start'
        });
    }
    resizeColumns(deltaPercent) {
        const action = resizeArgs(this.column, {
            deltaPercent,
            type: 'resizeColumn'
        });
        this.changes.emit(action);
    }
    resizeTable(column, delta) {
        const action = resizeArgs(column, {
            delta,
            type: 'resizeTable'
        });
        this.changes.emit(action);
    }
    resizedColumn(state$$1) {
        this.resizedColumns.push(state$$1);
    }
    end() {
        this.changes.emit({
            columns: [],
            resizedColumns: this.resizedColumns,
            type: 'end'
        });
    }
    registerTable(tableMetadata) {
        this.tables.push(tableMetadata);
        const unregisterTable = () => {
            this.tables.splice(this.tables.indexOf(tableMetadata), 1);
        };
        return unregisterTable;
    }
    measureColumns(info) {
        if (this.batch !== null) {
            this.batch.push(...info);
        }
        else {
            this.autoFitBatch(info, () => this.end());
        }
    }
    autoFit(...columns) {
        const nonLockedColumns = columns.filter(column => !column.isLocked);
        this.autoFitStart(nonLockedColumns);
        this.autoFitBatch(this.batch, () => {
            if (nonLockedColumns.length < columns.length) {
                const lockedColumns = columns.filter(column => column.isLocked);
                this.autoFitStart(lockedColumns);
                this.autoFitBatch(this.batch, () => this.end());
            }
            else {
                this.end();
            }
        });
    }
    trackColumns(column) {
        this.resizedColumns = [];
        this.column = column;
    }
    autoFitStart(columns) {
        this.batch = [];
        this.resizedColumns = [];
        if (columns.length === 0) {
            return;
        }
        const locked = columns[0].isLocked;
        this.changes.emit({
            type: 'start',
            columns,
            locked
        });
        this.changes.emit({
            type: 'triggerAutoFit',
            columns,
            locked
        });
    }
    autoFitBatch(info, onComplete) {
        const locked = info.length > 0 ? info[0].column.isLocked : false;
        const observables = this.tables
            .filter(table => table.locked === locked)
            .map(table => table.autoFit(info));
        zip(...observables)
            .pipe(take(1))
            .subscribe(widths => {
            this.changes.emit({
                columns: info.map(i => i.column),
                type: 'autoFitComplete',
                widths,
                locked
            });
            if (onComplete) {
                onComplete();
            }
        });
        this.batch = null;
    }
};
ColumnResizingService.ɵfac = function ColumnResizingService_Factory(t) { return new (t || ColumnResizingService)(); };
ColumnResizingService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ColumnResizingService, factory: function (t) { return ColumnResizingService.ɵfac(t); } });

/**
 * @hidden
 */
/**
 * @hidden
 */
const hasFilterMenu = (settings) => typeof settings === 'string' && settings.indexOf('menu') > -1;
/**
 * @hidden
 */
const hasFilterRow = (settings) => settings === true || (typeof settings === 'string' && settings.indexOf('row') > -1);

const contains$1 = (node, predicate) => {
    while (node) {
        if (predicate(node)) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
};
/**
 * Arguments for the `close` event of the filter and column-menu popup.
 */
class PopupCloseEvent extends PreventableEvent {
    constructor(e) {
        super();
        this.originalEvent = e;
    }
}
const DEFAULT_POPUP_CLASS = 'k-grid-filter-popup';
/**
 * The service that is used for the popups of the filter and column menus
 * ([see example]({% slug reusablecustomfilters_grid %}#toc-filter-menu-with-popup)).
 */
let SinglePopupService = class SinglePopupService {
    constructor(popupService, renderer, ngZone, scrollSyncService, localization) {
        this.popupService = popupService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.localization = localization;
        /**
         * Fires when the filter or column menus are about to close because the user clicked outside their popups.
         * Used to prevent the popup from closing.
         */
        this.onClose = new Subject();
        this.scrollSubscription = scrollSyncService.changes.subscribe(() => this.destroy());
    }
    /**
     * @hidden
     */
    open(anchor, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {
        const toggle = isPresent(popupRef) && this.popupRef === popupRef;
        this.destroy();
        if (!toggle) {
            const direction = this.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction },
                anchor: anchor,
                popupClass: popupClass,
                content: template,
                positionMode: "absolute"
            });
            this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.localization.rtl ? 'rtl' : 'ltr');
            this.attachClose(anchor);
        }
        return this.popupRef;
    }
    /**
     * @hidden
     */
    destroy() {
        if (this.popupRef) {
            this.detachClose();
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    ngOnDestroy() {
        this.destroy();
        this.scrollSubscription.unsubscribe();
    }
    detachClose() {
        if (this.removeClick) {
            this.removeClick();
        }
    }
    attachClose(skipElement) {
        this.detachClose();
        this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen("document", "click", (e) => {
            if (!contains$1(e.target, x => this.popupRef.popupElement === x || x === skipElement)) {
                const args = new PopupCloseEvent(e);
                this.onClose.next(args);
                if (!args.isDefaultPrevented()) {
                    this.destroy();
                }
            }
        }));
    }
};
SinglePopupService.ɵfac = function SinglePopupService_Factory(t) { return new (t || SinglePopupService)(ɵngcc0.ɵɵinject(ɵngcc3.PopupService), ɵngcc0.ɵɵinject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ScrollSyncService), ɵngcc0.ɵɵinject(ɵngcc1.LocalizationService)); };
SinglePopupService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SinglePopupService, factory: function (t) { return SinglePopupService.ɵfac(t); } });
SinglePopupService = __decorate([ __metadata("design:paramtypes", [PopupService,
        Renderer2,
        NgZone,
        ScrollSyncService,
        LocalizationService])
], SinglePopupService);

/* tslint:disable: no-bitwise */
/**
 * @hidden
 */
const append = (element) => {
    let appended = false;
    return () => {
        if (!appended) {
            document.body.appendChild(element);
            appended = true;
        }
        return element;
    };
};
/**
 * @hidden
 */
const getDocument = element => element.ownerDocument.documentElement;
/**
 * @hidden
 */
const getWindow = element => element.ownerDocument.defaultView;
/**
 * @hidden
 */
const offset = element => {
    const { clientTop, clientLeft } = getDocument(element);
    const { pageYOffset, pageXOffset } = getWindow(element);
    const { top, left } = element.getBoundingClientRect();
    return {
        top: top + pageYOffset - clientTop,
        left: left + pageXOffset - clientLeft
    };
};
/**
 * @hidden
 * If the target is before the draggable element, returns `true`.
 *
 * DOCUMENT_POSITION_FOLLOWING = 4
 */
const isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;
/**
 * @hidden
 * If the container and the element are the same
 * or if the container holds (contains) the element, returns `true`.
 *
 * DOCUMENT_POSITION_CONTAINED_BY = 16
 */
const contains$2 = (element, container) => element === container ||
    (container.compareDocumentPosition(element) & 16) !== 0;
/**
 * @hidden
 */
const position = (target, before) => {
    const targetRect = offset(target);
    const { offsetWidth, offsetHeight } = target;
    const left = targetRect.left + (before ? 0 : offsetWidth);
    const top = targetRect.top;
    const height = offsetHeight;
    return { left, top, height };
};

/**
 * @hidden
 */
let DragAndDropService = class DragAndDropService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new EventEmitter();
        this.register = [];
        this.lastTarget = null;
    }
    add(target) {
        this.register.push(target);
    }
    remove(target) {
        this.register = this.register.filter(current => current !== target);
    }
    notifyDrag(draggable, element, mouseEvent) {
        const target = this.targetFor(element);
        if (this.lastTarget === target) {
            return;
        }
        this.changes.next({
            draggable,
            mouseEvent,
            target: this.lastTarget,
            type: 'leave'
        });
        if (target) {
            this.changes.next({
                draggable,
                mouseEvent,
                target,
                type: 'enter'
            });
        }
        this.lastTarget = target;
    }
    notifyDrop(draggable, mouseEvent) {
        this.changes.next({
            draggable,
            mouseEvent,
            target: this.lastTarget,
            type: 'drop'
        });
        this.lastTarget = null;
    }
    targetFor(element) {
        const comparer = contains$2.bind(null, element);
        return this.register.find(({ element: { nativeElement } }) => comparer(nativeElement));
    }
};
DragAndDropService.ɵfac = function DragAndDropService_Factory(t) { return new (t || DragAndDropService)(); };
DragAndDropService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DragAndDropService, factory: function (t) { return DragAndDropService.ɵfac(t); } });

const updateClass = (element, valid) => {
    const icon = element.querySelector('.k-icon');
    icon.className = icon.className
        .replace(/(plus|cancel)/, valid ? 'plus' : 'cancel');
};
const updateLock = (element, locked = null) => {
    const icon = element.querySelectorAll('.k-icon')[1];
    const value = locked == null ? '' : (locked ? 'k-i-lock' : 'k-i-unlock');
    icon.className = icon.className
        .replace(/(k-i-unlock|k-i-lock)/, '') + ` ${value}`;
};
const decorate = (element) => {
    element.className = 'k-header k-drag-clue';
    element.style.position = 'absolute';
    element.style.zIndex = '20000';
};
/**
 * @hidden
 */
let DragHintService = class DragHintService {
    constructor(santizer) {
        this.santizer = santizer;
    }
    create(title) {
        this.dom = document.createElement("div");
        decorate(this.dom);
        const safeTitle = this.santizer.sanitize(SecurityContext.HTML, title);
        this.dom.innerHTML = `
            <span class="k-icon k-drag-status k-i-cancel k-icon-with-modifier">
                <span class="k-icon k-icon-modifier"></span>
            </span>
            ${safeTitle}
        `;
    }
    attach() {
        return append(this.dom);
    }
    remove() {
        if (this.dom && this.dom.parentNode) {
            (function (el) {
                setTimeout(() => document.body.removeChild(el));
            })(this.dom); // hack for IE + pointer events!
            this.dom = null;
        }
    }
    show() {
        this.dom.style.display = "";
    }
    hide() {
        this.dom.style.display = "none";
    }
    enable() {
        updateClass(this.dom, true);
    }
    disable() {
        updateClass(this.dom, false);
    }
    removeLock() {
        updateLock(this.dom);
    }
    toggleLock(locked) {
        updateLock(this.dom, locked);
    }
    move(move) {
        this.dom.style.top = move.pageY + 'px';
        this.dom.style.left = move.pageX + 'px';
    }
};
DragHintService.ɵfac = function DragHintService_Factory(t) { return new (t || DragHintService)(ɵngcc0.ɵɵinject(ɵngcc4.DomSanitizer)); };
DragHintService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DragHintService, factory: function (t) { return DragHintService.ɵfac(t); } });
DragHintService = __decorate([ __metadata("design:paramtypes", [DomSanitizer])
], DragHintService);

/**
 * @hidden
 */
let DropCueService = class DropCueService {
    create() {
        this.dom = document.createElement("div");
        this.dom.className = 'k-grouping-dropclue';
        this.hide();
    }
    attach() {
        return append(this.dom);
    }
    remove() {
        if (this.dom && this.dom.parentElement) {
            document.body.removeChild(this.dom);
            this.dom = null;
        }
    }
    hide() {
        this.dom.style.display = "none";
    }
    position({ left, top, height }) {
        this.dom.style.display = 'block';
        this.dom.style.height = height + 'px';
        this.dom.style.top = top + 'px';
        const width = this.dom.offsetWidth / 2;
        this.dom.style.left = left - width + 'px';
    }
};
DropCueService.ɵfac = function DropCueService_Factory(t) { return new (t || DropCueService)(); };
DropCueService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DropCueService, factory: function (t) { return DropCueService.ɵfac(t); } });

/**
 * @hidden
 */
let ColumnReorderService = class ColumnReorderService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new EventEmitter();
    }
    reorder(e) {
        this.changes.emit(e);
    }
};
ColumnReorderService.ɵfac = function ColumnReorderService_Factory(t) { return new (t || ColumnReorderService)(); };
ColumnReorderService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ColumnReorderService, factory: function (t) { return ColumnReorderService.ɵfac(t); } });

/**
 * Arguments for the `columnReorder` event.
 */
class ColumnReorderEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor({ column, newIndex, oldIndex }) {
        super();
        this.column = column;
        this.newIndex = newIndex;
        this.oldIndex = oldIndex;
    }
}

/**
 * @hidden
 */
class NavigationMetadata {
    constructor(dataRows, headerRows, isVirtual, hasPager, hasDetailTemplate, gridElement, virtualColumns, columns) {
        this.dataRows = dataRows;
        this.headerRows = headerRows;
        this.isVirtual = isVirtual;
        this.hasPager = hasPager;
        this.hasDetailTemplate = hasDetailTemplate;
        this.gridElement = gridElement;
        this.virtualColumns = virtualColumns;
        this.columns = columns;
    }
    get maxLogicalRowIndex() {
        const dataRows = this.hasDetailTemplate ? this.dataRows * 2 : this.dataRows;
        return this.headerRows + dataRows - 1;
    }
}

const NO_STICKY = { left: '0px', right: '0px' };
/**
 * @hidden
 */
let ColumnInfoService = class ColumnInfoService {
    /**
     * @hidden
     */
    constructor() {
        this.visibilityChange = new EventEmitter();
        this.lockedChange = new EventEmitter();
        this.stickyChange = new EventEmitter();
        this.columnRangeChange = new EventEmitter();
        this.columnsContainer = new ColumnsContainer(() => []);
    }
    get lockedLeafColumns() {
        return this.columnsContainer.lockedLeafColumns;
    }
    get nonLockedLeafColumns() {
        return this.columnsContainer.nonLockedLeafColumns;
    }
    get isLocked() {
        return this.lockedLeafColumns.length > 0;
    }
    get totalLevels() {
        return this.columnsContainer.totalLevels;
    }
    get hiddenColumns() {
        if (!this.list) {
            return [];
        }
        return this.list().filter(column => !column.isVisible);
    }
    get leafNamedColumns() {
        const columns = expandColumns(this.list().filterSort(column => !column.isColumnGroup))
            .filter(column => column.matchesMedia && column.displayTitle);
        return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);
    }
    get unlockedRootCount() {
        return this.list().rootColumns().filter(column => !column.locked && column.isVisible).length;
    }
    stickyColumnsStyles(column) {
        if (!this.stickyColumns) {
            this.stickyColumns = this.list().rootColumns().filter(column => column.sticky && !column.locked && column.isVisible);
        }
        if (this.stickyColumns.length === 0) {
            return NO_STICKY;
        }
        const result = this.stickyColumns.reduce((acc, curr) => {
            if (curr.leafIndex < column.leafIndex) {
                acc.left += curr.width;
            }
            else if (curr.leafIndex > column.leafIndex) {
                acc.right += curr.width;
            }
            return acc;
        }, { left: 0, right: 0 });
        return {
            left: `${result.left}px`,
            right: `${result.right}px`
        };
    }
    init(columns, list) {
        this.columnsContainer = columns;
        this.list = list;
        this.stickyColumns = null;
    }
    changeVisibility(columns) {
        this.stickyColumns = null;
        this.visibilityChange.emit(columns);
    }
    changeLocked(columns) {
        this.stickyColumns = null;
        this.lockedChange.emit(columns);
    }
    changeStuck(columns) {
        this.stickyColumns = null;
        this.stickyChange.emit(columns);
    }
};
ColumnInfoService.ɵfac = function ColumnInfoService_Factory(t) { return new (t || ColumnInfoService)(); };
ColumnInfoService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ColumnInfoService, factory: function (t) { return ColumnInfoService.ɵfac(t); } });

/**
 * @hidden
 */
class SortService {
    constructor() {
        this.changes = new Subject();
    }
    sort(value) {
        this.changes.next(value);
    }
}
SortService.ɵfac = function SortService_Factory(t) { return new (t || SortService)(); };
SortService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SortService, factory: SortService.ɵfac });

/**
 * Arguments for the `columnVisibilityChange` event.
 */
class ColumnVisibilityChangeEvent {
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * Arguments for the `columnLockedChange` event.
 */
class ColumnLockedChangeEvent {
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * @hidden
 */
const GROUP_CELL_WIDTH = 32; // this should be the value of group-cell inside the theme!
/**
 * @hidden
 */
const RESPONSIVE_BREAKPOINT_MEDIUM = 600;
/**
 * @hidden
 */
const RESPONSIVE_BREAKPOINT_LARGE = 768;

/**
 * @hidden
 */
function defaultTrackBy(index, item) {
    if (item.type === 'data' && item.isEditing) {
        return item.data;
    }
    return index;
}

/**
 * Arguments for the `columnStickyChange` event.
 */
class ColumnStickyChangeEvent {
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * Represents the virtual scrolling cell template of the Grid while loading new data. Provides an option to customize the
 * appearance of the indicator that is displayed while new data is loading. To define the loading cell template,
 * nest an `<ng-template>` tag with the `kendoGridCellLoadingTemplate` directive inside `<kendo-grid>` ([see example]({% slug virtualscrolling_grid %}#toc-custom-loading-skeleton)).
 *
 * The template context is set to the current column, and utilizes the `let-x` syntax&mdash;for example, `let-column`.
 *
 * @example
 * ```ts-no-run
 *       <kendo-grid [data]="data" scrollable="virtual" [rowHeight]="36">
 *         <ng-template kendoGridCellLoadingTemplate let-column>
 *             ...
 *         </ng-template>
 *       </kendo-grid>
 * ```
 */
let CellLoadingTemplateDirective = class CellLoadingTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
CellLoadingTemplateDirective.ɵfac = function CellLoadingTemplateDirective_Factory(t) { return new (t || CellLoadingTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
CellLoadingTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CellLoadingTemplateDirective, selectors: [["", "kendoGridCellLoadingTemplate", ""]] });
CellLoadingTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], CellLoadingTemplateDirective);

/**
 * Creates a loading template that overrides the default loading indicator of the Grid Component.
 * To define a loading template, nest an `<ng-template>` tag with the `kendoGridLoadingTemplate` directive inside the `<kendo-grid>` tag
 * [see example]({% slug databinding_grid %}#toc-loading-template).
 */
let LoadingTemplateDirective = class LoadingTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
LoadingTemplateDirective.ɵfac = function LoadingTemplateDirective_Factory(t) { return new (t || LoadingTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
LoadingTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LoadingTemplateDirective, selectors: [["", "kendoGridLoadingTemplate", ""]] });
LoadingTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], LoadingTemplateDirective);

const createControl = (source) => (acc, key) => {
    acc[key] = new FormControl(source[key]);
    return acc;
};
const validateColumnsField = (columns) => expandColumns(columns.toArray())
    .filter(isColumnComponent)
    .filter(({ field }) => !isValidFieldName(field))
    .forEach(({ field }) => console.warn(`
                Grid column field name '${field}' does not look like a valid JavaScript identifier.
                Identifiers can contain only alphanumeric characters (including "$" or "_"), and may not start with a digit.
                Please use only valid identifier names to ensure error-free operation.
            `));
const handleExpandCollapseGroupsService = (service, expandEmitter, collapseEmitter, map$$1) => (service.changes.pipe(filter(({ group }) => isPresent(group)))
    .subscribe((x) => x.expand ? expandEmitter.emit(map$$1(x)) : collapseEmitter.emit(map$$1(x))));
const handleExpandCollapseDetailsService = (service, expandEmitter, collapseEmitter, map$$1) => (service.changes.pipe(filter(({ dataItem }) => isPresent(dataItem)))
    .subscribe((x) => x.expand ? expandEmitter.emit(map$$1(x)) : collapseEmitter.emit(map$$1(x))));
const isInEditedCell = (element, gridElement) => closest(element, matchesClasses('k-grid-edit-cell')) &&
    closest(element, matchesNodeName('kendo-grid')) === gridElement;
const ɵ5$1 = EMPTY_CELL_CONTEXT;
/**
 * Represents the Kendo UI Grid component for Angular.
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-grid [data]="gridData">
 *        </kendo-grid>
 *    `
 * })
 * class AppComponent {
 *    public gridData: any[] = products;
 * }
 *
 * const products = [{
 *    "ProductID": 1,
 *    "ProductName": "Chai",
 *    "UnitPrice": 18.0000,
 *    "Discontinued": true
 *  }, {
 *    "ProductID": 2,
 *    "ProductName": "Chang",
 *    "UnitPrice": 19.0000,
 *    "Discontinued": false
 *  }
 * ];
 * ```
 */
let GridComponent = class GridComponent {
    constructor(supportService, selectionService, cellSelectionService, wrapper, groupInfoService, groupsService, changeNotification, detailsService, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, localization) {
        this.supportService = supportService;
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.wrapper = wrapper;
        this.groupInfoService = groupInfoService;
        this.groupsService = groupsService;
        this.changeNotification = changeNotification;
        this.detailsService = detailsService;
        this.editService = editService;
        this.filterService = filterService;
        this.pdfService = pdfService;
        this.responsiveService = responsiveService;
        this.renderer = renderer;
        this.excelService = excelService;
        this.ngZone = ngZone;
        this.scrollSyncService = scrollSyncService;
        this.domEvents = domEvents;
        this.columnResizingService = columnResizingService;
        this.changeDetectorRef = changeDetectorRef;
        this.columnReorderService = columnReorderService;
        this.columnInfoService = columnInfoService;
        this.navigationService = navigationService;
        this.sortService = sortService;
        this.scrollRequestService = scrollRequestService;
        this.localization = localization;
        /**
         * Sets the data of the Grid. If an array is provided, the Grid automatically gets the total count
         * ([more information and example]({% slug databinding_grid %})).
         */
        this.data = [];
        /**
         * Defines the scroll mode used by the Grid.
         *
         * The available options are:
         *  - `none`&mdash;Renders no scrollbar.
         *  - `scrollable`&mdash;The default scroll mode. It requires the setting of the `height` option.
         *  - `virtual`&mdash;Displays no pager and renders a portion of the data (optimized rendering) while the user is scrolling the content.
         */
        this.scrollable = 'scrollable';
        /**
         * Enables the single-row [selection]({% slug selection_grid %}) of the Grid.
         */
        this.selectable = false;
        /**
         * A function that defines how to track changes for the data rows.
         *
         * By default, the Grid tracks changes by the index of the data item.
         * Edited rows are tracked by reference.
         * In some cases, you might need to override the default behavior,
         * for example, when you implement editing with immutable data items.
         *
         * The following example demonstrates how to track items only by index.
         *
         * @example
         * ```ts
         * import { Component } from '@angular/core';
         * import { GridItem } from '@progress/kendo-angular-grid';
         *
         * _@Component({
         *    selector: 'my-app',
         *    template: `
         *        <kendo-grid [data]="gridData" [trackBy]="trackBy">
         *        </kendo-grid>
         *    `
         * })
         * class AppComponent {
         *    public gridData: any[] = products;
         *
         *    public trackBy(index: number, item: GridItem): any {
         *        console.log(item);
         *        return index;
         *    }
         * }
         *
         * const products = [{
         *    "ProductID": 1,
         *    "ProductName": "Chai",
         *    "UnitPrice": 18.0000,
         *    "Discontinued": true
         *  }, {
         *    "ProductID": 2,
         *    "ProductName": "Chang",
         *    "UnitPrice": 19.0000,
         *    "Discontinued": false
         *  }
         * ];
         * ```
         */
        this.trackBy = defaultTrackBy;
        /**
         * If set to `true`, the grid will render only the columns in the current viewport.
         */
        this.virtualColumns = false;
        /**
         * Enables the [filtering]({% slug filtering_grid %}) of the Grid columns that have their `field` option set.
         */
        this.filterable = false;
        /**
         * Enables the [sorting]({% slug sorting_grid %}) of the Grid columns that have their `field` option set.
         */
        this.sortable = false;
        /**
         * Configures the pager of the Grid ([see example]({% slug paging_grid %})).
         *
         * The available options are:
         * - `buttonCount: Number`&mdash;Sets the maximum numeric buttons count before the buttons are collapsed. Defaults to `10`.
         * - `info: Boolean`&mdash;Toggles the information about the current page and the total number of records. Defaults to `true`.
         * - `type: PagerType`&mdash;Accepts the `numeric` (buttons with numbers) and `input` (input for typing the page number) values. Defaults to `'numeric'`.
         * - `pageSizes: Boolean` or `Array<number>`&mdash;Shows a menu for selecting the page size. Defaults to `false`.
         * - `previousNext: Boolean`&mdash;Toggles the **Previous** and **Next** buttons. Defaults to `true`.
         * - `responsive: Boolean`&mdash;Toggles the built-in responsive behavior of the Pager. Defaults to `true`.
         */
        this.pageable = false;
        /**
         * If set to `true`, the user can group the Grid by dragging the column header cells.
         * By default, grouping is disabled ([see example]({% slug groupingbasics_grid %})).
         */
        this.groupable = false;
        /**
         * If set to `true`, the user can use dedicated shortcuts to interact with the Grid.
         * By default, navigation is disabled and the Grid content is accessible in the normal tab sequence.
         */
        this.navigable = false;
        /**
         * Indicates whether the Grid columns will be resized during initialization so that
         * they fit their headers and row content. Defaults to `false`.
         * Columns with `autoSize` set to `false` are excluded.
         * To dynamically update the column width to match the new content,
         * refer to [this example]({% slug resizing_columns_grid %}).
         */
        this.autoSize = false;
        /**
         * If set to `true`, the user can resize columns by dragging the edges (resize handles) of their header cells
         * ([see example]({% slug resizing_columns_grid %})).
         *
         * @default false
         */
        this.resizable = false;
        /**
         * If set to `true`, the user can reorder columns by dragging their header cells
         * ([see example]({% slug reordering_columns_grid %})).
         *
         * @default false
         */
        this.reorderable = false;
        /**
         * Specifies if the loading indicator of the Grid will be displayed ([see example]({% slug databinding_grid %})).
         *
         * @default false
         */
        this.loading = false;
        /**
         * Specifies if the column menu of the columns will be displayed ([see example]({% slug columnmenu_grid %})).
         *
         * @default false
         */
        this.columnMenu = false;
        /**
         * Specifies if the header of the grid will be hidden. The header is visible by default.
         *
         * > The header includes column headers and the [filter row]({% slug filtering_grid %}#toc-filter-row).
         */
        this.hideHeader = false;
        /**
         * Fires when the Grid filter is modified through the UI.
         * You have to handle the event yourself and filter the data.
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires when the page of the Grid is changed ([see example]({% slug paging_grid %})).
         * You have to handle the event yourself and page the data.
         */
        this.pageChange = new EventEmitter();
        /**
         * Fires when the grouping of the Grid is changed.
         * You have to handle the event yourself and group the data ([see example]({% slug groupingbasics_grid %})).
         */
        this.groupChange = new ZoneAwareEventEmitter(this.ngZone);
        /**
         * Fires when the sorting of the Grid is changed ([see example]({% slug sorting_grid %})).
         * You have to handle the event yourself and sort the data.
         */
        this.sortChange = new EventEmitter();
        /**
         * Fires when the user selects a Grid row.
         * Emits the [SelectionEvent]({% slug api_grid_selectionevent %}#toc-selectionchange).
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires when the data state of the Grid is changed.
         */
        this.dataStateChange = new EventEmitter();
        /**
         * Fires when the user expands a group header.
         */
        this.groupExpand = new EventEmitter();
        /**
         * Fires when the user collapses a group header.
         */
        this.groupCollapse = new EventEmitter();
        /**
         * Fires when the user expands a master row.
         */
        this.detailExpand = new EventEmitter();
        /**
         * Fires when the user collapses a master row.
         */
        this.detailCollapse = new EventEmitter();
        /**
         * Fires when the user clicks the **Edit** command button to edit a row
         * ([see example]({% slug editing_template_forms_grid %}#toc-editing-records)).
         */
        this.edit = new EventEmitter();
        /**
         * Fires when the user clicks the **Cancel** command button to close a row
         * ([see example]({% slug editing_template_forms_grid %}#toc-cancelling-editing)).
         */
        this.cancel = new EventEmitter();
        /**
         * Fires when the user clicks the **Save** command button to save changes in a row
         * ([see example]({% slug editing_template_forms_grid %}#toc-saving-records)).
         */
        this.save = new EventEmitter();
        /**
         * Fires when the user clicks the **Remove** command button to remove a row
         * ([see example]({% slug editing_template_forms_grid %}#toc-removing-records)).
         */
        this.remove = new EventEmitter();
        /**
         * Fires when the user clicks the **Add** command button to add a new row
         * ([see example]({% slug editing_template_forms_grid %}#toc-adding-records)).
         */
        this.add = new EventEmitter();
        /**
         * Fires when the user leaves an edited cell ([see example]({% slug editing_incell_grid %}#toc-basic-concepts)).
         */
        this.cellClose = new EventEmitter();
        /**
         * Fires when the user clicks a cell ([see example]({% slug editing_incell_grid %}#toc-basic-concepts)).
         */
        this.cellClick = new ZoneAwareEventEmitter(this.ngZone);
        /**
         * Fires when the user clicks the **Export to PDF** command button.
         */
        this.pdfExport = new EventEmitter();
        /**
         * Fires when the user clicks the **Export to Excel** command button.
         */
        this.excelExport = new EventEmitter();
        /**
         * Fires when the user completes the resizing of the column.
         */
        this.columnResize = new ZoneAwareEventEmitter(this.ngZone);
        /**
         * Fires when the user completes the reordering of the column.
         */
        this.columnReorder = new EventEmitter();
        /**
         * Fires when the user changes the visibility of the columns from the column menu or column chooser.
         */
        this.columnVisibilityChange = new EventEmitter();
        /**
         * Fires when the user changes the locked state of the columns from the column menu or by reordering the columns.
         */
        this.columnLockedChange = new EventEmitter();
        /**
         * Fires when the user changes the sticky state of the columns from the column menu.
         */
        this.columnStickyChange = new EventEmitter();
        /**
         * Fires when the user scrolls to the last record on the page and enables endless scrolling
         * ([see example]({% slug scrollmmodes_grid %}#toc-endless-scrolling)).
         * You have to handle the event yourself and page the data.
         */
        this.scrollBottom = new EventEmitter();
        /**
         * Fires when the grid content is scrolled.
         * For performance reasons, the event is triggered outside the Angular zone. Enter the Angular zone if you make any changes that require change detection.
         */
        this.contentScroll = new EventEmitter();
        /**
         * A query list of all declared columns.
         */
        this.columns = new QueryList();
        this.footer = new QueryList();
        this.selectionDirective = false;
        this.columnsContainer = new ColumnsContainer(() => this.columnList.filterHierarchy(column => {
            column.matchesMedia = this.matchesMedia(column);
            return column.isVisible;
        }));
        this.view = new DataCollection(() => new DataResultIterator(this.data, this.skip, this.hasGroupFooters));
        this.shouldGenerateColumns = true;
        this._sort = new Array();
        this._group = new Array();
        this._skip = 0;
        this.cachedWindowWidth = 0;
        this._rowSelected = null;
        this._cellSelected = null;
        this.rtl = false;
        this._rowClass = () => null;
        validatePackage(packageMetadata);
        this.localizationSubscription = this.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
        this.groupInfoService.registerColumnsContainer(() => this.columnList);
        this.columnInfoService.init(this.columnsContainer, () => this.columnList);
        this.columnVisibilityChangeSubscription = this.columnInfoService.visibilityChange.subscribe((changed) => {
            this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));
        });
        this.columnLockedChangeSubscription = this.columnInfoService.lockedChange.subscribe((changed) => {
            this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));
        });
        this.columnStickyChangeSubscription = this.columnInfoService.stickyChange.subscribe((changed) => {
            this.columnStickyChange.emit(new ColumnStickyChangeEvent(changed));
        });
        this.groupExpandCollapseSubscription = handleExpandCollapseGroupsService(groupsService, this.groupExpand, this.groupCollapse, ({ group, groupIndex, parentGroup }) => ({ group, groupIndex, parentGroup }));
        this.detailsServiceSubscription = handleExpandCollapseDetailsService(detailsService, this.detailExpand, this.detailCollapse, args => args);
        this.filterSubscription = this.filterService.changes.subscribe(x => {
            this.filterChange.emit(x);
        });
        this.sortSubscription = this.sortService.changes.subscribe(x => {
            this.sortChange.emit(x);
        });
        this.attachStateChangesEmitter();
        this.attachEditHandlers();
        this.attachDomEventHandlers();
        this.pdfSubscription = this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this));
        this.excelSubscription = this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this));
        this.columnsContainerChange();
        this.handleColumnResize();
        this.columnList = new ColumnList(this.columns);
        this.columnReorderSubscription = this.columnReorderService
            .changes.subscribe(this.reorder.bind(this));
        this.columnRangeChangeSubscription = this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this));
    }
    /**
     * Defines the number of records to be skipped by the pager.
     * Required by the [paging]({% slug paging_grid %}) functionality.
     */
    get skip() {
        return this._skip;
    }
    set skip(value) {
        if (value >= 0) {
            this._skip = value;
        }
    }
    /**
     * The descriptors by which the data will be sorted ([see example]({% slug sorting_grid %})).
     */
    set sort(value) {
        if (isArray(value)) {
            this._sort = value;
        }
    }
    get sort() {
        return this._sort;
    }
    /**
     * The descriptors by which the data will be grouped ([see example]({% slug groupingbasics_grid %})).
     */
    set group(value) {
        if (isArray(value)) {
            this._group = value;
        }
    }
    /**
     */
    get group() {
        return this._group;
    }
    /**
     * @hidden
     */
    get showTopToolbar() {
        return this.toolbarTemplate && ['top', 'both'].indexOf(this.toolbarTemplate.position) > -1;
    }
    /**
     * @hidden
     */
    get showBottomToolbar() {
        return this.toolbarTemplate && ['bottom', 'both'].indexOf(this.toolbarTemplate.position) > -1;
    }
    /**
     * @hidden
     */
    get isLocked() {
        return this.lockedLeafColumns.length > 0;
    }
    /**
     * @hidden
     */
    get showTopPager() {
        const position = this.pageable.position;
        return !this.isVirtual && this.pageable !== false && ['top', 'both'].indexOf(position) > -1;
    }
    /**
     * @hidden
     */
    get showBottomPager() {
        const position = this.pageable.position;
        return !this.isVirtual && this.pageable !== false && position !== 'top';
    }
    /**
     * @hidden
     */
    get hasPager() {
        return this.showTopPager || this.showBottomPager;
    }
    /**
     * @hidden
     */
    get showGroupPanel() {
        return this.groupable && this.groupable.enabled !== false;
    }
    /**
     * @hidden
     */
    get groupableEmptyText() {
        return this.groupable.emptyText;
    }
    /**
     * @hidden
     */
    get marqueeSelection() {
        return this.selectionService.enableMarquee || this.cellSelectionService.enableMarquee;
    }
    /**
     * @hidden
     *
     * An alias for `navigable` for users who migrate from Kendo UI for jQuery.
     */
    set navigatable(value) {
        this.navigable = value;
    }
    /**
     * @hidden
     */
    get navigatable() {
        return this.navigable;
    }
    /**
     * Defines a function that is executed for every data row in the component.
     *
     * @example
     * ```ts
     * import { Component, ViewEncapsulation } from '@angular/core';
     * import { RowClassArgs } from '@progress/kendo-angular-grid';
     *
     * _@Component({
     *    selector: 'my-app',
     *    encapsulation: ViewEncapsulation.None,
     *    styles: [`
     *        .k-grid tr.even { background-color: #f45c42; }
     *        .k-grid tr.odd { background-color: #41f4df; }
     *    `],
     *    template: `
     *        <kendo-grid [data]="gridData" [rowClass]="rowCallback">
     *        </kendo-grid>
     *    `
     * })
     * class AppComponent {
     *    public gridData: any[] = products;
     *
     *    public rowCallback(context: RowClassArgs) {
     *        const isEven = context.index % 2 == 0;
     *        return {
     *            even: isEven,
     *            odd: !isEven
     *        };
     *    }
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    set rowClass(fn) {
        if (isDevMode && typeof fn !== 'function') {
            throw new Error(`rowClass must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this._rowClass = fn;
    }
    get rowClass() {
        return this._rowClass;
    }
    /**
     * Defines a function that is executed for every data row in the component,
     * and determines whether the row will be sticky, i.e. always visible after scrolling.
     */
    set rowSticky(fn) {
        if (isDevMode && isPresent(fn) && typeof fn !== 'function') {
            throw new Error(`rowSticky must be a function, but received ${JSON.stringify(fn)}.`);
        }
        if (isPresent(fn)) {
            this._rowSticky = fn;
        }
    }
    get rowSticky() {
        return this._rowSticky;
    }
    /**
     * Defines a Boolean function that is executed for each data row in the component
     * ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-rows)).
     * Determines whether the row will be selected.
     */
    set rowSelected(fn) {
        if (isDevMode && typeof fn !== 'function') {
            throw new Error(`rowSelected must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this._rowSelected = fn;
    }
    get rowSelected() {
        return this._rowSelected;
    }
    /**
     * Defines a function that determines the selected state of a data cell.
     * Returns an object with `selected` and `item` properties.
     * The cell is marked as selected only if the `selected` property equals `true`.
     *
     * The function is executed for each data cell and may be called more than once
     * as part of a change detection cycle. ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-cells))
     */
    set cellSelected(fn) {
        if (isDevMode && typeof fn !== 'function') {
            throw new Error(`cellSelected must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this._cellSelected = fn;
    }
    get cellSelected() {
        return this._cellSelected;
    }
    /**
     * Returns the currently focused cell (if any).
     */
    get activeCell() {
        return this.navigationService.activeCell;
    }
    /**
     * Returns the currently focused row (if any).
     */
    get activeRow() {
        return this.navigationService.activeRow;
    }
    get dir() {
        return this.direction;
    }
    get hostClasses() {
        return true;
    }
    get lockedClasses() {
        return this.lockedLeafColumns.length > 0;
    }
    get virtualClasses() {
        return this.isVirtual;
    }
    get noScrollbarClass() {
        return this.scrollbarWidth === 0;
    }
    get detailTemplate() {
        if (this._customDetailTemplate) {
            return this._customDetailTemplate;
        }
        return this.detailTemplateChildren ? this.detailTemplateChildren.first : undefined;
    }
    set detailTemplate(detailTemplate) {
        this._customDetailTemplate = detailTemplate;
    }
    get cellLoadingTemplate() {
        if (this._cellLoadingTemplate) {
            return this._customDetailTemplate;
        }
        return this.cellLoadingTemplateChildren ? this.cellLoadingTemplateChildren.first : undefined;
    }
    set cellLoadingTemplate(cellLoadingTemplate) {
        this._cellLoadingTemplate = cellLoadingTemplate;
    }
    get loadingTemplate() {
        if (this._loadingTemplate) {
            return this._loadingTemplate;
        }
        return this.loadingTemplateChildren ? this.loadingTemplateChildren.first : undefined;
    }
    set loadingTemplate(loadingTemplate) {
        this._loadingTemplate = loadingTemplate;
    }
    get noRecordsTemplate() {
        if (this._customNoRecordsTemplate) {
            return this._customNoRecordsTemplate;
        }
        return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : undefined;
    }
    set noRecordsTemplate(customNoRecordsTemplate) {
        this._customNoRecordsTemplate = customNoRecordsTemplate;
    }
    get pagerTemplate() {
        if (this._customPagerTemplate) {
            return this._customPagerTemplate;
        }
        return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : undefined;
    }
    set pagerTemplate(customPagerTemplate) {
        this._customPagerTemplate = customPagerTemplate;
    }
    get toolbarTemplate() {
        if (this._customToolbarTemplate) {
            return this._customToolbarTemplate;
        }
        return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : undefined;
    }
    set toolbarTemplate(customToolbarTemplate) {
        this._customToolbarTemplate = customToolbarTemplate;
    }
    get scrollbarWidth() {
        return this.supportService.scrollbarWidth;
    }
    get headerPadding() {
        if (isUniversal()) {
            return "";
        }
        const padding = Math.max(0, this.scrollbarWidth) + 'px';
        const right = this.rtl ? 0 : padding;
        const left = this.rtl ? padding : 0;
        return `0 ${right} 0 ${left}`;
    }
    get hasGroupFooters() {
        return this.columnsContainer.hasGroupFooter;
    }
    get showFooter() {
        return this.columnsContainer.hasFooter;
    }
    get showGroupFooters() {
        return this.groupable && this.groupable.showFooter;
    }
    get ariaRowCount() {
        return this.totalColumnLevels + 1 + this.view.total;
    }
    get ariaColCount() {
        return this.columnsContainer.leafColumnsToRender.length;
    }
    get isVirtual() {
        return this.scrollable === 'virtual';
    }
    get isScrollable() {
        return this.scrollable !== 'none';
    }
    get visibleColumns() {
        return this.columnsContainer.allColumns;
    }
    get lockedColumns() {
        return this.columnsContainer.lockedColumns;
    }
    get nonLockedColumns() {
        return this.columnsContainer.nonLockedColumns;
    }
    get lockedLeafColumns() {
        return this.columnsContainer.lockedLeafColumns;
    }
    get stickyColumns() {
        return this.columns.filter(column => column.sticky);
    }
    get nonLockedLeafColumns() {
        return this.columnsContainer.nonLockedLeafColumns;
    }
    get leafColumns() {
        return this.columnsContainer.leafColumns;
    }
    get totalColumnLevels() {
        return this.columnsContainer.totalLevels;
    }
    get headerColumns() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.viewportColumns;
        }
        return this.nonLockedColumns;
    }
    get headerLeafColumns() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.leafViewportColumns;
        }
        return this.nonLockedLeafColumns;
    }
    get lockedWidth() {
        const groupCellsWidth = this.group.length * GROUP_CELL_WIDTH;
        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
    }
    get nonLockedWidth() {
        if ((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) {
            return !this.virtualColumns ? this.columnsContainer.unlockedWidth :
                this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);
        }
        return undefined;
    }
    get selectableSettings() {
        if (this.selectionService) {
            return this.selectionService.options;
        }
        return undefined;
    }
    get columnMenuTemplate() {
        const template = this.columnMenuTemplates.first;
        return template ? template.templateRef : null;
    }
    get totalCount() {
        if (this.isVirtual || !isPresent(this.pageSize)) {
            return this.view.total;
        }
        return this.pageSize;
    }
    /**
     * Expands the specified master row ([see example]({% slug hierarchy_grid %})).
     *
     * This method is provided only for backwards-compatibility with legacy versions.
     * These versions tracked the expanded state internally using the data row index.
     *
     * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})
     * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})
     * for examples on how to control the expanded state.
     *
     * @param index - The data row index of the master row.
     */
    expandRow(index) {
        this.toggleDetailRowLegacy(index, true);
    }
    /**
     * Collapses the specified master row ([see example]({% slug hierarchy_grid %})).
     *
     * This method is provided only for backwards-compatibility with legacy versions.
     * These versions tracked the expanded state internally using the data row index.
     *
     * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})
     * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})
     * for examples on how to control the expanded state.
     *
     * @param index - The data row index of the master row.
     */
    collapseRow(index) {
        this.toggleDetailRowLegacy(index, false);
    }
    /**
     * Expands a group header item for the given index. For example,
     * `0_1` expands the second inner group of the first master group.
     *
     * This method is provided only for backwards-compatibility with legacy versions.
     * These versions tracked the expanded group state internally using the hierarchical group index.
     *
     * > * When you use the [kendoGridGroupBinding]({% slug api_grid_groupbindingdirective %}) directive,
     * > the `expandGroup` method is not supported.
     * > * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
     *
     * @param {string} index - The underscore separated hierarchical index of the group.
     */
    expandGroup(index) {
        this.toggleGroupRowLegacy(index, true);
    }
    /**
     * Collapses a group header item for the given index. For example,
     * `0_1` collapses the second inner group of the first master group.
     *
     * This method is provided only for backwards-compatibility with legacy versions.
     * These versions tracked the expanded group state internally using the hierarchical group index.
     *
     * > * When you use the [kendoGridGroupBinding]({% slug api_grid_groupbindingdirective %}) directive,
     * > the `collapseGroup` method is not supported.
     * > * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
     *
     * @param {string} index - The underscore separated hierarchical index of the group.
     */
    collapseGroup(index) {
        this.toggleGroupRowLegacy(index, false);
    }
    /**
     * @hidden
     */
    resetGroupsState() {
        this.groupsService.reset();
    }
    /**
     * @hidden
     */
    expandGroupChildren(groupIndex) {
        this.groupsService.expandChildren(groupIndex);
    }
    /**
     * @hidden
     */
    onDataChange() {
        this.autoGenerateColumns();
        this.changeNotification.notify();
        this.pdfService.dataChanged.emit();
        if (isPresent(this.defaultSelection)) {
            this.defaultSelection.reset();
        }
        this.initSelectionService();
        this.updateNavigationMetadata();
    }
    ngOnChanges(changes) {
        if (isChanged("data", changes)) {
            this.onDataChange();
        }
        if (this.lockedLeafColumns.length && anyChanged(["pageSize", "skip", "sort", "group"], changes)) {
            this.changeNotification.notify();
        }
        if (anyChanged(["pageSize", "scrollable", 'virtualColumns'], changes)) {
            this.updateNavigationMetadata();
        }
        if (isChanged("virtualColumns", changes)) {
            this.viewportColumns = this.leafViewportColumns = null;
        }
        if (isChanged("height", changes, false)) {
            this.renderer.setStyle(this.wrapper.nativeElement, 'height', `${this.height}px`);
        }
        if (isChanged("filterable", changes) && this.lockedColumns.length) {
            this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));
        }
        if (anyChanged(["columnMenu", "sortable", "filterable"], changes, false)) {
            this.columnMenuOptions = this.columnMenu && Object.assign({
                filter: Boolean(this.filterable),
                sort: Boolean(this.sortable)
            }, this.columnMenu); // tslint:disable-line:align
        }
        if (isChanged("scrollable", changes) && this.isScrollable) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());
        }
        if (isChanged("selectable", changes) && this.shouldResetSelection(changes.selectable)) {
            if (this.defaultSelection) {
                this.defaultSelection.reset();
            }
            else if (this.selectionDirective) {
                this.selectionDirective.reset();
            }
        }
        if (isChanged('groupable', changes, true)) {
            this.groupable = changes.groupable.currentValue;
        }
    }
    ngAfterViewInit() {
        this.attachScrollSync();
        this.attachElementEventHandlers();
        this.updateNavigationMetadata();
        this.applyAutoSize();
    }
    ngAfterContentChecked() {
        this.columnsContainer.refresh();
        this.verifySettings();
        this.initSelectionService();
    }
    ngAfterContentInit() {
        this.shouldGenerateColumns = !this.columns.length;
        this.autoGenerateColumns();
        this.columnList = new ColumnList(this.columns);
        this.columnsChangeSubscription = this.columns.changes.subscribe(() => this.verifySettings());
    }
    ngOnInit() {
        if (this.navigable) {
            this.navigationService.init(this.navigationMetadata());
        }
    }
    ngOnDestroy() {
        if (this.selectionSubscription) {
            this.selectionSubscription.unsubscribe();
        }
        if (this.stateChangeSubscription) {
            this.stateChangeSubscription.unsubscribe();
        }
        if (this.groupExpandCollapseSubscription) {
            this.groupExpandCollapseSubscription.unsubscribe();
        }
        if (this.detailsServiceSubscription) {
            this.detailsServiceSubscription.unsubscribe();
        }
        if (this.editServiceSubscription) {
            this.editServiceSubscription.unsubscribe();
        }
        if (this.pdfSubscription) {
            this.pdfSubscription.unsubscribe();
        }
        if (this.filterSubscription) {
            this.filterSubscription.unsubscribe();
        }
        if (this.sortSubscription) {
            this.sortSubscription.unsubscribe();
        }
        if (this.columnsChangeSubscription) {
            this.columnsChangeSubscription.unsubscribe();
        }
        if (this.excelSubscription) {
            this.excelSubscription.unsubscribe();
        }
        if (this.columnsContainerChangeSubscription) {
            this.columnsContainerChangeSubscription.unsubscribe();
        }
        if (this.scrollSyncService) {
            this.scrollSyncService.destroy();
        }
        if (this.detachElementEventHandlers) {
            this.detachElementEventHandlers();
        }
        if (this.defaultSelection) {
            this.defaultSelection.destroy();
        }
        if (this.cellClickSubscription) {
            this.cellClickSubscription.unsubscribe();
        }
        if (this.footerChangeSubscription) {
            this.footerChangeSubscription.unsubscribe();
        }
        this.ngZone = null;
        if (this.columnResizingSubscription) {
            this.columnResizingSubscription.unsubscribe();
        }
        if (this.columnReorderSubscription) {
            this.columnReorderSubscription.unsubscribe();
        }
        if (this.localizationSubscription) {
            this.localizationSubscription.unsubscribe();
        }
        if (this.columnVisibilityChangeSubscription) {
            this.columnVisibilityChangeSubscription.unsubscribe();
        }
        if (this.columnLockedChangeSubscription) {
            this.columnLockedChangeSubscription.unsubscribe();
        }
        if (this.columnStickyChangeSubscription) {
            this.columnStickyChangeSubscription.unsubscribe();
        }
        if (this.focusElementSubscription) {
            this.focusElementSubscription.unsubscribe();
        }
        this.columnRangeChangeSubscription.unsubscribe();
    }
    /**
     * @hidden
     */
    attachScrollSync() {
        if (isUniversal()) {
            return;
        }
        if (this.header) {
            this.scrollSyncService.registerEmitter(this.header.nativeElement, "header");
        }
        if (this.footer) {
            this.footerChangeSubscription = observe(this.footer)
                .subscribe(footers => footers
                .map(footer => footer.nativeElement)
                .filter(isPresent)
                .forEach(element => this.scrollSyncService.registerEmitter(element, "footer")));
        }
    }
    /**
     * @hidden
     */
    get ariaLabel() {
        return this.localization.get('gridLabel');
    }
    /**
     * Switches the specified table row in the edit mode ([see example]({% slug editing_template_forms_grid %}#toc-editing-records)).
     *
     * @param rowIndex - The data row index that will be switched in the edit mode.
     * @param group - The [FormGroup]({{ site.data.urls.angular['formgroupapi'] }})
     * that describes the edit form.
     * @param options - Additional options configuring the focus target once the editor opens.
     */
    editRow(rowIndex, group, options) {
        this.editService.editRow(rowIndex, group);
        if (isPresent(options) && options.skipFocus) {
            return;
        }
        const row = `tr[data-kendo-grid-item-index="${rowIndex}"]`;
        const columnIndex = options && options.columnIndex;
        const target = isNaN(columnIndex) ? row : `${row} td[data-kendo-grid-column-index="${columnIndex}"]`;
        this.focusEditElement(target);
    }
    /**
     * Closes the editor for a given row ([see example]({% slug editing_template_forms_grid %}#toc-cancelling-editing)).
     *
     * @param {number} index - The row index that will be switched out of the edit mode. If no index is provided, it is assumed
     * that the new item editor will be closed.
     */
    closeRow(index) {
        this.editService.close(index);
    }
    /**
     * Creates a new row editor ([see example]({% slug editing_template_forms_grid %}#toc-adding-records)).
     *
     * @param {FormGroup} group - The [FormGroup]({{ site.data.urls.angular['formgroupapi'] }}) that describes
     * the edit form. If called with a data item, it will build the `FormGroup` from the data item fields.
     */
    addRow(group) {
        const isFormGroup = group instanceof FormGroup;
        if (!isFormGroup) {
            const fields = Object.keys(group).reduce(createControl(group), {}); // FormBuilder?
            group = new FormGroup(fields);
        }
        this.editService.addRow(group);
        this.focusEditElement('.k-grid-add-row');
    }
    /**
     * Puts the cell that is specified by the table row and column in edit mode.
     *
     * @param {number} rowIndex - The data row index that will be switched in the edit mode.
     * @param {number|string|any} column - The leaf column index, or the field name or the column instance that should be edited.
     * @param {FormGroup} group - The [FormGroup]({{ site.data.urls.angular['formgroupapi'] }})
     * that describes the edit form.
     */
    editCell(rowIndex, column, group) {
        const instance = this.columnInstance(column);
        this.editService.editCell(rowIndex, instance, group);
        this.focusEditElement('.k-grid-edit-cell');
    }
    /**
     * Closes the current cell in edit mode and fires
     * the [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event.
     *
     * @return {boolean} Indicates whether the edited cell was closed.
     * A `false` value indicates that the
     * [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event was prevented.
     */
    closeCell() {
        return !this.editService.closeCell();
    }
    /**
     * Closes the current cell in edit mode.
     */
    cancelCell() {
        this.editService.cancelCell();
    }
    /**
     * Returns a flag which indicates if a row or a cell is currently edited.
     *
     * @return {boolean} A flag which indicates if a row or a cell is currently edited.
     */
    isEditing() {
        return this.editService.isEditing();
    }
    /**
     * Returns a flag which indicates if a cell is currently edited.
     *
     * @return {boolean} A flag which indicates if a cell is currently being edited.
     */
    isEditingCell() {
        return this.editService.isEditingCell();
    }
    /**
     * Initiates the PDF export ([see example]({% slug pdfexport_grid %})).
     */
    saveAsPDF() {
        this.pdfService.save(this);
    }
    /**
     * Exports the Grid element to a Drawing [Group]({% slug api_kendo-drawing_group %}) by using the `kendo-grid-pdf` component options.
     * ([see example]({% slug pdfexport_grid %}#toc-exporting-multiple-grids-to-the-same-pdf)).
     *
     * @return {Promise} - A promise that will be resolved with the Drawing `Group`.
     */
    drawPDF() {
        const promise = createPromise();
        this.pdfService.draw(this, promise);
        return promise;
    }
    /**
     * Initiates the Excel export ([see example]({% slug excelexport_grid %})).
     */
    saveAsExcel() {
        this.excelService.save(this);
    }
    /**
     * Applies the minimum possible width for the specified column,
     * so that the whole text fits without wrapping. This method expects the Grid
     * to be resizable (set `resizable` to `true`).
     * Makes sense to execute this method only
     * after the Grid is already populated with data.
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-grid
     *            #grid
     *            [data]="gridData"
     *            [resizable]="true"
     *            style="height: 300px">
     *            <ng-template kendoGridToolbarTemplate>
     *                 <button kendoButton (click)="grid.autoFitColumn(groupColumn)">
     *                     Auto-fit the group column
     *                 </button>
     *            </ng-template>
     *            <kendo-grid-column-group #groupColumn title="Product Info">
     *                <kendo-grid-column
     *                    field="ProductID"
     *                    [width]="50"
     *                    [minResizableWidth]="30"
     *                    title="ID">
     *                </kendo-grid-column>
     *
     *                <kendo-grid-column
     *                    field="ProductName"
     *                    title="Product Name">
     *                </kendo-grid-column>
     *            </kendo-grid-column-group>
     *
     *            <kendo-grid-column
     *                field="UnitPrice"
     *                title="Unit Price"
     *                [width]="180"
     *                filter="numeric"
     *                format="{0:c}">
     *            </kendo-grid-column>
     *        </kendo-grid>
     *    `
     * })
     * class AppComponent {
     *    public gridData: any[] = products;
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    autoFitColumn(column) {
        this.columnResizingService.autoFit(column);
    }
    /**
     * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.
     * If no columns are specified, `autoFitColumns` is applied to all columns.
     *
     * This method requires the Grid to be resizable (set `resizable` to `true`).
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *      <kendo-grid
     *          #grid
     *          [data]="gridData"
     *          [resizable]="true"
     *          style="height: 300px">
     *          <ng-template kendoGridToolbarTemplate>
     *              <button kendoButton (click)="grid.autoFitColumns([firstColumn, lastColumn])">
     *                  Auto-fit the first and last column
     *              </button>
     *              <button kendoButton (click)="grid.autoFitColumns()">
     *                  Auto-fit all columns
     *              </button>
     *          </ng-template>
     *          <kendo-grid-column-group title="Product Info">
     *              <kendo-grid-column
     *                  #firstColumn
     *                  field="ProductID"
     *                  [width]="50"
     *                  [minResizableWidth]="30"
     *                  title="ID">
     *              </kendo-grid-column>
     *
     *              <kendo-grid-column
     *                  field="ProductName"
     *                  title="Product Name"
     *                  >
     *              </kendo-grid-column>
     *          </kendo-grid-column-group>
     *
     *          <kendo-grid-column
     *              #lastColumn
     *              field="UnitPrice"
     *              title="Unit Price"
     *              [width]="180"
     *              filter="numeric"
     *              format="{0:c}">
     *          </kendo-grid-column>
     *      </kendo-grid>
     *    `
     * })
     * class AppComponent {
     *    public gridData: any[] = products;
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    autoFitColumns(columns = this.columns) {
        let cols;
        if (columns instanceof QueryList) {
            cols = columns.toArray();
        }
        else {
            cols = columns;
        }
        this.columnResizingService.autoFit(...cols);
    }
    /**
     * @hidden
     */
    notifyPageChange(source, event) {
        if (source === "list" && !this.isVirtual) {
            return;
        }
        this.pageChange.emit(event);
    }
    /**
     * @hidden
     */
    notifyScrollBottom() {
        if (this.scrollable === 'none') {
            return;
        }
        if (hasObservers(this.scrollBottom)) {
            this.ngZone.run(() => this.scrollBottom.emit({ sender: this }));
        }
    }
    /**
     * @hidden
     */
    focusEditElement(containerSelector) {
        if (this.focusElementSubscription) {
            this.focusElementSubscription.unsubscribe();
        }
        this.ngZone.runOutsideAngular(() => {
            this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                const wrapper = this.wrapper.nativeElement;
                if (!this.setEditFocus(wrapper.querySelector(containerSelector)) && this.isLocked) {
                    this.setEditFocus(wrapper.querySelector(`.k-grid-content ${containerSelector}`));
                }
                this.focusElementSubscription = null;
            });
        });
    }
    /**
     * Focuses the last active or the first cell of the Grid.
     *
     * @returns {NavigationCell} The focused cell.
     */
    focus() {
        this.assertNavigable();
        return this.navigationService.focusCell();
    }
    /**
     * Focuses the cell with the specified row and column index.
     *
     * The row index is based on the logical structure of the Grid and does not correspond to the data item index:
     * * Header rows are included, starting at index 0.
     * * Group headers and footers are included.
     * * The row indexing is absolute and does not change with paging.
     *
     * If the Grid is configured for scrolling, including virtual scrolling, the scroll position will be updated.
     * If the row is not present on the current page, the method will have no effect.
     *
     * @param rowIndex - The logical row index to focus. The top header row has an index 0.
     * @param colIndex - The column index to focus.
     * @returns {NavigationCell} The focused cell.
     *
     */
    focusCell(rowIndex, colIndex) {
        this.assertNavigable();
        return this.navigationService.focusCell(rowIndex, colIndex);
    }
    /**
     * Focuses the next cell, optionally wrapping to the next row.
     *
     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.
     */
    focusNextCell(wrap = true) {
        this.assertNavigable();
        return this.navigationService.focusNextCell(wrap);
    }
    /**
     * Focuses the previous cell. Optionally wraps to the previous row.
     *
     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.
     */
    focusPrevCell(wrap = true) {
        this.assertNavigable();
        return this.navigationService.focusPrevCell(wrap);
    }
    /**
     * Scrolls to the specified row and column ([see example]({% slug scrollmmodes_grid %}#toc-scrolling-to-a-specific-row-and-column-index)).
     */
    scrollTo(request) {
        this.scrollRequestService.scrollTo(request);
    }
    /**
     * Changes the position of the specified column.
     * The reordering of columns operates only on the level
     * which is inferred by the source column.
     * For the `reorderColumn` method to work properly,
     * the `source` column has to be visible.
     *
     * @param {ColumnBase} source - The column whose position will be changed.
     * @param {number} destIndex - The new position of the column.
     * @param {ColumnReorderConfig} options - Additional options.
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-grid
     *            #grid
     *            [data]="gridData"
     *            [reorderable]="true"
     *            style="height: 300px">
     *            <ng-template kendoGridToolbarTemplate>
     *                 <button kendoButton
     *                     (click)="grid.reorderColumn(groupColumn, 2, { before: true })">
     *                     Move the group column before the last one.
     *                 </button>
     *            </ng-template>
     *            <kendo-grid-column-group #groupColumn title="Product Info">
     *                <kendo-grid-column
     *                    field="ProductID"
     *                    [width]="50"
     *                    title="ID">
     *                </kendo-grid-column>
     *
     *                <kendo-grid-column
     *                    field="ProductName"
     *                    title="Product Name">
     *                </kendo-grid-column>
     *            </kendo-grid-column-group>
     *
     *            <kendo-grid-column
     *                field="UnitPrice"
     *                title="Unit Price"
     *                [width]="180"
     *                format="{0:c}">
     *            </kendo-grid-column>
     *
     *            <kendo-grid-column
     *                field="Discontinued"
     *                title="Discontinued"
     *                [width]="100">
     *            </kendo-grid-column>
     *        </kendo-grid>
     *    `
     * })
     * class AppComponent {
     *    public gridData: any[] = products;
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    reorderColumn(source, destIndex, options = { before: false }) {
        const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
        let target = columnsForLevel[destIndex];
        if (!target) {
            return;
        }
        const lastNonLocked = target.isLocked &&
            !source.isLocked &&
            this.columnsContainer.nonLockedColumns.length === 1;
        if (lastNonLocked) {
            return;
        }
        if (isSpanColumnComponent(target) && !options.before) {
            target = target.childColumns.last;
        }
        this.reorder({
            before: options.before,
            source: source,
            target: target
        });
    }
    /**
     * A function which determines if a specific row is expanded.
     */
    set isDetailExpanded(callback) {
        this.detailsService.userCallback = callback;
    }
    get isDetailExpanded() {
        return this.detailsService.userCallback;
    }
    /**
     * A function which determines if a specific group row is expanded.
     */
    set isGroupExpanded(callback) {
        this.groupsService.userCallback = callback;
        this.groupable = isPresent(callback);
    }
    get isGroupExpanded() {
        return this.groupsService.userCallback;
    }
    /**
     * @hidden
     */
    reorder({ target, source, before, changeContainer }) {
        this.ngZone.run(() => {
            const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
            let newIndex = columnsForLevel.indexOf(target);
            if (target.parent && target.parent.isSpanColumn) {
                newIndex = columnsForLevel.indexOf(target.parent);
                if (before) {
                    target = target.parent;
                }
            }
            let oldIndex = columnsForLevel.indexOf(source);
            if (changeContainer) {
                if (before && 0 < newIndex && oldIndex < newIndex) { // dropped before the first not locked column
                    newIndex--;
                }
                else if (!before && oldIndex > newIndex) { // dropped after the last locked column
                    newIndex++;
                }
            }
            const args = new ColumnReorderEvent({
                column: source,
                oldIndex: oldIndex,
                newIndex: newIndex
            });
            this.columnReorder.emit(args);
            if (args.isDefaultPrevented()) {
                return;
            }
            if (changeContainer) {
                this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));
            }
            this.updateColumnIndices({ columnsForLevel, source, target, before });
            if (source.locked !== target.locked) {
                source.locked = target.locked;
            }
            this.columnsContainer.refresh();
            this.changeDetectorRef.markForCheck();
        });
    }
    updateColumnIndices({ columnsForLevel, source, target, before }) {
        const expandedColumns = expandColumnsWithSpan(columnsForLevel);
        const sourceColumnIndex = expandedColumns.indexOf(source);
        let nextSourceIndex = 0;
        let nextIndex = 0;
        let toSkip = 1;
        // Possible only when called from the API.
        if (source.isSpanColumn) {
            toSkip += source.childColumns.length;
        }
        let i = 0;
        while (i < expandedColumns.length) {
            let column = expandedColumns[i];
            if (column === target) {
                nextSourceIndex = before ? nextIndex : nextIndex + 1;
                nextIndex = before ? nextIndex + toSkip : nextIndex;
                column.orderIndex = nextIndex;
                if (nextSourceIndex === nextIndex + 1) {
                    nextIndex += toSkip;
                }
            }
            else if (column === source) {
                i += toSkip;
                continue;
            }
            else {
                column.orderIndex = nextIndex;
            }
            nextIndex++;
            i++;
        }
        for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {
            expandedColumns[i].orderIndex = nextSourceIndex++;
        }
        this.updateIndicesForLevel(source.level + 1);
    }
    updateIndicesForLevel(level) {
        const colsForParentLevel = this.allColumnsForLevel(level - 1);
        const colsForLevel = [];
        sortColumns(colsForParentLevel).forEach((c) => {
            if (c.isColumnGroup) {
                colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));
            }
        });
        expandColumnsWithSpan(colsForLevel).map((c, i) => c.orderIndex = i);
        if (level < this.columnList.totalColumnLevels()) {
            this.updateIndicesForLevel(level + 1);
        }
    }
    allColumnsForLevel(level) {
        return this.columnList.toArray().filter(column => column.level === level);
    }
    initSelectionService() {
        if (!this.selectable) {
            this.selectionService.ngOnDestroy();
            this.cellSelectionService.ngOnDestroy();
            return;
        }
        if (!this.selectionDirective && !isPresent(this.defaultSelection)) {
            this.defaultSelection = new Selection(this, this.changeDetectorRef);
        }
        const cellSelectionMode = this.selectable['cell'];
        const activeService = cellSelectionMode ? this.cellSelectionService : this.selectionService;
        const inactiveService = cellSelectionMode ? this.selectionService : this.cellSelectionService;
        if (inactiveService.active) {
            inactiveService.ngOnDestroy();
            activeService.addSubscriptions();
            inactiveService.active = false;
        }
        activeService.active = true;
        activeService.init({
            cellSelected: cellSelectionMode ? this.cellSelected : undefined,
            rowSelected: cellSelectionMode ? undefined : this.rowSelected,
            selectable: this.selectable,
            view: this.view,
            columns: cellSelectionMode ? this.columnList.toArray() : undefined
        });
        if (!this.selectionDirective && !this.selectableSettings.enabled) {
            this.defaultSelection.reset();
        }
        if (this.selectionSubscription) {
            this.selectionSubscription.unsubscribe();
        }
        if (cellSelectionMode) {
            this.selectionSubscription = this.cellSelectionService.changes.subscribe((event) => {
                this.ngZone.run(() => this.selectionChange.emit(event));
            });
        }
        else {
            this.selectionSubscription = this.selectionService.changes.subscribe((event) => {
                this.ngZone.run(() => this.selectionChange.emit(event));
            });
        }
    }
    setEditFocus(element) {
        if (element) {
            return this.navigationService.tryFocus(element);
        }
    }
    columnInstance(column) {
        let instance;
        if (typeof column === 'number') {
            instance = this.columnsContainer.lockedLeafColumns.toArray()
                .concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];
        }
        else if (typeof column === 'string') {
            instance = this.columnList.filter((item) => item.field === column)[0];
        }
        else {
            instance = column;
        }
        if (!instance && isDevMode()) {
            throw new Error(`Invalid column ${column}`);
        }
        return instance;
    }
    verifySettings() {
        if (isDevMode()) {
            const locked = this.lockedLeafColumns.length || (this.columnMenu && this.columnMenu.lock);
            const stickyColumns = this.stickyColumns.length || (this.columnMenu && this.columnMenu.stick);
            if (locked && this.detailTemplate) {
                throw new Error('Having both detail template and locked columns is not supported.');
            }
            if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {
                throw new Error('There should be at least one non-locked column');
            }
            if ((locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {
                throw new Error((locked ? 'Locked' : 'Virtual') + ' columns feature requires all columns to have set width.');
            }
            if (locked && !this.isScrollable) {
                throw new Error('Locked columns are only supported when scrolling is enabled.');
            }
            if (this.columnList.filter(isColumnGroupComponent).filter((x) => !x.hasChildren).length) {
                throw new Error('ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.');
            }
            if (this.columnList.filter(x => x.locked && x.parent && !x.parent.isLocked).length) {
                throw new Error('Locked child columns require their parent columns to be locked.');
            }
            if ((this.rowHeight || this.detailRowHeight) && !this.isVirtual) {
                throw new Error('Row height and detail row height settings require virtual scrolling mode to be enabled.');
            }
            if (stickyColumns && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {
                throw new Error('Sticky columns feature requires all columns to have set width.');
            }
            if (stickyColumns && !this.isScrollable) {
                throw new Error('Sticky columns are only supported when scrolling is enabled.');
            }
            if (stickyColumns && this.virtualColumns) {
                throw new Error('Having both sticky columns and column virtualization is not supported.');
            }
            if (this.rowSticky && this.scrollable === 'virtual') {
                throw new Error('Having both sticky rows and row virtualization (scrollable="virtual") is not supported.');
            }
            if (this.rowSticky && this.groupable) {
                throw new Error('Having both sticky rows and grouping is not supported.');
            }
            validateColumnsField(this.columnList);
        }
    }
    autoGenerateColumns() {
        if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {
            this.columns.reset(Object.keys(this.view.at(0)).map(field => {
                let column = new ColumnComponent();
                column.field = field;
                return column;
            }));
        }
    }
    attachStateChangesEmitter() {
        this.stateChangeSubscription =
            merge(this.pageChange.pipe(map(x => ({
                filter: this.filter, group: this.group, skip: x.skip, sort: this.sort, take: x.take
            }))), this.sortChange.pipe(map(sort => ({ filter: this.filter, group: this.group, skip: this.skip, sort: sort, take: this.pageSize }))), this.groupChange.pipe(map(group => ({
                filter: this.filter, group: group, skip: this.skip, sort: this.sort, take: this.pageSize
            }))), this.filterChange.pipe(map(filter$$1 => ({
                filter: filter$$1, group: this.group, skip: 0, sort: this.sort, take: this.pageSize
            }))))
                .subscribe(x => {
                this.closeCell();
                this.cancelCell();
                this.dataStateChange.emit(x);
            });
    }
    attachEditHandlers() {
        if (!this.editService) {
            return;
        }
        this.editServiceSubscription = this.editService
            .changes.subscribe(this.emitCRUDEvent.bind(this));
    }
    emitCRUDEvent(args) {
        const { action, rowIndex, formGroup } = args;
        let dataItem = this.view.at(rowIndex - this.skip);
        if (action !== 'add' && !dataItem) {
            dataItem = formGroup.value;
        }
        this.closeCell();
        Object.assign(args, {
            dataItem: dataItem,
            sender: this
        });
        switch (action) {
            case 'add':
                this.add.emit(args);
                break;
            case 'cancel':
                this.cancel.emit(args);
                break;
            case 'edit':
                this.edit.emit(args);
                break;
            case 'remove':
                this.remove.emit(args);
                break;
            case 'save':
                this.save.emit(args);
                break;
            case 'cellClose':
                this.cellClose.emit(args);
                break;
            default: break;
        }
    }
    attachDomEventHandlers() {
        this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
            this.cellClick.emit(Object.assign({ sender: this }, args));
        });
    }
    attachElementEventHandlers() {
        if (isUniversal()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const ariaRoot = this.ariaRoot.nativeElement;
        this.ngZone.runOutsideAngular(() => {
            const resizeCheck = this.resizeCheck.bind(this);
            const resizeSubscription = this.renderer.listen('window', 'resize', resizeCheck);
            const orientationSubscription = this.renderer.listen('window', 'orientationchange', resizeCheck);
            const documentClickSubscription = this.renderer.listen('document', 'click', (args) => {
                const activeElement = document.activeElement;
                if (this.editService.shouldCloseCell() &&
                    !closest(args.target, matchesClasses('k-animation-container k-grid-ignore-click')) &&
                    !(activeElement &&
                        (closest(activeElement, matchesClasses('k-animation-container')) ||
                            isInEditedCell(activeElement, this.wrapper.nativeElement)))) {
                    this.editService.closeCell(args);
                }
            });
            const windowBlurSubscription = this.renderer.listen('window', 'blur', (args) => {
                const activeElement = document.activeElement;
                if (activeElement && !(matchesNodeName('input')(activeElement) && activeElement.type === 'file' &&
                    isInEditedCell(activeElement, this.wrapper.nativeElement))) {
                    this.editService.closeCell(args);
                }
                this.domEvents.windowBlur.emit(args);
            });
            const clickSubscription = this.renderer.listen(wrapper, 'click', (args) => {
                this.domEvents.click.emit(args);
            });
            const keydownSubscription = this.renderer.listen(wrapper, 'keydown', (args) => {
                this.domEvents.keydown.emit(args);
            });
            // focusIn and focusOut are relative to the element with ARIA role "grid"
            let focused = false;
            const focusInSubscription = this.renderer.listen(ariaRoot, 'focusin', (args) => {
                this.domEvents.focus.emit(args);
                if (!focused) {
                    this.domEvents.focusIn.emit(args);
                    focused = true;
                }
            });
            const focusOutSubscription = this.renderer.listen(ariaRoot, 'focusout', (args) => {
                const next = args.relatedTarget || document.activeElement;
                const outside = !closest(next, (node) => node === ariaRoot);
                if (outside) {
                    this.domEvents.focusOut.emit(args);
                    focused = false;
                }
            });
            this.detachElementEventHandlers = () => {
                resizeSubscription();
                orientationSubscription();
                documentClickSubscription();
                windowBlurSubscription();
                clickSubscription();
                keydownSubscription();
                focusInSubscription();
                focusOutSubscription();
            };
        });
    }
    matchesMedia(c) {
        return this.responsiveService.matchesMedia(c.media);
    }
    resizeCheck() {
        if (window.innerWidth !== this.cachedWindowWidth) {
            this.cachedWindowWidth = window.innerWidth;
            let hasChanges = false;
            this.columnList.filterHierarchy(column => {
                const matchesMedia = this.matchesMedia(column);
                if (column.matchesMedia !== matchesMedia) {
                    hasChanges = true;
                    column.matchesMedia = matchesMedia;
                }
                return column.isVisible;
            });
            if (hasChanges) {
                this.ngZone.run(() => {
                    this.changeDetectorRef.markForCheck();
                });
            }
        }
    }
    emitPDFExportEvent() {
        const args = new PDFExportEvent();
        this.pdfExport.emit(args);
        if (!args.isDefaultPrevented()) {
            this.saveAsPDF();
        }
    }
    syncHeaderHeight(observable) {
        return observable
            .pipe(filter(() => isPresent(this.lockedHeader)))
            .subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));
    }
    columnsContainerChange() {
        this.columnsContainerChangeSubscription =
            this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))));
    }
    handleColumnResize() {
        const resizes = this.columnResizingService.changes;
        this.columnResizingSubscription = resizes.pipe(tap(e => {
            if (e.type === 'start') {
                this.renderer.addClass(this.wrapper.nativeElement, 'k-grid-column-resizing');
            }
            else if (e.type === 'end') {
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-grid-column-resizing');
            }
        }), filter(e => e.type === 'start'), switchMap(() => resizes.pipe(
        // tslint:disable-next-line: rxjs-no-unsafe-takeuntil
        takeUntil(resizes.pipe(filter(e => e.type === 'triggerAutoFit'))), filter(e => e.type === 'end'))))
            .subscribe(this.notifyResize.bind(this));
    }
    notifyResize(e) {
        const args = e.resizedColumns
            .filter(item => isTruthy(item.column.resizable) && !item.column.isColumnGroup)
            .map(item => ({
            column: item.column,
            newWidth: item.column.width,
            oldWidth: item.oldWidth
        }));
        this.columnResize.emit(args);
    }
    assertNavigable() {
        if (isDevMode() && !this.navigable) {
            throw new Error('The Grid should be configured as [navigable]="true" to control focus');
        }
    }
    navigationMetadata() {
        const isVirtual = this.isVirtual;
        const pageSize = this.pageSize;
        const dataRows = isVirtual ? this.view.total : pageSize;
        const addRowOffset = this.editService.hasNewItem ? 1 : 0;
        const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
        const headerRows = this.totalColumnLevels + 1 + filterRowOffset + addRowOffset;
        return new NavigationMetadata(dataRows, headerRows, isVirtual, this.hasPager, isPresent(this.detailTemplate), this.wrapper, this.virtualColumns, this.columnsContainer);
    }
    updateNavigationMetadata() {
        this.navigationService.metadata = this.navigationMetadata();
    }
    applyAutoSize() {
        const cols = this.columns.filter((c) => this.autoSize ? c.autoSize !== false : c.autoSize);
        if (cols.length > 0) {
            this.ngZone.onStable.pipe(take(1)).subscribe(_ => this.autoFitColumns(cols));
        }
    }
    onColumnRangeChange(range) {
        const viewportColumns = this.viewportColumns = [];
        const leafViewportColumns = this.columnsContainer
            .nonLockedLeafColumns.toArray().slice(range.start, range.end + 1);
        for (let idx = 0; idx < leafViewportColumns.length; idx++) {
            let column = leafViewportColumns[idx];
            while (column.parent) {
                column = column.parent;
            }
            const toAdd = [column];
            while (toAdd.length) {
                column = toAdd.shift();
                viewportColumns.push(column);
                if (column.isColumnGroup) {
                    toAdd.unshift.apply(toAdd, column.childrenArray);
                }
            }
            const lastFromGroup = viewportColumns[viewportColumns.length - 1];
            column = leafViewportColumns[idx];
            while (column !== lastFromGroup && idx < leafViewportColumns.length) {
                idx++;
                column = leafViewportColumns[idx];
            }
        }
        if (range.start > 0) {
            const first = leafViewportColumns[0];
            let offset = range.offset;
            let current = viewportColumns[0];
            let index = 0;
            while (current !== first) {
                offset -= current.isColumnGroup ? 0 : current.width;
                index++;
                current = viewportColumns[index];
            }
            if (offset > 0) {
                const totalLevels = this.columnsContainer.totalLevels;
                let previous;
                for (let idx = 0; idx <= totalLevels; idx++) {
                    const offsetColumn = idx < totalLevels ? new ColumnGroupComponent(previous) : new ColumnBase$1(previous);
                    previous = offsetColumn;
                    offsetColumn.title = "\u00A0";
                    offsetColumn.width = offset;
                    viewportColumns.unshift(offsetColumn);
                }
            }
        }
        this.leafViewportColumns = viewportColumns.filter(c => !c.isColumnGroup);
    }
    toggleDetailRowLegacy(index, expand) {
        const hasCallback = typeof this.isDetailExpanded === 'function';
        if (isDevMode() && hasCallback) {
            throw new Error('The expandRow and collapseRow methods should not be called when using the ' +
                'kendoGridDetailsExpandBy directive or the isDetailExpanded callback. ' +
                'These methods are provided only for backwards compatibility with legacy versions.');
        }
        if (!isDevMode() && hasCallback) {
            return;
        }
        if (this.detailsService.isExpanded(index, null) !== expand) {
            this.detailsService.toggleRow(index, null);
        }
    }
    toggleGroupRowLegacy(index, expand) {
        const hasCallback = typeof this.isGroupExpanded === 'function';
        if (isDevMode() && hasCallback) {
            throw new Error('The expandGroup and collapseGroup methods should not be called when using the ' +
                'kendoGridExpandGroupBy directive or the isGroupExpanded callback. ' +
                'These methods are provided only for backwards compatibility with legacy versions.');
        }
        if (!isDevMode() && hasCallback) {
            return;
        }
        if (this.groupsService.isExpanded({ groupIndex: index }) !== expand) {
            this.groupsService.toggleRow({ index });
        }
    }
    shouldResetSelection(selectableChanges) {
        const previousValue = selectableChanges.previousValue;
        if (!previousValue) {
            // Selection was disabled, no need to reset.
            return false;
        }
        const currentValue = selectableChanges.currentValue;
        if (!currentValue || currentValue.enabled === false) {
            // Selection disabled, reset.
            return true;
        }
        return previousValue.cell !== currentValue.cell;
    }
};
GridComponent.ɵfac = function GridComponent_Factory(t) { return new (t || GridComponent)(ɵngcc0.ɵɵdirectiveInject(BrowserSupportService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(CellSelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(GroupInfoService), ɵngcc0.ɵɵdirectiveInject(GroupsService), ɵngcc0.ɵɵdirectiveInject(ChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(DetailsService), ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(PDFService), ɵngcc0.ɵɵdirectiveInject(ResponsiveService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ExcelService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ScrollSyncService), ɵngcc0.ɵɵdirectiveInject(DomEventsService), ɵngcc0.ɵɵdirectiveInject(ColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ColumnReorderService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(SortService), ɵngcc0.ɵɵdirectiveInject(ScrollRequestService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
GridComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GridComponent, selectors: [["kendo-grid"]], contentQueries: function GridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase$1, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DetailTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellLoadingTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, LoadingTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NoRecordsTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PagerTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ToolbarTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.detailTemplateChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellLoadingTemplateChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingTemplateChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noRecordsTemplateChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pagerTemplateChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toolbarTemplateChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
    } }, viewQuery: function GridComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 5);
        ɵngcc0.ɵɵviewQuery(_c1, 5);
        ɵngcc0.ɵɵviewQuery(_c2, 7);
        ɵngcc0.ɵɵviewQuery(_c3, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lockedHeader = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ariaRoot = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footer = _t);
    } }, hostVars: 9, hostBindings: function GridComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-grid", ctx.hostClasses)("k-grid-lockedcolumns", ctx.lockedClasses)("k-grid-virtual", ctx.virtualClasses)("k-grid-no-scrollbar", ctx.noScrollbarClass);
    } }, inputs: { data: "data", scrollable: "scrollable", selectable: "selectable", trackBy: "trackBy", virtualColumns: "virtualColumns", filterable: "filterable", sortable: "sortable", pageable: "pageable", groupable: "groupable", navigable: "navigable", autoSize: "autoSize", resizable: "resizable", reorderable: "reorderable", loading: "loading", columnMenu: "columnMenu", hideHeader: "hideHeader", skip: "skip", sort: "sort", group: "group", navigatable: "navigatable", rowClass: "rowClass", rowSticky: "rowSticky", rowSelected: "rowSelected", cellSelected: "cellSelected", isDetailExpanded: "isDetailExpanded", isGroupExpanded: "isGroupExpanded", pageSize: "pageSize", height: "height", rowHeight: "rowHeight", detailRowHeight: "detailRowHeight", filter: "filter" }, outputs: { filterChange: "filterChange", pageChange: "pageChange", groupChange: "groupChange", sortChange: "sortChange", selectionChange: "selectionChange", dataStateChange: "dataStateChange", groupExpand: "groupExpand", groupCollapse: "groupCollapse", detailExpand: "detailExpand", detailCollapse: "detailCollapse", edit: "edit", cancel: "cancel", save: "save", remove: "remove", add: "add", cellClose: "cellClose", cellClick: "cellClick", pdfExport: "pdfExport", excelExport: "excelExport", columnResize: "columnResize", columnReorder: "columnReorder", columnVisibilityChange: "columnVisibilityChange", columnLockedChange: "columnLockedChange", columnStickyChange: "columnStickyChange", scrollBottom: "scrollBottom", contentScroll: "contentScroll" }, exportAs: ["kendoGrid"], features: [ɵngcc0.ɵɵProvidersFeature([
            BrowserSupportService,
            LocalizationService,
            ColumnInfoService,
            SelectionService,
            CellSelectionService,
            DetailsService,
            GroupsService,
            GroupInfoService,
            ChangeNotificationService,
            EditService,
            PDFService,
            SuspendService,
            {
                provide: CELL_CONTEXT,
                useValue: ɵ5$1
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.grid'
            },
            FilterService,
            ResponsiveService,
            PagerContextService,
            ExcelService,
            ScrollSyncService,
            ResizeService,
            LocalDataChangesService,
            DomEventsService,
            ColumnResizingService,
            SinglePopupService,
            DragAndDropService,
            DragHintService,
            DropCueService,
            ColumnReorderService,
            NavigationService,
            FocusRoot,
            IdService,
            ScrollRequestService,
            SortService
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 12, vars: 17, consts: function () { let i18n_4; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label visible in the Grid group panel when it is empty
         * @meaning kendo.grid.groupPanelEmpty
         */
        const MSG_EXTERNAL_1430663748859427158$$DIST_FESM2015_INDEX_JS_5 = goog.getMsg("Drag a column header and drop it here to group by that column");
        i18n_4 = MSG_EXTERNAL_1430663748859427158$$DIST_FESM2015_INDEX_JS_5;
    }
    else {
        i18n_4 = $localize `:kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty␟30bcb3a2fbc22fcab6ca805e74b90adb8ba1ae96␟1430663748859427158:Drag a column header and drop it here to group by that column`;
    } let i18n_6; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label visible in the Grid when there are no records
         * @meaning kendo.grid.noRecords
         */
        const MSG_EXTERNAL_1243399825085142134$$DIST_FESM2015_INDEX_JS_7 = goog.getMsg("No records available.");
        i18n_6 = MSG_EXTERNAL_1243399825085142134$$DIST_FESM2015_INDEX_JS_7;
    }
    else {
        i18n_6 = $localize `:kendo.grid.noRecords|The label visible in the Grid when there are no records␟ff9cfd4bf3e40305db251f2b6961796c0550b4b0␟1243399825085142134:No records available.`;
    } let i18n_8; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the first page button in Grid pager
         * @meaning kendo.grid.pagerFirstPage
         */
        const MSG_EXTERNAL_5647145449685906398$$DIST_FESM2015_INDEX_JS_9 = goog.getMsg("Go to the first page");
        i18n_8 = MSG_EXTERNAL_5647145449685906398$$DIST_FESM2015_INDEX_JS_9;
    }
    else {
        i18n_8 = $localize `:kendo.grid.pagerFirstPage|The label for the first page button in Grid pager␟b405dfc5ee42415daa08d54847d3010de1821111␟5647145449685906398:Go to the first page`;
    } let i18n_10; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the previous page button in Grid pager
         * @meaning kendo.grid.pagerPreviousPage
         */
        const MSG_EXTERNAL_6745088753482690847$$DIST_FESM2015_INDEX_JS_11 = goog.getMsg("Go to the previous page");
        i18n_10 = MSG_EXTERNAL_6745088753482690847$$DIST_FESM2015_INDEX_JS_11;
    }
    else {
        i18n_10 = $localize `:kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager␟47aa4fe05f5a2577d3336971d7c44ce48802b860␟6745088753482690847:Go to the previous page`;
    } let i18n_12; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the next page button in Grid pager
         * @meaning kendo.grid.pagerNextPage
         */
        const MSG_EXTERNAL_5510985262435270859$$DIST_FESM2015_INDEX_JS_13 = goog.getMsg("Go to the next page");
        i18n_12 = MSG_EXTERNAL_5510985262435270859$$DIST_FESM2015_INDEX_JS_13;
    }
    else {
        i18n_12 = $localize `:kendo.grid.pagerNextPage|The label for the next page button in Grid pager␟90031133fca899b4e491d9fc51128c1a184afb30␟5510985262435270859:Go to the next page`;
    } let i18n_14; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the last page button in Grid pager
         * @meaning kendo.grid.pagerLastPage
         */
        const MSG_EXTERNAL_4539768510520419313$$DIST_FESM2015_INDEX_JS_15 = goog.getMsg("Go to the last page");
        i18n_14 = MSG_EXTERNAL_4539768510520419313$$DIST_FESM2015_INDEX_JS_15;
    }
    else {
        i18n_14 = $localize `:kendo.grid.pagerLastPage|The label for the last page button in Grid pager␟fe84f2ea868286ce03e50b6e55558c16d675c753␟4539768510520419313:Go to the last page`;
    } let i18n_16; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label before the current page number in the Grid pager
         * @meaning kendo.grid.pagerPage
         */
        const MSG_EXTERNAL_5228228287003939680$$DIST_FESM2015_INDEX_JS_17 = goog.getMsg("Page");
        i18n_16 = MSG_EXTERNAL_5228228287003939680$$DIST_FESM2015_INDEX_JS_17;
    }
    else {
        i18n_16 = $localize `:kendo.grid.pagerPage|The label before the current page number in the Grid pager␟89c1f616c25bb610824cd8a26473a03921df48bd␟5228228287003939680:Page`;
    } let i18n_18; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label before the total pages number in the Grid pager
         * @meaning kendo.grid.pagerOf
         */
        const MSG_EXTERNAL_7004642096327889102$$DIST_FESM2015_INDEX_JS_19 = goog.getMsg("of");
        i18n_18 = MSG_EXTERNAL_7004642096327889102$$DIST_FESM2015_INDEX_JS_19;
    }
    else {
        i18n_18 = $localize `:kendo.grid.pagerOf|The label before the total pages number in the Grid pager␟0c9abe48f5d4bd2cb51846712e41864fc64aad6a␟7004642096327889102:of`;
    } let i18n_20; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label after the total pages number in the Grid pager
         * @meaning kendo.grid.pagerItems
         */
        const MSG_EXTERNAL_700193548223931835$$DIST_FESM2015_INDEX_JS_21 = goog.getMsg("items");
        i18n_20 = MSG_EXTERNAL_700193548223931835$$DIST_FESM2015_INDEX_JS_21;
    }
    else {
        i18n_20 = $localize `:kendo.grid.pagerItems|The label after the total pages number in the Grid pager␟7c1704d11bfb77340485acd891439c2b6c6616ca␟700193548223931835:items`;
    } let i18n_22; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the pager input in the Grid pager
         * @meaning kendo.grid.pagerPageNumberInputTitle
         */
        const MSG_EXTERNAL_2090461908134774363$$DIST_FESM2015_INDEX_JS_23 = goog.getMsg("Page Number");
        i18n_22 = MSG_EXTERNAL_2090461908134774363$$DIST_FESM2015_INDEX_JS_23;
    }
    else {
        i18n_22 = $localize `:kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager␟f8bad8f2c7345e4fe531480e3034f7d3e954d383␟2090461908134774363:Page Number`;
    } let i18n_24; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the page size chooser in the Grid pager
         * @meaning kendo.grid.pagerItemsPerPage
         */
        const MSG_EXTERNAL_8838594644885628398$$DIST_FESM2015_INDEX_JS_25 = goog.getMsg("items per page");
        i18n_24 = MSG_EXTERNAL_8838594644885628398$$DIST_FESM2015_INDEX_JS_25;
    }
    else {
        i18n_24 = $localize `:kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager␟3331fe7ec45f299afaa4c1e08ea25c493eda9144␟8838594644885628398:items per page`;
    } let i18n_26; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label of the filter cell or icon
         * @meaning kendo.grid.filter
         */
        const MSG_EXTERNAL_7977992299945497789$$DIST_FESM2015_INDEX_JS_27 = goog.getMsg("Filter");
        i18n_26 = MSG_EXTERNAL_7977992299945497789$$DIST_FESM2015_INDEX_JS_27;
    }
    else {
        i18n_26 = $localize `:kendo.grid.filter|The label of the filter cell or icon␟21a04b7b090dac60e0449cb6e435b7e879173c75␟7977992299945497789:Filter`;
    } let i18n_28; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the equal filter operator
         * @meaning kendo.grid.filterEqOperator
         */
        const MSG_EXTERNAL_4328959145426393682$$DIST_FESM2015_INDEX_JS_29 = goog.getMsg("Is equal to");
        i18n_28 = MSG_EXTERNAL_4328959145426393682$$DIST_FESM2015_INDEX_JS_29;
    }
    else {
        i18n_28 = $localize `:kendo.grid.filterEqOperator|The text of the equal filter operator␟8b31e1604d10a2f8709dcb1ed5c237e33cffc135␟4328959145426393682:Is equal to`;
    } let i18n_30; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the not equal filter operator
         * @meaning kendo.grid.filterNotEqOperator
         */
        const MSG_EXTERNAL_8497658332767349737$$DIST_FESM2015_INDEX_JS_31 = goog.getMsg("Is not equal to");
        i18n_30 = MSG_EXTERNAL_8497658332767349737$$DIST_FESM2015_INDEX_JS_31;
    }
    else {
        i18n_30 = $localize `:kendo.grid.filterNotEqOperator|The text of the not equal filter operator␟d46e14d35d89d2fadf5c852abf5557643510a013␟8497658332767349737:Is not equal to`;
    } let i18n_32; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the is null filter operator
         * @meaning kendo.grid.filterIsNullOperator
         */
        const MSG_EXTERNAL_1298299704757177797$$DIST_FESM2015_INDEX_JS_33 = goog.getMsg("Is null");
        i18n_32 = MSG_EXTERNAL_1298299704757177797$$DIST_FESM2015_INDEX_JS_33;
    }
    else {
        i18n_32 = $localize `:kendo.grid.filterIsNullOperator|The text of the is null filter operator␟078c50eb1fe8b2b43fcc40c5e7f4493152310c2f␟1298299704757177797:Is null`;
    } let i18n_34; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the is not null filter operator
         * @meaning kendo.grid.filterIsNotNullOperator
         */
        const MSG_EXTERNAL_8362279767336741540$$DIST_FESM2015_INDEX_JS_35 = goog.getMsg("Is not null");
        i18n_34 = MSG_EXTERNAL_8362279767336741540$$DIST_FESM2015_INDEX_JS_35;
    }
    else {
        i18n_34 = $localize `:kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator␟70b39eeaf2674907b2e59b414baf17e032b464dc␟8362279767336741540:Is not null`;
    } let i18n_36; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the is empty filter operator
         * @meaning kendo.grid.filterIsEmptyOperator
         */
        const MSG_EXTERNAL_4762263229995523226$$DIST_FESM2015_INDEX_JS_37 = goog.getMsg("Is empty");
        i18n_36 = MSG_EXTERNAL_4762263229995523226$$DIST_FESM2015_INDEX_JS_37;
    }
    else {
        i18n_36 = $localize `:kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator␟a4e77e444b4e9b63851ac818e20136212b06c750␟4762263229995523226:Is empty`;
    } let i18n_38; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the is not empty filter operator
         * @meaning kendo.grid.filterIsNotEmptyOperator
         */
        const MSG_EXTERNAL_8245213618709258015$$DIST_FESM2015_INDEX_JS_39 = goog.getMsg("Is not empty");
        i18n_38 = MSG_EXTERNAL_8245213618709258015$$DIST_FESM2015_INDEX_JS_39;
    }
    else {
        i18n_38 = $localize `:kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator␟dee7553c341248e90aef4a8e7438c52e667e68be␟8245213618709258015:Is not empty`;
    } let i18n_40; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the starts with filter operator
         * @meaning kendo.grid.filterStartsWithOperator
         */
        const MSG_EXTERNAL_6087783423599420507$$DIST_FESM2015_INDEX_JS_41 = goog.getMsg("Starts with");
        i18n_40 = MSG_EXTERNAL_6087783423599420507$$DIST_FESM2015_INDEX_JS_41;
    }
    else {
        i18n_40 = $localize `:kendo.grid.filterStartsWithOperator|The text of the starts with filter operator␟da43b363b636156e3ccdbb64a0788bdeab51e992␟6087783423599420507:Starts with`;
    } let i18n_42; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the contains filter operator
         * @meaning kendo.grid.filterContainsOperator
         */
        const MSG_EXTERNAL_3831180413287131758$$DIST_FESM2015_INDEX_JS_43 = goog.getMsg("Contains");
        i18n_42 = MSG_EXTERNAL_3831180413287131758$$DIST_FESM2015_INDEX_JS_43;
    }
    else {
        i18n_42 = $localize `:kendo.grid.filterContainsOperator|The text of the contains filter operator␟5b568a46d2e34ebde7dd53a7e599cbbb7dc6bae1␟3831180413287131758:Contains`;
    } let i18n_44; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the does not contain filter operator
         * @meaning kendo.grid.filterNotContainsOperator
         */
        const MSG_EXTERNAL_7331253838216904826$$DIST_FESM2015_INDEX_JS_45 = goog.getMsg("Does not contain");
        i18n_44 = MSG_EXTERNAL_7331253838216904826$$DIST_FESM2015_INDEX_JS_45;
    }
    else {
        i18n_44 = $localize `:kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator␟be06aa4fde7fa722c9de5a45f241ff595071d718␟7331253838216904826:Does not contain`;
    } let i18n_46; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the ends with filter operator
         * @meaning kendo.grid.filterEndsWithOperator
         */
        const MSG_EXTERNAL_3662435311670509156$$DIST_FESM2015_INDEX_JS_47 = goog.getMsg("Ends with");
        i18n_46 = MSG_EXTERNAL_3662435311670509156$$DIST_FESM2015_INDEX_JS_47;
    }
    else {
        i18n_46 = $localize `:kendo.grid.filterEndsWithOperator|The text of the ends with filter operator␟a54b2ecffb41f0603ceedc7ea5a40b7d130e2fa1␟3662435311670509156:Ends with`;
    } let i18n_48; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the greater than or equal filter operator
         * @meaning kendo.grid.filterGteOperator
         */
        const MSG_EXTERNAL_4542824413455511831$$DIST_FESM2015_INDEX_JS_49 = goog.getMsg("Is greater than or equal to");
        i18n_48 = MSG_EXTERNAL_4542824413455511831$$DIST_FESM2015_INDEX_JS_49;
    }
    else {
        i18n_48 = $localize `:kendo.grid.filterGteOperator|The text of the greater than or equal filter operator␟68471603db771d0304d02fe086da9701c16911c3␟4542824413455511831:Is greater than or equal to`;
    } let i18n_50; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the greater than filter operator
         * @meaning kendo.grid.filterGtOperator
         */
        const MSG_EXTERNAL_1527483349261806183$$DIST_FESM2015_INDEX_JS_51 = goog.getMsg("Is greater than");
        i18n_50 = MSG_EXTERNAL_1527483349261806183$$DIST_FESM2015_INDEX_JS_51;
    }
    else {
        i18n_50 = $localize `:kendo.grid.filterGtOperator|The text of the greater than filter operator␟ae68acc0e18252a348bdfb32112996d81e5305de␟1527483349261806183:Is greater than`;
    } let i18n_52; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the less than or equal filter operator
         * @meaning kendo.grid.filterLteOperator
         */
        const MSG_EXTERNAL_4840714404733417604$$DIST_FESM2015_INDEX_JS_53 = goog.getMsg("Is less than or equal to");
        i18n_52 = MSG_EXTERNAL_4840714404733417604$$DIST_FESM2015_INDEX_JS_53;
    }
    else {
        i18n_52 = $localize `:kendo.grid.filterLteOperator|The text of the less than or equal filter operator␟e48d50a6422c616a00b95025adc5283aff4fa8cb␟4840714404733417604:Is less than or equal to`;
    } let i18n_54; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the less than filter operator
         * @meaning kendo.grid.filterLtOperator
         */
        const MSG_EXTERNAL_498627126459578706$$DIST_FESM2015_INDEX_JS_55 = goog.getMsg("Is less than");
        i18n_54 = MSG_EXTERNAL_498627126459578706$$DIST_FESM2015_INDEX_JS_55;
    }
    else {
        i18n_54 = $localize `:kendo.grid.filterLtOperator|The text of the less than filter operator␟c4d58f0e509cb7e37014715dd91546a724210d70␟498627126459578706:Is less than`;
    } let i18n_56; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the IsTrue boolean filter option
         * @meaning kendo.grid.filterIsTrue
         */
        const MSG_EXTERNAL_2361673238316312251$$DIST_FESM2015_INDEX_JS_57 = goog.getMsg("Is True");
        i18n_56 = MSG_EXTERNAL_2361673238316312251$$DIST_FESM2015_INDEX_JS_57;
    }
    else {
        i18n_56 = $localize `:kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option␟d5f1e9028bc60c30e8f8e0f9cfeb872512446cea␟2361673238316312251:Is True`;
    } let i18n_58; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the IsFalse boolean filter option
         * @meaning kendo.grid.filterIsFalse
         */
        const MSG_EXTERNAL_7759366406135608407$$DIST_FESM2015_INDEX_JS_59 = goog.getMsg("Is False");
        i18n_58 = MSG_EXTERNAL_7759366406135608407$$DIST_FESM2015_INDEX_JS_59;
    }
    else {
        i18n_58 = $localize `:kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option␟6d34731320e2536fd78f4a9e08f0b8dcd01edf3d␟7759366406135608407:Is False`;
    } let i18n_60; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the (All) boolean filter option
         * @meaning kendo.grid.filterBooleanAll
         */
        const MSG_EXTERNAL_9215343856736761875$$DIST_FESM2015_INDEX_JS_61 = goog.getMsg("(All)");
        i18n_60 = MSG_EXTERNAL_9215343856736761875$$DIST_FESM2015_INDEX_JS_61;
    }
    else {
        i18n_60 = $localize `:kendo.grid.filterBooleanAll|The text of the (All) boolean filter option␟4da1456a62bafe2614ed2bc05a2c790a64a4dd0b␟9215343856736761875:(All)`;
    } let i18n_62; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the after or equal date filter operator
         * @meaning kendo.grid.filterAfterOrEqualOperator
         */
        const MSG_EXTERNAL_1964413288176201979$$DIST_FESM2015_INDEX_JS_63 = goog.getMsg("Is after or equal to");
        i18n_62 = MSG_EXTERNAL_1964413288176201979$$DIST_FESM2015_INDEX_JS_63;
    }
    else {
        i18n_62 = $localize `:kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator␟d7dac1bbc2372d578a9d2bca099de766043aed7e␟1964413288176201979:Is after or equal to`;
    } let i18n_64; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the after date filter operator
         * @meaning kendo.grid.filterAfterOperator
         */
        const MSG_EXTERNAL_3078502182807244703$$DIST_FESM2015_INDEX_JS_65 = goog.getMsg("Is after");
        i18n_64 = MSG_EXTERNAL_3078502182807244703$$DIST_FESM2015_INDEX_JS_65;
    }
    else {
        i18n_64 = $localize `:kendo.grid.filterAfterOperator|The text of the after date filter operator␟bff777df0d0831cc02679227422fab4ef2763fa9␟3078502182807244703:Is after`;
    } let i18n_66; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the before date filter operator
         * @meaning kendo.grid.filterBeforeOperator
         */
        const MSG_EXTERNAL_3348865631071358219$$DIST_FESM2015_INDEX_JS_67 = goog.getMsg("Is before");
        i18n_66 = MSG_EXTERNAL_3348865631071358219$$DIST_FESM2015_INDEX_JS_67;
    }
    else {
        i18n_66 = $localize `:kendo.grid.filterBeforeOperator|The text of the before date filter operator␟35ef5cf367670f15432c9f8761bc85fbdb2b1830␟3348865631071358219:Is before`;
    } let i18n_68; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the before or equal date filter operator
         * @meaning kendo.grid.filterBeforeOrEqualOperator
         */
        const MSG_EXTERNAL_6582064037090631388$$DIST_FESM2015_INDEX_JS_69 = goog.getMsg("Is before or equal to");
        i18n_68 = MSG_EXTERNAL_6582064037090631388$$DIST_FESM2015_INDEX_JS_69;
    }
    else {
        i18n_68 = $localize `:kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator␟27a6b29ffbc1eb498de8d7af20051461a2e842ec␟6582064037090631388:Is before or equal to`;
    } let i18n_70; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the filter button
         * @meaning kendo.grid.filterFilterButton
         */
        const MSG_EXTERNAL_5185263258022896121$$DIST_FESM2015_INDEX_JS_71 = goog.getMsg("Filter");
        i18n_70 = MSG_EXTERNAL_5185263258022896121$$DIST_FESM2015_INDEX_JS_71;
    }
    else {
        i18n_70 = $localize `:kendo.grid.filterFilterButton|The text of the filter button␟4f1c08d0b056646cdb668da669e2e15825adfe4d␟5185263258022896121:Filter`;
    } let i18n_72; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the clear filter button
         * @meaning kendo.grid.filterClearButton
         */
        const MSG_EXTERNAL_3031209415830321799$$DIST_FESM2015_INDEX_JS_73 = goog.getMsg("Clear");
        i18n_72 = MSG_EXTERNAL_3031209415830321799$$DIST_FESM2015_INDEX_JS_73;
    }
    else {
        i18n_72 = $localize `:kendo.grid.filterClearButton|The text of the clear filter button␟06e4e4dadede6f91f261cdbb7fb174246a135238␟3031209415830321799:Clear`;
    } let i18n_74; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the And filter logic
         * @meaning kendo.grid.filterAndLogic
         */
        const MSG_EXTERNAL_512662285155477884$$DIST_FESM2015_INDEX_JS_75 = goog.getMsg("And");
        i18n_74 = MSG_EXTERNAL_512662285155477884$$DIST_FESM2015_INDEX_JS_75;
    }
    else {
        i18n_74 = $localize `:kendo.grid.filterAndLogic|The text of the And filter logic␟f73fbcc2f813d469e4a34491950ca01ea1ac8f60␟512662285155477884:And`;
    } let i18n_76; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the Or filter logic
         * @meaning kendo.grid.filterOrLogic
         */
        const MSG_EXTERNAL_1964926727342405367$$DIST_FESM2015_INDEX_JS_77 = goog.getMsg("Or");
        i18n_76 = MSG_EXTERNAL_1964926727342405367$$DIST_FESM2015_INDEX_JS_77;
    }
    else {
        i18n_76 = $localize `:kendo.grid.filterOrLogic|The text of the Or filter logic␟04e64780de0fc1c3a9986997e0808ec53a5f2a63␟1964926727342405367:Or`;
    } let i18n_78; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The loading text
         * @meaning kendo.grid.loading
         */
        const MSG_EXTERNAL_5425510787229531767$$DIST_FESM2015_INDEX_JS_79 = goog.getMsg("Loading");
        i18n_78 = MSG_EXTERNAL_5425510787229531767$$DIST_FESM2015_INDEX_JS_79;
    }
    else {
        i18n_78 = $localize `:kendo.grid.loading|The loading text␟781c049cc69efc30bc8053af9ace3cb4b04bd438␟5425510787229531767:Loading`;
    } let i18n_80; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Grid aria-label
         * @meaning kendo.grid.gridLabel
         */
        const MSG_EXTERNAL_1756559638952980203$$DIST_FESM2015_INDEX_JS_81 = goog.getMsg("Data table");
        i18n_80 = MSG_EXTERNAL_1756559638952980203$$DIST_FESM2015_INDEX_JS_81;
    }
    else {
        i18n_80 = $localize `:kendo.grid.gridLabel|The Grid aria-label␟03316b5e0c6e91f110c8f015ca63318ced71b1ab␟1756559638952980203:Data table`;
    } let i18n_82; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu for the columns item
         * @meaning kendo.grid.columns
         */
        const MSG_EXTERNAL_5332162737795508854$$DIST_FESM2015_INDEX_JS_83 = goog.getMsg("Columns");
        i18n_82 = MSG_EXTERNAL_5332162737795508854$$DIST_FESM2015_INDEX_JS_83;
    }
    else {
        i18n_82 = $localize `:kendo.grid.columns|The text shown in the column menu for the columns item␟9b841399fbb3d81f2401f98b4f4763834b72a1e5␟5332162737795508854:Columns`;
    } let i18n_84; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu for the lock item
         * @meaning kendo.grid.lock
         */
        const MSG_EXTERNAL_5849203148124173556$$DIST_FESM2015_INDEX_JS_85 = goog.getMsg("Lock");
        i18n_84 = MSG_EXTERNAL_5849203148124173556$$DIST_FESM2015_INDEX_JS_85;
    }
    else {
        i18n_84 = $localize `:kendo.grid.lock|The text shown in the column menu for the lock item␟f356cae509dec3dc1b7156326b9a0328a79c62a8␟5849203148124173556:Lock`;
    } let i18n_86; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu for the unlock item
         * @meaning kendo.grid.unlock
         */
        const MSG_EXTERNAL_6968586378603932789$$DIST_FESM2015_INDEX_JS_87 = goog.getMsg("Unlock");
        i18n_86 = MSG_EXTERNAL_6968586378603932789$$DIST_FESM2015_INDEX_JS_87;
    }
    else {
        i18n_86 = $localize `:kendo.grid.unlock|The text shown in the column menu for the unlock item␟f33355540003068372e39ba7f3def794869ea9f8␟6968586378603932789:Unlock`;
    } let i18n_88; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu for the set column position item
         * @meaning kendo.grid.setColumnPosition
         */
        const MSG_EXTERNAL_4152513791950180353$$DIST_FESM2015_INDEX_JS_89 = goog.getMsg("Set Column Position");
        i18n_88 = MSG_EXTERNAL_4152513791950180353$$DIST_FESM2015_INDEX_JS_89;
    }
    else {
        i18n_88 = $localize `:kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item␟e5b09fd8ecea276841b1018a376a43d5f26cf187␟4152513791950180353:Set Column Position`;
    } let i18n_90; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu for the stick item
         * @meaning kendo.grid.stick
         */
        const MSG_EXTERNAL_2051035907018784050$$DIST_FESM2015_INDEX_JS_91 = goog.getMsg("Stick");
        i18n_90 = MSG_EXTERNAL_2051035907018784050$$DIST_FESM2015_INDEX_JS_91;
    }
    else {
        i18n_90 = $localize `:kendo.grid.stick|The text shown in the column menu for the stick item␟31d7229bfb18a112e19a6e8040d7d2e261293dca␟2051035907018784050:Stick`;
    } let i18n_92; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu for the unstick item
         * @meaning kendo.grid.unstick
         */
        const MSG_EXTERNAL_7237321134369658080$$DIST_FESM2015_INDEX_JS_93 = goog.getMsg("Unstick");
        i18n_92 = MSG_EXTERNAL_7237321134369658080$$DIST_FESM2015_INDEX_JS_93;
    }
    else {
        i18n_92 = $localize `:kendo.grid.unstick|The text shown in the column menu for the unstick item␟01d4c7e75b7fadc09544cf2277208d39b4eef86a␟7237321134369658080:Unstick`;
    } let i18n_94; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label of the sort icon
         * @meaning kendo.grid.sortable
         */
        const MSG_EXTERNAL_3824304972336788145$$DIST_FESM2015_INDEX_JS_95 = goog.getMsg("Sortable");
        i18n_94 = MSG_EXTERNAL_3824304972336788145$$DIST_FESM2015_INDEX_JS_95;
    }
    else {
        i18n_94 = $localize `:kendo.grid.sortable|The label of the sort icon␟a692ba271be066ce379f942ff67094e1ea989f4c␟3824304972336788145:Sortable`;
    } let i18n_96; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu for the sort ascending item
         * @meaning kendo.grid.sortAscending
         */
        const MSG_EXTERNAL_6297762560864270240$$DIST_FESM2015_INDEX_JS_97 = goog.getMsg("Sort Ascending");
        i18n_96 = MSG_EXTERNAL_6297762560864270240$$DIST_FESM2015_INDEX_JS_97;
    }
    else {
        i18n_96 = $localize `:kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item␟96beffd8446c5455f3bbdc313c946db32df7dcc2␟6297762560864270240:Sort Ascending`;
    } let i18n_98; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu for the sort descending item
         * @meaning kendo.grid.sortDescending
         */
        const MSG_EXTERNAL_5605073536641230977$$DIST_FESM2015_INDEX_JS_99 = goog.getMsg("Sort Descending");
        i18n_98 = MSG_EXTERNAL_5605073536641230977$$DIST_FESM2015_INDEX_JS_99;
    }
    else {
        i18n_98 = $localize `:kendo.grid.sortDescending|The text shown in the column menu for the sort descending item␟208d0538d4c2537a1cbf456941e34a2884053d52␟5605073536641230977:Sort Descending`;
    } let i18n_100; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The status announcement when a column is sorted ascending
         * @meaning kendo.grid.sortedAscending
         */
        const MSG_EXTERNAL_6275944032047713540$$DIST_FESM2015_INDEX_JS_101 = goog.getMsg("Sorted Ascending");
        i18n_100 = MSG_EXTERNAL_6275944032047713540$$DIST_FESM2015_INDEX_JS_101;
    }
    else {
        i18n_100 = $localize `:kendo.grid.sortedAscending|The status announcement when a column is sorted ascending␟947c64329461efd9f8a9aa2c51acbbd099170aa5␟6275944032047713540:Sorted Ascending`;
    } let i18n_102; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The status announcement when a column is sorted descending
         * @meaning kendo.grid.sortedDescending
         */
        const MSG_EXTERNAL_8155280769473236383$$DIST_FESM2015_INDEX_JS_103 = goog.getMsg("Sorted Descending");
        i18n_102 = MSG_EXTERNAL_8155280769473236383$$DIST_FESM2015_INDEX_JS_103;
    }
    else {
        i18n_102 = $localize `:kendo.grid.sortedDescending|The status announcement when a column is sorted descending␟092a688d1b2b6d873bdc29beaaf43c3f45336581␟8155280769473236383:Sorted Descending`;
    } let i18n_104; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The status announcement when a column is no longer sorted
         * @meaning kendo.grid.sortedDefault
         */
        const MSG_EXTERNAL_5229177293891232538$$DIST_FESM2015_INDEX_JS_105 = goog.getMsg("Not Sorted");
        i18n_104 = MSG_EXTERNAL_5229177293891232538$$DIST_FESM2015_INDEX_JS_105;
    }
    else {
        i18n_104 = $localize `:kendo.grid.sortedDefault|The status announcement when a column is no longer sorted␟66e99ea340974022c07c52a6f668f5573e7edab0␟5229177293891232538:Not Sorted`;
    } let i18n_106; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu or column chooser for the columns apply button
         * @meaning kendo.grid.columnsApply
         */
        const MSG_EXTERNAL_34213208292862969$$DIST_FESM2015_INDEX_JS_107 = goog.getMsg("Apply");
        i18n_106 = MSG_EXTERNAL_34213208292862969$$DIST_FESM2015_INDEX_JS_107;
    }
    else {
        i18n_106 = $localize `:kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button␟04600bd6e362cf9da9f7f9c4666eab2c88eb6a90␟34213208292862969:Apply`;
    } let i18n_108; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text shown in the column menu or column chooser for the columns reset button
         * @meaning kendo.grid.columnsReset
         */
        const MSG_EXTERNAL_4465838259914958827$$DIST_FESM2015_INDEX_JS_109 = goog.getMsg("Reset");
        i18n_108 = MSG_EXTERNAL_4465838259914958827$$DIST_FESM2015_INDEX_JS_109;
    }
    else {
        i18n_108 = $localize `:kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button␟94d3b472d99994a5cca9930afd4cf0ac2774c382␟4465838259914958827:Reset`;
    } let i18n_110; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the expand icon of detail rows.
         * @meaning kendo.grid.detailExpand
         */
        const MSG_EXTERNAL_6952757249912226136$$DIST_FESM2015_INDEX_JS_111 = goog.getMsg("Expand Details");
        i18n_110 = MSG_EXTERNAL_6952757249912226136$$DIST_FESM2015_INDEX_JS_111;
    }
    else {
        i18n_110 = $localize `:kendo.grid.detailExpand|The title of the expand icon of detail rows.␟ad6629bb6e79235623cfce486ef48087dbe96fb5␟6952757249912226136:Expand Details`;
    } let i18n_112; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the collapse icon of detail rows.
         * @meaning kendo.grid.detailCollapse
         */
        const MSG_EXTERNAL_6065477639036399169$$DIST_FESM2015_INDEX_JS_113 = goog.getMsg("Collapse Details");
        i18n_112 = MSG_EXTERNAL_6065477639036399169$$DIST_FESM2015_INDEX_JS_113;
    }
    else {
        i18n_112 = $localize `:kendo.grid.detailCollapse|The title of the collapse icon of detail rows.␟ace0c0a58fbb211e8678efb3bd6ac9bb587144c3␟6065477639036399169:Collapse Details`;
    } let i18n_114; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the Today button of the Date filter.
         * @meaning kendo.grid.filterDateToday
         */
        const MSG_EXTERNAL_1656723147090613075$$DIST_FESM2015_INDEX_JS_115 = goog.getMsg("TODAY");
        i18n_114 = MSG_EXTERNAL_1656723147090613075$$DIST_FESM2015_INDEX_JS_115;
    }
    else {
        i18n_114 = $localize `:kendo.grid.filterDateToday|The text of the Today button of the Date filter.␟745058f85d92ee5228977277195262978828c4c8␟1656723147090613075:TODAY`;
    } let i18n_116; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the Toggle button of the Date filter.
         * @meaning kendo.grid.filterDateToggle
         */
        const MSG_EXTERNAL_15438307630389352$$DIST_FESM2015_INDEX_JS_117 = goog.getMsg("Toggle Calendar");
        i18n_116 = MSG_EXTERNAL_15438307630389352$$DIST_FESM2015_INDEX_JS_117;
    }
    else {
        i18n_116 = $localize `:kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter.␟2c916ea2cbd37665e512219650c37dc17b9ef0c0␟15438307630389352:Toggle Calendar`;
    } let i18n_118; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the Decrement button of the Numeric filter.
         * @meaning kendo.grid.filterNumericDecrement
         */
        const MSG_EXTERNAL_534533728304192410$$DIST_FESM2015_INDEX_JS_119 = goog.getMsg("Decrement");
        i18n_118 = MSG_EXTERNAL_534533728304192410$$DIST_FESM2015_INDEX_JS_119;
    }
    else {
        i18n_118 = $localize `:kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter.␟7f991d698abebb2e50570f9aef14126ae931c513␟534533728304192410:Decrement`;
    } let i18n_120; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the Increment button of the Numeric filter.
         * @meaning kendo.grid.filterNumericIncrement
         */
        const MSG_EXTERNAL_5462143714591662391$$DIST_FESM2015_INDEX_JS_121 = goog.getMsg("Increment");
        i18n_120 = MSG_EXTERNAL_5462143714591662391$$DIST_FESM2015_INDEX_JS_121;
    }
    else {
        i18n_120 = $localize `:kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter.␟25bc8b86968819d3f687aa6dde652800bd4b6b2a␟5462143714591662391:Increment`;
    } let i18n_122; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The labels of the checkbox column checkboxes.
         * @meaning kendo.grid.selectionCheckboxLabel
         */
        const MSG_EXTERNAL_8181603152758207780$$DIST_FESM2015_INDEX_JS_123 = goog.getMsg("Select Row");
        i18n_122 = MSG_EXTERNAL_8181603152758207780$$DIST_FESM2015_INDEX_JS_123;
    }
    else {
        i18n_122 = $localize `:kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes.␟be92546944c9cb75e92f8b968456d82a101fc35b␟8181603152758207780:Select Row`;
    } let i18n_124; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label of the checkbox column select all checkbox.
         * @meaning kendo.grid.selectAllCheckboxLabel
         */
        const MSG_EXTERNAL_6136285170059274319$$DIST_FESM2015_INDEX_JS_125 = goog.getMsg("Select All Rows");
        i18n_124 = MSG_EXTERNAL_6136285170059274319$$DIST_FESM2015_INDEX_JS_125;
    }
    else {
        i18n_124 = $localize `:kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox.␟20fbea69eff950cbfcf690203ca6104e8346fa48␟6136285170059274319:Select All Rows`;
    } let i18n_126; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the title and aria-label attributes applied to the collapse icon of group rows.
         * @meaning kendo.grid.groupCollapse
         */
        const MSG_EXTERNAL_7772550046681609079$$DIST_FESM2015_INDEX_JS_127 = goog.getMsg("Collapse Group");
        i18n_126 = MSG_EXTERNAL_7772550046681609079$$DIST_FESM2015_INDEX_JS_127;
    }
    else {
        i18n_126 = $localize `:kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows.␟caf1557000de0fb3c367fc81500d19fb534c165a␟7772550046681609079:Collapse Group`;
    } let i18n_128; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text of the title and aria-label attributes applied to the expand icon of group rows.
         * @meaning kendo.grid.groupExpand
         */
        const MSG_EXTERNAL_1232300275422220104$$DIST_FESM2015_INDEX_JS_129 = goog.getMsg("Expand Group");
        i18n_128 = MSG_EXTERNAL_1232300275422220104$$DIST_FESM2015_INDEX_JS_129;
    }
    else {
        i18n_128 = $localize `:kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows.␟ac06c8a43721591f02bbb3414bc1f4088853fbd8␟1232300275422220104:Expand Group`;
    } let i18n_130; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Grid pager
         * @meaning kendo.grid.pagerLabel
         */
        const MSG_EXTERNAL_941504587982751782$$DIST_FESM2015_INDEX_JS_131 = goog.getMsg("{$interpolation}", { "interpolation": "\uFFFD0\uFFFD" });
        i18n_130 = MSG_EXTERNAL_941504587982751782$$DIST_FESM2015_INDEX_JS_131;
    }
    else {
        i18n_130 = $localize `:kendo.grid.pagerLabel|The label for the Grid pager␟03a0df03d11d80b3aeca50cf4827096a51a853fc␟941504587982751782:${"\uFFFD0\uFFFD"}:INTERPOLATION:`;
    } let i18n_132; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label of the filter row and menu inputs
         * @meaning kendo.grid.filterInputLabel
         */
        const MSG_EXTERNAL_3836147469421132954$$DIST_FESM2015_INDEX_JS_133 = goog.getMsg("{$interpolation}", { "interpolation": "\uFFFD0\uFFFD" });
        i18n_132 = MSG_EXTERNAL_3836147469421132954$$DIST_FESM2015_INDEX_JS_133;
    }
    else {
        i18n_132 = $localize `:kendo.grid.filterInputLabel|The label of the filter row and menu inputs␟491dbf44b1ca040395b94229d00d4109af48e64c␟3836147469421132954:${"\uFFFD0\uFFFD"}:INTERPOLATION:`;
    } let i18n_134; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the filter menu icon
         * @meaning kendo.grid.filterMenuTitle
         */
        const MSG_EXTERNAL_7968307322474586314$$DIST_FESM2015_INDEX_JS_135 = goog.getMsg("{$interpolation}", { "interpolation": "\uFFFD0\uFFFD" });
        i18n_134 = MSG_EXTERNAL_7968307322474586314$$DIST_FESM2015_INDEX_JS_135;
    }
    else {
        i18n_134 = $localize `:kendo.grid.filterMenuTitle|The title of the filter menu icon␟04e8a1bee6d2dd6edfc921e890fae44a01ceb18c␟7968307322474586314:${"\uFFFD0\uFFFD"}:INTERPOLATION:`;
    } let i18n_136; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label of the filter menu operators dropdown
         * @meaning kendo.grid.filterMenuOperatorsDropDownLabel
         */
        const MSG_EXTERNAL_1505989735336544615$$DIST_FESM2015_INDEX_JS_137 = goog.getMsg("{$interpolation}", { "interpolation": "\uFFFD0\uFFFD" });
        i18n_136 = MSG_EXTERNAL_1505989735336544615$$DIST_FESM2015_INDEX_JS_137;
    }
    else {
        i18n_136 = $localize `:kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown␟884eac0bb5b4a01ea36fea20ffa29c6dfe1987e0␟1505989735336544615:${"\uFFFD0\uFFFD"}:INTERPOLATION:`;
    } let i18n_138; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label of the filter menu logic dropdown
         * @meaning kendo.grid.filterMenuLogicDropDownLabel
         */
        const MSG_EXTERNAL_7212349983175276206$$DIST_FESM2015_INDEX_JS_139 = goog.getMsg("{$interpolation}", { "interpolation": "\uFFFD0\uFFFD" });
        i18n_138 = MSG_EXTERNAL_7212349983175276206$$DIST_FESM2015_INDEX_JS_139;
    }
    else {
        i18n_138 = $localize `:kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown␟c9ba4917588987b943dc414dc6ca108392d8cb40␟7212349983175276206:${"\uFFFD0\uFFFD"}:INTERPOLATION:`;
    } let i18n_140; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the column menu icon
         * @meaning kendo.grid.columnMenu
         */
        const MSG_EXTERNAL_8738132440639204439$$DIST_FESM2015_INDEX_JS_141 = goog.getMsg("{$interpolation}", { "interpolation": "\uFFFD0\uFFFD" });
        i18n_140 = MSG_EXTERNAL_8738132440639204439$$DIST_FESM2015_INDEX_JS_141;
    }
    else {
        i18n_140 = $localize `:kendo.grid.columnMenu|The title of the column menu icon␟28d8b294e285a6c34641eb1c7982870b412ef106␟8738132440639204439:${"\uFFFD0\uFFFD"}:INTERPOLATION:`;
    } return [["kendoGridLocalizedMessages", "", "groupPanelEmpty", i18n_4, "noRecords", i18n_6, "pagerFirstPage", i18n_8, "pagerPreviousPage", i18n_10, "pagerNextPage", i18n_12, "pagerLastPage", i18n_14, "pagerPage", i18n_16, "pagerOf", i18n_18, "pagerItems", i18n_20, "pagerPageNumberInputTitle", i18n_22, "pagerItemsPerPage", i18n_24, "filter", i18n_26, "filterEqOperator", i18n_28, "filterNotEqOperator", i18n_30, "filterIsNullOperator", i18n_32, "filterIsNotNullOperator", i18n_34, "filterIsEmptyOperator", i18n_36, "filterIsNotEmptyOperator", i18n_38, "filterStartsWithOperator", i18n_40, "filterContainsOperator", i18n_42, "filterNotContainsOperator", i18n_44, "filterEndsWithOperator", i18n_46, "filterGteOperator", i18n_48, "filterGtOperator", i18n_50, "filterLteOperator", i18n_52, "filterLtOperator", i18n_54, "filterIsTrue", i18n_56, "filterIsFalse", i18n_58, "filterBooleanAll", i18n_60, "filterAfterOrEqualOperator", i18n_62, "filterAfterOperator", i18n_64, "filterBeforeOperator", i18n_66, "filterBeforeOrEqualOperator", i18n_68, "filterFilterButton", i18n_70, "filterClearButton", i18n_72, "filterAndLogic", i18n_74, "filterOrLogic", i18n_76, "loading", i18n_78, "gridLabel", i18n_80, "columns", i18n_82, "lock", i18n_84, "unlock", i18n_86, "setColumnPosition", i18n_88, "stick", i18n_90, "unstick", i18n_92, "sortable", i18n_94, "sortAscending", i18n_96, "sortDescending", i18n_98, "sortedAscending", i18n_100, "sortedDescending", i18n_102, "sortedDefault", i18n_104, "columnsApply", i18n_106, "columnsReset", i18n_108, "detailExpand", i18n_110, "detailCollapse", i18n_112, "filterDateToday", i18n_114, "filterDateToggle", i18n_116, "filterNumericDecrement", i18n_118, "filterNumericIncrement", i18n_120, "selectionCheckboxLabel", i18n_122, "selectAllCheckboxLabel", i18n_124, "groupCollapse", i18n_126, "groupExpand", i18n_128, 6, "pagerLabel", "filterInputLabel", "filterMenuTitle", "filterMenuOperatorsDropDownLabel", "filterMenuLogicDropDownLabel", "columnMenu"], ["pagerLabel", i18n_130, "filterInputLabel", i18n_132, "filterMenuTitle", i18n_134, "filterMenuOperatorsDropDownLabel", i18n_136, "filterMenuLogicDropDownLabel", i18n_138, "columnMenu", i18n_140], ["class", "k-toolbar k-grid-toolbar", "position", "top", 4, "ngIf"], ["class", "k-grid-pager-top", 3, "tabindex", "template", "pageSize", "total", "skip", "options", "pageChange", 4, "ngIf"], [3, "text", "groups", "change", 4, "ngIf"], ["role", "grid", 1, "k-grid-aria-root"], ["ariaRoot", ""], [3, "ngIf"], ["kendoGridLoading", "", 3, "loadingTemplate", 4, "ngIf"], [3, "tabindex", "template", "pageSize", "total", "skip", "options", "pageChange", 4, "ngIf"], ["class", "k-toolbar k-grid-toolbar k-grid-toolbar-bottom", "position", "bottom", 4, "ngIf"], ["position", "top", 1, "k-toolbar", "k-grid-toolbar"], [1, "k-grid-pager-top", 3, "tabindex", "template", "pageSize", "total", "skip", "options", "pageChange"], [3, "text", "groups", "change"], ["class", "k-grid-header", "role", "presentation", 3, "padding", 4, "ngIf"], ["kendoDraggable", "", "kendoGridSelectionMarquee", "", 3, "data", "rowHeight", "detailRowHeight", "total", "take", "groups", "groupable", "skip", "trackBy", "columns", "selectable", "filterable", "detailTemplate", "noRecordsTemplate", "rowClass", "rowSticky", "loading", "isVirtual", "cellLoadingTemplate", "loadingTemplate", "virtualColumns", "enableDrag", "pageChange", "scrollBottom", "contentScroll"], ["class", "k-grid-footer", 3, "padding", 4, "ngIf"], ["role", "presentation", 1, "k-grid-header"], ["role", "presentation", "class", "k-grid-header-locked", 3, "width", 4, "ngIf"], ["role", "presentation", "data-scrollable", "", 1, "k-grid-header-wrap", 3, "kendoGridResizableContainer", "lockedWidth"], ["header", ""], ["role", "presentation", 3, "virtualColumns"], ["kendoGridColGroup", "", "role", "presentation", 3, "columns", "groups", "detailTemplate"], ["kendoGridHeader", "", "role", "presentation", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "filter", "filterable", "groupable", "reorderable", "groups", "sortable", "columnMenu", "columnMenuTemplate", "lockedColumnsCount", "totalColumnsCount", "detailTemplate", "tabIndex"], ["class", "k-width-container", "role", "presentation", 4, "ngIf"], ["role", "presentation", 1, "k-grid-header-locked"], ["lockedHeader", ""], ["role", "presentation", 3, "locked"], ["kendoGridHeader", "", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "groups", "filter", "filterable", "groupable", "reorderable", "sortable", "columnMenu", "columnMenuTemplate", "totalColumnsCount", "detailTemplate", "tabIndex"], ["role", "presentation", 1, "k-width-container"], [1, "k-grid-footer"], ["class", "k-grid-footer-locked", 3, "width", 4, "ngIf"], ["data-scrollable", "", 1, "k-grid-footer-wrap", 3, "kendoGridResizableContainer", "lockedWidth"], ["footer", ""], ["role", "presentation"], ["kendoGridColGroup", "", 3, "columns", "groups", "detailTemplate"], ["kendoGridFooter", "", 3, "logicalRowIndex", "scrollable", "groups", "columns", "lockedColumnsCount", "detailTemplate"], [1, "k-grid-footer-locked"], ["kendoGridFooter", "", 3, "scrollable", "groups", "columns", "detailTemplate", "logicalRowIndex"], ["kendoGridHeader", "", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "groups", "groupable", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate", "detailTemplate", "tabIndex", 4, "ngIf"], ["kendoGridTableBody", "", "kendoDraggable", "", "kendoGridSelectionMarquee", "", 3, "isLoading", "groups", "data", "skip", "columns", "selectable", "filterable", "noRecordsTemplate", "detailTemplate", "showGroupFooters", "trackBy", "rowClass", "enableDrag"], ["kendoGridFooter", "", 3, "scrollable", "logicalRowIndex", "groups", "columns", "detailTemplate", 4, "ngIf"], ["kendoGridHeader", "", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "groups", "groupable", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate", "detailTemplate", "tabIndex"], ["kendoGridFooter", "", 3, "scrollable", "logicalRowIndex", "groups", "columns", "detailTemplate"], ["kendoGridLoading", "", 3, "loadingTemplate"], [3, "tabindex", "template", "pageSize", "total", "skip", "options", "pageChange"], ["position", "bottom", 1, "k-toolbar", "k-grid-toolbar", "k-grid-toolbar-bottom"]]; }, template: function GridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, 1);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵtemplate(2, GridComponent_kendo_grid_toolbar_2_Template, 1, 0, "kendo-grid-toolbar", 2);
        ɵngcc0.ɵɵtemplate(3, GridComponent_kendo_pager_3_Template, 1, 7, "kendo-pager", 3);
        ɵngcc0.ɵɵtemplate(4, GridComponent_kendo_grid_group_panel_4_Template, 1, 2, "kendo-grid-group-panel", 4);
        ɵngcc0.ɵɵelementStart(5, "div", 5, 6);
        ɵngcc0.ɵɵtemplate(7, GridComponent_ng_template_7_Template, 3, 24, "ng-template", 7);
        ɵngcc0.ɵɵtemplate(8, GridComponent_ng_template_8_Template, 5, 20, "ng-template", 7);
        ɵngcc0.ɵɵtemplate(9, GridComponent_div_9_Template, 1, 1, "div", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, GridComponent_kendo_pager_10_Template, 1, 7, "kendo-pager", 9);
        ɵngcc0.ɵɵtemplate(11, GridComponent_kendo_grid_toolbar_11_Template, 1, 0, "kendo-grid-toolbar", 10);
    } if (rf & 2) {
        ɵngcc0.ɵɵi18nExp("Page navigation, page {currentPage} of {totalPages}")("{columnName} Filter")("{columnName} Filter Menu")("{columnName} Filter Operators")("{columnName} Filter Logic")("{columnName} Column Menu");
        ɵngcc0.ɵɵi18nApply(1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTopToolbar);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTopPager);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showGroupPanel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel)("aria-rowcount", ctx.ariaRowCount)("aria-colcount", ctx.ariaColCount);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isScrollable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isScrollable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.loading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showBottomPager);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showBottomToolbar);
    } }, directives: function () { return [LocalizedMessagesDirective, ɵngcc5.NgIf, ToolbarComponent, PagerComponent, GroupPanelComponent, TableDirective, ColGroupComponent, HeaderComponent, ResizableContainerDirective, ListComponent, ɵngcc2.DraggableDirective, GridMarqueeDirective, FooterComponent, TableBodyComponent, LoadingComponent]; }, styles: ["   .k-grid .k-grid-aria-root {\n            display: flex;\n            flex-direction: column;\n            flex: 1 1 auto;\n            overflow: hidden;\n        }\n\n        .k-grid .k-filter-row td {\n            white-space: nowrap;\n        }"], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], GridComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GridComponent.prototype, "pageSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GridComponent.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GridComponent.prototype, "rowHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GridComponent.prototype, "detailRowHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], GridComponent.prototype, "skip", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], GridComponent.prototype, "scrollable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GridComponent.prototype, "selectable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], GridComponent.prototype, "sort", null);
__decorate([
    Input(),
    __metadata("design:type", Function)
], GridComponent.prototype, "trackBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GridComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], GridComponent.prototype, "group", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GridComponent.prototype, "virtualColumns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GridComponent.prototype, "filterable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GridComponent.prototype, "sortable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GridComponent.prototype, "pageable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GridComponent.prototype, "groupable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GridComponent.prototype, "navigable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], GridComponent.prototype, "navigatable", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GridComponent.prototype, "autoSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], GridComponent.prototype, "rowClass", null);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], GridComponent.prototype, "rowSticky", null);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], GridComponent.prototype, "rowSelected", null);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], GridComponent.prototype, "cellSelected", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GridComponent.prototype, "resizable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GridComponent.prototype, "reorderable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GridComponent.prototype, "loading", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GridComponent.prototype, "columnMenu", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GridComponent.prototype, "hideHeader", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "filterChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "pageChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "groupChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "sortChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "selectionChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "dataStateChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "groupExpand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "groupCollapse", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "detailExpand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "detailCollapse", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "edit", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "cancel", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "save", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "remove", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "add", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "cellClose", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "cellClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "pdfExport", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "excelExport", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "columnResize", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "columnReorder", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "columnVisibilityChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "columnLockedChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "columnStickyChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "scrollBottom", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GridComponent.prototype, "contentScroll", void 0);
__decorate([
    ContentChildren(ColumnBase$1),
    __metadata("design:type", QueryList)
], GridComponent.prototype, "columns", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], GridComponent.prototype, "dir", null);
__decorate([
    HostBinding('class.k-grid'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], GridComponent.prototype, "hostClasses", null);
__decorate([
    HostBinding('class.k-grid-lockedcolumns'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], GridComponent.prototype, "lockedClasses", null);
__decorate([
    HostBinding('class.k-grid-virtual'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], GridComponent.prototype, "virtualClasses", null);
__decorate([
    HostBinding('class.k-grid-no-scrollbar'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], GridComponent.prototype, "noScrollbarClass", null);
__decorate([
    ContentChildren(DetailTemplateDirective),
    __metadata("design:type", QueryList)
], GridComponent.prototype, "detailTemplateChildren", void 0);
__decorate([
    ContentChildren(CellLoadingTemplateDirective),
    __metadata("design:type", QueryList)
], GridComponent.prototype, "cellLoadingTemplateChildren", void 0);
__decorate([
    ContentChildren(LoadingTemplateDirective),
    __metadata("design:type", QueryList)
], GridComponent.prototype, "loadingTemplateChildren", void 0);
__decorate([
    ContentChildren(NoRecordsTemplateDirective),
    __metadata("design:type", QueryList)
], GridComponent.prototype, "noRecordsTemplateChildren", void 0);
__decorate([
    ContentChildren(PagerTemplateDirective),
    __metadata("design:type", QueryList)
], GridComponent.prototype, "pagerTemplateChildren", void 0);
__decorate([
    ContentChildren(ToolbarTemplateDirective),
    __metadata("design:type", QueryList)
], GridComponent.prototype, "toolbarTemplateChildren", void 0);
__decorate([
    ContentChildren(ColumnMenuTemplateDirective),
    __metadata("design:type", QueryList)
], GridComponent.prototype, "columnMenuTemplates", void 0);
__decorate([
    ViewChild('lockedHeader', { static: false }),
    __metadata("design:type", Object)
], GridComponent.prototype, "lockedHeader", void 0);
__decorate([
    ViewChild('header', { static: false }),
    __metadata("design:type", Object)
], GridComponent.prototype, "header", void 0);
__decorate([
    ViewChildren('footer'),
    __metadata("design:type", QueryList)
], GridComponent.prototype, "footer", void 0);
__decorate([
    ViewChild('ariaRoot', { static: true }),
    __metadata("design:type", ElementRef)
], GridComponent.prototype, "ariaRoot", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], GridComponent.prototype, "isDetailExpanded", null);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], GridComponent.prototype, "isGroupExpanded", null);
GridComponent = __decorate([ __metadata("design:paramtypes", [BrowserSupportService,
        SelectionService,
        CellSelectionService,
        ElementRef,
        GroupInfoService,
        GroupsService,
        ChangeNotificationService,
        DetailsService,
        EditService,
        FilterService,
        PDFService,
        ResponsiveService,
        Renderer2,
        ExcelService,
        NgZone,
        ScrollSyncService,
        DomEventsService,
        ColumnResizingService,
        ChangeDetectorRef,
        ColumnReorderService,
        ColumnInfoService,
        NavigationService,
        SortService,
        ScrollRequestService,
        LocalizationService])
], GridComponent);

/**
 * @hidden
 */
const update = (arr, idx, value) => ([
    ...arr.slice(0, idx + 1),
    ...(arr.slice(idx + 1).map(x => x + value))
]);
/**
 * @hidden
 */
class RowHeightService {
    constructor(total = 0, rowHeight, detailRowHeight) {
        this.total = total;
        this.rowHeight = rowHeight;
        this.detailRowHeight = detailRowHeight;
        this.offsets = [];
        this.heights = [];
        let agg = 0;
        for (let idx = 0; idx < total; idx++) {
            this.offsets.push(agg);
            agg += rowHeight;
            this.heights.push(rowHeight);
        }
    }
    height(rowIndex) {
        return this.heights[rowIndex];
    }
    expandDetail(rowIndex) {
        if (this.height(rowIndex) === this.rowHeight) {
            this.updateRowHeight(rowIndex, this.detailRowHeight);
        }
    }
    collapseDetail(rowIndex) {
        if (this.height(rowIndex) > this.rowHeight) {
            this.updateRowHeight(rowIndex, this.detailRowHeight * -1);
        }
    }
    isExpanded(rowIndex) {
        return this.height(rowIndex) > this.rowHeight;
    }
    index(position) {
        if (position < 0) {
            return undefined;
        }
        const result = this.offsets.reduce((prev, current, idx) => {
            if (prev !== undefined) {
                return prev;
            }
            else if (current === position) {
                return idx;
            }
            else if (current > position) {
                return idx - 1;
            }
            return undefined;
        }, undefined); // tslint:disable-line:align
        return result === undefined ? this.total - 1 : result;
    }
    offset(rowIndex) {
        return this.offsets[rowIndex];
    }
    totalHeight() {
        return this.heights.reduce((prev, curr) => prev + curr, 0);
    }
    updateRowHeight(rowIndex, value) {
        if (this.total > 0) {
            this.heights[rowIndex] += value;
            this.offsets = update(this.offsets, rowIndex, value);
        }
    }
}

/**
 * @hidden
 */
class ScrollAction {
    constructor(offset) {
        this.offset = offset;
    }
}
/**
 * @hidden
 */
class PageAction {
    constructor(skip, take$$1) {
        this.skip = skip;
        this.take = take$$1;
    }
}
/**
 * @hidden
 */
class ScrollBottomAction {
}
const SCROLL_BOTTOM_THRESHOLD = 2;
/**
 * @hidden
 */
class ScrollerService {
    constructor(scrollObservable) {
        this.scrollObservable = scrollObservable;
        this.firstLoaded = 0;
    }
    create(rowHeightService, skip, take$$1, total) {
        this.rowHeightService = rowHeightService;
        this.firstLoaded = skip;
        this.lastLoaded = skip + take$$1;
        this.take = take$$1;
        this.total = total;
        this.lastScrollTop = 0;
        const subject = new BehaviorSubject(new ScrollAction(this.rowHeightService.offset(skip)));
        this.subscription = Observable.create(observer => {
            this.unsubscribe();
            this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));
        }).subscribe(x => subject.next(x));
        return subject;
    }
    destroy() {
        this.unsubscribe();
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    onScroll({ scrollTop, offsetHeight, scrollHeight, clientHeight }, observer) {
        if (this.lastScrollTop === scrollTop) {
            return;
        }
        const up = this.lastScrollTop >= scrollTop;
        this.lastScrollTop = scrollTop;
        let firstItemIndex = this.rowHeightService.index(scrollTop);
        let firstItemOffset = this.rowHeightService.offset(firstItemIndex);
        const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);
        if (!up) {
            if (lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {
                const overflow = (firstItemIndex + this.take) - this.total;
                if (overflow > 0) {
                    firstItemIndex = firstItemIndex - overflow;
                    firstItemOffset = this.rowHeightService.offset(firstItemIndex);
                }
                this.firstLoaded = firstItemIndex;
                observer.next(new ScrollAction(firstItemOffset));
                let nextTake = this.firstLoaded + this.take;
                this.lastLoaded = Math.min(nextTake, this.total);
                nextTake = nextTake > this.total ? this.total - this.firstLoaded : this.take;
                observer.next(new PageAction(this.firstLoaded, this.take));
            }
            else {
                const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;
                if (atBottom) {
                    observer.next(new ScrollBottomAction());
                }
            }
        }
        if (up && firstItemIndex < this.firstLoaded) {
            const nonVisibleBuffer = Math.floor(this.take * 0.3);
            this.firstLoaded = Math.max(firstItemIndex - nonVisibleBuffer, 0);
            observer.next(new ScrollAction(this.rowHeightService.offset(this.firstLoaded)));
            this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
            observer.next(new PageAction(this.firstLoaded, this.take));
        }
    }
    unsubscribe() {
        if (this.scrollSubscription) {
            this.scrollSubscription.unsubscribe();
            this.scrollSubscription = undefined;
        }
    }
}

/**
 * @hidden
 */
const NON_DATA_CELL_CLASSES = 'k-hierarchy-cell k-detail-cell k-group-cell';
/**
 * @hidden
 */
const NON_DATA_ROW_CLASSES = 'k-grouping-row k-group-footer k-detail-row k-grid-norecords';
/**
 * @hidden
 */
const IGNORE_TARGET_CLASSSES = 'k-icon';
/**
 * @hidden
 */
const IGNORE_CONTAINER_CLASSES = 'k-grid k-grid-ignore-click';

const elementAt = (index, elements, elementOffset) => {
    for (let idx = 0, elementIdx = 0; idx < elements.length; idx++) {
        const offset = elementOffset(elements[idx]);
        if (elementIdx <= index && index <= elementIdx + offset - 1) {
            return elements[idx];
        }
        elementIdx += offset;
    }
};
const rowAt = (index, rows) => elementAt(index, rows, row => row.hasAttribute('data-kendo-grid-item-index') ? 1 : 0);
const cellAt = (index, cells) => elementAt(index, cells, cell => !hasClasses(cell, NON_DATA_CELL_CLASSES) ? parseInt(cell.getAttribute('colSpan'), 10) || 1 : 0);
const EMPTY_OBJECT = {};
/**
 * @hidden
 */
const SCROLLER_FACTORY_TOKEN = new InjectionToken('grid-scroll-service-factory');
/**
 * @hidden
 */
function DEFAULT_SCROLLER_FACTORY(observable) {
    return new ScrollerService(observable);
}
const wheelDeltaY = (e) => {
    const deltaY = e.wheelDeltaY;
    if (e.wheelDelta && (deltaY === undefined || deltaY)) {
        return e.wheelDelta;
    }
    else if (e.detail && e.axis === e.VERTICAL_AXIS) {
        return (-e.detail) * 10;
    }
    return 0;
};
const preventLockedScroll = (args, element) => {
    const delta = wheelDeltaY(args);
    const scrollTop = element.scrollTop;
    const allowScroll = (scrollTop === 0 && 0 < delta) || (element.scrollHeight <= element.offsetHeight + scrollTop && delta < 0);
    if (!allowScroll) {
        event.preventDefault();
    }
};
const translateY = (renderer, value) => el => renderer.setStyle(el, "transform", `translateY(${value}px)`);
const maybeNativeElement = el => el ? el.nativeElement : null;
const hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;
const setHeight$1 = renderer => ({ el, height }) => renderer.setStyle(el, "height", `${height}px`);
const bufferSize = 1;
/**
 * @hidden
 */
let ListComponent = class ListComponent {
    constructor(scrollerFactory, detailsService, changeNotification, suspendService, groupsService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, localization, columnResizingService, changeDetector, pdfService, columnInfo) {
        this.changeNotification = changeNotification;
        this.suspendService = suspendService;
        this.groupsService = groupsService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.scrollSyncService = scrollSyncService;
        this.resizeService = resizeService;
        this.editService = editService;
        this.supportService = supportService;
        this.navigationService = navigationService;
        this.localization = localization;
        this.columnResizingService = columnResizingService;
        this.changeDetector = changeDetector;
        this.pdfService = pdfService;
        this.columnInfo = columnInfo;
        this.groups = [];
        this.skip = 0;
        this.columns = new ColumnsContainer(() => []);
        this.selectable = false;
        this.groupable = false;
        this.trackBy = defaultTrackBy;
        this.contentScroll = new EventEmitter();
        this.pageChange = new EventEmitter();
        this.scrollBottom = new EventEmitter();
        this.columnsStartIdx = 0;
        this.resizeSensors = new QueryList();
        this.dispatcher = new Subject();
        this.containerScrollTop = 0;
        this.scrollLeft = 0;
        this.rtl = false;
        this.scroller = scrollerFactory(this.dispatcher);
        this.subscriptions = detailsService.changes.subscribe(x => this.detailExpand(x));
        this.subscriptions.add(scrollRequestService.requests.subscribe(x => this.scrollTo(x)));
    }
    get hostClass() {
        return true;
    }
    get hostRole() {
        return 'presentation';
    }
    get showFooter() {
        return this.groupable && this.groupable.showFooter;
    }
    get totalWidth() {
        if (this.virtualColumns && this.columns.unlockedWidth) {
            return this.columns.unlockedWidth;
        }
    }
    get lockedLeafColumns() {
        return this.columns.lockedLeafColumns;
    }
    get nonLockedLeafColumns() {
        return this.columns.nonLockedLeafColumns;
    }
    get nonLockedColumnsToRender() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.viewportColumns;
        }
        return this.nonLockedLeafColumns;
    }
    get leafColumns() {
        return this.columns.leafColumnsToRender;
    }
    get lockedWidth() {
        const groupCellsWidth = this.groups.length * GROUP_CELL_WIDTH;
        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
    }
    get nonLockedWidth() {
        if ((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) {
            return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));
        }
        return undefined;
    }
    get isLocked() {
        return this.lockedLeafColumns.length > 0;
    }
    ngOnInit() {
        this.init();
        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));
        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));
        this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {
            if (this.virtualColumns) {
                this.ngZone.run(() => {
                    this.updateViewportColumns();
                    this.changeDetector.markForCheck();
                });
            }
        }));
        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));
    }
    ngOnChanges(changes) {
        const hasInitialSkip = changes.skip && changes.skip.firstChange && changes.skip.currentValue > 0;
        if (hasInitialSkip) {
            this.handleInitialScrollToSkip();
        }
        if (isChanged("skip", changes) && !this.rebind) {
            this.skipScroll = true;
            this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
        }
        if (anyChanged(["total", "take"], changes)) {
            this.init();
        }
        this.rebind = false;
    }
    ngDoCheck() {
        if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {
            this.updateViewportColumns();
        }
    }
    ngAfterViewInit() {
        if (this.skip && this.isVirtual) {
            this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
        }
        this.resetNavigationViewport();
        this.attachContainerScroll();
        this.initResizeService();
    }
    ngAfterViewChecked() {
        const isLocked = this.isLocked;
        if (isLocked && !this.hasLockedContainer) {
            this.syncRowsHeight();
        }
        this.hasLockedContainer = isLocked;
    }
    syncRowsHeight() {
        if (this.lockedContainer) {
            syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        if (this.resizeService) {
            this.resizeService.destroy();
        }
        this.cleanupScroller();
    }
    init() {
        if (this.suspendService.scroll) {
            return;
        }
        this.rowHeightService = new RowHeightService(this.total, this.rowHeight, this.detailRowHeight);
        this.totalHeight = this.rowHeightService.totalHeight();
        if (!isUniversal()) {
            this.ngZone.runOutsideAngular(this.createScroller.bind(this));
        }
    }
    lockedScroll() {
        if (!this.suspendService.scroll) {
            const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;
            if (lockedScrollTop !== this.containerScrollTop) {
                this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;
            }
        }
    }
    lockedMousewheel(args) {
        if (!args.ctrlKey) {
            preventLockedScroll(args, this.container.nativeElement);
            const scrollDelta = wheelDeltaY(args);
            this.container.nativeElement.scrollTop -= scrollDelta;
        }
    }
    lockedKeydown(args) {
        if (args.keyCode === Keys.PageDown || args.keyCode === Keys.PageUp) {
            const dir = args.keyCode === Keys.PageDown ? 1 : -1;
            const element = this.container.nativeElement;
            element.scrollTop += element.offsetHeight * dir * 0.8;
            args.preventDefault();
        }
    }
    detailExpand({ index, expand }) {
        if (expand) {
            this.rowHeightService.expandDetail(index);
        }
        else {
            this.rowHeightService.collapseDetail(index);
        }
        this.totalHeight = this.rowHeightService.totalHeight();
        this.resetNavigationViewport();
    }
    attachContainerScroll() {
        if (isUniversal()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(fromEvent(this.container.nativeElement, 'scroll').pipe(map((event) => event.target), filter(() => !this.suspendService.scroll), tap((target) => {
                this.onContainerScroll(target);
                this.resetNavigationViewport();
                if (this.virtualColumns) {
                    this.handleColumnScroll();
                }
                const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;
                const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;
                this.contentScroll.emit({
                    scrollLeft: target.scrollLeft,
                    scrollTop: target.scrollTop,
                    startRow: rowViewport.firstItemIndex,
                    endRow: rowViewport.lastItemIndex,
                    startColumn: columnViewport.firstItemIndex,
                    endColumn: columnViewport.lastItemIndex
                });
            })).subscribe(this.dispatcher));
        });
        this.scrollSyncService.registerEmitter(this.container.nativeElement, "body");
    }
    createScroller() {
        this.cleanupScroller();
        const observable = this.scroller
            .create(this.rowHeightService, this.skip, this.take, this.total);
        this.skipScroll = false;
        this.scrollerSubscription = observable.pipe(filter((x) => x instanceof PageAction), filter(() => {
            const temp = this.skipScroll;
            this.skipScroll = false;
            return !temp;
        }), tap(() => this.rebind = true))
            .subscribe((x) => this.ngZone.run(() => this.pageChange.emit(x)));
        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollAction))
            .subscribe(this.scroll.bind(this)));
        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollBottomAction))
            .subscribe(() => this.scrollBottom.emit()));
    }
    scroll({ offset = 0 }) {
        if (this.isVirtual) {
            [
                maybeNativeElement(this.table),
                maybeNativeElement(this.lockedTable)
            ].filter(isPresent).forEach(translateY(this.renderer, offset));
        }
        this.resetNavigationViewport();
    }
    onContainerScroll({ scrollTop }) {
        this.containerScrollTop = scrollTop;
        if (this.lockedContainer) {
            this.lockedContainer.nativeElement.scrollTop = scrollTop;
        }
    }
    handleInitialScrollToSkip() {
        const shouldScroll = () => this.isVirtual && this.skip > 0 && this.total > 0;
        const sub = this.changeNotification.changes
            .pipe(filter(shouldScroll))
            .subscribe(_ => {
            this.scrollTo({ row: this.skip });
            sub.unsubscribe();
        });
    }
    handleRowSync() {
        const isLocked = () => isPresent(this.lockedContainer);
        const onStable = () => this.ngZone.onStable.asObservable().pipe(take(1));
        return merge(this.changeNotification.changes, this.groupsService.changes
            .pipe(filter(isLocked), switchMapTo(onStable())), this.editService.changed, this.resizeService.changes, this.columnResizingService.changes
            .pipe(filter(change => change.type === 'end')), this.supportService.changes)
            .pipe(tap(() => this.resetNavigationViewport()), filter(isLocked))
            .subscribe(() => {
            const scrollTop = this.container.nativeElement.scrollTop;
            const scrollLeft = this.container.nativeElement.scrollLeft;
            this.syncRowsHeight();
            this.syncContainerHeight();
            this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop;
            // fixes scroll left position in IE when editing
            this.container.nativeElement.scrollLeft = scrollLeft;
            this.resizeSensors.forEach(sensor => sensor.acceptSize());
        });
    }
    handleRowNavigationLocked() {
        return this.navigationService.changes.pipe(filter(() => isPresent(this.lockedContainer)), delay(10)).subscribe((args) => {
            if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {
                const cell = this.navigationService.activeCell;
                if (cell && cell.colIndex + cell.colSpan < args.prevColIndex) {
                    this.container.nativeElement.scrollLeft = 0;
                }
            }
        });
    }
    scrollToVirtualRow(itemIndex) {
        if (isPresent(this.detailTemplate)) {
            itemIndex = Math.floor(itemIndex / 2);
        }
        const offset = this.rowHeightService.offset(itemIndex);
        this.container.nativeElement.scrollTop = offset;
        this.resetNavigationViewport();
    }
    scrollTo({ row, column }) {
        if (isNumber(row)) {
            if (this.isVirtual) {
                this.scrollToVirtualRow(row);
            }
            else {
                const element = rowAt(row, this.table.nativeElement.rows);
                if (element) {
                    this.container.nativeElement.scrollTop = element.offsetTop;
                }
            }
        }
        if (isNumber(column)) {
            column -= this.lockedLeafColumns.length;
            if (this.virtualColumns) {
                const columns = this.columns.leafColumnsToRender;
                let offset = 0;
                for (let idx = 0; idx < column; idx++) {
                    offset += columns[idx].width || 0;
                }
                const startOffset = this.lockedLeafColumns.length ? 0 : this.groups.length * GROUP_CELL_WIDTH + (this.detailTemplate && column > 0 ? GROUP_CELL_WIDTH : 0);
                this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset + startOffset);
            }
            else if (column === 0 && this.detailTemplate) {
                this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(0);
            }
            else {
                const firstRow = rowAt(0, this.table.nativeElement.rows);
                if (firstRow) {
                    const element = cellAt(column, firstRow.cells);
                    if (element) {
                        this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);
                    }
                }
            }
        }
    }
    resetNavigationViewport() {
        if (!this.container || !this.navigationService.enabled ||
            !this.navigationService.needsViewport() || this.data.length === 0) {
            return;
        }
        const { scrollTop, offsetHeight } = this.container.nativeElement;
        const scrollBottom = scrollTop + offsetHeight;
        const firstItemIndex = this.rowHeightService.index(scrollTop);
        let lastItemIndex = this.rowHeightService.index(scrollBottom);
        const lastItemOffset = this.rowHeightService.offset(lastItemIndex);
        const lastItemOverflows = lastItemOffset + this.rowHeight > scrollBottom;
        if (lastItemIndex > 0 && lastItemOverflows) {
            lastItemIndex--;
        }
        let viewportStart = firstItemIndex;
        let viewportEnd = lastItemIndex;
        if (isPresent(this.detailTemplate)) {
            viewportStart *= 2;
            viewportEnd *= 2;
            const firstItemHeight = this.rowHeightService.offset(firstItemIndex);
            if (firstItemHeight + this.rowHeight < scrollTop) {
                viewportStart++;
            }
            const lastItemHeight = this.rowHeightService.height(lastItemIndex);
            const lastItemExpanded = this.rowHeightService.isExpanded(lastItemIndex);
            const lastItemDetailOverflows = lastItemOffset + lastItemHeight > scrollBottom;
            if (lastItemExpanded && !lastItemDetailOverflows) {
                viewportEnd++;
            }
        }
        this.navigationService.setViewport(viewportStart, viewportEnd);
    }
    cleanupScroller() {
        if (this.scrollerSubscription) {
            this.scrollerSubscription.unsubscribe();
        }
        if (this.scroller) {
            this.scroller.destroy();
        }
    }
    initResizeService() {
        this.resizeService.connect(merge(...this.resizeSensors.map(sensor => sensor.resize)));
    }
    syncContainerHeight() {
        [maybeNativeElement(this.lockedContainer)]
            .filter(isPresent)
            .map(el => {
            el.style.height = '';
            let height = this.container.nativeElement.offsetHeight;
            if (hasScrollbar(this.table, this.container)) {
                height -= this.supportService.scrollbarWidth;
            }
            return { el, height };
        })
            .forEach(setHeight$1(this.renderer));
    }
    updateViewportColumns(range) {
        const columns = this.columns.nonLockedLeafColumns.toArray();
        let { startIdx, endIdx, offset } = range || this.calculateViewportColumns();
        const start = Math.max(0, startIdx - bufferSize);
        const end = Math.min(endIdx + bufferSize, columns.length - 1);
        if (start < startIdx) {
            for (let idx = startIdx - 1; idx >= start; idx--) {
                offset -= columns[idx].width;
            }
        }
        let currentColumns = columns.slice(start, end + 1);
        this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);
        if (start > 0) {
            const offsetColumn = new ColumnBase$1();
            offsetColumn.width = offset;
            currentColumns.unshift(offsetColumn);
        }
        this.viewportColumns = new QueryList();
        this.viewportColumns.reset(currentColumns);
        this.columnsStartIdx = start;
        this.columnsEndIdx = end;
        this.columnInfo.columnRangeChange.emit({ start, end, offset });
        if (!range) {
            this.updateColumnViewport(startIdx, endIdx);
        }
    }
    handleColumnScroll() {
        const container = this.container.nativeElement;
        const scrollLeft = container.scrollLeft;
        if (this.scrollLeft !== scrollLeft) {
            this.scrollLeft = scrollLeft;
            const range = this.calculateViewportColumns();
            this.updateColumnViewport(range.startIdx, range.endIdx);
            if (range.startIdx < this.columnsStartIdx || this.columnsEndIdx < range.endIdx) {
                cancelAnimationFrame(this.columnUpdateFrame);
                this.columnUpdateFrame = requestAnimationFrame(() => {
                    this.ngZone.run(() => {
                        this.updateViewportColumns(range);
                        this.changeDetector.markForCheck();
                    });
                });
            }
        }
    }
    updateColumnViewport(startIdx, endIdx) {
        const lockedCount = this.lockedLeafColumns.length;
        const leafColumns$$1 = this.nonLockedLeafColumns.toArray();
        const viewportStart = lockedCount + startIdx + (this.detailTemplate && startIdx > 0 ? 1 : 0);
        let viewportEnd = lockedCount + endIdx + (this.detailTemplate ? 1 : 0);
        for (let idx = 0; idx < leafColumns$$1.length; idx++) {
            const column = leafColumns$$1[idx];
            if (column.isSpanColumn) {
                viewportEnd += column.childColumns.length;
            }
        }
        this.navigationService.setColumnViewport(viewportStart, viewportEnd);
    }
    calculateViewportColumns() {
        const { scrollLeft, clientWidth } = this.container.nativeElement;
        const columns = this.columns.nonLockedLeafColumns.toArray();
        const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);
        const viewportEnd = normalizedScrollLeft + clientWidth;
        let startIdx;
        let endIdx = 0;
        let current = 0;
        let offset = 0;
        let idx;
        for (idx = 0; idx < columns.length; idx++) {
            const column = columns[idx];
            current += column.width || 0;
            if (startIdx === undefined && current > normalizedScrollLeft) {
                startIdx = idx;
                offset = current - (column.width || 0);
            }
            if (current >= viewportEnd) {
                endIdx = idx;
                break;
            }
        }
        if (!endIdx && idx > 0) {
            endIdx = columns.length - 1;
        }
        return { startIdx, endIdx, offset };
    }
    viewportWidthChange() {
        const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);
        return currentWidth !== this.viewportColumnsWidth;
    }
    normalizeScrollLeft(position) {
        return this.rtl ? rtlScrollPosition(position, this.container.nativeElement, this.supportService.rtlScrollLeft) : position;
    }
    elementScrollLeft(element) {
        if (this.rtl) {
            return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);
        }
        return element.offsetLeft;
    }
};
ListComponent.ɵfac = function ListComponent_Factory(t) { return new (t || ListComponent)(ɵngcc0.ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), ɵngcc0.ɵɵdirectiveInject(DetailsService), ɵngcc0.ɵɵdirectiveInject(ChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(SuspendService), ɵngcc0.ɵɵdirectiveInject(GroupsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ScrollSyncService), ɵngcc0.ɵɵdirectiveInject(ResizeService), ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(BrowserSupportService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ScrollRequestService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PDFService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService)); };
ListComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ListComponent, selectors: [["kendo-grid-list"]], viewQuery: function ListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c143, 7);
        ɵngcc0.ɵɵviewQuery(_c144, 5);
        ɵngcc0.ɵɵviewQuery(_c145, 5);
        ɵngcc0.ɵɵviewQuery(_c146, 7);
        ɵngcc0.ɵɵviewQuery(ResizeSensorComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lockedContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lockedTable = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.table = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeSensors = _t);
    } }, hostVars: 3, hostBindings: function ListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.hostRole);
        ɵngcc0.ɵɵclassProp("k-grid-container", ctx.hostClass);
    } }, inputs: { groups: "groups", skip: "skip", columns: "columns", selectable: "selectable", groupable: "groupable", trackBy: "trackBy", data: "data", total: "total", rowHeight: "rowHeight", stickyRowHeight: "stickyRowHeight", detailRowHeight: "detailRowHeight", take: "take", detailTemplate: "detailTemplate", noRecordsTemplate: "noRecordsTemplate", filterable: "filterable", rowClass: "rowClass", rowSticky: "rowSticky", loading: "loading", virtualColumns: "virtualColumns", isVirtual: "isVirtual", cellLoadingTemplate: "cellLoadingTemplate", loadingTemplate: "loadingTemplate" }, outputs: { contentScroll: "contentScroll", pageChange: "pageChange", scrollBottom: "scrollBottom" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: SCROLLER_FACTORY_TOKEN,
                useValue: DEFAULT_SCROLLER_FACTORY
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 13, vars: 35, consts: [["class", "k-grid-content-locked", "role", "presentation", "tabindex", "-1", 3, "width", "kendoEventsOutsideAngular", "scope", 4, "ngIf"], ["role", "presentation", "tabindex", "-1", 1, "k-grid-content", "k-virtual-content", 3, "kendoGridResizableContainer", "lockedWidth"], ["container", ""], ["role", "presentation", 1, "k-grid-table-wrap"], ["role", "presentation", 1, "k-grid-table", 3, "virtualColumns"], ["table", ""], ["kendoGridColGroup", "", "role", "presentation", 3, "groups", "columns", "detailTemplate"], ["kendoGridTableBody", "", "role", "presentation", 3, "skipGroupDecoration", "data", "groups", "showGroupFooters", "columns", "allColumns", "detailTemplate", "noRecordsTemplate", "lockedColumnsCount", "totalColumnsCount", "skip", "selectable", "trackBy", "filterable", "rowClass", "rowSticky", "virtualColumns", "isLoading", "isVirtual", "cellLoadingTemplate"], [4, "ngIf"], ["role", "presentation", 1, "k-height-container"], ["class", "k-width-container", "role", "presentation", 4, "ngIf"], ["role", "presentation", "tabindex", "-1", 1, "k-grid-content-locked", 3, "kendoEventsOutsideAngular", "scope"], ["lockedContainer", ""], ["role", "presentation", 1, "k-grid-table", 3, "locked"], ["lockedTable", ""], ["kendoGridTableBody", "", "role", "presentation", 3, "groups", "isLocked", "data", "noRecordsText", "columns", "totalColumnsCount", "detailTemplate", "showGroupFooters", "skip", "selectable", "trackBy", "filterable", "rowClass", "isLoading", "isVirtual", "cellLoadingTemplate"], ["role", "presentation", 1, "k-width-container"]], template: function ListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ListComponent_div_0_Template, 10, 33, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2)(3, "div", 3)(4, "table", 4, 5);
        ɵngcc0.ɵɵelement(6, "colgroup", 6)(7, "tbody", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, ListComponent_kendo_resize_sensor_8_Template, 1, 0, "kendo-resize-sensor", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, ListComponent_kendo_resize_sensor_9_Template, 1, 0, "kendo-resize-sensor", 8);
        ɵngcc0.ɵɵelementStart(10, "div", 9);
        ɵngcc0.ɵɵelement(11, "div");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, ListComponent_div_12_Template, 2, 2, "div", 10);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isLocked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("kendoGridResizableContainer", ctx.lockedLeafColumns.length)("lockedWidth", ctx.lockedWidth + 1);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("width", ctx.nonLockedWidth, "px");
        ɵngcc0.ɵɵproperty("virtualColumns", ctx.virtualColumns);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("groups", ctx.isLocked ? ɵngcc0.ɵɵpureFunction0(34, _c142) : ctx.groups)("columns", ctx.nonLockedColumnsToRender)("detailTemplate", ctx.detailTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("skipGroupDecoration", ctx.isLocked)("data", ctx.data)("groups", ctx.groups)("showGroupFooters", ctx.showFooter)("columns", ctx.nonLockedColumnsToRender)("allColumns", ctx.nonLockedLeafColumns)("detailTemplate", ctx.detailTemplate)("noRecordsTemplate", ctx.noRecordsTemplate)("lockedColumnsCount", ctx.lockedLeafColumns.length)("totalColumnsCount", ctx.leafColumns.length)("skip", ctx.skip)("selectable", ctx.selectable)("trackBy", ctx.trackBy)("filterable", ctx.filterable)("rowClass", ctx.rowClass)("rowSticky", ctx.rowSticky)("virtualColumns", ctx.virtualColumns)("isLoading", ctx.loading)("isVirtual", ctx.isVirtual)("cellLoadingTemplate", ctx.cellLoadingTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isLocked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isLocked || ctx.virtualColumns);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", ctx.totalHeight, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.virtualColumns);
    } }, directives: function () { return [ɵngcc5.NgIf, ɵngcc2.EventsOutsideAngularDirective, TableDirective, ColGroupComponent, TableBodyComponent, ɵngcc2.ResizeSensorComponent, ResizableContainerDirective]; }, encapsulation: 2 });
__decorate([
    HostBinding("class.k-grid-container"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ListComponent.prototype, "hostClass", null);
__decorate([
    HostBinding("attr.role"),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ListComponent.prototype, "hostRole", null);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ListComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ListComponent.prototype, "groups", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ListComponent.prototype, "total", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ListComponent.prototype, "rowHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ListComponent.prototype, "stickyRowHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ListComponent.prototype, "detailRowHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ListComponent.prototype, "take", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ListComponent.prototype, "skip", void 0);
__decorate([
    Input(),
    __metadata("design:type", ColumnsContainer)
], ListComponent.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", DetailTemplateDirective)
], ListComponent.prototype, "detailTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", NoRecordsTemplateDirective)
], ListComponent.prototype, "noRecordsTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ListComponent.prototype, "selectable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ListComponent.prototype, "groupable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ListComponent.prototype, "filterable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ListComponent.prototype, "rowClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ListComponent.prototype, "rowSticky", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ListComponent.prototype, "loading", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ListComponent.prototype, "trackBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ListComponent.prototype, "virtualColumns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ListComponent.prototype, "isVirtual", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ListComponent.prototype, "cellLoadingTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ListComponent.prototype, "loadingTemplate", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ListComponent.prototype, "contentScroll", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ListComponent.prototype, "pageChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ListComponent.prototype, "scrollBottom", void 0);
__decorate([
    ViewChild('container', { static: true }),
    __metadata("design:type", ElementRef)
], ListComponent.prototype, "container", void 0);
__decorate([
    ViewChild('lockedContainer', { static: false }),
    __metadata("design:type", ElementRef)
], ListComponent.prototype, "lockedContainer", void 0);
__decorate([
    ViewChild('lockedTable', { static: false }),
    __metadata("design:type", ElementRef)
], ListComponent.prototype, "lockedTable", void 0);
__decorate([
    ViewChild('table', { static: true }),
    __metadata("design:type", ElementRef)
], ListComponent.prototype, "table", void 0);
__decorate([
    ViewChildren(ResizeSensorComponent),
    __metadata("design:type", QueryList)
], ListComponent.prototype, "resizeSensors", void 0);
ListComponent = __decorate([ __param(0, Inject(SCROLLER_FACTORY_TOKEN)),
    __metadata("design:paramtypes", [Object, DetailsService,
        ChangeNotificationService,
        SuspendService,
        GroupsService,
        NgZone,
        Renderer2,
        ScrollSyncService,
        ResizeService,
        EditService,
        BrowserSupportService,
        NavigationService,
        ScrollRequestService,
        LocalizationService,
        ColumnResizingService,
        ChangeDetectorRef,
        PDFService,
        ColumnInfoService])
], ListComponent);

/**
 * A directive which encapsulates the in-memory handling of data operations such as [paging]({% slug paging_grid %}),
 * [sorting]({% slug sorting_grid %}), and [grouping]({% slug groupingbasics_grid %})
 * ([more information and examples]({% slug automaticoperations_grid %})).
 */
let DataBindingDirective = class DataBindingDirective {
    constructor(grid, changeDetector, localDataChangesService) {
        this.grid = grid;
        this.changeDetector = changeDetector;
        this.localDataChangesService = localDataChangesService;
        this.state = {
            skip: 0
        };
        this.originalData = [];
        if (localDataChangesService) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));
        }
    }
    /**
     * Defines the number of records that will be skipped by the pager.
     */
    set skip(value) {
        if (!isPresent(value)) {
            value = 0;
        }
        this.grid.skip = this.state.skip = value;
    }
    /**
     * Defines the descriptors by which the data will be sorted.
     */
    set sort(value) {
        this.grid.sort = this.state.sort = value;
    }
    /**
     * Defines the descriptor by which the data will be filtered.
     */
    set filter(value) {
        this.grid.filter = this.state.filter = value;
    }
    /**
     * Defines the page size used by the Grid pager.
     */
    set pageSize(value) {
        this.grid.pageSize = this.state.take = value;
    }
    /**
     * The descriptors by which the data will be grouped.
     */
    set group(value) {
        this.grid.group = this.state.group = value;
    }
    /**
     * The array of data which will be used to populate the Grid.
     */
    set data(value) {
        this.originalData = value || [];
        if (this.localDataChangesService) {
            this.localDataChangesService.data = value;
        }
        this.dataChanged = true;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.applyState(this.state);
        this.stateChangeSubscription = this.grid
            .dataStateChange
            .subscribe(this.onStateChange.bind(this));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.stateChangeSubscription) {
            this.stateChangeSubscription.unsubscribe();
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (anyChanged(["pageSize", "skip", "sort", "group", "filter"], changes)) {
            this.rebind();
        }
    }
    ngDoCheck() {
        if (this.dataChanged) {
            this.updateGridData();
        }
    }
    /**
     * @hidden
     */
    onStateChange(state$$1) {
        this.applyState(state$$1);
        this.rebind();
    }
    /**
     * @hidden
     */
    rebind() {
        this.data = this.originalData;
        this.updateGridData();
        this.notifyDataChange();
    }
    /**
     * Notifies the Grid that its data has changed.
     */
    notifyDataChange() {
        this.grid.onDataChange();
        if (this.changeDetector) {
            this.changeDetector.markForCheck();
        }
    }
    process(state$$1) {
        return process(this.originalData, state$$1);
    }
    applyState({ skip, take: take$$1, sort, group, filter: filter$$1 }) {
        this.skip = skip;
        this.pageSize = take$$1;
        this.sort = sort;
        this.group = group;
        this.filter = filter$$1;
    }
    updateGridData() {
        this.grid.data = this.process(this.state);
        this.dataChanged = false;
    }
};
DataBindingDirective.ɵfac = function DataBindingDirective_Factory(t) { return new (t || DataBindingDirective)(ɵngcc0.ɵɵdirectiveInject(GridComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(LocalDataChangesService)); };
DataBindingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DataBindingDirective, selectors: [["", "kendoGridBinding", ""]], inputs: { skip: "skip", sort: "sort", filter: "filter", pageSize: "pageSize", group: "group", data: ["kendoGridBinding", "data"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], DataBindingDirective.prototype, "skip", null);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], DataBindingDirective.prototype, "sort", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DataBindingDirective.prototype, "filter", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], DataBindingDirective.prototype, "pageSize", null);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], DataBindingDirective.prototype, "group", null);
__decorate([
    Input("kendoGridBinding"),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], DataBindingDirective.prototype, "data", null);
DataBindingDirective = __decorate([ __metadata("design:paramtypes", [GridComponent,
        ChangeDetectorRef,
        LocalDataChangesService])
], DataBindingDirective);

/**
 * A directive which stores the row selection state of the Grid in memory
 * ([see example]({% slug selection_grid %}#toc-during-data-operations)).
 */
let SelectionDirective = class SelectionDirective extends Selection {
    constructor(grid, cd) {
        super(grid, cd);
        this.grid = grid;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.grid.selectable === false) {
            this.grid.selectable = true;
        }
        this.grid.selectionDirective = this;
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        super.destroy();
    }
};
SelectionDirective.ɵfac = function SelectionDirective_Factory(t) { return new (t || SelectionDirective)(ɵngcc0.ɵɵdirectiveInject(GridComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
SelectionDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SelectionDirective, selectors: [["", "kendoGridSelectBy", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
SelectionDirective = __decorate([ __metadata("design:paramtypes", [GridComponent, ChangeDetectorRef])
], SelectionDirective);

/**
 * A directive which controls the expanded state of the master detail rows.
 */
let ExpandDetailsDirective = class ExpandDetailsDirective {
    constructor(grid) {
        this.grid = grid;
        /**
         * Fires when the expandedDetailKeys are changed.
         */
        this.expandedDetailKeysChange = new EventEmitter();
        /**
         * Defines the collection that will store the expanded keys.
         */
        this.expandedDetailKeys = [];
        /**
         * Specifies if the items should be initially expanded.
         * When set to `true` items added to the `expandedDetailKeys` collection will be collapsed, and items that are not present in it will be expanded.
         *
         * @default false
         */
        this.initiallyExpanded = false;
        this.expandedState = new Set();
        this.subscriptions = new Subscription();
        this.grid.isDetailExpanded = this.isExpanded.bind(this);
        this.subscriptions.add(merge(this.grid.detailExpand.pipe(map(e => (Object.assign({ expand: true }, e)))), this.grid.detailCollapse.pipe(map(e => (Object.assign({ expand: false }, e))))).subscribe(this.toggleState.bind(this)));
    }
    /**
     * Defines the item key that will be stored in the `expandedDetailKeys` collection ([see example]({% slug master_detail_expanded_state_grid %}#toc-built-in-directive)).
     */
    get expandDetailsKey() {
        return this._expandBy;
    }
    set expandDetailsKey(key) {
        if (isString(key)) {
            this._expandBy = getter(key);
        }
        else {
            this._expandBy = key;
        }
    }
    /**
     *
     * @hidden
     * A deprecated alias for setting the `expandDetailsKey` property.
     */
    get expandDetailBy() {
        return this.expandDetailsKey;
    }
    set expandDetailBy(key) {
        this.expandDetailsKey = key;
    }
    ngOnChanges(changes) {
        // skip reinitialization if the user data is the same as the last state change
        if (isPresent(changes.expandedDetailKeys) && this.lastExpandedState !== this.expandedDetailKeys) {
            this.expandedState = new Set(this.expandedDetailKeys);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    get keyGetter() {
        return this._expandBy || getter(undefined);
    }
    /**
     * @hidden
     */
    isExpanded(args) {
        const key = this.keyGetter(args.dataItem);
        const hasKey = this.expandedState.has(key);
        // when [initiallyExpanded]="true" a present key means the corresponding detail row is collapsed
        return this.initiallyExpanded ? !hasKey : hasKey;
    }
    toggleState(args) {
        const key = this.keyGetter(args.dataItem);
        if (Boolean(this.initiallyExpanded) !== args.expand) {
            this.expandedState.add(key);
        }
        else {
            this.expandedState.delete(key);
        }
        this.notifyChange();
    }
    notifyChange() {
        this.lastExpandedState = Array.from(this.expandedState);
        this.expandedDetailKeysChange.emit(this.lastExpandedState);
    }
};
ExpandDetailsDirective.ɵfac = function ExpandDetailsDirective_Factory(t) { return new (t || ExpandDetailsDirective)(ɵngcc0.ɵɵdirectiveInject(GridComponent)); };
ExpandDetailsDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ExpandDetailsDirective, selectors: [["", "kendoGridExpandDetailsBy", ""]], inputs: { expandedDetailKeys: "expandedDetailKeys", initiallyExpanded: "initiallyExpanded", expandDetailsKey: ["kendoGridExpandDetailsBy", "expandDetailsKey"], expandDetailBy: "expandDetailBy" }, outputs: { expandedDetailKeysChange: "expandedDetailKeysChange" }, exportAs: ["kendoGridExpandDetailsBy"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ExpandDetailsDirective.prototype, "expandedDetailKeysChange", void 0);
__decorate([
    Input('kendoGridExpandDetailsBy'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ExpandDetailsDirective.prototype, "expandDetailsKey", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ExpandDetailsDirective.prototype, "expandDetailBy", null);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ExpandDetailsDirective.prototype, "expandedDetailKeys", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ExpandDetailsDirective.prototype, "initiallyExpanded", void 0);
ExpandDetailsDirective = __decorate([ __metadata("design:paramtypes", [GridComponent])
], ExpandDetailsDirective);

const mapParentGroup = (parentGroup) => {
    const parentGroupKeys = [];
    while (parentGroup) {
        parentGroupKeys.push({ field: parentGroup.group.field, value: parentGroup.group.value });
        parentGroup = parentGroup.parentGroup;
    }
    return parentGroupKeys;
};
const DEFAULT_KEY_GETTER = (groupRowArgs) => ({
    field: groupRowArgs.group.field,
    value: groupRowArgs.group.value,
    parentGroupKeys: mapParentGroup(groupRowArgs.parentGroup)
});
/**
 * A directive which controls the expanded state of the group rows
 * ([see example]({% slug groups_expanded_state_grid %}#toc-built-in-directive)).
 */
let ExpandGroupDirective = class ExpandGroupDirective {
    constructor(grid) {
        this.grid = grid;
        /**
         * Fires when the expandedGroupKeys are changed.
         */
        this.expandedGroupKeysChange = new EventEmitter();
        /**
         * Specifies if the group items should be initially expanded.
         * @default false
         */
        this.groupsInitiallyExpanded = false;
        this.subscriptions = new Subscription();
        this.grid.isGroupExpanded = this.isExpanded.bind(this);
        this.subscriptions.add(merge(this.grid.groupExpand.pipe(map(e => (Object.assign({ expand: true }, e)))), this.grid.groupCollapse.pipe(map(e => (Object.assign({ expand: false }, e))))).subscribe(this.toggleState.bind(this)));
    }
    /**
     * Defines the item format that will be stored in the `expandedGroupKeys`
     * ([see example]({% slug groups_expanded_state_grid %}#toc-custom-group-key-format)).
     */
    get expandGroupBy() {
        return this._expandGroupBy;
    }
    set expandGroupBy(key) {
        if (typeof key === 'function') {
            this._expandGroupBy = key;
        }
    }
    /**
     * Defines the collection that will store the expanded group keys.
     */
    get expandedGroupKeys() {
        return this._expandedGroupKeys;
    }
    set expandedGroupKeys(expandedGroups) {
        this._expandedGroupKeys = (expandedGroups || []).slice();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    get keyGetter() {
        return this.expandGroupBy || DEFAULT_KEY_GETTER;
    }
    /**
     * @hidden
     */
    isExpanded(groupArgs) {
        const itemIndex = this.getItemIndex(groupArgs);
        return itemIndex > -1 ? !this.groupsInitiallyExpanded : this.groupsInitiallyExpanded;
    }
    getItemIndex(groupArgs) {
        if (this.expandGroupBy) {
            return this.expandedGroupKeys.indexOf(this.keyGetter(groupArgs));
        }
        return this.expandedGroupKeys.findIndex(item => {
            let index = 0;
            let parentGroup = groupArgs.parentGroup;
            while (isPresent(parentGroup)) {
                if (!isPresent(item.parentGroupKeys) || !isPresent(item.parentGroupKeys[index]) ||
                    parentGroup.group.value !== item.parentGroupKeys[index].value ||
                    parentGroup.group.field !== item.parentGroupKeys[index].field) {
                    return false;
                }
                parentGroup = parentGroup.parentGroup;
                index++;
            }
            return item.value === groupArgs.group.value && item.field === groupArgs.group.field;
        });
    }
    toggleState(groupArgs) {
        const key = this.keyGetter(groupArgs);
        if (Boolean(this.groupsInitiallyExpanded) !== groupArgs.expand) {
            this.expandedGroupKeys.push(key);
        }
        else {
            const index = this.expandedGroupKeys.indexOf(key);
            this.expandedGroupKeys.splice(index, 1);
        }
        this.expandedGroupKeysChange.emit(this.expandedGroupKeys.slice());
    }
};
ExpandGroupDirective.ɵfac = function ExpandGroupDirective_Factory(t) { return new (t || ExpandGroupDirective)(ɵngcc0.ɵɵdirectiveInject(GridComponent)); };
ExpandGroupDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ExpandGroupDirective, selectors: [["", "kendoGridExpandGroupBy", ""]], inputs: { groupsInitiallyExpanded: "groupsInitiallyExpanded", expandGroupBy: ["kendoGridExpandGroupBy", "expandGroupBy"], expandedGroupKeys: "expandedGroupKeys" }, outputs: { expandedGroupKeysChange: "expandedGroupKeysChange" }, exportAs: ["kendoGridExpandGroupBy"] });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ExpandGroupDirective.prototype, "expandedGroupKeysChange", void 0);
__decorate([
    Input('kendoGridExpandGroupBy'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ExpandGroupDirective.prototype, "expandGroupBy", null);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], ExpandGroupDirective.prototype, "expandedGroupKeys", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ExpandGroupDirective.prototype, "groupsInitiallyExpanded", void 0);
ExpandGroupDirective = __decorate([ __metadata("design:paramtypes", [GridComponent])
], ExpandGroupDirective);

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = /*@__PURE__*/ function () { let ɵMessages_BaseFactory; return function Messages_Factory(t) { return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages)))(t || Messages); }; }();
Messages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: Messages, inputs: { groupPanelEmpty: "groupPanelEmpty", noRecords: "noRecords", pagerLabel: "pagerLabel", pagerFirstPage: "pagerFirstPage", pagerLastPage: "pagerLastPage", pagerPreviousPage: "pagerPreviousPage", pagerNextPage: "pagerNextPage", pagerPage: "pagerPage", pagerItemsPerPage: "pagerItemsPerPage", pagerOf: "pagerOf", pagerItems: "pagerItems", pagerPageNumberInputTitle: "pagerPageNumberInputTitle", filter: "filter", filterInputLabel: "filterInputLabel", filterMenuTitle: "filterMenuTitle", filterMenuOperatorsDropDownLabel: "filterMenuOperatorsDropDownLabel", filterMenuLogicDropDownLabel: "filterMenuLogicDropDownLabel", filterEqOperator: "filterEqOperator", filterNotEqOperator: "filterNotEqOperator", filterIsNullOperator: "filterIsNullOperator", filterIsNotNullOperator: "filterIsNotNullOperator", filterIsEmptyOperator: "filterIsEmptyOperator", filterIsNotEmptyOperator: "filterIsNotEmptyOperator", filterStartsWithOperator: "filterStartsWithOperator", filterContainsOperator: "filterContainsOperator", filterNotContainsOperator: "filterNotContainsOperator", filterEndsWithOperator: "filterEndsWithOperator", filterGteOperator: "filterGteOperator", filterGtOperator: "filterGtOperator", filterLteOperator: "filterLteOperator", filterLtOperator: "filterLtOperator", filterIsTrue: "filterIsTrue", filterIsFalse: "filterIsFalse", filterBooleanAll: "filterBooleanAll", filterAfterOrEqualOperator: "filterAfterOrEqualOperator", filterAfterOperator: "filterAfterOperator", filterBeforeOperator: "filterBeforeOperator", filterBeforeOrEqualOperator: "filterBeforeOrEqualOperator", filterFilterButton: "filterFilterButton", filterClearButton: "filterClearButton", filterAndLogic: "filterAndLogic", filterOrLogic: "filterOrLogic", loading: "loading", gridLabel: "gridLabel", columnMenu: "columnMenu", setColumnPosition: "setColumnPosition", columns: "columns", lock: "lock", unlock: "unlock", stick: "stick", unstick: "unstick", sortable: "sortable", sortAscending: "sortAscending", sortDescending: "sortDescending", sortedAscending: "sortedAscending", sortedDescending: "sortedDescending", sortedDefault: "sortedDefault", columnsApply: "columnsApply", columnsReset: "columnsReset", detailExpand: "detailExpand", detailCollapse: "detailCollapse", filterDateToday: "filterDateToday", filterDateToggle: "filterDateToggle", filterNumericDecrement: "filterNumericDecrement", filterNumericIncrement: "filterNumericIncrement", selectionCheckboxLabel: "selectionCheckboxLabel", selectAllCheckboxLabel: "selectAllCheckboxLabel", groupCollapse: "groupCollapse", groupExpand: "groupExpand" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "groupPanelEmpty", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "noRecords", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerFirstPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerLastPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerPreviousPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerNextPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerItemsPerPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerOf", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerItems", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "pagerPageNumberInputTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterInputLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterMenuTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterMenuOperatorsDropDownLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterMenuLogicDropDownLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterEqOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterNotEqOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterIsNullOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterIsNotNullOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterIsEmptyOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterIsNotEmptyOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterStartsWithOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterContainsOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterNotContainsOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterEndsWithOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterGteOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterGtOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterLteOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterLtOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterIsTrue", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterIsFalse", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterBooleanAll", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterAfterOrEqualOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterAfterOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterBeforeOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterBeforeOrEqualOperator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterFilterButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterClearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterAndLogic", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterOrLogic", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "loading", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "gridLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "columnMenu", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "setColumnPosition", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "lock", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "unlock", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "stick", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "unstick", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "sortable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "sortAscending", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "sortDescending", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "sortedAscending", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "sortedDescending", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "sortedDefault", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "columnsApply", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "columnsReset", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "detailExpand", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "detailCollapse", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterDateToday", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterDateToggle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterNumericDecrement", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "filterNumericIncrement", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "selectionCheckboxLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "selectAllCheckboxLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "groupCollapse", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "groupExpand", void 0);

var LocalizedMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedMessagesDirective = LocalizedMessagesDirective_1 = class LocalizedMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) { return new (t || LocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedMessagesDirective, selectors: [["", "kendoGridLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedMessagesDirective_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedMessagesDirective = LocalizedMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedMessagesDirective);

var CustomMessagesComponent_1;
/**
 * Custom component messages override default component messages
 * ([see example]({% slug globalization_grid %}#toc-localization)).
 */
let CustomMessagesComponent = CustomMessagesComponent_1 = class CustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) { return new (t || CustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
CustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CustomMessagesComponent, selectors: [["kendo-grid-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => CustomMessagesComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
CustomMessagesComponent = CustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], CustomMessagesComponent);

/**
 * @hidden
 */
let FilterRowComponent = class FilterRowComponent {
    constructor(localization, columnInfoService) {
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.columns = [];
        this.groups = [];
        this.filterRowClass = true;
    }
    addStickyStyles(column) {
        const sticky = column.sticky ? this.columnInfoService.stickyColumnsStyles(column) : null;
        return Object.assign({}, sticky, column.filterStyle);
    }
    filterLabel(column) {
        const localizationMsg = this.localization.get('filterInputLabel') || '';
        const columnName = column.title || column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
FilterRowComponent.ɵfac = function FilterRowComponent_Factory(t) { return new (t || FilterRowComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService)); };
FilterRowComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FilterRowComponent, selectors: [["", "kendoGridFilterRow", ""]], hostVars: 2, hostBindings: function FilterRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filter-row", ctx.filterRowClass);
    } }, inputs: { columns: "columns", groups: "groups", filter: "filter", detailTemplate: "detailTemplate", logicalRowIndex: "logicalRowIndex", lockedColumnsCount: "lockedColumnsCount" }, attrs: _c148, decls: 3, vars: 3, consts: [["role", "presentation", 3, "k-group-cell", 4, "ngFor", "ngForOf"], ["role", "presentation", 3, "k-hierarchy-cell", 4, "ngIf"], ["kendoGridFilterCell", "", "kendoGridLogicalCell", "", 3, "k-grid-header-sticky", "ngStyle", "ngClass", "column", "filter", "logicalRowIndex", "logicalColIndex", 4, "ngFor", "ngForOf"], ["role", "presentation"], ["kendoGridFilterCell", "", "kendoGridLogicalCell", "", 3, "ngStyle", "ngClass", "column", "filter", "logicalRowIndex", "logicalColIndex"]], template: function FilterRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FilterRowComponent_td_0_Template, 1, 2, "td", 0);
        ɵngcc0.ɵɵtemplate(1, FilterRowComponent_td_1_Template, 1, 2, "td", 1);
        ɵngcc0.ɵɵtemplate(2, FilterRowComponent_td_2_Template, 1, 9, "td", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.groups);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.columns);
    } }, directives: function () { return [ɵngcc5.NgForOf, ɵngcc5.NgIf, FilterCellComponent, LogicalCellDirective, ɵngcc5.NgStyle, ɵngcc5.NgClass]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], FilterRowComponent.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FilterRowComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], FilterRowComponent.prototype, "groups", void 0);
__decorate([
    Input(),
    __metadata("design:type", DetailTemplateDirective)
], FilterRowComponent.prototype, "detailTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FilterRowComponent.prototype, "logicalRowIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FilterRowComponent.prototype, "lockedColumnsCount", void 0);
__decorate([
    HostBinding('class.k-filter-row'),
    __metadata("design:type", Boolean)
], FilterRowComponent.prototype, "filterRowClass", void 0);
FilterRowComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ColumnInfoService])
], FilterRowComponent);

const areDifferent = (a, b) => a.field !== b.field || a.operator !== b.operator || a.value !== b.value;
const isChanged$1 = (a, b) => {
    if (a.length !== b.length) {
        return true;
    }
    for (let idx = 0, len = a.length; idx < len; idx++) {
        const prev = a[idx];
        const curr = b[idx];
        if (isCompositeFilterDescriptor(prev)) {
            // tslint:disable-next-line:no-use-before-declare
            if (diffFilters(prev, curr[idx])) {
                return true;
            }
        }
        else if (areDifferent(prev, curr)) {
            return true;
        }
    }
    return false;
};
const copyObject = (obj) => {
    const result = {};
    Object.assign(result, obj);
    if (obj.constructor !== Object) {
        const proto = obj.constructor.prototype;
        Object.getOwnPropertyNames(proto).forEach((property) => {
            if (property !== 'constructor' && proto.hasOwnProperty(property)) {
                result[property] = obj[property];
            }
        });
    }
    return result;
};
const cloneFilter = (filter$$1) => copyObject(filter$$1);
/**
 * @hidden
 */
const cloneFilters = (filter$$1) => {
    if (!filter$$1) {
        return;
    }
    if (isCompositeFilterDescriptor(filter$$1)) {
        return {
            filters: cloneFilters(filter$$1.filters),
            logic: filter$$1.logic
        };
    }
    else if (Array.isArray(filter$$1)) {
        return filter$$1.map(cloneFilters);
    }
    return cloneFilter(filter$$1);
};
/**
 * @hidden
 */
const diffFilters = (a, b) => {
    if (isPresent(a) && !isPresent(b)) {
        return true;
    }
    if (!isPresent(a) && isPresent(b)) {
        return true;
    }
    return isPresent(a) && isPresent(b) && isChanged$1(a.filters, b.filters);
};

/**
 * @hidden
 */
let FilterCellComponent = class FilterCellComponent {
    /**
     * @hidden
     */
    constructor() {
        this._templateContext = {};
    }
    get filter() {
        return this._filter;
    }
    set filter(value) {
        this._filter = cloneFilters(value);
    }
    get templateContext() {
        this._templateContext.column = this.column;
        this._templateContext.filter = this.filter;
        // tslint:disable-next-line:no-string-literal
        this._templateContext["$implicit"] = this.filter;
        return this._templateContext;
    }
    get hasTemplate() {
        return isPresent(this.column.filterCellTemplateRef);
    }
    get isFilterable() {
        return isPresent(this.column) && !isNullOrEmptyString(this.column.field) && this.column.filterable;
    }
};
FilterCellComponent.ɵfac = function FilterCellComponent_Factory(t) { return new (t || FilterCellComponent)(); };
FilterCellComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FilterCellComponent, selectors: [["", "kendoGridFilterCell", ""]], inputs: { filter: "filter", column: "column" }, attrs: _c149, decls: 1, vars: 1, consts: [[3, "ngIf"], [3, "ngSwitch"], [4, "ngSwitchCase"], ["kendoFilterCellHost", "", 3, "column", "filter"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function FilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FilterCellComponent_ng_template_0_Template, 3, 3, "ng-template", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isFilterable);
    } }, directives: function () { return [ɵngcc5.NgIf, ɵngcc5.NgSwitch, ɵngcc5.NgSwitchCase, FilterCellHostDirective, ɵngcc5.NgTemplateOutlet]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], FilterCellComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], FilterCellComponent.prototype, "filter", null);

const localizeOperators = operators => localization => Object.keys(operators).reduce((acc, key) => {
    acc[operators[key]] = localization.get(key);
    return acc;
}, {}); // tslint:disable-line:align
const operatorTexts = localizeOperators({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterGteOperator": "gte",
    "filterGtOperator": "gt",
    "filterLteOperator": "lte",
    "filterLtOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty",
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterAfterOrEqualOperator": "after-eq",
    "filterAfterOperator": "after",
    "filterBeforeOrEqualOperator": "before-eq",
    "filterBeforeOperator": "before"
});
/**
 * @hidden
 */
const toJSON = (xs) => xs.map(x => x.toJSON());
/**
 * @hidden
 */
class FilterOperatorBase {
    constructor(operator, localization) {
        this.operator = operator;
        this.localization = localization;
        this.messages = operatorTexts(this.localization);
        this._text = this.messages[this.operator];
        this.localization.changes.subscribe(this.refreshText.bind(this));
    }
    /**
     * The text that will be displayed in the drop-down list.
     * @readonly
     * @type {string}
     * @memberOf FilterOperatorBase
     */
    get text() {
        return this._text;
    }
    /**
     *
     */
    set text(value) {
        this._text = isNullOrEmptyString(value) ? this.messages[this.operator] : value;
    }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: this.operator
        };
    }
    refreshText() {
        const update = this._text === this.messages[this.operator];
        this.messages = operatorTexts(this.localization);
        if (update) {
            this._text = this.messages[this.operator];
        }
    }
}
FilterOperatorBase.ɵfac = function FilterOperatorBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FilterOperatorBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilterOperatorBase, inputs: { text: "text" } });
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], FilterOperatorBase.prototype, "text", null);

const insertDefaultFilter = (index, rootFilter, filter$$1) => {
    rootFilter = (rootFilter || { filters: [], logic: "and" });
    rootFilter.filters[index] = filter$$1;
    return filter$$1;
};
/**
 * @hidden
 */
const setFilter = (index, filter$$1, field, defaultOperator) => {
    if (isPresent(filter$$1) && isPresent(filter$$1.filters) && filter$$1.filters.length > index) {
        return filter$$1.filters[index];
    }
    else {
        return insertDefaultFilter(index, filter$$1, {
            field,
            operator: defaultOperator
        });
    }
};
/**
 * @hidden
 */
const logicOperators = (localization) => [
    { text: localization.get("filterAndLogic"), value: "and" },
    { text: localization.get("filterOrLogic"), value: "or" }
];
/**
 * @hidden
 */
const flatten = (filter$$1) => {
    if (isPresent(filter$$1.filters)) {
        return filter$$1.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten(curr) : [curr]), []);
    }
    return [];
};
const trimFilterByField = (filter$$1, field) => {
    if (isPresent(filter$$1) && isPresent(filter$$1.filters)) {
        filter$$1.filters = filter$$1.filters.filter(x => {
            if (isCompositeFilterDescriptor(x)) {
                trimFilterByField(x, field);
                return x.filters.length;
            }
            else {
                return x.field !== field;
            }
        });
    }
};
/**
 * @hidden
 */
const filtersByField = (filter$$1, field) => flatten(filter$$1 || {}).filter(x => x.field === field);
/**
 * @hidden
 */
const filterByField = (filter$$1, field) => {
    let [currentFilter] = filtersByField(filter$$1, field);
    return currentFilter;
};
/**
 * @hidden
 */
const removeFilter = (filter$$1, field) => {
    trimFilterByField(filter$$1, field);
    return filter$$1;
};
/**
 * @hidden
 */
const localizeOperators$1 = operators => localization => Object.keys(operators).map(key => ({
    text: localization.get(key),
    value: operators[key]
}));
/**
 * An abstract base class for the filter-cell component ([see example]({% slug reusablecustomfilters_grid %}#toc-filter-row)).
 */
class BaseFilterCellComponent {
    constructor(filterService) {
        this.filterService = filterService;
        this.operatorList = new QueryList();
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return true;
    }
    get operators() {
        return this._operators.length ? this._operators : this.defaultOperators;
    }
    set operators(values) {
        this._operators = values;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.operationListSubscription = observe(this.operatorList)
            .pipe(map(q => q.toArray()), map(toJSON))
            .subscribe(x => {
            this.operators = x;
        });
    }
    ngOnDestroy() {
        if (this.operationListSubscription) {
            this.operationListSubscription.unsubscribe();
        }
    }
    filterByField(field) {
        return filterByField(this.filter, field);
    }
    filtersByField(field) {
        return filtersByField(this.filter, field);
    }
    removeFilter(field) {
        return removeFilter(this.filter, field);
    }
    updateFilter(filter$$1) {
        const root = this.filter || {
            filters: [],
            logic: "and"
        };
        let [currentFilter] = flatten(root).filter(x => x.field === filter$$1.field);
        if (!isPresent(currentFilter)) {
            root.filters.push(filter$$1);
        }
        else {
            Object.assign(currentFilter, filter$$1);
        }
        return root;
    }
    applyFilter(filter$$1) {
        this.filterService.filter(filter$$1);
    }
}
BaseFilterCellComponent.ɵfac = function BaseFilterCellComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
BaseFilterCellComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BaseFilterCellComponent, contentQueries: function BaseFilterCellComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FilterOperatorBase, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.operatorList = _t);
    } }, hostVars: 2, hostBindings: function BaseFilterCellComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } } });
__decorate([
    HostBinding('class.k-filtercell'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], BaseFilterCellComponent.prototype, "hostClasses", null);
__decorate([
    ContentChildren(FilterOperatorBase),
    __metadata("design:type", QueryList)
], BaseFilterCellComponent.prototype, "operatorList", void 0);

const numericOperators = localizeOperators$1({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterGteOperator": "gte",
    "filterGtOperator": "gt",
    "filterLteOperator": "lte",
    "filterLtOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull"
});
/**
 * Represents a base numeric filter component.
 */
class NumericFilterComponent extends BaseFilterCellComponent {
    constructor(filterService, localization) {
        super(filterService);
        this.localization = localization;
        /**
         * The default filter operator. Defaults to `eq`.
         * @type {string}
         */
        this.operator = "eq";
        /**
         * Specifies the value that is used to increment or decrement the component value.
         * @type {numeric}
         */
        this.step = 1;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered.
         * @type {boolean}
         */
        this.spinners = true;
        this.defaultOperators = numericOperators(this.localization);
    }
    /**
     * Specifies the number format used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     */
    set format(value) {
        this._format = value;
    }
    /**
     * @readonly
     * @type {string}
     */
    get format() {
        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    get columnFormat() {
        return this.column && !isNullOrEmptyString(this.column.format) ?
            extractFormat(this.column.format) : "n2";
    }
    ngOnInit() {
        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = numericOperators(this.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
}
NumericFilterComponent.ɵfac = function NumericFilterComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
NumericFilterComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NumericFilterComponent, inputs: { operator: "operator", step: "step", spinners: "spinners", format: "format", column: "column", filter: "filter", min: "min", max: "max", decimals: "decimals" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], NumericFilterComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NumericFilterComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericFilterComponent.prototype, "operator", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericFilterComponent.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericFilterComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericFilterComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericFilterComponent.prototype, "spinners", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericFilterComponent.prototype, "decimals", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NumericFilterComponent.prototype, "format", null);

/**
 * Represents a numeric filter cell.
 *
 * @example
 *  ```html-no-run
 *      <kendo-grid-column field="ProductName" title="Product Name">
 *          <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *          <kendo-grid-numeric-filter-cell
 *              [column]="column"
 *              [filter]="filter">
 *          </kendo-grid-numeric-filter-cell>
 *          </ng-template>
 *      </kendo-grid-column>
 *   ```
 */
let NumericFilterCellComponent = class NumericFilterCellComponent extends NumericFilterComponent {
    constructor(filterService, localization) {
        super(filterService, localization);
        this.localization = localization;
        /**
         * Determines the delay time (in milliseconds) before the filter value is submitted.
         * A value of `0` indicates no delay. The default value is `500`.
         * @type {boolean}
         */
        this.filterDelay = 500;
        /**
         * Determines if the drop-down filter operators will be displayed.
         * The default value is `true`.
         * @type {boolean}
         */
        this.showOperators = true;
    }
    /**
     * @hidden
     */
    messageFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
NumericFilterCellComponent.ɵfac = function NumericFilterCellComponent_Factory(t) { return new (t || NumericFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
NumericFilterCellComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NumericFilterCellComponent, selectors: [["kendo-grid-numeric-filter-cell"]], inputs: { filterDelay: "filterDelay", showOperators: "showOperators" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 17, consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoGridFocusable", "", "kendoFilterInput", "", 3, "columnLabel", "filterDelay", "autoCorrect", "value", "format", "decimals", "spinners", "min", "max", "step"], [3, "increment", "decrement"]], template: function NumericFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0)(1, "kendo-numerictextbox", 1);
        ɵngcc0.ɵɵelement(2, "kendo-numerictextbox-messages", 2);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("autoCorrect", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("increment", ctx.messageFor("filterNumericIncrement"))("decrement", ctx.messageFor("filterNumericDecrement"));
    } }, directives: function () { return [FilterCellWrapperComponent, ɵngcc6.NumericTextBoxComponent, FocusableDirective, FilterInputDirective, ɵngcc6.NumericTextBoxCustomMessagesComponent]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericFilterCellComponent.prototype, "filterDelay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericFilterCellComponent.prototype, "showOperators", void 0);
NumericFilterCellComponent = __decorate([ __metadata("design:paramtypes", [FilterService,
        LocalizationService])
], NumericFilterCellComponent);

/**
 * @hidden
 */
let FilterInputDirective = class FilterInputDirective {
    constructor(valueAccessors, ngZone, element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.change = new EventEmitter();
        this.composing = false;
        this.filterDelay = 500;
        this.changeRequests = new Subject();
        this.accessor = valueAccessors[0];
        ngZone.runOutsideAngular(() => {
            const unsubscribeStart = renderer.listen(element.nativeElement, 'compositionstart', () => this.composing = true);
            const unsubscribeEnd = renderer.listen(element.nativeElement, 'compositionend', () => this.composing = false);
            this.unsubscribeEvents = () => {
                unsubscribeStart();
                unsubscribeEnd();
            };
        });
    }
    set value(value) {
        this.accessor.writeValue(value);
    }
    set disabled(value) {
        this.accessor.setDisabledState(value);
    }
    ngAfterViewInit() {
        this.addAriaAttributes();
        this.accessor.registerOnChange(x => this.filterDelay > 0 ?
            this.changeRequests.next(x) :
            this.change.emit(x));
        this.subscribeChanges();
    }
    ngOnChanges(changes) {
        if (isChanged('filterDelay', changes)) {
            this.unsubscribeChanges();
            this.subscribeChanges();
        }
    }
    ngOnDestroy() {
        this.unsubscribeChanges();
        this.unsubscribeEvents();
    }
    subscribeChanges() {
        this.changeRequestsSubscription = this.changeRequests
            .pipe(debounceTime(this.filterDelay), filter(() => !this.composing))
            .subscribe(x => this.change.emit(x));
    }
    unsubscribeChanges() {
        if (this.changeRequestsSubscription) {
            this.changeRequestsSubscription.unsubscribe();
        }
    }
    addAriaAttributes() {
        const ariaValue = this.columnLabel;
        if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
            const focusableElement = this.element.nativeElement.querySelector(`#${this.kendoInput.focusableId}`) ||
                this.element.nativeElement;
            this.renderer.setAttribute(focusableElement, 'aria-label', ariaValue);
        }
        else {
            this.renderer.setAttribute(this.element.nativeElement, 'aria-label', ariaValue);
        }
    }
};
FilterInputDirective.ɵfac = function FilterInputDirective_Factory(t) { return new (t || FilterInputDirective)(ɵngcc0.ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FilterInputDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilterInputDirective, selectors: [["", "kendoFilterInput", ""]], contentQueries: function FilterInputDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, KendoInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
    } }, inputs: { filterDelay: "filterDelay", value: "value", columnLabel: "columnLabel" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    ContentChild(KendoInput, { static: true }),
    __metadata("design:type", Object)
], FilterInputDirective.prototype, "kendoInput", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FilterInputDirective.prototype, "filterDelay", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FilterInputDirective.prototype, "columnLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], FilterInputDirective.prototype, "value", null);
FilterInputDirective = __decorate([ __param(0, Self()), __param(0, Inject(NG_VALUE_ACCESSOR)),
    __metadata("design:paramtypes", [Array, NgZone,
        ElementRef,
        Renderer2])
], FilterInputDirective);

const EMPTY_VALUE_OPERATORS = new Set(['isnull', 'isnotnull', 'isempty', 'isnotempty']);
const isEmptyValueOperator = (operator) => EMPTY_VALUE_OPERATORS.has(operator);
/**
 * @hidden
 */
class FilterInputWrapperComponent extends BaseFilterCellComponent {
    constructor(filterService) {
        super(filterService);
        this.operators = [];
    }
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    get currentOperator() {
        const filter$$1 = this.currentFilter;
        if (!this._operator) {
            this._operator = filter$$1 ? filter$$1.operator : this.defaultOperator;
        }
        return this._operator;
    }
    set currentOperator(value) {
        this._operator = value;
        const emptyValueOperator = isEmptyValueOperator(value);
        this.filterInputDisabled = emptyValueOperator;
        if (emptyValueOperator) {
            this.applyNoValueFilter(value);
        }
        else if (!isBlank(value) && isPresent(this.currentFilter)) {
            this.onChange(this.currentFilter.value);
        }
    }
    get defaultOperator() {
        if (!isNullOrEmptyString(this._defaultOperator)) {
            return this._defaultOperator;
        }
        else if (this.operators && this.operators.length) {
            return this.operators[0].value;
        }
        return "eq";
    }
    set defaultOperator(value) {
        this._defaultOperator = value;
    }
    set filterInputDisabled(disabled) {
        if (!this.input) {
            return;
        }
        this.input.disabled = disabled;
    }
    ngAfterContentInit() {
        if (isPresent(this.input)) {
            this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));
            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.changeSubscription) {
            this.changeSubscription.unsubscribe();
        }
    }
    onChange(value) {
        if (!isNullOrEmptyString(value) || this.filterByField(this.column.field)) {
            this.filterChange(isNullOrEmptyString(value) ?
                this.removeFilter(this.column.field) :
                this.updateFilter({
                    field: this.column.field,
                    operator: this.currentOperator,
                    value: value
                }));
        }
    }
    onClear() {
        this.onChange(null);
        this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);
    }
    applyNoValueFilter(operator) {
        this.filterChange(this.updateFilter({
            field: this.column.field,
            operator: operator,
            value: null
        }));
    }
    ngOnChanges(changes) {
        if (isChanged("filter", changes, false)) {
            this._operator = null;
            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
        }
    }
}
FilterInputWrapperComponent.ɵfac = function FilterInputWrapperComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FilterInputWrapperComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilterInputWrapperComponent, contentQueries: function FilterInputWrapperComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FilterInputDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, inputs: { operators: "operators", defaultOperator: "defaultOperator", column: "column", filter: "filter" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Array)
], FilterInputWrapperComponent.prototype, "operators", void 0);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], FilterInputWrapperComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FilterInputWrapperComponent.prototype, "filter", void 0);
__decorate([
    ContentChild(FilterInputDirective, { static: false }),
    __metadata("design:type", FilterInputDirective)
], FilterInputWrapperComponent.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], FilterInputWrapperComponent.prototype, "defaultOperator", null);

const EMPTY_FILTER_OPERATORS = ['isnull', 'isnotnull', 'isempty', 'isnotempty'];
/**
 * @hidden
 */
let FilterCellWrapperComponent = class FilterCellWrapperComponent extends FilterInputWrapperComponent {
    constructor(filterService) {
        super(filterService);
        this.showOperators = true;
    }
    get hostClasses() {
        return true;
    }
    get overrideBaseClasses() {
        return false;
    }
    get showButton() {
        const filter$$1 = this.currentFilter;
        return isPresent(filter$$1) && (!isNullOrEmptyString(filter$$1.value) ||
            EMPTY_FILTER_OPERATORS.indexOf(String(filter$$1.operator)) >= 0);
    }
    filterChange(filter$$1) {
        this.applyFilter(filter$$1);
    }
};
FilterCellWrapperComponent.ɵfac = function FilterCellWrapperComponent_Factory(t) { return new (t || FilterCellWrapperComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService)); };
FilterCellWrapperComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FilterCellWrapperComponent, selectors: [["kendo-grid-filter-wrapper-cell"]], hostVars: 4, hostBindings: function FilterCellWrapperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell-wrapper", ctx.hostClasses)("k-filtercell", ctx.overrideBaseClasses);
    } }, inputs: { showOperators: "showOperators" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c150, decls: 2, vars: 4, consts: [[3, "showOperators", "operators", "showButton", "value", "clear", "valueChange"]], template: function FilterCellWrapperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "kendo-grid-filter-cell-operators", 0);
        ɵngcc0.ɵɵlistener("clear", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_clear_1_listener() { return ctx.onClear(); })("valueChange", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_valueChange_1_listener($event) { return ctx.currentOperator = $event; });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("showOperators", ctx.showOperators)("operators", ctx.operators)("showButton", ctx.showButton)("value", ctx.currentOperator);
    } }, directives: function () { return [FilterCellOperatorsComponent]; }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-filtercell-wrapper'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FilterCellWrapperComponent.prototype, "hostClasses", null);
__decorate([
    HostBinding('class.k-filtercell'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FilterCellWrapperComponent.prototype, "overrideBaseClasses", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FilterCellWrapperComponent.prototype, "showOperators", void 0);
FilterCellWrapperComponent = __decorate([ __metadata("design:paramtypes", [FilterService])
], FilterCellWrapperComponent);

// tslint:disable:no-access-missing-member
const stringOperators = localizeOperators$1({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty"
});
/**
 * Represents a base string filter component.
 */
class StringFilterComponent extends BaseFilterCellComponent {
    constructor(filterService, localization) {
        super(filterService);
        this.localization = localization;
        /**
         * The default filter operator. Defaults to `contains`.
         * @type {string}
         */
        this.operator = "contains";
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField((this.column || {}).field);
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    ngOnInit() {
        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = stringOperators(this.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
}
StringFilterComponent.ɵfac = function StringFilterComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
StringFilterComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: StringFilterComponent, inputs: { operator: "operator", column: "column", filter: "filter" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], StringFilterComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], StringFilterComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StringFilterComponent.prototype, "operator", void 0);

/**
 * Represents a string-filter cell component
 * ([see example]({% slug builtinfiltertemplate_grid %}#toc-configuration-components-for-filter-templates)).
 *
 * @example
 *
 *  ```html-no-run
 *      <kendo-grid-column field="ProductName" title="Product Name">
 *          <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *          <kendo-grid-string-filter-cell
 *              [showOperators]="false"
 *              [column]="column"
 *              [filter]="filter">
 *          </kendo-grid-string-filter-cell>
 *          </ng-template>
 *      </kendo-grid-column>
 *   ```
 */
let StringFilterCellComponent = class StringFilterCellComponent extends StringFilterComponent {
    constructor(filterService, localization) {
        super(filterService, localization);
        /**
         * Determines the delay time (in milliseconds) before the filter value is submitted.
         * A value of `0` indicates no delay. The default value is `500`.
         * @type {boolean}
         */
        this.filterDelay = 500;
        /**
         * Determines if the drop-down filter operators will be displayed.
         * The default value is `true`.
         * @type {boolean}
         */
        this.showOperators = true;
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
StringFilterCellComponent.ɵfac = function StringFilterCellComponent_Factory(t) { return new (t || StringFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
StringFilterCellComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StringFilterCellComponent, selectors: [["kendo-grid-string-filter-cell"]], inputs: { filterDelay: "filterDelay", showOperators: "showOperators" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 8, consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoTextBox", "", "kendoGridFocusable", "", "kendoFilterInput", "", 3, "columnLabel", "filterDelay", "ngModel"]], template: function StringFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
        ɵngcc0.ɵɵelement(1, "input", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("ngModel", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    } }, directives: [FilterCellWrapperComponent, ɵngcc6.TextBoxDirective, ɵngcc7.DefaultValueAccessor, FocusableDirective, FilterInputDirective, ɵngcc7.NgControlStatus, ɵngcc7.NgModel], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], StringFilterCellComponent.prototype, "filterDelay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], StringFilterCellComponent.prototype, "showOperators", void 0);
StringFilterCellComponent = __decorate([ __metadata("design:paramtypes", [FilterService,
        LocalizationService])
], StringFilterCellComponent);

/**
 * Represents a component which accommodates the filter operators.
 */
let FilterCellOperatorsComponent = class FilterCellOperatorsComponent {
    constructor(localization) {
        this.localization = localization;
        this.clearText = 'Clear';
        /**
         * The filter operators that will be displayed.
         */
        this.operators = [];
        /**
         * Determines if the list of operators will be displayed.
         * @type {boolean}
         */
        this.showOperators = true;
        /**
         * Fires when the operator is selected.
         * @type {EventEmitter<string>}
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires when the **Clear** button is clicked.
         * @type {EventEmitter<{}>}
         */
        this.clear = new EventEmitter();
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return true;
    }
    /**
     * @hidden
     */
    onChange(dataItem) {
        this.valueChange.emit(dataItem);
    }
    /**
     * @hidden
     */
    clearClick() {
        this.clear.emit();
        return false;
    }
    /**
     * @hidden
     */
    clearKeydown(args) {
        if (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) {
            this.clear.emit();
        }
    }
    /**
     * @hidden
     */
    dropdownKeydown(args) {
        if (args.defaultPrevented) {
            return;
        }
        if (args.keyCode === Keys.Enter && !this.dropdown.isOpen) {
            this.dropdown.toggle(true);
            args.preventDefault();
        }
    }
    ngOnInit() {
        this.localization.changes.subscribe(() => this.clearText = this.localization.get("filterClearButton"));
    }
};
FilterCellOperatorsComponent.ɵfac = function FilterCellOperatorsComponent_Factory(t) { return new (t || FilterCellOperatorsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
FilterCellOperatorsComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FilterCellOperatorsComponent, selectors: [["kendo-grid-filter-cell-operators"]], viewQuery: function FilterCellOperatorsComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c151, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdown = _t.first);
    } }, hostVars: 2, hostBindings: function FilterCellOperatorsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell-operator", ctx.hostClasses);
    } }, inputs: { operators: "operators", showOperators: "showOperators", showButton: "showButton", value: "value" }, outputs: { valueChange: "valueChange", clear: "clear" }, decls: 2, vars: 2, consts: [["kendoGridFocusable", "", "class", "k-dropdown-operator", "iconClass", "k-i-filter", "textField", "text", "valueField", "value", 3, "data", "value", "valuePrimitive", "popupSettings", "valueChange", "keydown", 4, "ngIf"], ["type", "button", "kendoGridFocusable", "", "class", "k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle k-icon-button", 3, "title", "click", "keydown", 4, "ngIf"], ["kendoGridFocusable", "", "iconClass", "k-i-filter", "textField", "text", "valueField", "value", 1, "k-dropdown-operator", 3, "data", "value", "valuePrimitive", "popupSettings", "valueChange", "keydown"], ["dropdown", ""], ["type", "button", "kendoGridFocusable", "", 1, "k-button", "k-button-solid-base", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", "k-icon-button", 3, "title", "click", "keydown"], [1, "k-icon", "k-button-icon", "k-i-filter-clear"]], template: function FilterCellOperatorsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FilterCellOperatorsComponent_kendo_dropdownlist_0_Template, 2, 5, "kendo-dropdownlist", 0);
        ɵngcc0.ɵɵtemplate(1, FilterCellOperatorsComponent_button_1_Template, 2, 1, "button", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButton);
    } }, directives: [ɵngcc5.NgIf, ɵngcc8.DropDownListComponent, FocusableDirective], encapsulation: 2 });
__decorate([
    HostBinding('class.k-filtercell-operator'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FilterCellOperatorsComponent.prototype, "hostClasses", null);
__decorate([
    ViewChild('dropdown', { static: false }),
    __metadata("design:type", DropDownListComponent)
], FilterCellOperatorsComponent.prototype, "dropdown", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], FilterCellOperatorsComponent.prototype, "operators", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FilterCellOperatorsComponent.prototype, "showButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FilterCellOperatorsComponent.prototype, "showOperators", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FilterCellOperatorsComponent.prototype, "value", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FilterCellOperatorsComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FilterCellOperatorsComponent.prototype, "clear", void 0);
FilterCellOperatorsComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], FilterCellOperatorsComponent);

// tslint:disable:no-access-missing-member
const stringOperators$1 = localizeOperators$1({
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty"
});
/**
 * @hidden
 */
let AutoCompleteFilterCellComponent = class AutoCompleteFilterCellComponent extends BaseFilterCellComponent {
    constructor(filterService, column, localization) {
        super(filterService);
        this.localization = localization;
        this.showOperators = true;
        this.defaultOperators = stringOperators$1(this.localization);
        this.column = column;
    }
    set valueField(value) {
        this._valueField = value;
    }
    get valueField() {
        return this._valueField ? this._valueField : this.column.field;
    }
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : "contains";
    }
};
AutoCompleteFilterCellComponent.ɵfac = function AutoCompleteFilterCellComponent_Factory(t) { return new (t || AutoCompleteFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ColumnComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
AutoCompleteFilterCellComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AutoCompleteFilterCellComponent, selectors: [["kendo-grid-autocomplete-filter-cell"]], inputs: { showOperators: "showOperators", column: "column", valueField: "valueField", filter: "filter", data: "data" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 7, consts: [[3, "column", "filter", "operators", "showOperators"], ["kendoFilterInput", "", 3, "data", "valueField", "value"]], template: function AutoCompleteFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
        ɵngcc0.ɵɵelement(1, "kendo-autocomplete", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("showOperators", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("data", ctx.data)("valueField", ctx.valueField)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    } }, directives: [FilterCellWrapperComponent, ɵngcc8.AutoCompleteComponent, FilterInputDirective], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AutoCompleteFilterCellComponent.prototype, "showOperators", void 0);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], AutoCompleteFilterCellComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AutoCompleteFilterCellComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], AutoCompleteFilterCellComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], AutoCompleteFilterCellComponent.prototype, "valueField", null);
AutoCompleteFilterCellComponent = __decorate([ __metadata("design:paramtypes", [FilterService,
        ColumnComponent,
        LocalizationService])
], AutoCompleteFilterCellComponent);

// tslint:disable:no-access-missing-member
/**
 * @hidden
 */
class BooleanFilterComponent extends BaseFilterCellComponent {
    constructor(filterService, localization) {
        super(filterService);
        this.localization = localization;
        /**
         * @hidden
         */
        this.operator = "eq";
        /**
         * @hidden
         */
        this.items = [
            { text: this.localization.get("filterIsTrue"), value: true },
            { text: this.localization.get("filterIsFalse"), value: false }
        ];
        /**
         * @hidden
         */
        this.defaultItem = { text: this.localization.get("filterBooleanAll"), value: null };
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return true;
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    ngOnInit() {
        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.items = [
            { text: this.localization.get("filterIsTrue"), value: true },
            { text: this.localization.get("filterIsFalse"), value: false }
        ];
        this.defaultItem = { text: this.localization.get("filterBooleanAll"), value: null };
    }
}
BooleanFilterComponent.ɵfac = function BooleanFilterComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
BooleanFilterComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BooleanFilterComponent, hostVars: 2, hostBindings: function BooleanFilterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell-boolean", ctx.hostClasses);
    } }, inputs: { column: "column", filter: "filter" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    HostBinding('class.k-filtercell-boolean'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], BooleanFilterComponent.prototype, "hostClasses", null);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], BooleanFilterComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BooleanFilterComponent.prototype, "filter", void 0);

/**
 * Represents a Boolean filter-cell component.
 *
 * @example
 *
 *  ```html-no-run
 *      <kendo-grid-column field="ProductName" title="Product Name">
 *          <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *          <kendo-grid-boolean-filter-cell
 *              [column]="column"
 *              [filter]="filter">
 *          </kendo-grid-boolean-filter-cell>
 *          </ng-template>
 *      </kendo-grid-column>
 *   ```
 */
let BooleanFilterCellComponent = class BooleanFilterCellComponent extends BooleanFilterComponent {
    constructor(filterService, localization, cd) {
        super(filterService, localization);
        this.cd = cd;
    }
    localizationChange() {
        super.localizationChange();
        this.cd.markForCheck();
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
BooleanFilterCellComponent.ɵfac = function BooleanFilterCellComponent_Factory(t) { return new (t || BooleanFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
BooleanFilterCellComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BooleanFilterCellComponent, selectors: [["kendo-grid-boolean-filter-cell"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 11, consts: [[3, "column", "filter", "showOperators", "defaultOperator"], ["kendoFilterInput", "", "kendoGridFocusable", "", "textField", "text", "valueField", "value", 3, "columnLabel", "defaultItem", "data", "popupSettings", "valuePrimitive", "value"]], template: function BooleanFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
        ɵngcc0.ɵɵelement(1, "kendo-dropdownlist", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("showOperators", false)("defaultOperator", ctx.operator);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("columnLabel", ctx.columnLabel)("defaultItem", ctx.defaultItem)("data", ctx.items)("popupSettings", ɵngcc0.ɵɵpureFunction0(10, _c152))("valuePrimitive", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    } }, directives: [FilterCellWrapperComponent, ɵngcc8.DropDownListComponent, FilterInputDirective, FocusableDirective], encapsulation: 2 });
BooleanFilterCellComponent = __decorate([ __metadata("design:paramtypes", [FilterService,
        LocalizationService,
        ChangeDetectorRef])
], BooleanFilterCellComponent);

// tslint:disable:no-access-missing-member
const dateOperators = localizeOperators$1({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterAfterOrEqualOperator": "gte",
    "filterAfterOperator": "gt",
    "filterBeforeOrEqualOperator": "lte",
    "filterBeforeOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull"
});
/**
 * @hidden
 */
class DateFilterComponent extends BaseFilterCellComponent {
    constructor(filterService, localization) {
        super(filterService);
        this.localization = localization;
        /**
         * The default filter operator. Defaults to `contains`.
         * @type {string}
         */
        this.operator = "gte";
        /**
         * Defines the active view that the calendar initially renders.
         * By default, the active view is `month`.
         *
         * > You have to set `activeView` within the `topView`-`bottomView` range.
         */
        this.activeView = "month";
        /**
         * Defines the bottommost calendar view, to which the user can navigate.
         */
        this.bottomView = "month";
        /**
         * Defines the topmost calendar view, to which the user can navigate.
         */
        this.topView = "century";
        /**
         * Determines whether to display a week number column in the `month` view of the Calendar.
         */
        this.weekNumber = false;
        this.defaultOperators = dateOperators(this.localization);
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * Specifies the date format that is used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     */
    set format(value) {
        this._format = value;
    }
    /**
     * Specifies the date format that is used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     *
     * @readonly
     * @type {string}
     */
    get format() {
        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
    }
    get columnFormat() {
        return this.column && !isNullOrEmptyString(this.column.format) ?
            extractFormat(this.column.format) : "d";
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    ngOnInit() {
        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = dateOperators(this.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
}
DateFilterComponent.ɵfac = function DateFilterComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
DateFilterComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DateFilterComponent, inputs: { operator: "operator", activeView: "activeView", bottomView: "bottomView", topView: "topView", weekNumber: "weekNumber", format: "format", column: "column", filter: "filter", min: "min", max: "max", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], DateFilterComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateFilterComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterComponent.prototype, "operator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DateFilterComponent.prototype, "format", null);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DateFilterComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DateFilterComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateFilterComponent.prototype, "formatPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterComponent.prototype, "bottomView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterComponent.prototype, "topView", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateFilterComponent.prototype, "weekNumber", void 0);

/**
 * Represents a date-filter cell component.
 *
 * @example
 *
 *  ```html-no-run
 *      <kendo-grid-column field="OrderDate" title="Order Date">
 *          <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *          <kendo-grid-date-filter-cell
 *              [showOperators]="false"
 *              [column]="column"
 *              [filter]="filter">
 *          </kendo-grid-date-filter-cell>
 *          </ng-template>
 *      </kendo-grid-column>
 *   ```
 */
let DateFilterCellComponent = class DateFilterCellComponent extends DateFilterComponent {
    constructor(filterService, localization) {
        super(filterService, localization);
        this.localization = localization;
        /**
         * Determines if the drop-down filter operators will be displayed. The default value is `true`.
         * @type {boolean}
         */
        this.showOperators = true;
    }
    /**
     * @hidden
     */
    messageFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
DateFilterCellComponent.ɵfac = function DateFilterCellComponent_Factory(t) { return new (t || DateFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
DateFilterCellComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateFilterCellComponent, selectors: [["kendo-grid-date-filter-cell"]], inputs: { showOperators: "showOperators" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 18, consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoFilterInput", "", "kendoGridFocusable", "", 3, "columnLabel", "value", "format", "formatPlaceholder", "placeholder", "activeView", "bottomView", "topView", "min", "max", "weekNumber"], [3, "toggle", "today"]], template: function DateFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0)(1, "kendo-datepicker", 1);
        ɵngcc0.ɵɵelement(2, "kendo-datepicker-messages", 2);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("columnLabel", ctx.columnLabel)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("toggle", ctx.messageFor("filterDateToggle"))("today", ctx.messageFor("filterDateToday"));
    } }, directives: [FilterCellWrapperComponent, ɵngcc9.DatePickerComponent, FilterInputDirective, FocusableDirective, ɵngcc9.DatePickerCustomMessagesComponent], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateFilterCellComponent.prototype, "showOperators", void 0);
DateFilterCellComponent = __decorate([ __metadata("design:paramtypes", [FilterService,
        LocalizationService])
], DateFilterCellComponent);

/**
 * @hidden
 */
let ColGroupComponent = class ColGroupComponent {
    /**
     * @hidden
     */
    constructor() {
        this.columns = [];
        this.groups = [];
    }
    get columnsToRender() {
        return columnsToRender(this.columns);
    }
    trackBy(index, _item) {
        return index;
    }
};
ColGroupComponent.ɵfac = function ColGroupComponent_Factory(t) { return new (t || ColGroupComponent)(); };
ColGroupComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColGroupComponent, selectors: [["", "kendoGridColGroup", ""]], inputs: { columns: "columns", groups: "groups", detailTemplate: "detailTemplate" }, attrs: _c153, decls: 1, vars: 1, consts: [[3, "ngIf"], [3, "k-group-col", 4, "ngFor", "ngForOf"], [3, "k-hierarchy-col", 4, "ngIf"], [3, "width", 4, "ngFor", "ngForOf", "ngForTrackBy"]], template: function ColGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ColGroupComponent_ng_template_0_Template, 3, 4, "ng-template", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", true);
    } }, directives: [ɵngcc5.NgIf, ɵngcc5.NgForOf], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], ColGroupComponent.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ColGroupComponent.prototype, "groups", void 0);
__decorate([
    Input(),
    __metadata("design:type", DetailTemplateDirective)
], ColGroupComponent.prototype, "detailTemplate", void 0);

/**
 * @hidden
 */
let LoadingComponent = class LoadingComponent {
    constructor(localization) {
        this.localization = localization;
        this.hostClass = true;
    }
    get loadingText() {
        return this.localization.get('loading');
    }
};
LoadingComponent.ɵfac = function LoadingComponent_Factory(t) { return new (t || LoadingComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LoadingComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LoadingComponent, selectors: [["", "kendoGridLoading", ""]], hostVars: 2, hostBindings: function LoadingComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-loading-mask", ctx.hostClass);
    } }, inputs: { loadingTemplate: "loadingTemplate" }, attrs: _c154, decls: 2, vars: 2, consts: [[4, "ngIf"], [1, "k-loading-text"], [1, "k-loading-image"], [1, "k-loading-color"], [3, "ngTemplateOutlet"]], template: function LoadingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, LoadingComponent_ng_container_0_Template, 5, 1, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, LoadingComponent_1_Template, 1, 1, null, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.loadingTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.loadingTemplate);
    } }, directives: [ɵngcc5.NgIf, ɵngcc5.NgTemplateOutlet], encapsulation: 2 });
__decorate([
    HostBinding('class.k-loading-mask'),
    __metadata("design:type", Boolean)
], LoadingComponent.prototype, "hostClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", LoadingTemplateDirective)
], LoadingComponent.prototype, "loadingTemplate", void 0);
LoadingComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LoadingComponent);

/**
 * @hidden
 */
let ResizableContainerDirective = class ResizableContainerDirective {
    constructor(el, renderer, resizeService, grid) {
        this.el = el;
        this.renderer = renderer;
        this.resizeService = resizeService;
        this.grid = grid;
        this.enabled = false;
    }
    set lockedWidth(value) {
        this._lockedWidth = value;
        if (this.enabled) {
            this.attachResize();
            this.resize();
        }
    }
    set kendoGridResizableContainer(enabled) {
        const refresh = enabled !== this.enabled;
        this.enabled = enabled;
        if (refresh) {
            this.attachResize();
            this.resize();
        }
    }
    ngOnDestroy() {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    attachResize() {
        if (this.resizeSubscription && !this.enabled) {
            this.resizeSubscription.unsubscribe();
            this.resizeSubscription = null;
        }
        if (!this.resizeSubscription && this.enabled) {
            this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));
        }
    }
    resize() {
        if (this.grid && this.grid.wrapper) {
            const containerElement = this.grid.wrapper.nativeElement;
            const width = Math.max(containerElement.clientWidth - this._lockedWidth, 0);
            if (this.enabled && width > 0) {
                this.renderer.setStyle(this.el.nativeElement, "width", width + "px");
            }
            else {
                this.renderer.setStyle(this.el.nativeElement, "width", "");
            }
        }
    }
};
ResizableContainerDirective.ɵfac = function ResizableContainerDirective_Factory(t) { return new (t || ResizableContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ResizeService), ɵngcc0.ɵɵdirectiveInject(GridComponent, 8)); };
ResizableContainerDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ResizableContainerDirective, selectors: [["", "kendoGridResizableContainer", ""]], inputs: { lockedWidth: "lockedWidth", kendoGridResizableContainer: "kendoGridResizableContainer" } });
__decorate([
    Input('lockedWidth'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ResizableContainerDirective.prototype, "lockedWidth", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], ResizableContainerDirective.prototype, "kendoGridResizableContainer", null);
ResizableContainerDirective = __decorate([ __param(3, Optional()),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ResizeService,
        GridComponent])
], ResizableContainerDirective);

/**
 * @hidden
 */
let TemplateContextDirective = class TemplateContextDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    set templateContext(context) {
        this.removeView();
        if (context.templateRef) {
            this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);
        }
    }
    ngOnDestroy() {
        this.removeView();
    }
    removeView() {
        if (this.insertedViewRef) {
            this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));
            this.insertedViewRef = undefined;
        }
    }
};
TemplateContextDirective.ɵfac = function TemplateContextDirective_Factory(t) { return new (t || TemplateContextDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
TemplateContextDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TemplateContextDirective, selectors: [["", "templateContext", ""]], inputs: { templateContext: "templateContext" } });
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TemplateContextDirective.prototype, "templateContext", null);
TemplateContextDirective = __decorate([ __metadata("design:paramtypes", [ViewContainerRef])
], TemplateContextDirective);

/**
 * @hidden
 */
let FocusGroup = class FocusGroup {
    constructor(root) {
        this.root = root;
        this.active = true;
        this.children = [];
        this.root.registerGroup(this);
    }
    get focusableChildren() {
        return this.children.filter(el => el.canFocus());
    }
    get isActive() {
        return this.active;
    }
    ngOnDestroy() {
        this.root.unregisterGroup(this);
    }
    registerElement(element) {
        this.unregisterElement(element);
        this.children.push(element);
    }
    unregisterElement(element) {
        this.children = this.children.filter(f => f !== element);
    }
    /**
     * Returns a Boolean value which indicates if the group will receive focus when the cell is focused.
     * Requires a single "simple" focusable element such as a button or a checkbox.
     */
    isNavigable() {
        const focusable = this.focusableChildren;
        return focusable.length === 1 && focusable[0].isNavigable();
    }
    canFocus() {
        return this.focusableChildren.length > 0;
    }
    focus() {
        if (this.canFocus() && !this.hasFocus()) {
            this.focusableChildren[0].focus();
        }
    }
    activate() {
        this.toggleState(true);
    }
    deactivate() {
        this.toggleState(false);
    }
    hasFocus() {
        return this.children.reduce((focused, element) => focused || element.hasFocus(), false);
    }
    toggleState(active) {
        if (this.active !== active) {
            this.active = active;
            this.children.forEach(f => f.toggle(active));
        }
    }
};
FocusGroup.ɵfac = function FocusGroup_Factory(t) { return new (t || FocusGroup)(ɵngcc0.ɵɵinject(FocusRoot)); };
FocusGroup.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FocusGroup, factory: function (t) { return FocusGroup.ɵfac(t); } });
FocusGroup = __decorate([ __metadata("design:paramtypes", [FocusRoot])
], FocusGroup);

let id = 0;
function nextId() {
    return id++;
}
/**
 * @hidden
 */
let LogicalCellDirective = class LogicalCellDirective {
    constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone, cellContext) {
        this.focusGroup = focusGroup;
        this.element = element;
        this.columnInfoService = columnInfoService;
        this.idService = idService;
        this.navigationService = navigationService;
        this.renderer = renderer;
        this.zone = zone;
        this.cellContext = cellContext;
        this.logicalSlaveCell = false;
        this.colSpan = 1;
        this.rowSpan = 1;
        this.dataRowIndex = -1;
        this.detailExpandCell = false;
        this.uid = nextId();
    }
    get id() {
        if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {
            return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);
        }
    }
    get ariaColIndex() {
        if (this.logicalSlaveCell || this.logicalColIndex === -1) {
            return undefined;
        }
        return this.logicalColIndex + 1;
    }
    ngOnInit() {
        if (!this.navigationService.enabled) {
            return;
        }
        this.navigationChange = this.navigationService.changes.subscribe((e) => this.onNavigationChange(e));
    }
    ngDoCheck() {
        if (!this.navigationService.enabled || this.logicalColIndex === -1) {
            return;
        }
        if (this.cellContext) {
            this.cellContext.focusGroup = this.focusGroup;
        }
        this.registerNoChanges();
    }
    ngOnChanges(changes) {
        if (!this.navigationService.enabled) {
            return;
        }
        const keys = Object.keys(changes);
        if ((keys.length === 1 && keys[0] === 'groupItem') || this.logicalColIndex === -1) {
            // Ignore groupItem changes as the reference is not stable
            return;
        }
        const indexChange = changes.logicalColIndex;
        const rowIndexChange = changes.logicalRowIndex;
        const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;
        const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;
        this.navigationService.unregisterCell(index, rowIndex, this);
        this.registerChanges();
        this.updateElement();
    }
    ngOnDestroy() {
        if (this.navigationChange) {
            this.navigationChange.unsubscribe();
        }
        this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);
    }
    onNavigationChange(e) {
        const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;
        const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;
        if (active || wasActive) {
            this.updateElement();
        }
    }
    updateElement() {
        const el = this.element.nativeElement;
        this.renderer.setAttribute(el, 'tabIndex', this.isFocusable() && !this.logicalSlaveCell ? '0' : '-1');
        if (this.isFocused()) {
            if (this.focusGroup.isNavigable()) {
                this.focusGroup.focus();
            }
            else {
                if (!this.logicalSlaveCell && this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {
                    this.microtask(() => this.isFocused() && el.focus());
                }
                this.renderer.addClass(el, 'k-state-focused');
            }
            if (this.headerLabelText) {
                el.setAttribute('aria-label', '');
            }
        }
        else {
            this.renderer.removeClass(el, 'k-state-focused');
            if (this.headerLabelText) {
                el.setAttribute('aria-label', this.headerLabelText);
            }
        }
    }
    microtask(callback) {
        this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));
    }
    registerChanges() {
        if (!this.logicalSlaveCell) {
            this.navigationService.registerCell(this);
        }
    }
    registerNoChanges() {
        if (!this.logicalSlaveCell) {
            this.navigationService.registerCellOnCurrentRow(this);
        }
    }
    isFocusable() {
        return this.navigationService.isCellFocusable(this);
    }
    isFocused() {
        return this.navigationService.isCellFocused(this);
    }
};
LogicalCellDirective.ɵfac = function LogicalCellDirective_Factory(t) { return new (t || LogicalCellDirective)(ɵngcc0.ɵɵdirectiveInject(FocusGroup), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(IdService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(CELL_CONTEXT, 8)); };
LogicalCellDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LogicalCellDirective, selectors: [["", "kendoGridLogicalCell", ""]], hostVars: 2, hostBindings: function LogicalCellDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("aria-colindex", ctx.ariaColIndex);
    } }, inputs: { logicalSlaveCell: "logicalSlaveCell", colSpan: "colSpan", rowSpan: "rowSpan", dataRowIndex: "dataRowIndex", detailExpandCell: "detailExpandCell", logicalColIndex: "logicalColIndex", logicalRowIndex: "logicalRowIndex", colIndex: "colIndex", groupItem: "groupItem", dataItem: "dataItem", headerLabelText: "headerLabelText" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: FocusGroup,
                deps: [FocusRoot],
                useClass: FocusGroup
            }]), ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalCellDirective.prototype, "logicalColIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalCellDirective.prototype, "logicalRowIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], LogicalCellDirective.prototype, "logicalSlaveCell", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalCellDirective.prototype, "colIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalCellDirective.prototype, "colSpan", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalCellDirective.prototype, "rowSpan", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LogicalCellDirective.prototype, "groupItem", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalCellDirective.prototype, "dataRowIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LogicalCellDirective.prototype, "dataItem", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], LogicalCellDirective.prototype, "detailExpandCell", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LogicalCellDirective.prototype, "headerLabelText", void 0);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], LogicalCellDirective.prototype, "id", null);
__decorate([
    HostBinding('attr.aria-colindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], LogicalCellDirective.prototype, "ariaColIndex", null);
LogicalCellDirective = __decorate([ __param(7, Optional()), __param(7, Inject(CELL_CONTEXT)),
    __metadata("design:paramtypes", [FocusGroup,
        ElementRef,
        ColumnInfoService,
        IdService,
        NavigationService,
        Renderer2,
        NgZone, Object])
], LogicalCellDirective);

let id$1 = 0;
function nextId$1() {
    return id$1++;
}
/**
 * @hidden
 */
let LogicalRowDirective = class LogicalRowDirective {
    constructor(idService, navigation) {
        this.idService = idService;
        this.navigation = navigation;
        this.logicalSlaveRow = false;
        this.logicalSlaveCellsCount = 0;
        this.dataRowIndex = -1;
        this.uid = nextId$1();
    }
    get hostRole() {
        return this.logicalSlaveRow ? 'presentation' : 'row';
    }
    get ariaRowIndex() {
        return this.logicalRowIndex + 1;
    }
    get ariaOwns() {
        if (!this.navigation.enabled || this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {
            return undefined;
        }
        const ids = [];
        const total = this.logicalCellsCount + this.logicalSlaveCellsCount;
        for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {
            ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));
        }
        return ids.join(' ');
    }
    ngOnChanges(changes) {
        if (!this.navigation.enabled || this.logicalSlaveRow) {
            return;
        }
        const indexChange = changes.logicalRowIndex;
        const logicalSlaveRowChange = changes.logicalSlaveRow;
        if (indexChange || logicalSlaveRowChange) {
            const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;
            this.navigation.unregisterRow(index, this);
            this.navigation.registerRow(this);
        }
        else if (anyChanged(['dataRowIndex', 'dataItem'], changes)) {
            this.navigation.updateRow(this);
        }
    }
    ngOnDestroy() {
        this.navigation.unregisterRow(this.logicalRowIndex, this);
    }
};
LogicalRowDirective.ɵfac = function LogicalRowDirective_Factory(t) { return new (t || LogicalRowDirective)(ɵngcc0.ɵɵdirectiveInject(IdService), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
LogicalRowDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LogicalRowDirective, selectors: [["", "kendoGridLogicalRow", ""]], hostVars: 3, hostBindings: function LogicalRowDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.hostRole)("aria-rowindex", ctx.ariaRowIndex)("aria-owns", ctx.ariaOwns);
    } }, inputs: { logicalSlaveRow: "logicalSlaveRow", logicalSlaveCellsCount: "logicalSlaveCellsCount", dataRowIndex: "dataRowIndex", logicalRowIndex: "logicalRowIndex", logicalCellsCount: "logicalCellsCount", dataItem: "dataItem" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalRowDirective.prototype, "logicalRowIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], LogicalRowDirective.prototype, "logicalSlaveRow", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalRowDirective.prototype, "logicalCellsCount", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalRowDirective.prototype, "logicalSlaveCellsCount", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LogicalRowDirective.prototype, "dataRowIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LogicalRowDirective.prototype, "dataItem", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], LogicalRowDirective.prototype, "hostRole", null);
__decorate([
    HostBinding('attr.aria-rowindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], LogicalRowDirective.prototype, "ariaRowIndex", null);
__decorate([
    HostBinding('attr.aria-owns'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], LogicalRowDirective.prototype, "ariaOwns", null);
LogicalRowDirective = __decorate([ __metadata("design:paramtypes", [IdService,
        NavigationService])
], LogicalRowDirective);

const FORMAT_REGEX = /\{\d+:?/;
/**
 * @hidden
 */
let FieldAccessorPipe = class FieldAccessorPipe {
    constructor(intlService) {
        this.intlService = intlService;
    }
    transform(dataItem, fieldName, format) {
        if (!isNullOrEmptyString(fieldName)) {
            const value = getter(fieldName)(dataItem);
            if (!isNullOrEmptyString(format)) {
                return this.formatValue(format, value);
            }
            return value;
        }
        return dataItem;
    }
    formatValue(format, value) {
        const intl = this.intlService;
        if (isString(format) && format.match(FORMAT_REGEX)) {
            return intl.format(format, value);
        }
        return intl.toString(value, format);
    }
};
FieldAccessorPipe.ɵfac = function FieldAccessorPipe_Factory(t) { return new (t || FieldAccessorPipe)(ɵngcc0.ɵɵdirectiveInject(ɵngcc10.IntlService, 16)); };
FieldAccessorPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "valueOf", type: FieldAccessorPipe, pure: false });
FieldAccessorPipe = __decorate([ __metadata("design:paramtypes", [IntlService])
], FieldAccessorPipe);

/**
 * @hidden
 */
const columnsToResize = ({ columns }) => Math.max(1, resizableColumns(columns).length);
/**
 * @hidden
 */
const row = selector => element => element.querySelector(selector);
/**
 * @hidden
 */
const headerRow = index => element => element.querySelectorAll('thead>tr')[index];
/**
 * @hidden
 */
const cell = (index, selector = 'td') => element => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];
/**
 * @hidden
 */
const offsetWidth = element => element.offsetWidth;
/**
 * @hidden
 */
const pipe = (...fns) => data => fns.reduce((state$$1, fn) => state$$1 ? fn(state$$1) : 0, data);
/**
 * @hidden
 */
let TableDirective = class TableDirective {
    constructor(element, renderer, service, zone, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.service = service;
        this.zone = zone;
        this.cdr = cdr;
        this.locked = false;
        this.firstResize = false;
    }
    get minWidth() {
        return this.firstResize ? 0 : null;
    }
    ngOnInit() {
        const obs = this.service
            .changes.pipe(filter(e => this.locked === e.locked));
        this.subscription = obs.pipe(filter(e => e.type === 'start'), tap(this.initState.bind(this)), map(columnsToResize), switchMap((take$$1) => obs.pipe(filter(e => e.type === 'resizeTable'), map(e => e.delta), bufferCount(take$$1)))).subscribe(this.resize.bind(this));
        this.autoFitSubscription = this.service
            .registerTable({
            autoFit: this.autoFitObservable.bind(this),
            locked: this.locked
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.autoFitSubscription) {
            this.autoFitSubscription();
            this.autoFitSubscription = null;
        }
    }
    initState() {
        this.firstResize = true;
        if (!this.virtualColumns || this.locked) {
            this.originalWidth = offsetWidth(this.element.nativeElement);
        }
    }
    resize(deltas) {
        if (!this.virtualColumns || this.locked) {
            const delta = deltas.reduce((sum, item) => sum + item, 0);
            const width = this.originalWidth + delta;
            this.renderer.setStyle(this.element.nativeElement, 'width', width + 'px');
        }
        this.cdr.detectChanges();
    }
    autoFitObservable(columnInfo) {
        return Observable.create(observer => {
            this.zone.runOutsideAngular(() => {
                this.renderer.addClass(this.element.nativeElement, 'k-autofitting');
                this.cdr.detectChanges();
                const widths = columnInfo.map(this.measureColumn.bind(this));
                this.renderer.removeClass(this.element.nativeElement, 'k-autofitting');
                observer.next(widths);
            });
        });
    }
    measureColumn(info) {
        const dom = this.element.nativeElement;
        const header = pipe(headerRow(info.level), cell(info.headerIndex, 'th'), offsetWidth)(dom);
        let data = 0;
        if (!info.isParentSpan || (info.isParentSpan && info.isLastInSpan)) {
            data = pipe(row('tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)'), cell(info.index), offsetWidth)(dom);
        }
        const footer = pipe(row('tfoot>tr'), cell(info.index), offsetWidth)(dom);
        return Math.max(header, data, footer);
    }
};
TableDirective.ɵfac = function TableDirective_Factory(t) { return new (t || TableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
TableDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TableDirective, selectors: [["table"]], hostVars: 2, hostBindings: function TableDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("min-width", ctx.minWidth);
    } }, inputs: { locked: "locked", virtualColumns: "virtualColumns" } });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TableDirective.prototype, "locked", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TableDirective.prototype, "virtualColumns", void 0);
__decorate([
    HostBinding('style.min-width'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], TableDirective.prototype, "minWidth", null);
TableDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ColumnResizingService,
        NgZone,
        ChangeDetectorRef])
], TableDirective);

const exportedModules = [
    ColumnComponent,
    ColumnGroupComponent,
    LogicalCellDirective,
    LogicalRowDirective,
    FocusableDirective,
    FooterTemplateDirective,
    ColGroupComponent,
    ResizableContainerDirective,
    TemplateContextDirective,
    FieldAccessorPipe,
    DetailTemplateDirective,
    SpanColumnComponent,
    TableDirective,
    LoadingComponent
];
/**
 * @hidden
 */
let SharedModule = class SharedModule {
    static exports() {
        return [
            ColumnComponent,
            SpanColumnComponent,
            ColumnGroupComponent,
            FooterTemplateDirective,
            DetailTemplateDirective,
            FocusableDirective
        ];
    }
};
SharedModule.ɵfac = function SharedModule_Factory(t) { return new (t || SharedModule)(); };
SharedModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
SharedModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule], DraggableModule, EventsModule] });

var ContainsFilterOperatorComponent_1;
/**
 * Represents the `Contains` (**Contains**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let ContainsFilterOperatorComponent = ContainsFilterOperatorComponent_1 = class ContainsFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("contains", localization); }
};
ContainsFilterOperatorComponent.ɵfac = function ContainsFilterOperatorComponent_Factory(t) { return new (t || ContainsFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ContainsFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ContainsFilterOperatorComponent, selectors: [["kendo-filter-contains-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => ContainsFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ContainsFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
ContainsFilterOperatorComponent = ContainsFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], ContainsFilterOperatorComponent);

var DoesNotContainFilterOperatorComponent_1;
/**
 * Represents the `DoesNotContain` (**Does not contain**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let DoesNotContainFilterOperatorComponent = DoesNotContainFilterOperatorComponent_1 = class DoesNotContainFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("doesnotcontain", localization); }
};
DoesNotContainFilterOperatorComponent.ɵfac = function DoesNotContainFilterOperatorComponent_Factory(t) { return new (t || DoesNotContainFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
DoesNotContainFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DoesNotContainFilterOperatorComponent, selectors: [["kendo-filter-not-contains-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function DoesNotContainFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
DoesNotContainFilterOperatorComponent = DoesNotContainFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], DoesNotContainFilterOperatorComponent);

var EndsWithFilterOperatorComponent_1;
/**
 * Represents the `EndsWith` (**Ends with**) string filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let EndsWithFilterOperatorComponent = EndsWithFilterOperatorComponent_1 = class EndsWithFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("endswith", localization); }
};
EndsWithFilterOperatorComponent.ɵfac = function EndsWithFilterOperatorComponent_Factory(t) { return new (t || EndsWithFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
EndsWithFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: EndsWithFilterOperatorComponent, selectors: [["kendo-filter-endswith-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => EndsWithFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function EndsWithFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
EndsWithFilterOperatorComponent = EndsWithFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], EndsWithFilterOperatorComponent);

var EqualFilterOperatorComponent_1;
/**
 * Represents the `Equal` (**Is equal to**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let EqualFilterOperatorComponent = EqualFilterOperatorComponent_1 = class EqualFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("eq", localization); }
};
EqualFilterOperatorComponent.ɵfac = function EqualFilterOperatorComponent_Factory(t) { return new (t || EqualFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
EqualFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: EqualFilterOperatorComponent, selectors: [["kendo-filter-eq-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => EqualFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function EqualFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
EqualFilterOperatorComponent = EqualFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], EqualFilterOperatorComponent);

var IsEmptyFilterOperatorComponent_1;
/**
 * Represents the `IsEmpty` (**Is empty**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let IsEmptyFilterOperatorComponent = IsEmptyFilterOperatorComponent_1 = class IsEmptyFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("isempty", localization); }
};
IsEmptyFilterOperatorComponent.ɵfac = function IsEmptyFilterOperatorComponent_Factory(t) { return new (t || IsEmptyFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
IsEmptyFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: IsEmptyFilterOperatorComponent, selectors: [["kendo-filter-isempty-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsEmptyFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IsEmptyFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
IsEmptyFilterOperatorComponent = IsEmptyFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], IsEmptyFilterOperatorComponent);

var IsNotEmptyFilterOperatorComponent_1;
/**
 * Represents the `IsNotEmpty` (**Is not empty**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let IsNotEmptyFilterOperatorComponent = IsNotEmptyFilterOperatorComponent_1 = class IsNotEmptyFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("isnotempty", localization); }
};
IsNotEmptyFilterOperatorComponent.ɵfac = function IsNotEmptyFilterOperatorComponent_Factory(t) { return new (t || IsNotEmptyFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
IsNotEmptyFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: IsNotEmptyFilterOperatorComponent, selectors: [["kendo-filter-isnotempty-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IsNotEmptyFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
IsNotEmptyFilterOperatorComponent = IsNotEmptyFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], IsNotEmptyFilterOperatorComponent);

var IsNotNullFilterOperatorComponent_1;
/**
 * Represents the `IsNotNull` (**Is not null**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let IsNotNullFilterOperatorComponent = IsNotNullFilterOperatorComponent_1 = class IsNotNullFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("isnotnull", localization); }
};
IsNotNullFilterOperatorComponent.ɵfac = function IsNotNullFilterOperatorComponent_Factory(t) { return new (t || IsNotNullFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
IsNotNullFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: IsNotNullFilterOperatorComponent, selectors: [["kendo-filter-isnotnull-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNotNullFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IsNotNullFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
IsNotNullFilterOperatorComponent = IsNotNullFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], IsNotNullFilterOperatorComponent);

var IsNullFilterOperatorComponent_1;
/**
 * Represents the `IsNull` (**Is null**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let IsNullFilterOperatorComponent = IsNullFilterOperatorComponent_1 = class IsNullFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("isnull", localization); }
};
IsNullFilterOperatorComponent.ɵfac = function IsNullFilterOperatorComponent_Factory(t) { return new (t || IsNullFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
IsNullFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: IsNullFilterOperatorComponent, selectors: [["kendo-filter-isnull-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNullFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IsNullFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
IsNullFilterOperatorComponent = IsNullFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], IsNullFilterOperatorComponent);

var NotEqualFilterOperatorComponent_1;
/**
 * Represents the `NotEqual` (**Is not equal to**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let NotEqualFilterOperatorComponent = NotEqualFilterOperatorComponent_1 = class NotEqualFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("neq", localization); }
};
NotEqualFilterOperatorComponent.ɵfac = function NotEqualFilterOperatorComponent_Factory(t) { return new (t || NotEqualFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
NotEqualFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NotEqualFilterOperatorComponent, selectors: [["kendo-filter-neq-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => NotEqualFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NotEqualFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
NotEqualFilterOperatorComponent = NotEqualFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], NotEqualFilterOperatorComponent);

var StartsWithFilterOperatorComponent_1;
/**
 * Represents the `StartsWith` (**Starts with**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let StartsWithFilterOperatorComponent = StartsWithFilterOperatorComponent_1 = class StartsWithFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("startswith", localization); }
};
StartsWithFilterOperatorComponent.ɵfac = function StartsWithFilterOperatorComponent_Factory(t) { return new (t || StartsWithFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
StartsWithFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StartsWithFilterOperatorComponent, selectors: [["kendo-filter-startswith-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => StartsWithFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function StartsWithFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
StartsWithFilterOperatorComponent = StartsWithFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], StartsWithFilterOperatorComponent);

var GreaterFilterOperatorComponent_1;
/*
 * Represents the `Greater` (**Is greater than**) numeric filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let GreaterFilterOperatorComponent = GreaterFilterOperatorComponent_1 = class GreaterFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("gt", localization); }
};
GreaterFilterOperatorComponent.ɵfac = function GreaterFilterOperatorComponent_Factory(t) { return new (t || GreaterFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
GreaterFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GreaterFilterOperatorComponent, selectors: [["kendo-filter-gt-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => GreaterFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function GreaterFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
GreaterFilterOperatorComponent = GreaterFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], GreaterFilterOperatorComponent);

var GreaterOrEqualToFilterOperatorComponent_1;
/**
 * Represents the `GreaterOrEqualTo` (**Is greater than or equal to**) numeric filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let GreaterOrEqualToFilterOperatorComponent = GreaterOrEqualToFilterOperatorComponent_1 = class GreaterOrEqualToFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("gte", localization); }
};
GreaterOrEqualToFilterOperatorComponent.ɵfac = function GreaterOrEqualToFilterOperatorComponent_Factory(t) { return new (t || GreaterOrEqualToFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
GreaterOrEqualToFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GreaterOrEqualToFilterOperatorComponent, selectors: [["kendo-filter-gte-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function GreaterOrEqualToFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
GreaterOrEqualToFilterOperatorComponent = GreaterOrEqualToFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], GreaterOrEqualToFilterOperatorComponent);

var LessFilterOperatorComponent_1;
/*
 * Represents the `Less` (**Is less than**) numeric filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let LessFilterOperatorComponent = LessFilterOperatorComponent_1 = class LessFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("lt", localization); }
};
LessFilterOperatorComponent.ɵfac = function LessFilterOperatorComponent_Factory(t) { return new (t || LessFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LessFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LessFilterOperatorComponent, selectors: [["kendo-filter-lt-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => LessFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LessFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
LessFilterOperatorComponent = LessFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LessFilterOperatorComponent);

var LessOrEqualToFilterOperatorComponent_1;
/*
 * Represents the `LessOrEqualTo` (**Is less than or equal to**) numeric filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let LessOrEqualToFilterOperatorComponent = LessOrEqualToFilterOperatorComponent_1 = class LessOrEqualToFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("lte", localization); }
};
LessOrEqualToFilterOperatorComponent.ɵfac = function LessOrEqualToFilterOperatorComponent_Factory(t) { return new (t || LessOrEqualToFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LessOrEqualToFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LessOrEqualToFilterOperatorComponent, selectors: [["kendo-filter-lte-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LessOrEqualToFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
LessOrEqualToFilterOperatorComponent = LessOrEqualToFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LessOrEqualToFilterOperatorComponent);

var AfterFilterOperatorComponent_1;
/*
 * Represents the `Greater` (**Is after**) date filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let AfterFilterOperatorComponent = AfterFilterOperatorComponent_1 = class AfterFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("after", localization); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "gt"
        };
    }
};
AfterFilterOperatorComponent.ɵfac = function AfterFilterOperatorComponent_Factory(t) { return new (t || AfterFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
AfterFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AfterFilterOperatorComponent, selectors: [["kendo-filter-after-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => AfterFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function AfterFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
AfterFilterOperatorComponent = AfterFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], AfterFilterOperatorComponent);

var AfterEqFilterOperatorComponent_1;
/*
 * Represents the `GreaterOrEqualTo` (**Is after or equal to**) date filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let AfterEqFilterOperatorComponent = AfterEqFilterOperatorComponent_1 = class AfterEqFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("after-eq", localization); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "gte"
        };
    }
};
AfterEqFilterOperatorComponent.ɵfac = function AfterEqFilterOperatorComponent_Factory(t) { return new (t || AfterEqFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
AfterEqFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AfterEqFilterOperatorComponent, selectors: [["kendo-filter-after-eq-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => AfterEqFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function AfterEqFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
AfterEqFilterOperatorComponent = AfterEqFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], AfterEqFilterOperatorComponent);

var BeforeEqFilterOperatorComponent_1;
/*
 * Represents the `LessOrEqualTo` (**Is before or equal to**) date filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let BeforeEqFilterOperatorComponent = BeforeEqFilterOperatorComponent_1 = class BeforeEqFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("before-eq", localization); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "lte"
        };
    }
};
BeforeEqFilterOperatorComponent.ɵfac = function BeforeEqFilterOperatorComponent_Factory(t) { return new (t || BeforeEqFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
BeforeEqFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BeforeEqFilterOperatorComponent, selectors: [["kendo-filter-before-eq-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => BeforeEqFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function BeforeEqFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
BeforeEqFilterOperatorComponent = BeforeEqFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], BeforeEqFilterOperatorComponent);

var BeforeFilterOperatorComponent_1;
/*
 * Represents the `Less then` (**Is before**) date filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)
 */
let BeforeFilterOperatorComponent = BeforeFilterOperatorComponent_1 = class BeforeFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("before", localization); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "lt"
        };
    }
};
BeforeFilterOperatorComponent.ɵfac = function BeforeFilterOperatorComponent_Factory(t) { return new (t || BeforeFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
BeforeFilterOperatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BeforeFilterOperatorComponent, selectors: [["kendo-filter-before-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => BeforeFilterOperatorComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function BeforeFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
BeforeFilterOperatorComponent = BeforeFilterOperatorComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], BeforeFilterOperatorComponent);

const FILTER_OPERATORS = [
    FilterCellOperatorsComponent,
    ContainsFilterOperatorComponent,
    DoesNotContainFilterOperatorComponent,
    EndsWithFilterOperatorComponent,
    EqualFilterOperatorComponent,
    IsEmptyFilterOperatorComponent,
    IsNotEmptyFilterOperatorComponent,
    IsNotNullFilterOperatorComponent,
    IsNullFilterOperatorComponent,
    NotEqualFilterOperatorComponent,
    StartsWithFilterOperatorComponent,
    GreaterFilterOperatorComponent,
    GreaterOrEqualToFilterOperatorComponent,
    LessFilterOperatorComponent,
    LessOrEqualToFilterOperatorComponent,
    AfterFilterOperatorComponent,
    AfterEqFilterOperatorComponent,
    BeforeEqFilterOperatorComponent,
    BeforeFilterOperatorComponent
];
const importedModules = [
    CommonModule,
    ReactiveFormsModule,
    FormsModule,
    DropDownListModule,
    AutoCompleteModule,
    InputsModule,
    DatePickerModule,
    PopupModule,
    SharedModule
];
const COMPONENTS = [
    FilterInputDirective
];
/**
 * @hidden
 */
let SharedFilterModule = class SharedFilterModule {
    static exports() {
        return [
            ...FILTER_OPERATORS
        ];
    }
};
SharedFilterModule.ɵfac = function SharedFilterModule_Factory(t) { return new (t || SharedFilterModule)(); };
SharedFilterModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SharedFilterModule });
SharedFilterModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[...importedModules], CommonModule,
        ReactiveFormsModule,
        FormsModule,
        DropDownListModule,
        AutoCompleteModule,
        InputsModule,
        DatePickerModule,
        PopupModule, SharedModule] });

/**
 * @hidden
 */
class FilterHostDirective {
    constructor(host, resolver) {
        this.host = host;
        this.resolver = resolver;
    }
    ngOnInit() {
        this.component = this.host.createComponent(this.resolver.resolveComponentFactory(this.componentType()));
        this.initComponent({
            column: this.column,
            filter: this.filter
        });
    }
    ngOnDestroy() {
        if (this.component) {
            this.component.destroy();
            this.component = null;
        }
    }
    ngOnChanges(changes) {
        if (anyChanged(["column", "filter"], changes)) {
            this.initComponent({
                column: this.column,
                filter: this.filter
            });
        }
    }
    initComponent({ column, filter: filter$$1 }) {
        const instance = this.component.instance;
        instance.column = column;
        instance.filter = filter$$1;
    }
}
FilterHostDirective.ɵfac = function FilterHostDirective_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FilterHostDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilterHostDirective, inputs: { column: "column", filter: "filter" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], FilterHostDirective.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FilterHostDirective.prototype, "filter", void 0);

/**
 * @hidden
 *
 * > List the following components in the GridModule as `entryComponents`.
 */
const filterComponentFactory = (type) => ({
    "boolean": BooleanFilterCellComponent,
    "date": DateFilterCellComponent,
    "numeric": NumericFilterCellComponent,
    "text": StringFilterCellComponent
}[type]);

/**
 * @hidden
 */
let FilterCellHostDirective = class FilterCellHostDirective extends FilterHostDirective {
    constructor(host, resolver) {
        super(host, resolver);
    }
    componentType() {
        if (!isNullOrEmptyString(this.column.filter)) {
            return filterComponentFactory(this.column.filter);
        }
        return StringFilterCellComponent;
    }
};
FilterCellHostDirective.ɵfac = function FilterCellHostDirective_Factory(t) { return new (t || FilterCellHostDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver)); };
FilterCellHostDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilterCellHostDirective, selectors: [["", "kendoFilterCellHost", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
FilterCellHostDirective = __decorate([ __metadata("design:paramtypes", [ViewContainerRef,
        ComponentFactoryResolver])
], FilterCellHostDirective);

const INTERNAL_COMPONENTS = [
    FilterRowComponent,
    FilterCellComponent,
    FilterCellTemplateDirective,
    StringFilterCellComponent,
    NumericFilterCellComponent,
    AutoCompleteFilterCellComponent,
    BooleanFilterCellComponent,
    FilterCellHostDirective,
    FilterCellWrapperComponent,
    DateFilterCellComponent
];
const ENTRY_COMPONENTS = [
    StringFilterCellComponent,
    NumericFilterCellComponent,
    BooleanFilterCellComponent,
    DateFilterCellComponent
];
/**
 * @hidden
 */
let RowFilterModule = class RowFilterModule {
    static exports() {
        return [
            FilterRowComponent,
            FilterCellComponent,
            FilterCellTemplateDirective,
            FilterCellOperatorsComponent,
            StringFilterCellComponent,
            NumericFilterCellComponent,
            AutoCompleteFilterCellComponent,
            BooleanFilterCellComponent,
            DateFilterCellComponent,
            SharedFilterModule.exports()
        ];
    }
};
RowFilterModule.ɵfac = function RowFilterModule_Factory(t) { return new (t || RowFilterModule)(); };
RowFilterModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: RowFilterModule });
RowFilterModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[SharedFilterModule], SharedFilterModule] });

/**
 * @hidden
 */
let PagerInputDirective = class PagerInputDirective {
    constructor(host, renderer) {
        this.host = host;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        const inputElement = this.host.numericInput.nativeElement;
        this.renderer.addClass(inputElement, 'k-pager-nav');
    }
};
PagerInputDirective.ɵfac = function PagerInputDirective_Factory(t) { return new (t || PagerInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc6.NumericTextBoxComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
PagerInputDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PagerInputDirective, selectors: [["", "kendoGridPagerInput", ""]] });
PagerInputDirective = __decorate([ __metadata("design:paramtypes", [NumericTextBoxComponent,
        Renderer2])
], PagerInputDirective);

/**
 * @hidden
 */
let PagerDropDownListDirective = class PagerDropDownListDirective {
    constructor(host) {
        this.host = host;
        this.keydownHandler = (e) => {
            if (e.keyCode === Keys.Escape && this.host.isOpen) {
                e.stopPropagation();
                this.host.toggle(false);
            }
        };
    }
    ngAfterViewInit() {
        const wrapperElement = this.host.wrapper.nativeElement;
        wrapperElement.addEventListener('keydown', this.keydownHandler, true);
    }
    ngOnDestroy() {
        this.host.wrapper.nativeElement.removeEventListener('keydown', this.keydownHandler);
    }
};
PagerDropDownListDirective.ɵfac = function PagerDropDownListDirective_Factory(t) { return new (t || PagerDropDownListDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc8.DropDownListComponent)); };
PagerDropDownListDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PagerDropDownListDirective, selectors: [["", "kendoGridPagerDropDown", ""]] });
PagerDropDownListDirective = __decorate([ __metadata("design:paramtypes", [DropDownListComponent])
], PagerDropDownListDirective);

/**
 * @hidden
 */
const normalizeSettings = ({ buttonCount = 10, info = true, type = 'numeric', pageSizes = false, previousNext = true, responsive = true, position = 'bottom' }) => ({
    buttonCount,
    info,
    pageSizes: pageSizes === true ? [5, 10, 20] : pageSizes,
    previousNext,
    type,
    responsive,
    position
});
/**
 * @hidden
 */
const normalize = (settings) => normalizeSettings(settings === true ? {} : settings);

/**
 * @hidden
 */
let PagerComponent = class PagerComponent {
    constructor(pagerContext, navigationService, element, renderer, zone, localizationService, cellContext, focusRoot, focusGroup) {
        this.pagerContext = pagerContext;
        this.navigationService = navigationService;
        this.element = element;
        this.renderer = renderer;
        this.zone = zone;
        this.localizationService = localizationService;
        this.cellContext = cellContext;
        this.focusRoot = focusRoot;
        this.focusGroup = focusGroup;
        this.total = 0;
        this.skip = 1;
        this.pageChange = new EventEmitter();
        this.pagerWrapClass = true;
        this.gridPagerClass = true;
        this.settings = normalize({});
        this.subscriptions = new Subscription();
        this._templateContext = {};
        this._isFocused = false;
        this.resizeHandler = () => {
            const element = this.element.nativeElement;
            if (this.template || !element) {
                return;
            }
            const width = element.offsetWidth;
            if (width < RESPONSIVE_BREAKPOINT_MEDIUM) {
                this.renderer.removeClass(element, 'k-pager-md');
                this.renderer.addClass(element, 'k-pager-sm');
            }
            else if (width >= RESPONSIVE_BREAKPOINT_MEDIUM && width < RESPONSIVE_BREAKPOINT_LARGE) {
                this.renderer.addClass(element, 'k-pager-md');
                this.renderer.removeClass(element, 'k-pager-sm');
            }
            else {
                this.clearResponsiveClasses();
            }
        };
    }
    set options(value) {
        this.settings = normalize(value);
    }
    get isFocused() {
        return this._isFocused;
    }
    get pagerAriaLabel() {
        return this.navigationService.enabled ? this.pagerLabel : undefined;
    }
    /**
     * @hidden
     */
    get pagerLabel() {
        const localizationMsg = this.localizationService.get('pagerLabel') || '';
        return replaceMessagePlaceholder(replaceMessagePlaceholder(localizationMsg, 'currentPage', this.currentPage.toString()), 'totalPages', this.totalPages.toString());
    }
    get focusTrapTabIndex() {
        return this.focusGroup.isActive ? '0' : '-1';
    }
    onFocusIn(event) {
        if (this.navigationService.enabled) {
            const shouldFocusPager = event.target === this.element.nativeElement;
            if (shouldFocusPager) {
                this._isFocused = true;
                this.focusRoot.deactivate();
            }
            else {
                this.focusRoot.activate();
            }
        }
    }
    onFocusOut() {
        if (this.navigationService.enabled) {
            this._isFocused = false;
        }
    }
    onEscape() {
        if (this.navigationService.enabled) {
            this.focusRoot.deactivate();
            this.element.nativeElement.focus();
        }
    }
    onEnter(event) {
        if (this.navigationService.enabled && event.target === this.element.nativeElement) {
            this.focusRoot.activate();
            this.focusFirstElement();
        }
    }
    navigateToPreviousPage(e) {
        if (this.shouldTriggerPageChange(e.target, this.currentPage > 1)) {
            this.pagerContext.prevPage();
        }
    }
    navigateToNextPage(e) {
        if (this.shouldTriggerPageChange(e.target, this.currentPage < this.totalPages)) {
            this.pagerContext.nextPage();
        }
    }
    navigateToFirstPage(e) {
        if (this.shouldTriggerPageChange(e.target, this.currentPage > 1)) {
            this.pagerContext.changePage(0);
        }
    }
    navigateToLastPage(e) {
        if (this.shouldTriggerPageChange(e.target, this.currentPage < this.totalPages)) {
            this.pagerContext.changePage(this.totalPages - 1);
        }
    }
    get totalPages() {
        return Math.ceil((this.total || 0) / this.pageSize);
    }
    get currentPage() {
        return Math.floor((this.skip || 0) / this.pageSize) + 1;
    }
    get templateContext() {
        const context = this._templateContext;
        context.totalPages = this.totalPages;
        context.total = this.total;
        context.skip = this.skip;
        context.pageSize = this.pageSize;
        context.currentPage = this.currentPage;
        return context;
    }
    ngOnInit() {
        this.subscriptions.add(this.pagerContext.pageChange.subscribe(this.changePage.bind(this)));
        if (this.navigationService.enabled) {
            this.focusRoot.deactivate();
        }
    }
    ngDoCheck() {
        this.updateCellContext();
    }
    ngOnChanges(changes) {
        if (anyChanged(['pageSize', 'skip', 'total'], changes, false)) {
            this.pagerContext.notifyChanges({
                pageSize: this.pageSize,
                skip: this.skip,
                total: this.total
            });
        }
        if (changes.template) {
            changes.template.currentValue ? this.clearResponsiveClasses() : this.resizeHandler();
        }
        if (changes.options) {
            this.settings.responsive ? this.resizeHandler() : this.clearResponsiveClasses();
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    changePage(event) {
        this.pageChange.emit(event);
    }
    onInnerFocusIn(event, position) {
        this.zone.onStable.pipe(take(1)).subscribe(() => {
            if (position === 'start') {
                if (event.relatedTarget === this.element.nativeElement) {
                    this.focusFirstElement();
                }
                else {
                    this.focusLastElement();
                }
            }
            else {
                this.focusFirstElement();
            }
        });
    }
    clearResponsiveClasses() {
        const element = this.element.nativeElement;
        this.renderer.removeClass(element, 'k-pager-sm');
        this.renderer.removeClass(element, 'k-pager-md');
    }
    shouldTriggerPageChange(target, condition) {
        return this.navigationService.enabled &&
            target === this.element.nativeElement &&
            condition;
    }
    focusFirstElement() {
        const first = findFocusableChild(this.element.nativeElement, true);
        if (first) {
            first.focus();
        }
    }
    focusLastElement() {
        const last = findLastFocusableChild(this.element.nativeElement, true);
        if (last) {
            last.focus();
        }
    }
    updateCellContext() {
        if (this.cellContext) {
            this.cellContext.focusGroup = this.focusGroup;
        }
    }
};
PagerComponent.ɵfac = function PagerComponent_Factory(t) { return new (t || PagerComponent)(ɵngcc0.ɵɵdirectiveInject(PagerContextService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(CELL_CONTEXT, 8), ɵngcc0.ɵɵdirectiveInject(FocusRoot), ɵngcc0.ɵɵdirectiveInject(FocusGroup)); };
PagerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PagerComponent, selectors: [["kendo-pager"]], hostVars: 7, hostBindings: function PagerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function PagerComponent_focusin_HostBindingHandler($event) { return ctx.onFocusIn($event); })("focusout", function PagerComponent_focusout_HostBindingHandler() { return ctx.onFocusOut(); })("keydown.escape", function PagerComponent_keydown_escape_HostBindingHandler() { return ctx.onEscape(); })("keydown.enter", function PagerComponent_keydown_enter_HostBindingHandler($event) { return ctx.onEnter($event); })("keydown.arrowleft", function PagerComponent_keydown_arrowleft_HostBindingHandler($event) { return ctx.navigateToPreviousPage($event); })("keydown.pageup", function PagerComponent_keydown_pageup_HostBindingHandler($event) { return ctx.navigateToPreviousPage($event); })("keydown.arrowright", function PagerComponent_keydown_arrowright_HostBindingHandler($event) { return ctx.navigateToNextPage($event); })("keydown.pagedown", function PagerComponent_keydown_pagedown_HostBindingHandler($event) { return ctx.navigateToNextPage($event); })("keydown.home", function PagerComponent_keydown_home_HostBindingHandler($event) { return ctx.navigateToFirstPage($event); })("keydown.end", function PagerComponent_keydown_end_HostBindingHandler($event) { return ctx.navigateToLastPage($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.pagerAriaLabel);
        ɵngcc0.ɵɵclassProp("k-pager-wrap", ctx.pagerWrapClass)("k-grid-pager", ctx.gridPagerClass)("k-state-focused", ctx.isFocused);
    } }, inputs: { total: "total", skip: "skip", options: "options", pageSize: "pageSize", template: "template" }, outputs: { pageChange: "pageChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: FOCUS_ROOT_ACTIVE,
                useValue: true
            }, {
                provide: FocusRoot,
                deps: [FOCUS_ROOT_ACTIVE],
                useClass: FocusRoot
            }, {
                provide: FocusGroup,
                deps: [FocusRoot],
                useClass: FocusGroup
            }]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 5, consts: [["class", "k-sr-only", 3, "tabindex", "focusin", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [4, "ngIf"], [3, "resize", 4, "ngIf"], [1, "k-sr-only", 3, "tabindex", "focusin"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "buttonCount", 4, "ngIf"], [3, "pageSizes", 4, "ngIf"], [3, "buttonCount"], [3, "pageSizes"], ["pageSizes", ""], [3, "resize"]], template: function PagerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, PagerComponent_div_0_Template, 1, 2, "div", 0);
        ɵngcc0.ɵɵtemplate(1, PagerComponent_ng_container_1_Template, 1, 2, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, PagerComponent_ng_container_2_Template, 7, 6, "ng-container", 2);
        ɵngcc0.ɵɵtemplate(3, PagerComponent_div_3_Template, 1, 2, "div", 0);
        ɵngcc0.ɵɵtemplate(4, PagerComponent_kendo_resize_sensor_4_Template, 1, 0, "kendo-resize-sensor", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.navigationService.enabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.template == null ? null : ctx.template.templateRef);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !(ctx.template == null ? null : ctx.template.templateRef));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navigationService.enabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.settings.responsive);
    } }, directives: function () { return [ɵngcc5.NgIf, ɵngcc5.NgTemplateOutlet, PagerPrevButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerNextButtonsComponent, PagerInfoComponent, PagerPageSizesComponent, ɵngcc2.ResizeSensorComponent]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], PagerComponent.prototype, "total", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], PagerComponent.prototype, "skip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], PagerComponent.prototype, "pageSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], PagerComponent.prototype, "options", null);
__decorate([
    Input(),
    __metadata("design:type", PagerTemplateDirective)
], PagerComponent.prototype, "template", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], PagerComponent.prototype, "pageChange", void 0);
__decorate([
    HostBinding('class.k-pager-wrap'),
    __metadata("design:type", Boolean)
], PagerComponent.prototype, "pagerWrapClass", void 0);
__decorate([
    HostBinding('class.k-grid-pager'),
    __metadata("design:type", Boolean)
], PagerComponent.prototype, "gridPagerClass", void 0);
__decorate([
    HostBinding('class.k-state-focused'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PagerComponent.prototype, "isFocused", null);
__decorate([
    HostBinding('attr.aria-label'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], PagerComponent.prototype, "pagerAriaLabel", null);
__decorate([
    HostListener('focusin', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PagerComponent.prototype, "onFocusIn", null);
__decorate([
    HostListener('focusout'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PagerComponent.prototype, "onFocusOut", null);
__decorate([
    HostListener('keydown.escape'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PagerComponent.prototype, "onEscape", null);
__decorate([
    HostListener('keydown.enter', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PagerComponent.prototype, "onEnter", null);
__decorate([
    HostListener('keydown.arrowleft', ['$event']),
    HostListener('keydown.pageup', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PagerComponent.prototype, "navigateToPreviousPage", null);
__decorate([
    HostListener('keydown.arrowright', ['$event']),
    HostListener('keydown.pagedown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PagerComponent.prototype, "navigateToNextPage", null);
__decorate([
    HostListener('keydown.home', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PagerComponent.prototype, "navigateToFirstPage", null);
__decorate([
    HostListener('keydown.end', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PagerComponent.prototype, "navigateToLastPage", null);
PagerComponent = __decorate([ __param(6, Optional()), __param(6, Inject(CELL_CONTEXT)),
    __metadata("design:paramtypes", [PagerContextService,
        NavigationService,
        ElementRef,
        Renderer2,
        NgZone,
        LocalizationService, Object, FocusRoot,
        FocusGroup])
], PagerComponent);

/**
 * @hidden
 */
class PagerElementComponent {
    constructor(localization, pagerContext, cd) {
        this.localization = localization;
        this.pagerContext = pagerContext;
        this.cd = cd;
        this.total = this.pagerContext.total;
        this.skip = this.pagerContext.skip;
        this.pageSize = this.pagerContext.pageSize;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerElementComponent
     */
    get currentPage() {
        return Math.floor((this.skip || 0) / this.pageSize) + 1;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerElementComponent
     */
    get totalPages() {
        return Math.ceil((this.total || 0) / this.pageSize);
    }
    /**
     * @hidden
     *
     * @param {string} key
     * @returns {string}
     *
     * @memberOf PagerElementComponent
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     *
     * @param {number} page
     *
     * @memberOf PagerElementComponent
     */
    changePage(page) {
        this.pagerContext.changePage(page);
        return false;
    }
    /**
     * @hidden
     *
     * @memberOf PagerElementComponent
     */
    ngOnInit() {
        this.subscriptions = this.pagerContext.changes.subscribe(this.onChanges.bind(this));
        this.subscriptions.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
}
PagerElementComponent.ɵfac = function PagerElementComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
PagerElementComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PagerElementComponent });

/**
 * Displays buttons for navigating to the first and to the previous page ([see example]({% slug paging_grid %}#toc-pager-templates)).
 */
let PagerPrevButtonsComponent = class PagerPrevButtonsComponent extends PagerElementComponent {
    constructor(localization, pagerContext, cd, navigationService) {
        super(localization, pagerContext, cd);
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {boolean}
     * @memberOf PagerPrevButtonsComponent
     */
    get disabled() {
        return this.currentPage === 1 || !this.total;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
};
PagerPrevButtonsComponent.ɵfac = function PagerPrevButtonsComponent_Factory(t) { return new (t || PagerPrevButtonsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(PagerContextService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
PagerPrevButtonsComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PagerPrevButtonsComponent, selectors: [["kendo-pager-prev-buttons"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 16, consts: [["role", "button", 3, "kendoGridFocusable", "title", "ngClass", "click", "keydown.enter"], ["role", "note", 3, "ngClass"]], template: function PagerPrevButtonsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵlistener("click", function PagerPrevButtonsComponent_Template_span_click_0_listener() { return ctx.currentPage !== 1 ? ctx.changePage(0) : false; })("keydown.enter", function PagerPrevButtonsComponent_Template_span_keydown_enter_0_listener() { return ctx.currentPage !== 1 ? ctx.changePage(0) : false; });
        ɵngcc0.ɵɵelement(1, "span", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 0);
        ɵngcc0.ɵɵlistener("click", function PagerPrevButtonsComponent_Template_span_click_2_listener() { return ctx.currentPage !== 1 ? ctx.changePage(ctx.currentPage - 2) : false; })("keydown.enter", function PagerPrevButtonsComponent_Template_span_keydown_enter_2_listener() { return ctx.currentPage !== 1 ? ctx.changePage(ctx.currentPage - 2) : false; });
        ɵngcc0.ɵɵelement(3, "span", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("kendoGridFocusable", !ctx.disabled)("title", ctx.textFor("pagerFirstPage"))("ngClass", ɵngcc0.ɵɵpureFunction1(10, _c155, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(12, _c156));
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("pagerFirstPage"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("kendoGridFocusable", !ctx.disabled)("title", ctx.textFor("pagerPreviousPage"))("ngClass", ɵngcc0.ɵɵpureFunction1(13, _c157, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(15, _c158));
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("pagerPreviousPage"));
    } }, directives: [FocusableDirective, ɵngcc5.NgClass], encapsulation: 2, changeDetection: 0 });
PagerPrevButtonsComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        PagerContextService,
        ChangeDetectorRef,
        NavigationService])
], PagerPrevButtonsComponent);

/**
 * Displays buttons for navigating to the next and to the last page ([see example]({% slug paging_grid %}#toc-pager-template)).
 */
let PagerNextButtonsComponent = class PagerNextButtonsComponent extends PagerElementComponent {
    constructor(localization, pagerContext, cd, navigationService) {
        super(localization, pagerContext, cd);
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {boolean}
     * @memberOf PagerNextButtonsComponent
     */
    get disabled() {
        return this.currentPage === this.totalPages || !this.total;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
};
PagerNextButtonsComponent.ɵfac = function PagerNextButtonsComponent_Factory(t) { return new (t || PagerNextButtonsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(PagerContextService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
PagerNextButtonsComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PagerNextButtonsComponent, selectors: [["kendo-pager-next-buttons"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 16, consts: [["tabindex", "0", "role", "button", 3, "kendoGridFocusable", "title", "ngClass", "click", "keydown.enter"], ["role", "note", 3, "ngClass"]], template: function PagerNextButtonsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵlistener("click", function PagerNextButtonsComponent_Template_span_click_0_listener() { return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.currentPage) : false; })("keydown.enter", function PagerNextButtonsComponent_Template_span_keydown_enter_0_listener() { return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.currentPage) : false; });
        ɵngcc0.ɵɵelement(1, "span", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 0);
        ɵngcc0.ɵɵlistener("click", function PagerNextButtonsComponent_Template_span_click_2_listener() { return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.totalPages - 1) : false; })("keydown.enter", function PagerNextButtonsComponent_Template_span_keydown_enter_2_listener() { return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.totalPages - 1) : false; });
        ɵngcc0.ɵɵelement(3, "span", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("kendoGridFocusable", !ctx.disabled)("title", ctx.textFor("pagerNextPage"))("ngClass", ɵngcc0.ɵɵpureFunction1(10, _c157, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(12, _c159));
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("pagerNextPage"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("kendoGridFocusable", !ctx.disabled)("title", ctx.textFor("pagerLastPage"))("ngClass", ɵngcc0.ɵɵpureFunction1(13, _c160, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(15, _c161));
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("pagerLastPage"));
    } }, directives: [FocusableDirective, ɵngcc5.NgClass], encapsulation: 2, changeDetection: 0 });
PagerNextButtonsComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        PagerContextService,
        ChangeDetectorRef,
        NavigationService])
], PagerNextButtonsComponent);

/**
 * Displays numeric buttons to enable navigation between the pages.
 */
let PagerNumericButtonsComponent = class PagerNumericButtonsComponent extends PagerElementComponent {
    constructor(localization, cd, pagerContext) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
        this.numbersWrapClass = true;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number[]}
     * @memberOf PagerNumericButtonsComponent
     */
    get buttons() {
        let result = [];
        for (let idx = this.start; idx <= this.end; idx++) {
            result.push(idx);
        }
        return result;
    }
    /**
     * @hidden
     */
    get end() {
        return Math.min((this.start + this.buttonCount) - 1, this.totalPages);
    }
    /**
     * @hidden
     */
    get start() {
        const page = this.currentPage;
        const buttonCount = this.buttonCount;
        if (page > buttonCount) {
            const reminder = (page % buttonCount);
            return (reminder === 0) ? (page - buttonCount) + 1 : (page - reminder) + 1;
        }
        return 1;
    }
    /**
     * @hidden
     */
    pageLabel(num) {
        const pageText = this.textFor('pagerPage');
        if (pageText) {
            return pageText + ' ' + num;
        }
        return num.toString();
    }
    /**
     * @hidden
     */
    onSelectChange(e) {
        const target = e.target;
        const valueAsNumber = Number(target.value);
        if (!Number.isNaN(valueAsNumber)) {
            this.changePage(valueAsNumber - 1);
        }
        else {
            if (target.value === 'previousButtons') {
                this.changePage(this.start - 2);
            }
            else {
                this.changePage(this.end);
            }
        }
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
};
PagerNumericButtonsComponent.ɵfac = function PagerNumericButtonsComponent_Factory(t) { return new (t || PagerNumericButtonsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PagerContextService)); };
PagerNumericButtonsComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PagerNumericButtonsComponent, selectors: [["kendo-pager-numeric-buttons"]], hostVars: 2, hostBindings: function PagerNumericButtonsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-pager-numbers-wrap", ctx.numbersWrapClass);
    } }, inputs: { buttonCount: "buttonCount" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 8, vars: 9, consts: [["kendoGridFocusable", "", "tabindex", "0", 1, "k-dropdownlist", "k-pager-nav", 3, "value", "change"], ["class", "k-link", "value", "previousButtons", 4, "ngIf"], [3, "value", "ngClass", 4, "ngFor", "ngForOf"], ["value", "nextButtons", "class", "k-link", 4, "ngIf"], [3, "ngClass"], [4, "ngIf"], [4, "ngFor", "ngForOf"], ["value", "previousButtons", 1, "k-link"], [3, "value", "ngClass"], ["value", "nextButtons", 1, "k-link"], ["kendoGridFocusable", "", "tabindex", "0", "role", "button", 1, "k-link", "k-pager-nav", 3, "click", "keydown.enter"], ["kendoGridFocusable", "", "tabindex", "0", "role", "button", 3, "ngClass", "click", "keydown.enter"]], template: function PagerNumericButtonsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "select", 0);
        ɵngcc0.ɵɵlistener("change", function PagerNumericButtonsComponent_Template_select_change_0_listener($event) { return ctx.onSelectChange($event); });
        ɵngcc0.ɵɵtemplate(1, PagerNumericButtonsComponent_option_1_Template, 2, 1, "option", 1);
        ɵngcc0.ɵɵtemplate(2, PagerNumericButtonsComponent_option_2_Template, 2, 7, "option", 2);
        ɵngcc0.ɵɵtemplate(3, PagerNumericButtonsComponent_option_3_Template, 2, 1, "option", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "ul", 4);
        ɵngcc0.ɵɵtemplate(5, PagerNumericButtonsComponent_li_5_Template, 3, 1, "li", 5);
        ɵngcc0.ɵɵtemplate(6, PagerNumericButtonsComponent_li_6_Template, 3, 5, "li", 6);
        ɵngcc0.ɵɵtemplate(7, PagerNumericButtonsComponent_li_7_Template, 3, 1, "li", 5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("value", ctx.currentPage.toString());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.start > 1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.buttons);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.end < ctx.totalPages);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(8, _c164));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.start > 1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.buttons);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.end < ctx.totalPages);
    } }, directives: [FocusableDirective, ɵngcc5.NgIf, ɵngcc5.NgForOf, ɵngcc5.NgClass], encapsulation: 2, changeDetection: 0 });
__decorate([
    HostBinding('class.k-pager-numbers-wrap'),
    __metadata("design:type", Boolean)
], PagerNumericButtonsComponent.prototype, "numbersWrapClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], PagerNumericButtonsComponent.prototype, "buttonCount", void 0);
PagerNumericButtonsComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ChangeDetectorRef,
        PagerContextService])
], PagerNumericButtonsComponent);

/**
 * Displays an input element which allows the typing and rendering of page numbers.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *      <kendo-grid
 *        [kendoGridBinding]="gridData"
 *        [pageSize]="1"
 *        [pageable]="true"
 *      >
 *       <kendo-grid-column field="ProductID" title="ID" width="40">
 *       </kendo-grid-column>
 *       <kendo-grid-column field="ProductName" title="Name" width="250">
 *       </kendo-grid-column>
 *       <kendo-grid-column field="UnitPrice" title="Price" width="80" format="{0:c}">
 *       </kendo-grid-column>
 *
 *       <ng-template kendoPagerTemplate let-totalPages="totalPages" let-currentPage="currentPage">
 *          <kendo-pager-prev-buttons></kendo-pager-prev-buttons>
 *          <kendo-pager-numeric-buttons [buttonCount]="10"></kendo-pager-numeric-buttons>
 *          <kendo-pager-next-buttons></kendo-pager-next-buttons>
 *          <kendo-pager-input></kendo-pager-input>
 *          <kendo-pager-info></kendo-pager-info>
 *       </ng-template>
 *
 *    </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *     public gridData = [{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000,
 *         "Discontinued": false
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000,
 *         "Discontinued": true
 *       }
 *     ];
 * }
 *
 * ```
 */
let PagerInputComponent = class PagerInputComponent extends PagerElementComponent {
    constructor(localization, pagerContext, zone, navigationService, cd) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
        this.zone = zone;
        this.navigationService = navigationService;
        /**
         * @hidden
         *
         * @param {string} value
         *
         * @memberOf PagerInputComponent
         */
        this.handleKeyDown = (event) => {
            let incomingValue = this.numericInput.value || this.current;
            if (event.keyCode === Keys.Enter) {
                event.preventDefault();
                if (incomingValue !== this.current) {
                    this.zone.run(() => {
                        this.changePage(incomingValue - 1);
                    });
                }
            }
        };
        /**
         * @hidden
         *
         * @param {string} value
         *
         * @memberOf PagerInputComponent
         */
        this.handleBlur = () => {
            const inputValue = this.numericInput.value;
            if (!inputValue) {
                this.numericInput.writeValue(this.current);
                return;
            }
            if (inputValue !== this.current) {
                this.zone.run(() => {
                    this.changePage(inputValue - 1);
                });
            }
        };
    }
    /**
     * @hidden
     */
    get current() {
        return this.hasPages ? this.currentPage : 0;
    }
    get hasPages() {
        return this.totalPages !== 0;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
};
PagerInputComponent.ɵfac = function PagerInputComponent_Factory(t) { return new (t || PagerInputComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(PagerContextService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
PagerInputComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PagerInputComponent, selectors: [["kendo-pager-input"]], viewQuery: function PagerInputComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NumericTextBoxComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.numericInput = _t.first);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 18, consts: [[3, "ngClass"], ["kendoGridPagerInput", "", "tabindex", "0", "format", "n0", 3, "kendoGridFocusable", "spinners", "decimals", "disabled", "value", "min", "max", "autoCorrect", "title", "kendoEventsOutsideAngular"]], template: function PagerInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelement(2, "kendo-numerictextbox", 1);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(14, _c165));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.textFor("pagerPage"), " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("kendoGridFocusable", ctx.hasPages)("spinners", false)("decimals", 0)("disabled", !ctx.hasPages)("value", ctx.current)("min", ctx.hasPages ? 1 : 0)("max", ctx.totalPages)("autoCorrect", true)("title", ctx.textFor("pagerPageNumberInputTitle"))("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(15, _c166, ctx.handleKeyDown, ctx.handleBlur));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate2(" ", ctx.textFor("pagerOf"), " ", ctx.totalPages, " ");
    } }, directives: [ɵngcc5.NgClass, ɵngcc6.NumericTextBoxComponent, PagerInputDirective, FocusableDirective, ɵngcc2.EventsOutsideAngularDirective], encapsulation: 2 });
__decorate([
    ViewChild(NumericTextBoxComponent, { static: false }),
    __metadata("design:type", NumericTextBoxComponent)
], PagerInputComponent.prototype, "numericInput", void 0);
PagerInputComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        PagerContextService,
        NgZone,
        NavigationService,
        ChangeDetectorRef])
], PagerInputComponent);

/**
 * Displays information about the current page and the total number of records ([see example]({% slug paging_grid %}#toc-pager-templates)).
 */
let PagerInfoComponent = class PagerInfoComponent extends PagerElementComponent {
    constructor(localization, cd, pagerContext) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerInfoComponent
     */
    get maxItems() {
        return Math.min(this.currentPage * this.pageSize, this.total);
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerInfoComponent
     */
    get currentPageText() {
        return this.total ?
            (this.currentPage - 1) * this.pageSize + 1 :
            0;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {boolean}
     * @memberOf PagerInfoComponent
     */
    get classes() {
        return true;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
};
PagerInfoComponent.ɵfac = function PagerInfoComponent_Factory(t) { return new (t || PagerInfoComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PagerContextService)); };
PagerInfoComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PagerInfoComponent, selectors: [["kendo-pager-info"]], hostVars: 4, hostBindings: function PagerInfoComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-pager-info", ctx.classes)("k-label", ctx.classes);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 5, template: function PagerInfoComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate5("", ctx.currentPageText, " - ", ctx.maxItems, " ", ctx.textFor("pagerOf"), " ", ctx.total, " ", ctx.textFor("pagerItems"), "");
    } }, encapsulation: 2, changeDetection: 0 });
__decorate([
    HostBinding("class.k-pager-info"),
    HostBinding("class.k-label"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PagerInfoComponent.prototype, "classes", null);
PagerInfoComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ChangeDetectorRef,
        PagerContextService])
], PagerInfoComponent);

/**
 * Displays a drop-down list for the page size selection ([see example]({% slug paging_grid %}#toc-pager-templates)).
 */
let PagerPageSizesComponent = class PagerPageSizesComponent extends PagerElementComponent {
    constructor(localization, cd, pagerContext, navigationService) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
        this.navigationService = navigationService;
        this._pageSizes = [];
    }
    get pageSizes() {
        return this._pageSizes;
    }
    /**
     * The page sizes collection. Can be an Array of numbers and/or PageSizeItem objects.
     *
     * @example
     * ```ts-preview
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-grid [kendoGridBinding]="gridData" [height]="200"
     *           [pageable]="true"
     *            [pageSize]="pageSize">
     *            <ng-template kendoPagerTemplate let-totalPages="totalPages" let-currentPage="currentPage">
     *                <kendo-pager-page-sizes [pageSizes]="pagesizes"></kendo-pager-page-sizes>
     *            </ng-template>
     *        </kendo-grid>
     *    `
     * })
     * class AppComponent {
     *    public gridData: any[] = products;
     *    public pageSize = 2;
     *    public pagesizes = [{text: 'One', value: 1}, {text: 'Two', value: 2}, {text: 'All', value : 'all'}];
     * }
     *
     * const products = [{
     *   'ProductID' : 1,
     *   'ProductName' : "Chai",
     *   'SupplierID' : 1,
     *   'CategoryID' : 1,
     *   'QuantityPerUnit' : "10 boxes x 20 bags",
     *   'UnitPrice' : 18.0000,
     *   'UnitsInStock' : 39,
     *   'UnitsOnOrder' : 0,
     *   'ReorderLevel' : 10,
     *   'Discontinued' : false
     *
     * }, {
     *   'ProductID' : 2,
     *   'ProductName' : "Chang",
     *   'SupplierID' : 1,
     *   'CategoryID' : 1,
     *   'QuantityPerUnit' : "24 - 12 oz bottles",
     *   'UnitPrice' : 19.0000,
     *   'UnitsInStock' : 17,
     *   'UnitsOnOrder' : 40,
     *   'ReorderLevel' : 25,
     *   'Discontinued' : false
     * }, {
     *   'ProductID' : 3,
     *   'ProductName' : "Aniseed Syrup",
     *   'SupplierID' : 1,
     *   'CategoryID' : 2,
     *   'QuantityPerUnit' : "12 - 550 ml bottles",
     *   'UnitPrice' : 10.0000,
     *   'UnitsInStock' : 13,
     *   'UnitsOnOrder' : 70,
     *   'ReorderLevel' : 25,
     *   'Discontinued' : false
     * }, {
     *   'ProductID' : 4,
     *   'ProductName' : "Chef Anton\'s Cajun Seasoning",
     *   'SupplierID' : 2,
     *  'CategoryID' : 2,
     *   'QuantityPerUnit' : "48 - 6 oz jars",
     *   'UnitPrice' : 22.0000,
     *   'UnitsInStock' : 53,
     *   'UnitsOnOrder' : 0,
     *   'ReorderLevel' : 0,
     *   'Discontinued' : false
     * }, {
     *   'ProductID' : 5,
     *   'ProductName' : "Chef Anton\'s Gumbo Mix",
     *   'SupplierID' : 2,
     *   'CategoryID' : 2,
     *   'QuantityPerUnit' : "36 boxes",
     *   'UnitPrice' : 21.3500,
     *   'UnitsInStock' : 0,
     *   'UnitsOnOrder' : 0,
     *   'ReorderLevel' : 0,
     *   'Discontinued' : true
     * }, {
     *   'ProductID' : 6,
     *   'ProductName' : "Grandma\'s Boysenberry Spread",
     *   'SupplierID' : 3,
     *   'CategoryID' : 2,
     *   'QuantityPerUnit' : "12 - 8 oz jars",
     *   'UnitPrice' : 25.0000,
     *   'UnitsInStock' : 120,
     *   'UnitsOnOrder' : 0,
     *   'ReorderLevel' : 25,
     *   'Discontinued' : false
     * }];
     * ```
     */
    set pageSizes(pageSizes) {
        let normalizedItems = [];
        pageSizes.forEach(item => {
            if (typeof item === 'number') {
                normalizedItems.push({
                    text: item.toString(),
                    value: item
                });
            }
            else {
                normalizedItems.push(item);
            }
        });
        if (this.pageSize && !normalizedItems.some(item => item.value === this.pageSize)) {
            normalizedItems = [{ text: this.pageSize.toString(), value: this.pageSize }, ...normalizedItems];
        }
        this._pageSizes = normalizedItems;
    }
    /**
     * @hidden
     *
     * @readonly
     */
    get classes() {
        return true;
    }
    /**
     * @hidden
     *
     * @readonly
     */
    get showInitialPageSize() {
        return this.pageSizes
            .filter(item => {
            if (typeof item.value === 'number') {
                return item.value === Number(this.pageSize);
            }
            return this.total === Number(this.pageSize);
        })
            .length === 0;
    }
    /**
     * @hidden
     */
    pageSizeChange(value) {
        this.pageSize = typeof value === 'number' ? value : this.total;
        this.pagerContext.changePageSize(this.pageSize);
    }
    /**
     * @hidden
     */
    getValue(page) {
        return typeof page.value === 'number' ? page.value : this.total;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = typeof pageSize === 'number' ? pageSize : this.total;
        this.cd.markForCheck();
    }
};
PagerPageSizesComponent.ɵfac = function PagerPageSizesComponent_Factory(t) { return new (t || PagerPageSizesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PagerContextService), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
PagerPageSizesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PagerPageSizesComponent, selectors: [["kendo-pager-page-sizes"]], hostVars: 4, hostBindings: function PagerPageSizesComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-pager-sizes", ctx.classes)("k-label", ctx.classes);
    } }, inputs: { pageSizes: "pageSizes" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 5, consts: [["kendoGridPagerDropDown", "", "tabindex", "0", "kendoGridFocusable", "", "textField", "text", "valueField", "value", 3, "data", "valuePrimitive", "value", "valueChange"], ["dropdownlist", ""], [3, "for", "text"]], template: function PagerPageSizesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 0, 1);
        ɵngcc0.ɵɵlistener("valueChange", function PagerPageSizesComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) { return ctx.pageSizeChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(2, "kendo-label", 2);
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵproperty("data", ctx.pageSizes)("valuePrimitive", true)("value", ctx.pageSize);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("for", _r0)("text", ctx.textFor("pagerItemsPerPage"));
    } }, directives: [ɵngcc8.DropDownListComponent, PagerDropDownListDirective, FocusableDirective, ɵngcc11.LabelComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], PagerPageSizesComponent.prototype, "pageSizes", null);
__decorate([
    HostBinding('class.k-pager-sizes'),
    HostBinding('class.k-label'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PagerPageSizesComponent.prototype, "classes", null);
PagerPageSizesComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ChangeDetectorRef,
        PagerContextService,
        NavigationService])
], PagerPageSizesComponent);

const importedModules$1 = [
    CommonModule,
    InputsModule,
    LabelModule,
    DropDownsModule,
    ResizeSensorModule,
    SharedModule
];
const INTERNAL_COMPONENTS$1 = [
    PagerComponent,
    PagerPrevButtonsComponent,
    PagerNextButtonsComponent,
    PagerNumericButtonsComponent,
    PagerInputComponent,
    PagerInfoComponent,
    PagerPageSizesComponent,
    PagerTemplateDirective,
    PagerDropDownListDirective,
    PagerInputDirective
];
/**
 * @hidden
 */
let PagerModule = class PagerModule {
    static exports() {
        return [
            PagerComponent,
            PagerPrevButtonsComponent,
            PagerNextButtonsComponent,
            PagerNumericButtonsComponent,
            PagerInputComponent,
            PagerInfoComponent,
            PagerPageSizesComponent,
            PagerTemplateDirective,
            PagerDropDownListDirective,
            PagerInputDirective
        ];
    }
};
PagerModule.ɵfac = function PagerModule_Factory(t) { return new (t || PagerModule)(); };
PagerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: PagerModule });
PagerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[...importedModules$1]] });

/**
 * @hidden
 */
let GroupHeaderComponent = class GroupHeaderComponent {
    constructor(groupsService, groupInfoService, localization) {
        this.groupsService = groupsService;
        this.groupInfoService = groupInfoService;
        this.localization = localization;
        this.skipGroupDecoration = false;
        this.hasDetails = false;
        this.totalColumnsCount = 0;
        this.groups = [];
        this.isExpanded = false;
    }
    get groupItemClass() {
        return true;
    }
    ngDoCheck() {
        const groupArgs = {
            group: this.item.data,
            groupIndex: this.item.index,
            parentGroup: getGroupRowArgs(this.item.parentGroup)
        };
        this.isExpanded = this.groupsService.isExpanded(groupArgs);
    }
    prefixGroupCell(item) {
        return new Array(item.level);
    }
    toggleGroup(item) {
        this.groupsService.toggleRow(item);
        return false;
    }
    groupSpan(item) {
        const groupCount = (this.groups || []).length;
        const detailOffset = this.hasDetails ? 1 : 0;
        if (this.hasGroupHeaderColumn) {
            return groupCount + 1 + detailOffset - item.level;
        }
        let columnCount = columnsSpan(this.columns);
        if (this.skipGroupDecoration) {
            return columnCount;
        }
        return groupCount + columnCount + detailOffset - item.level;
    }
    logicalColSpan() {
        return this.skipGroupDecoration ? 1 : this.totalColumnsCount;
    }
    ariaRole() {
        if (this.skipGroupDecoration) {
            return 'presentation';
        }
        return 'gridcell';
    }
    formatForGroup(item) {
        return this.groupInfoService.formatForGroup(item);
    }
    groupTitle(item) {
        return this.groupInfoService.groupTitle(item);
    }
    groupHeaderTemplate(item) {
        return this.groupInfoService.groupHeaderTemplate(item);
    }
    get groupButtonTitle() {
        const messageKey = this.isExpanded ? 'groupCollapse' : 'groupExpand';
        return this.localization.get(messageKey);
    }
};
GroupHeaderComponent.ɵfac = function GroupHeaderComponent_Factory(t) { return new (t || GroupHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(GroupsService), ɵngcc0.ɵɵdirectiveInject(GroupInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
GroupHeaderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GroupHeaderComponent, selectors: [["", "kendoGridGroupHeader", ""]], hostVars: 2, hostBindings: function GroupHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grouping-row", ctx.groupItemClass);
    } }, inputs: { skipGroupDecoration: "skipGroupDecoration", hasDetails: "hasDetails", totalColumnsCount: "totalColumnsCount", groups: "groups", rowIndex: "rowIndex", logicalRowIndex: "logicalRowIndex", item: "item", hasGroupHeaderColumn: "hasGroupHeaderColumn", groupHeaderColumns: "groupHeaderColumns", columns: "columns" }, attrs: _c167, decls: 3, vars: 3, consts: [[3, "ngIf"], ["aria-selected", "false", "kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan", 4, "ngIf"], [4, "ngIf"], ["class", "k-group-cell", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "k-group-cell"], ["aria-selected", "false", "kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan"], [1, "k-reset"], ["href", "#", "tabindex", "-1", "role", "presentation", 1, "k-icon", 3, "ngClass", "click"], [3, "templateContext"], ["role", "gridcell", "aria-selected", "false", "kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan", 4, "ngFor", "ngForOf"], ["role", "gridcell", "aria-selected", "false", "kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function GroupHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, GroupHeaderComponent_ng_template_0_Template, 1, 1, "ng-template", 0);
        ɵngcc0.ɵɵtemplate(1, GroupHeaderComponent_td_1_Template, 3, 9, "td", 1);
        ɵngcc0.ɵɵtemplate(2, GroupHeaderComponent_ng_container_2_Template, 2, 1, "ng-container", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.skipGroupDecoration);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !(ctx.skipGroupDecoration && ctx.hasGroupHeaderColumn));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGroupHeaderColumn);
    } }, directives: [ɵngcc5.NgIf, ɵngcc5.NgForOf, LogicalCellDirective, ɵngcc5.NgClass, TemplateContextDirective, ɵngcc5.NgTemplateOutlet], pipes: [FieldAccessorPipe], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], GroupHeaderComponent.prototype, "rowIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GroupHeaderComponent.prototype, "logicalRowIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GroupHeaderComponent.prototype, "item", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GroupHeaderComponent.prototype, "skipGroupDecoration", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GroupHeaderComponent.prototype, "hasDetails", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GroupHeaderComponent.prototype, "totalColumnsCount", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GroupHeaderComponent.prototype, "hasGroupHeaderColumn", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], GroupHeaderComponent.prototype, "groupHeaderColumns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GroupHeaderComponent.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], GroupHeaderComponent.prototype, "groups", void 0);
__decorate([
    HostBinding('class.k-grouping-row'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], GroupHeaderComponent.prototype, "groupItemClass", null);
GroupHeaderComponent = __decorate([ __metadata("design:paramtypes", [GroupsService,
        GroupInfoService,
        LocalizationService])
], GroupHeaderComponent);

/**
 * @hidden
 */
let DropTargetDirective = class DropTargetDirective {
    constructor(element, service) {
        this.element = element;
        this.service = service;
        this.context = {};
        this.enter = new EventEmitter();
        this.leave = new EventEmitter();
        this.drop = new EventEmitter();
        this.subscriptions = new Subscription();
    }
    ngOnInit() {
        this.service.add(this);
        const changes = this.service.changes.pipe(filter(({ target }) => target === this));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'leave'))
            .subscribe(e => {
            this.leave.next(this.eventArgs(e));
        }));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'enter'))
            .subscribe(e => {
            this.enter.next(this.eventArgs(e));
        }));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'drop'))
            .subscribe(e => {
            this.drop.next(this.eventArgs(e));
        }));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    eventArgs(e) {
        return {
            target: this,
            mouseEvent: e.mouseEvent,
            draggable: e.draggable
        };
    }
};
DropTargetDirective.ɵfac = function DropTargetDirective_Factory(t) { return new (t || DropTargetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragAndDropService)); };
DropTargetDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DropTargetDirective, selectors: [["", "kendoDropTarget", ""]], inputs: { context: "context" }, outputs: { enter: "enter", leave: "leave", drop: "drop" } });
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropTargetDirective.prototype, "context", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DropTargetDirective.prototype, "enter", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DropTargetDirective.prototype, "leave", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DropTargetDirective.prototype, "drop", void 0);
DropTargetDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        DragAndDropService])
], DropTargetDirective);

const withoutField = ({ field }) => isNullOrEmptyString(field);
const alreadyGrouped = ({ groups, field }) => groups.some(group => group.field === field);
const overSameTarget = ({ target, field }) => target.field === field;
const overLastTarget = ({ target }) => target.lastTarget;
const isLastGroup = ({ groups, field }) => groups.map(group => group.field).indexOf(field) === groups.length - 1;
const isNotGroupable = (groupsService) => ({ field }) => !groupsService.isGroupable(field);
const columnRules = (groupService) => or(withoutField, alreadyGrouped, isNotGroupable(groupService));
const indicatorRules = or(overSameTarget, and(overLastTarget, isLastGroup));
/**
 * @hidden
 */
let GroupPanelComponent = class GroupPanelComponent {
    constructor(hint, cue, groupInfoService, localization, cd) {
        this.hint = hint;
        this.cue = cue;
        this.groupInfoService = groupInfoService;
        this.localization = localization;
        this.cd = cd;
        this.change = new EventEmitter();
        this.groups = [];
        this.dropTargets = new QueryList();
        this.groupTitles = [];
        this.subscription = new Subscription();
    }
    get groupHeaderClass() {
        return true;
    }
    set text(value) {
        this.emptyText = value;
    }
    get text() {
        return this.emptyText ? this.emptyText : this.localization.get('groupPanelEmpty');
    }
    ngAfterViewInit() {
        this.subscription.add(observe(this.dropTargets)
            .subscribe(this.attachTargets.bind(this)));
    }
    ngOnInit() {
        this.subscription.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));
    }
    ngDoCheck() {
        const currentTitles = this.groups.map(group => this.groupInfoService.groupTitle(group));
        if (currentTitles.length !== this.groupTitles.length || currentTitles.some((current, idx) => current !== this.groupTitles[idx])) {
            this.groupTitles = currentTitles;
            this.cd.markForCheck();
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
    }
    directionChange(group) {
        const index = this.groups.findIndex(x => x.field === group.field);
        const groups = [...this.groups.slice(0, index), group, ...this.groups.slice(index + 1)];
        this.change.emit(groups);
    }
    insert(field, index) {
        const groups = this.groups.filter(x => x.field !== field);
        if (groups.length || this.groups.length === 0) {
            this.change.emit([...groups.slice(0, index), { field: field }, ...groups.slice(index)]);
        }
    }
    remove(group) {
        this.change.emit(this.groups.filter(x => x.field !== group.field));
    }
    canDrop(draggable, target) {
        const isIndicator = draggable.type === 'groupIndicator';
        const rules = isIndicator
            ? indicatorRules
            : columnRules(this.groupInfoService);
        return !rules({
            field: draggable.field,
            groups: this.groups,
            target
        });
    }
    attachTargets() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        this.targetSubscription = new Subscription();
        const enterStream = this.dropTargets
            .reduce((acc, target) => merge(acc, target.enter), from([]));
        const leaveStream = this.dropTargets
            .reduce((acc, target) => merge(acc, target.leave), from([]));
        const dropStream = this.dropTargets
            .reduce((acc, target) => merge(acc, target.drop), from([]));
        this.targetSubscription.add(enterStream.pipe(tap(_ => this.hint.removeLock()), filter(({ draggable, target }) => this.canDrop(draggable.context, target.context)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));
    }
    enter({ draggable, target }) {
        this.hint.enable();
        let before = target.context.lastTarget || isTargetBefore(draggable.element.nativeElement, target.element.nativeElement);
        if (this.localization.rtl) {
            before = !before;
        }
        this.cue.position(position(target.element.nativeElement, before));
    }
    leave() {
        this.hint.disable();
        this.cue.hide();
    }
    drop({ target, draggable }) {
        const field = draggable.context.field;
        const index = this.dropTargets.toArray().indexOf(target);
        this.insert(field, index);
    }
};
GroupPanelComponent.ɵfac = function GroupPanelComponent_Factory(t) { return new (t || GroupPanelComponent)(ɵngcc0.ɵɵdirectiveInject(DragHintService), ɵngcc0.ɵɵdirectiveInject(DropCueService), ɵngcc0.ɵɵdirectiveInject(GroupInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
GroupPanelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GroupPanelComponent, selectors: [["kendo-grid-group-panel"]], viewQuery: function GroupPanelComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(DropTargetDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropTargets = _t);
    } }, hostVars: 4, hostBindings: function GroupPanelComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grouping-header", ctx.groupHeaderClass)("k-grouping-header-flex", ctx.groupHeaderClass);
    } }, inputs: { groups: "groups", text: "text" }, outputs: { change: "change" }, decls: 3, vars: 3, consts: [[3, "ngIf"], ["class", "k-indicator-container", "kendoDropTarget", "", 3, "context", 4, "ngFor", "ngForOf"], ["class", "k-indicator-container", "kendoDropTarget", "", 3, "context", 4, "ngIf"], ["kendoDropTarget", "", 1, "k-indicator-container", 3, "context"], ["kendoDraggableColumn", "", "kendoGroupIndicator", "", "kendoDraggable", "", 3, "enableDrag", "context", "group", "groupTitle", "directionChange", "remove"]], template: function GroupPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, GroupPanelComponent_ng_template_0_Template, 2, 3, "ng-template", 0);
        ɵngcc0.ɵɵtemplate(1, GroupPanelComponent_div_1_Template, 2, 10, "div", 1);
        ɵngcc0.ɵɵtemplate(2, GroupPanelComponent_div_2_Template, 2, 2, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.groups.length === 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.groups);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.groups.length !== 0);
    } }, directives: function () { return [ɵngcc5.NgIf, DropTargetDirective, ɵngcc5.NgForOf, DraggableColumnDirective, GroupIndicatorComponent, ɵngcc2.DraggableDirective]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GroupPanelComponent.prototype, "change", void 0);
__decorate([
    HostBinding("class.k-grouping-header"),
    HostBinding("class.k-grouping-header-flex"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], GroupPanelComponent.prototype, "groupHeaderClass", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], GroupPanelComponent.prototype, "text", null);
__decorate([
    Input(),
    __metadata("design:type", Array)
], GroupPanelComponent.prototype, "groups", void 0);
__decorate([
    ViewChildren(DropTargetDirective),
    __metadata("design:type", QueryList)
], GroupPanelComponent.prototype, "dropTargets", void 0);
GroupPanelComponent = __decorate([ __metadata("design:paramtypes", [DragHintService,
        DropCueService,
        GroupInfoService,
        LocalizationService,
        ChangeDetectorRef])
], GroupPanelComponent);

/**
 * @hidden
 */
let GroupIndicatorComponent = class GroupIndicatorComponent {
    /**
     * @hidden
     */
    constructor() {
        this.directionChange = new EventEmitter();
        this.remove = new EventEmitter();
    }
    get groupIndicatorClass() {
        return true;
    }
    get dir() {
        return this.group.dir ? this.group.dir : "asc";
    }
    toggleDirection() {
        this.directionChange.emit({
            dir: this.dir === "asc" ? "desc" : "asc",
            field: this.group.field
        });
        return false;
    }
    removeDescriptor() {
        this.remove.emit({
            dir: this.group.dir,
            field: this.group.field
        });
        return false;
    }
};
GroupIndicatorComponent.ɵfac = function GroupIndicatorComponent_Factory(t) { return new (t || GroupIndicatorComponent)(); };
GroupIndicatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GroupIndicatorComponent, selectors: [["", "kendoGroupIndicator", ""]], hostVars: 2, hostBindings: function GroupIndicatorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-group-indicator", ctx.groupIndicatorClass);
    } }, inputs: { group: "group", groupTitle: "groupTitle" }, outputs: { directionChange: "directionChange", remove: "remove" }, attrs: _c174, decls: 5, vars: 5, consts: [["href", "#", "tabindex", "-1", 1, "k-link", 3, "click"], [1, "k-icon"], ["tabindex", "-1", 1, "k-button", "k-button-flat-base", "k-button-flat", "k-icon-button", "k-button-md", "k-rounded-md", "k-button-rectangle", "k-icon-button", 3, "click"], [1, "k-button-icon", "k-icon", "k-i-group-delete"]], template: function GroupIndicatorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵlistener("click", function GroupIndicatorComponent_Template_a_click_0_listener() { return ctx.toggleDirection(); });
        ɵngcc0.ɵɵelement(1, "span", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "a", 2);
        ɵngcc0.ɵɵlistener("click", function GroupIndicatorComponent_Template_a_click_3_listener() { return ctx.removeDescriptor(); });
        ɵngcc0.ɵɵelement(4, "span", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("k-i-sort-asc-sm", ctx.dir === "asc")("k-i-sort-desc-sm", ctx.dir === "desc");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.groupTitle, "");
    } }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GroupIndicatorComponent.prototype, "directionChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GroupIndicatorComponent.prototype, "remove", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GroupIndicatorComponent.prototype, "group", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], GroupIndicatorComponent.prototype, "groupTitle", void 0);
__decorate([
    HostBinding("class.k-group-indicator"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], GroupIndicatorComponent.prototype, "groupIndicatorClass", null);

// TODO
// tslint:disable:rxjs-no-unsafe-takeuntil
/**
 * @hidden
 */
const preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
const hasClass = className => el => new RegExp(`(^| )${className}( |$)`).test(el.className);
const isDeleteButton = or(hasClass('k-i-group-delete'), hasClass('k-icon-button'));
const isSortIcon = or(hasClass('k-i-sort-asc-sm'), hasClass('k-i-sort-desc-sm'));
const skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName('label')));
const elementUnderCursor = ({ clientX, clientY }) => document.elementFromPoint(clientX, clientY);
const hideThenShow = (element, cont) => {
    element.style.display = 'none';
    const result = cont();
    element.style.display = 'block';
    return result;
};
/**
 * @hidden
 */
let DraggableColumnDirective = class DraggableColumnDirective {
    constructor(draggable, element, zone, service, hint, cue, nav, renderer) {
        this.draggable = draggable;
        this.element = element;
        this.zone = zone;
        this.service = service;
        this.hint = hint;
        this.cue = cue;
        this.nav = nav;
        this.renderer = renderer;
        this.context = {};
        this.drag = new EventEmitter();
        this.subscriptions = new Subscription();
    }
    set enableDrag(enabled) {
        this.enabled = enabled;
        this.updateTouchAction();
    }
    get hostClass() {
        return this.enabled;
    }
    ngOnInit() {
        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter(_ => this.enabled), filter(({ originalEvent: { target } }) => target === this.element.nativeElement || skipButtons(target)), tap((e) => {
            const originalEvent = e.originalEvent;
            if (!e.isTouch) {
                originalEvent.preventDefault();
            }
            this.nav.navigateTo(originalEvent.target);
        }), switchMap(preventOnDblClick(this.draggable.kendoRelease)), tap((_) => {
            this.hint.create(this.context.hint);
            this.cue.create();
        }), switchMap(down => this.draggable.kendoDrag.pipe(tap((e) => {
            if (e.isTouch) {
                e.originalEvent.preventDefault();
            }
        }), tap(this.hint.attach()), tap(this.cue.attach()), takeUntil(this.draggable.kendoRelease), map(move => ({ move, down })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    drop(upEvent) {
        this.hint.remove();
        this.cue.remove();
        this.service.notifyDrop(this, upEvent);
    }
    performDrag({ move }) {
        this.hint.move(move);
        const cursorElement = this.elementUnderCursor(move);
        if (cursorElement) {
            this.service.notifyDrag(this, cursorElement, move);
        }
        this.drag.emit({
            draggable: this,
            mouseEvent: move
        });
    }
    elementUnderCursor(mouseEvent) {
        this.hint.hide();
        let target = elementUnderCursor(mouseEvent);
        if (target && /k-grouping-dropclue/.test(target.className)) {
            target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));
        }
        this.hint.show();
        return target;
    }
    updateTouchAction() {
        if (!this.element) {
            return;
        }
        this.enabled ? this.renderer.addClass(this.element.nativeElement, 'k-touch-action-none') :
            this.renderer.removeClass(this.element.nativeElement, 'k-touch-action-none');
    }
};
DraggableColumnDirective.ɵfac = function DraggableColumnDirective_Factory(t) { return new (t || DraggableColumnDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DraggableDirective, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DragAndDropService), ɵngcc0.ɵɵdirectiveInject(DragHintService), ɵngcc0.ɵɵdirectiveInject(DropCueService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
DraggableColumnDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DraggableColumnDirective, selectors: [["", "kendoDraggableColumn", ""]], hostVars: 2, hostBindings: function DraggableColumnDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-draggable-header", ctx.hostClass);
    } }, inputs: { context: "context", enableDrag: "enableDrag" }, outputs: { drag: "drag" } });
__decorate([
    Input(),
    __metadata("design:type", Object)
], DraggableColumnDirective.prototype, "context", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], DraggableColumnDirective.prototype, "enableDrag", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DraggableColumnDirective.prototype, "drag", void 0);
__decorate([
    HostBinding('class.k-grid-draggable-header'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DraggableColumnDirective.prototype, "hostClass", null);
DraggableColumnDirective = __decorate([ __param(0, Host()),
    __metadata("design:paramtypes", [DraggableDirective,
        ElementRef,
        NgZone,
        DragAndDropService,
        DragHintService,
        DropCueService,
        NavigationService,
        Renderer2])
], DraggableColumnDirective);

const exported = [
    DraggableColumnDirective,
    DropTargetDirective
];
/**
 * @hidden
 */
let DragAndDropModule = class DragAndDropModule {
};
DragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) { return new (t || DragAndDropModule)(); };
DragAndDropModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DragAndDropModule });
DragAndDropModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});

const exportedModules$1 = [
    GroupHeaderTemplateDirective,
    GroupHeaderColumnTemplateDirective,
    GroupFooterTemplateDirective,
    GroupHeaderComponent,
    GroupPanelComponent,
    GroupIndicatorComponent
];
/**
 * @hidden
 */
let GroupModule = class GroupModule {
    static exports() {
        return [
            GroupHeaderTemplateDirective,
            GroupHeaderColumnTemplateDirective,
            GroupFooterTemplateDirective
        ];
    }
};
GroupModule.ɵfac = function GroupModule_Factory(t) { return new (t || GroupModule)(); };
GroupModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: GroupModule });
GroupModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, SharedModule, DragAndDropModule]] });

/**
 * @hidden
 */
const DEFAULTS = {
    allowUnsort: true,
    mode: 'single',
    showIndexes: true,
    initialDirection: 'asc',
    multiSortKey: 'none'
};
/**
 * @hidden
 */
const normalize$1 = (...settings) => Object.assign({}, DEFAULTS, ...settings);

/**
 * @hidden
 */
const hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;
/**
 * @hidden
 */
const hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;
/**
 * @hidden
 */
const hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasStick = (settings, column) => settings.stick && column.stickable && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasPosition = (settings, column) => settings.setColumnPosition && (column.stickable || column.lockable) && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasColumnChooser = (settings) => settings.columnChooser !== false;
/**
 * @hidden
 */
const hasItems = (settings, column) => hasColumnChooser(settings) || hasLock(settings, column) || hasSort(settings, column) || hasFilter(settings, column);

/**
 * @hidden
 */
let FilterMenuComponent = class FilterMenuComponent {
    constructor(filterService, popupService, localization, navigationService) {
        this.filterService = filterService;
        this.popupService = popupService;
        this.localization = localization;
        this.navigationService = navigationService;
        this.tabIndex = '-1';
    }
    get hasFilters() {
        return filtersByField(this.filter, (this.column || {}).field).length > 0;
    }
    /**
     * @hidden
     */
    get filterLabel() {
        const localizationMsg = this.localization.get('filterMenuTitle') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    toggle(anchor, template) {
        this.popupRef = this.popupService.open(anchor, template, this.popupRef);
        if (!this.popupRef) {
            if (this.navigationService.enabled) {
                this.navigationService.focusCell(0, this.column.leafIndex);
            }
            else {
                this.anchor.nativeElement.focus();
            }
        }
        return false;
    }
    close() {
        this.popupService.destroy();
        if (this.navigationService.enabled) {
            this.navigationService.focusCell(0, this.column.leafIndex);
        }
        else {
            this.anchor.nativeElement.focus();
        }
    }
};
FilterMenuComponent.ɵfac = function FilterMenuComponent_Factory(t) { return new (t || FilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(SinglePopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
FilterMenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FilterMenuComponent, selectors: [["kendo-grid-filter-menu"]], viewQuery: function FilterMenuComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c175, 7);
        ɵngcc0.ɵɵviewQuery(_c176, 7, TemplateRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.anchor = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, inputs: { tabIndex: "tabIndex", column: "column", filter: "filter" }, decls: 5, vars: 5, consts: [["href", "#", 3, "ngClass", "tabindex", "click", "keydown.enter"], ["anchor", ""], [1, "k-icon", "k-i-filter"], ["template", ""], [3, "column", "filter", "close", "keydown.escape", "keydown.enter"]], template: function FilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        const _r7 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "a", 0, 1);
        ɵngcc0.ɵɵlistener("click", function FilterMenuComponent_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r7); const _r0 = ɵngcc0.ɵɵreference(1); const _r1 = ɵngcc0.ɵɵreference(4); return ctx.toggle(_r0, _r1); })("keydown.enter", function FilterMenuComponent_Template_a_keydown_enter_0_listener($event) { return $event.stopImmediatePropagation(); });
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, FilterMenuComponent_ng_template_3_Template, 1, 2, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c177, ctx.hasFilters))("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵattribute("title", ctx.filterLabel);
    } }, directives: function () { return [ɵngcc5.NgClass, FilterMenuContainerComponent]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], FilterMenuComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FilterMenuComponent.prototype, "filter", void 0);
__decorate([
    ViewChild('anchor', { static: true }),
    __metadata("design:type", ElementRef)
], FilterMenuComponent.prototype, "anchor", void 0);
__decorate([
    ViewChild('template', { static: true, read: TemplateRef }),
    __metadata("design:type", TemplateRef)
], FilterMenuComponent.prototype, "template", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FilterMenuComponent.prototype, "tabIndex", void 0);
FilterMenuComponent = __decorate([ __metadata("design:paramtypes", [FilterService,
        SinglePopupService,
        LocalizationService,
        NavigationService])
], FilterMenuComponent);

/**
 * Represents the service that is passed to the
 * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [data]="data" [columnMenu]="true">
 *          <ng-template kendoGridColumnMenuTemplate let-service="service">
 *              <span class="k-icon k-i-close" (click)="service.close()"
 *                  style="position: absolute; right: 5px; top: 5px;cursor: pointer;"></span>
 *              <kendo-grid-columnmenu-sort [service]="service">
 *              </kendo-grid-columnmenu-sort>
 *          </ng-template>
 *          <kendo-grid-column field="Field1"></kendo-grid-column>
 *          <kendo-grid-column field="Field2"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
 * }
 *
 * ```
 */
let ColumnMenuService = class ColumnMenuService {
    /**
     * @hidden
     */
    constructor(menuTabbingService) {
        /**
         * @hidden
         */
        this.closeMenu = new EventEmitter();
        this.menuTabbingService = menuTabbingService;
    }
    /**
     * Closes the column menu.
     */
    close() {
        this.closeMenu.emit();
    }
};
ColumnMenuService.ɵfac = function ColumnMenuService_Factory(t) { return new (t || ColumnMenuService)(ɵngcc0.ɵɵinject(MenuTabbingService)); };
ColumnMenuService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ColumnMenuService, factory: function (t) { return ColumnMenuService.ɵfac(t); } });
ColumnMenuService = __decorate([ __metadata("design:paramtypes", [MenuTabbingService])
], ColumnMenuService);

const POPUP_CLASS = 'k-grid-columnmenu-popup';
/**
 * Represents the [column menu]({% slug columnmenu_grid %}) component.
 */
let ColumnMenuComponent = class ColumnMenuComponent {
    constructor(popupService, localization, service, navigationService) {
        this.popupService = popupService;
        this.localization = localization;
        this.service = service;
        this.navigationService = navigationService;
        /**
         * @hidden
         */
        this.standalone = true;
        /**
         * The settings for the Column Menu.
         */
        this.settings = {};
        /**
         * @hidden
         */
        this.sortable = true;
        /**
         * @hidden
         */
        this.tabIndex = '-1';
        /**
         * @hidden
         */
        this.expandedFilter = false;
        /**
         * @hidden
         */
        this.expandedColumns = false;
        /**
         * @hidden
         */
        this.expandedPosition = false;
        this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this));
    }
    /**
     * @hidden
     */
    get isActive() {
        return (this.hasFilter && filtersByField(this.filter, this.column.field).length > 0) ||
            (!this.sortable && this.hasSort && this.sort.find(descriptor => descriptor.field === this.column.field));
    }
    /**
     * @hidden
     */
    get hasFilter() {
        return hasFilter(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasSort() {
        return hasSort(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasColumnChooser() {
        return hasColumnChooser(this.settings);
    }
    /**
     * @hidden
     */
    get hasLock() {
        return hasLock(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasStick() {
        return hasStick(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasPosition() {
        return hasPosition(this.settings, this.column);
    }
    ngOnChanges() {
        this.service.column = this.column;
        this.service.sort = this.sort;
        this.service.filter = this.filter;
        this.service.sortable = this.sortable;
    }
    ngOnDestroy() {
        this.close();
        this.closeSubscription.unsubscribe();
    }
    /**
     * @hidden
     */
    toggle(e, anchor, template) {
        if (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }
        this.expandedFilter = this.getExpandedState(this.settings.filter);
        this.expandedColumns = this.getExpandedState(this.settings.columnChooser);
        this.expandedPosition = this.getExpandedState(this.settings.setColumnPosition);
        this.popupRef = this.popupService.open(anchor, template, this.popupRef, POPUP_CLASS);
        if (!this.popupRef) {
            if (this.navigationService.enabled) {
                this.navigationService.focusCell(0, this.column.leafIndex);
            }
            else {
                this.anchor.nativeElement.focus();
            }
        }
    }
    /**
     * @hidden
     */
    close() {
        this.popupService.destroy();
        this.popupRef = null;
        if (this.navigationService.enabled) {
            this.navigationService.focusCell(0, this.column.leafIndex);
        }
        else {
            this.anchor.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    get columnMenuTitle() {
        const localizationMsg = this.localization.get('columnMenu') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    getExpandedState(menuItemSettings) {
        return typeof (menuItemSettings) === 'object' ? menuItemSettings.expanded : false;
    }
};
ColumnMenuComponent.ɵfac = function ColumnMenuComponent_Factory(t) { return new (t || ColumnMenuComponent)(ɵngcc0.ɵɵdirectiveInject(SinglePopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnMenuService), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
ColumnMenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuComponent, selectors: [["kendo-grid-column-menu"]], viewQuery: function ColumnMenuComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c175, 7);
        ɵngcc0.ɵɵviewQuery(_c176, 7, TemplateRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.anchor = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, hostVars: 2, hostBindings: function ColumnMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-column-menu-standalone", ctx.standalone);
    } }, inputs: { standalone: "standalone", settings: "settings", sortable: "sortable", tabIndex: "tabIndex", column: "column", sort: "sort", filter: "filter", columnMenuTemplate: "columnMenuTemplate" }, features: [ɵngcc0.ɵɵProvidersFeature([
            ColumnMenuService,
            MenuTabbingService
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 5, consts: [["href", "#", 1, "k-grid-column-menu", "k-grid-filter", 3, "ngClass", "tabindex", "click", "keydown.enter"], ["anchor", ""], [1, "k-icon", "k-i-more-vertical"], ["template", ""], ["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "keydown.escape", "keydown.enter"], [3, "kendoGridColumnMenuItem", "service", 4, "ngIf"], [3, "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded", 4, "ngIf"], [3, "kendoGridColumnMenuItem", "service", "expanded", 4, "ngIf"], [3, "kendoGridColumnMenuItem", "service"], ["sortItem", ""], ["lockItem", ""], ["stickItem", ""], [3, "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded"], ["positionItem", ""], [3, "kendoGridColumnMenuItem", "service", "expanded"], ["chooserItem", ""], ["filterItem", ""]], template: function ColumnMenuComponent_Template(rf, ctx) { if (rf & 1) {
        const _r20 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "a", 0, 1);
        ɵngcc0.ɵɵlistener("click", function ColumnMenuComponent_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r20); const _r0 = ɵngcc0.ɵɵreference(1); const _r1 = ɵngcc0.ɵɵreference(4); return ctx.toggle($event, _r0, _r1); })("keydown.enter", function ColumnMenuComponent_Template_a_keydown_enter_0_listener($event) { return $event.stopImmediatePropagation(); });
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ColumnMenuComponent_ng_template_3_Template, 1, 5, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, ColumnMenuComponent_ng_template_5_Template, 7, 6, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c179, ctx.isActive))("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵattribute("title", ctx.columnMenuTitle);
    } }, directives: function () { return [ɵngcc5.NgClass, ɵngcc5.NgTemplateOutlet, ColumnMenuContainerComponent, ɵngcc5.NgIf, ColumnMenuSortComponent, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent]; }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-grid-column-menu-standalone'),
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuComponent.prototype, "standalone", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnMenuComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnMenuComponent.prototype, "settings", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnMenuComponent.prototype, "sort", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnMenuComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnMenuComponent.prototype, "sortable", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ColumnMenuComponent.prototype, "columnMenuTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnMenuComponent.prototype, "tabIndex", void 0);
__decorate([
    ViewChild('anchor', { static: true }),
    __metadata("design:type", ElementRef)
], ColumnMenuComponent.prototype, "anchor", void 0);
__decorate([
    ViewChild('template', { static: true, read: TemplateRef }),
    __metadata("design:type", TemplateRef)
], ColumnMenuComponent.prototype, "template", void 0);
ColumnMenuComponent = __decorate([ __metadata("design:paramtypes", [SinglePopupService,
        LocalizationService,
        ColumnMenuService,
        NavigationService])
], ColumnMenuComponent);

const mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));
const directions = initialDirection => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
/**
 * @hidden
 */
const isRootLevel = ({ parent }) => !isTruthy(parent);
const ofColumnType = ({ draggable }) => ['column', 'columnGroup']
    .indexOf(draggable.context.type) >= 0;
const notSameElement = ({ draggable, target }) => draggable.element.nativeElement !== target.element.nativeElement;
const inSameParent = (x, y) => x.parent === y.parent ||
    (isInSpanColumn(y) && inSameParent(x, y.parent));
const sameParent = ({ draggable, target }) => inSameParent(draggable.context.column, target.context.column);
const lastNonLocked = ({ draggable }) => !isTruthy(draggable.context.column.locked) &&
    isRootLevel(draggable.context.column) &&
    draggable.context.lastColumn;
const notInSpanColumn = ({ draggable }) => !isInSpanColumn(draggable.context.column);
const reorderable = ({ draggable }) => draggable.context.column.reorderable;
const lockable = ({ draggable, target }) => draggable.context.column.lockable !== false ||
    draggable.context.column.isLocked === target.context.column.isLocked;
const rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);
const modifierKeys = ['alt', 'ctrl', 'shift', 'meta'];
/**
 * @hidden
 */
let HeaderComponent = class HeaderComponent {
    constructor(popupService, hint, cue, reorderService, idService, sortService, localization, columnInfoService, cd) {
        this.popupService = popupService;
        this.hint = hint;
        this.cue = cue;
        this.reorderService = reorderService;
        this.idService = idService;
        this.sortService = sortService;
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.cd = cd;
        this.columns = [];
        this.groups = [];
        this.sort = new Array();
        this.sortable = false;
        this.groupable = false;
        this.lockedColumnsCount = 0;
        this.resizable = false;
        this.reorderable = false;
        this.columnMenu = false;
        this.totalColumnsCount = 0;
        this.sortedFields = {};
        this.dropTargets = new QueryList();
        this.subscription = new Subscription();
    }
    get headerClass() {
        return !this.scrollable;
    }
    get sortableLabel() {
        return this.localization.get('sortable');
    }
    // Number of unlocked columns in the next table, if any
    get unlockedColumnsCount() {
        return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;
    }
    sortColumn(descriptor) {
        this.sortService.sort(descriptor);
    }
    onSortClick(column, event, link) {
        const target = event.target;
        if (column.headerTemplateRef && target !== link) {
            const hasFocusableParent = Boolean(closestInScope(target, isFocusable, link));
            if (hasFocusableParent) {
                // Do not sort when clicking focusable template elements.
                return;
            }
        }
        const modifier = this.matchModifier(event);
        const toggledColumn = this.toggleSort(column, modifier);
        this.sortColumn(toggledColumn);
    }
    onHeaderKeydown(column, args) {
        if (args.keyCode === Keys.ArrowDown && args.altKey && this.showFilterMenu) {
            args.preventDefault();
            args.stopImmediatePropagation();
            const filterMenu = this.filterMenus.find(fm => fm.column === column);
            filterMenu.toggle(filterMenu.anchor.nativeElement, filterMenu.template);
        }
        if (args.keyCode === Keys.ArrowDown && args.altKey && this.showColumnMenu(column)) {
            args.preventDefault();
            args.stopImmediatePropagation();
            const columnMenu = this.columnMenus.find(cm => cm.column === column);
            columnMenu.toggle(null, columnMenu.anchor.nativeElement, columnMenu.template);
        }
        if (!this.sortable || args.defaultPrevented || column.sortable === false) {
            return;
        }
        if (args.keyCode === Keys.Enter && isPresent(column.field)) {
            const modifier = this.matchModifier(args);
            this.sortService.sort(this.toggleSort(column, modifier));
        }
    }
    showSortNumbering(column) {
        const { showIndexes } = normalize$1(this.sortable);
        return showIndexes
            && this.sort
            && this.sort.filter(({ dir }) => isPresent(dir)).length > 1
            && this.sortOrder(column.field) > 0;
    }
    sortOrder(field) {
        return this.sort
            .filter(({ dir }) => isPresent(dir))
            .findIndex(x => x.field === field)
            + 1;
    }
    sortIcon(field) {
        const state$$1 = this.sortDescriptor(field);
        return {
            'k-icon': isPresent(state$$1.dir),
            'k-i-sort-desc-sm': state$$1.dir === "desc",
            'k-i-sort-asc-sm': state$$1.dir === "asc"
        };
    }
    sortState(column) {
        if (!this.isSortable(column)) {
            return;
        }
        const state$$1 = this.sortDescriptor(column.field);
        if (state$$1.dir === 'asc') {
            return 'ascending';
        }
        if (state$$1.dir === 'desc') {
            return 'descending';
        }
    }
    sortStatus(column) {
        if (!this.sortedFields[column.field] || !this.isSortable(column)) {
            return;
        }
        let msg = 'sortedDefault';
        const state$$1 = this.sortDescriptor(column.field);
        if (state$$1.dir === 'asc') {
            msg = 'sortedAscending';
        }
        else if (state$$1.dir === 'desc') {
            msg = 'sortedDescending';
        }
        return this.localization.get(msg);
    }
    /**
     *
     * @param column
     * @param modifier - Indicates whether the client-defined `multiSortKey` modifier is met. Defaults to `true`.
     * @returns - SortDescriptor[]
     */
    toggleSort(column, modifier = true) {
        const { allowUnsort, mode, initialDirection } = normalize$1(this.sortable, column.sortable);
        const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);
        if (mode === 'single' || !modifier) {
            return [descriptor];
        }
        return [...this.sort.filter(desc => desc.field !== column.field), descriptor];
    }
    /**
     *
     * Determines whether the modifier key (if any) passed
     * with a click/keyboard event matches the user-defined multiSortKey.
     */
    matchModifier(event) {
        const { multiSortKey } = normalize$1(this.sortable);
        if (multiSortKey === 'none') {
            return modifierKeys.every(key => !event[`${key}Key`]);
        }
        return multiSortKey === 'ctrl'
            ? event.ctrlKey || event.metaKey
            : event[`${multiSortKey}Key`];
    }
    ngAfterViewInit() {
        this.subscription.add(observe(this.dropTargets)
            .subscribe(this.attachTargets.bind(this)));
    }
    ngDoCheck() {
        this._leafColumns = columnsToRender(this.columns || []).filter(x => !isColumnGroupComponent(x));
    }
    ngOnChanges(changes) {
        const sortChange = changes.sort;
        if (sortChange && !sortChange.isFirstChange()) {
            sortChange.currentValue.forEach(change => {
                this.sortedFields[change.field] = true;
            });
        }
    }
    ngOnInit() {
        this.subscription.add(this.localization.changes
            .subscribe(() => this.cd.markForCheck()));
    }
    ngOnDestroy() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        if (this.popupService) {
            this.popupService.destroy();
        }
        this.subscription.unsubscribe();
    }
    selectAllCheckboxId() {
        return this.idService.selectAllCheckboxId();
    }
    get selectAllCheckboxLabel() {
        return this.localization.get('selectAllCheckboxLabel');
    }
    isFirstOnRow(column, index) {
        const isTailing = (c) => c &&
            (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));
        return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);
    }
    logicalColumnIndex(column) {
        const index = column.leafIndex;
        if (isPresent(index)) {
            return index + (isPresent(this.detailTemplate) ? 1 : 0);
        }
        return -1;
    }
    get showFilterMenu() {
        return !this.columnMenu && hasFilterMenu(this.filterable);
    }
    get showFilterRow() {
        return hasFilterRow(this.filterable);
    }
    showColumnMenu(column) {
        return this.columnMenu && column.columnMenu &&
            (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));
    }
    isFilterable(column) {
        return !isNullOrEmptyString(column.field) && column.filterable === true;
    }
    canDrop(draggable, target) {
        return this.reorderable && rules({ draggable, target });
    }
    shouldActivate(column) {
        const canReorder = this.reorderable && column.reorderable;
        if (!canReorder && !isColumnComponent(column)) {
            return false;
        }
        const groupable = this.groupable && isColumnComponent(column) && column.groupable !== false;
        return groupable || canReorder;
    }
    isSortable(column) {
        return !isNullOrEmptyString(column.field)
            && isTruthy(this.sortable) && isTruthy(column.sortable);
    }
    isCheckboxColumn(column) {
        return isCheckboxColumn(column) && !column.templateRef;
    }
    trackByIndex(index, _item) {
        return index;
    }
    addStickyStyles(column) {
        const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
        return Object.assign({}, column.style, stickyStyles);
    }
    toggleDirection(field, allowUnsort, initialDirection) {
        const descriptor = this.sortDescriptor(field);
        const [first, second] = directions(initialDirection);
        let dir = first;
        if (descriptor.dir === first) {
            dir = second;
        }
        else if (descriptor.dir === second && allowUnsort) {
            dir = undefined;
        }
        return { dir, field };
    }
    columnsForLevel(level) {
        const columns = this.columns ? this.columns.filter(column => column.level === level) : [];
        return sortColumns(columnsToRender(columns));
    }
    isColumnGroupComponent(column) {
        return isColumnGroupComponent(column);
    }
    get columnLevels() {
        return new Array((this.totalColumnLevels || 0) + 1);
    }
    sortDescriptor(field) {
        return this.sort.find(item => item.field === field) || { field };
    }
    get leafColumns() {
        return this._leafColumns;
    }
    attachTargets() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        this.targetSubscription = new Subscription();
        const enterStream = merge(...this.dropTargets.map(target => target.enter));
        const leaveStream = merge(...this.dropTargets.map(target => target.leave));
        const dropStream = merge(...this.dropTargets.map(target => target.drop));
        this.targetSubscription.add(enterStream.pipe(tap(({ target, draggable }) => {
            if (draggable.context.type === 'groupIndicator') {
                return;
            }
            const targetLocked = isTruthy(target.context.column.isLocked);
            const draggableLocked = isTruthy(draggable.context.column.isLocked);
            if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {
                this.hint.toggleLock(targetLocked);
            }
        }), filter(({ draggable, target }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map((e) => mergeObjects(e, { before: this.calculateBefore(e), changeContainer: e.changeContainer })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap((args) => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this)))))))
            .subscribe(this.drop.bind(this)));
    }
    normalizeTarget(e) {
        let target = e.target;
        const parent = target.context.column.parent;
        if (parent && parent.isSpanColumn) {
            const arr = this.dropTargets.toArray();
            const firstSpan = arr.find(t => t.context.column.parent === parent);
            const index = arr.indexOf(firstSpan);
            const adjust = e.before ? 0 : parent.childColumns.length - 1;
            target = arr[index + adjust];
        }
        return mergeObjects(e, { target });
    }
    trackMove(leaveStream, dropStream, e) {
        const column = e.target.context.column;
        const levelColumns = this.columnsForLevel(column.level);
        const index = levelColumns.indexOf(column);
        const isFirst = (column.locked ? index === levelColumns.length - 1 : index === 0);
        const changed = e.draggable.context.column.isLocked !== column.isLocked;
        if (changed && isFirst) {
            return e.draggable.drag
                .pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({ mouseEvent }) => mergeObjects({ changeContainer: true }, e, { mouseEvent })));
        }
        return of(mergeObjects({ changeContainer: changed }, e));
    }
    calculateBefore({ draggable, target, mouseEvent, changeContainer = false }) {
        const targetElement = target.element.nativeElement;
        let before = false;
        if (changeContainer) {
            const { left } = offset(targetElement);
            const halfWidth = targetElement.offsetWidth / 2;
            const middle = left + halfWidth;
            before = middle > mouseEvent.pageX;
            if (this.localization.rtl) {
                before = !before;
            }
        }
        else {
            before = isTargetBefore(draggable.element.nativeElement, targetElement);
        }
        return before;
    }
    enter({ target, before }) {
        this.hint.enable();
        if (this.localization.rtl) {
            before = !before;
        }
        this.cue.position(position(target.element.nativeElement, before));
    }
    leave() {
        this.hint.disable();
        this.cue.hide();
    }
    drop({ draggable, target, before, changeContainer }) {
        this.reorderService.reorder({
            before,
            changeContainer,
            source: draggable.context.column,
            target: target.context.column
        });
    }
};
HeaderComponent.ɵfac = function HeaderComponent_Factory(t) { return new (t || HeaderComponent)(ɵngcc0.ɵɵdirectiveInject(SinglePopupService), ɵngcc0.ɵɵdirectiveInject(DragHintService), ɵngcc0.ɵɵdirectiveInject(DropCueService), ɵngcc0.ɵɵdirectiveInject(ColumnReorderService), ɵngcc0.ɵɵdirectiveInject(IdService), ɵngcc0.ɵɵdirectiveInject(SortService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
HeaderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: HeaderComponent, selectors: [["", "kendoGridHeader", ""]], viewQuery: function HeaderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(DropTargetDirective, 5);
        ɵngcc0.ɵɵviewQuery(FilterMenuComponent, 5);
        ɵngcc0.ɵɵviewQuery(ColumnMenuComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropTargets = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterMenus = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnMenus = _t);
    } }, hostVars: 2, hostBindings: function HeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-header", ctx.headerClass);
    } }, inputs: { columns: "columns", groups: "groups", sort: "sort", sortable: "sortable", groupable: "groupable", lockedColumnsCount: "lockedColumnsCount", resizable: "resizable", reorderable: "reorderable", columnMenu: "columnMenu", totalColumnsCount: "totalColumnsCount", totalColumnLevels: "totalColumnLevels", detailTemplate: "detailTemplate", scrollable: "scrollable", filterable: "filterable", filter: "filter", columnMenuTemplate: "columnMenuTemplate", tabIndex: "tabIndex" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c180, decls: 1, vars: 1, consts: [[3, "ngIf"], ["kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngFor", "ngForOf"], ["kendoGridFilterRow", "", "kendoGridLogicalRow", "", 3, "columns", "filter", "groups", "detailTemplate", "lockedColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngIf"], ["kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount"], ["class", "k-group-cell k-header", "role", "presentation", 4, "ngFor", "ngForOf"], ["class", "k-hierarchy-cell k-header", "role", "presentation", "kendoGridLogicalCell", "", "aria-selected", "false", 3, "logicalRowIndex", "logicalColIndex", 4, "ngIf"], ["ngFor", "", 3, "ngForOf", "ngForTrackBy"], ["role", "presentation", 1, "k-group-cell", "k-header"], ["role", "presentation", "kendoGridLogicalCell", "", "aria-selected", "false", 1, "k-hierarchy-cell", "k-header", 3, "logicalRowIndex", "logicalColIndex"], ["kendoGridLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", "class", "k-header", 3, "logicalRowIndex", "logicalColIndex", "headerLabelText", "colSpan", "rowSpan", "enableDrag", "context", "k-filterable", "k-first", "k-grid-header-sticky", "ngClass", "ngStyle", "keydown", 4, "ngIf"], ["kendoGridLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", "class", "k-header", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "headerLabelText", "enableDrag", "context", "k-first", "k-filterable", "k-grid-content-sticky", "ngClass", "ngStyle", 4, "ngIf"], ["kendoGridLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", 3, "logicalRowIndex", "logicalColIndex", "headerLabelText", "colSpan", "rowSpan", "enableDrag", "context", "ngClass", "ngStyle", "keydown"], ["kendoGridColumnHandle", "", "kendoDraggable", "", "class", "k-column-resizer", 3, "column", "columns", 4, "ngIf"], [3, "column", "filter", "tabIndex", 4, "ngIf"], [3, "standalone", "settings", "column", "columnMenuTemplate", "sort", "filter", "sortable", "tabIndex", 4, "ngIf"], [3, "templateContext"], [3, "column", "filter", "tabIndex"], [3, "standalone", "settings", "column", "columnMenuTemplate", "sort", "filter", "sortable", "tabIndex"], [1, "k-cell-inner"], [1, "k-link", 3, "click"], ["link", ""], ["role", "note", 3, "ngClass"], ["class", "k-sort-order", 4, "ngIf"], ["role", "status", 1, "k-sort-status", 2, "position", "absolute", "left", "-10000px", 3, "innerHtml"], [1, "k-column-title"], [1, "k-sort-order"], ["kendoGridSelectAllCheckbox", "", "kendoGridFocusable", "", 1, "k-checkbox", "k-checkbox-md", "k-rounded-md"], ["kendoGridColumnHandle", "", "kendoDraggable", "", 1, "k-column-resizer", 3, "column", "columns"], ["kendoGridLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "headerLabelText", "enableDrag", "context", "ngClass", "ngStyle"], [3, "standalone", "settings", "column", "columnMenuTemplate", 4, "ngIf"], [3, "standalone", "settings", "column", "columnMenuTemplate"], ["kendoGridFilterRow", "", "kendoGridLogicalRow", "", 3, "columns", "filter", "groups", "detailTemplate", "lockedColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount"]], template: function HeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, HeaderComponent_ng_template_0_Template, 2, 2, "ng-template", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", true);
    } }, directives: function () { return [ɵngcc5.NgIf, ɵngcc5.NgForOf, LogicalRowDirective, LogicalCellDirective, DropTargetDirective, ɵngcc2.DraggableDirective, DraggableColumnDirective, ɵngcc5.NgClass, ɵngcc5.NgStyle, FilterMenuComponent, ColumnMenuComponent, TemplateContextDirective, SelectAllCheckboxDirective, FocusableDirective, ColumnHandleDirective, FilterRowComponent]; }, styles: [".k-column-resizer[_ngcontent-%COMP%] {\n            cursor: col-resize;\n            display: block;\n            height: 1000%;\n            position: absolute;\n            top: 0;\n            width: .5em;\n        }"] });
__decorate([
    Input(),
    __metadata("design:type", Number)
], HeaderComponent.prototype, "totalColumnLevels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], HeaderComponent.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], HeaderComponent.prototype, "groups", void 0);
__decorate([
    Input(),
    __metadata("design:type", DetailTemplateDirective)
], HeaderComponent.prototype, "detailTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HeaderComponent.prototype, "scrollable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HeaderComponent.prototype, "filterable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], HeaderComponent.prototype, "sort", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HeaderComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HeaderComponent.prototype, "sortable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HeaderComponent.prototype, "groupable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], HeaderComponent.prototype, "lockedColumnsCount", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HeaderComponent.prototype, "resizable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HeaderComponent.prototype, "reorderable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HeaderComponent.prototype, "columnMenu", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], HeaderComponent.prototype, "columnMenuTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], HeaderComponent.prototype, "totalColumnsCount", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], HeaderComponent.prototype, "tabIndex", void 0);
__decorate([
    HostBinding('class.k-grid-header'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], HeaderComponent.prototype, "headerClass", null);
__decorate([
    ViewChildren(DropTargetDirective),
    __metadata("design:type", QueryList)
], HeaderComponent.prototype, "dropTargets", void 0);
__decorate([
    ViewChildren(FilterMenuComponent),
    __metadata("design:type", QueryList)
], HeaderComponent.prototype, "filterMenus", void 0);
__decorate([
    ViewChildren(ColumnMenuComponent),
    __metadata("design:type", QueryList)
], HeaderComponent.prototype, "columnMenus", void 0);
HeaderComponent = __decorate([ __metadata("design:paramtypes", [SinglePopupService,
        DragHintService,
        DropCueService,
        ColumnReorderService,
        IdService,
        SortService,
        LocalizationService,
        ColumnInfoService,
        ChangeDetectorRef])
], HeaderComponent);

// TODO
// tslint:disable:rxjs-no-unsafe-takeuntil
/**
 * @hidden
 */
const fromPercentage = (value, percent) => {
    const sign = percent < 0 ? -1 : 1;
    return Math.ceil((Math.abs(percent) / 100) * value) * sign;
};
/**
 * @hidden
 */
const toPercentage = (value, whole) => (value / whole) * 100;
/**
 * @hidden
 */
const headerWidth = (handle) => handle.nativeElement.parentElement.offsetWidth;
/**
 * @hidden
 */
const allLeafColumns = columns => expandColumns(columns)
    .filter(c => !c.isColumnGroup);
/**
 * @hidden
 */
const stopPropagation = ({ originalEvent: event }) => {
    event.stopPropagation();
    event.preventDefault();
};
/**
 * @hidden
 */
const createMoveStream = (service, draggable) => mouseDown => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({ pageX }) => ({
    originalX: mouseDown.pageX,
    pageX
})));
/**
 * @hidden
 */
const preventOnDblClick$1 = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
/**
 * @hidden
 */
const isInSpanColumn$1 = column => !!(column.parent && column.parent.isSpanColumn);
/**
 * @hidden
 *
 * Calculates the column index. If the column is stated in `SpanColumn`,
 * the index for all child columns equals the index of the first child.
 */
const indexOf = (target, list) => {
    let index = 0;
    let ignore = 0;
    let skip = 0;
    while (index < list.length) {
        const current = list[index];
        const isParentSpanColumn = isInSpanColumn$1(current);
        if (current === target) {
            break;
        }
        if ((ignore-- <= 0) && isParentSpanColumn) {
            ignore = current.parent.childColumns.length - 1;
            skip += ignore;
        }
        index++;
    }
    return index - skip;
};
/**
 * @hidden
 */
let ColumnHandleDirective = class ColumnHandleDirective {
    constructor(draggable, element, service, zone, cdr, localization, columnInfoService) {
        this.draggable = draggable;
        this.element = element;
        this.service = service;
        this.zone = zone;
        this.cdr = cdr;
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.columns = [];
        this.subscriptions = new Subscription();
        this.rtl = false;
    }
    get visible() {
        return this.column.resizable ? 'block' : 'none';
    }
    get leftStyle() {
        return isTruthy(this.rtl) ? 0 : null;
    }
    get rightStyle() {
        return isTruthy(this.rtl) ? null : 0;
    }
    autoFit() {
        const allLeafs = allLeafColumns(this.columns);
        const currentLeafs = leafColumns([this.column]).filter(column => isTruthy(column.resizable));
        const columnInfo = currentLeafs.map(column => {
            const isParentSpan = isInSpanColumn$1(column);
            const isLastInSpan = isParentSpan ? column.parent.childColumns.last === column : false;
            const index = indexOf(column, allLeafs);
            return {
                column,
                headerIndex: this.columnsForLevel(column.level).indexOf(column),
                index,
                isLastInSpan,
                isParentSpan,
                level: column.level
            };
        });
        currentLeafs.forEach(column => column.width = 0);
        this.service.measureColumns(columnInfo);
    }
    ngOnInit() {
        if (isBlank(this.column.width)) {
            this.column.implicitWidth = headerWidth(this.element);
        }
        const service = this.service.changes.pipe(filter(() => this.column.resizable), filter(e => isPresent(e.columns.find(column => column === this.column))));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'start'))
            .subscribe(this.initState.bind(this)));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'resizeColumn'))
            .subscribe(this.resize.bind(this)));
        this.subscriptions.add(this.service.changes.pipe(filter(e => e.type === 'start'), filter(this.shouldUpdate.bind(this)), take(1) //on first resize only
        ).subscribe(this.initColumnWidth.bind(this)));
        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), switchMap(createMoveStream(this.service, this.draggable)))
            .subscribe(({ pageX, originalX }) => {
            const delta = pageX - originalX;
            const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);
            this.service.resizeColumns(percent);
        })));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'autoFitComplete'))
            .subscribe(this.sizeToFit.bind(this)));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'triggerAutoFit'))
            .subscribe(this.autoFit.bind(this)));
        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    shouldUpdate() {
        return !allLeafColumns(this.columns)
            .map(column => column.width)
            .some(isBlank);
    }
    initColumnWidth() {
        this.column.width = headerWidth(this.element);
    }
    initState() {
        this.column.resizeStartWidth = headerWidth(this.element);
        this.service.resizedColumn({
            column: this.column,
            oldWidth: this.column.resizeStartWidth
        });
    }
    resize({ deltaPercent }) {
        let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);
        if (isTruthy(this.rtl)) {
            delta *= -1;
        }
        const newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);
        const tableDelta = newWidth > this.column.minResizableWidth ?
            delta : this.column.minResizableWidth - this.column.resizeStartWidth;
        this.updateWidth(this.column, newWidth);
        this.service.resizeTable(this.column, tableDelta);
    }
    sizeToFit({ columns, widths }) {
        const index = columns.indexOf(this.column);
        const width = Math.max(...widths.map(w => w[index])) + 1; //add 1px for IE
        const tableDelta = width - this.column.resizeStartWidth;
        this.updateWidth(this.column, width);
        this.service.resizeTable(this.column, tableDelta);
    }
    updateWidth(column, width) {
        column.width = width;
        this.columnInfoService.hiddenColumns.forEach((col) => {
            if (isBlank(col.width) && isPresent(col.implicitWidth)) {
                // Resize hidden columns to their implicit width so they
                // can be displayed with the same width if made visible.
                col.width = col.implicitWidth;
            }
        });
        this.cdr.markForCheck(); //force CD cycle
    }
    columnsForLevel(level) {
        return columnsToRender(this.columns ? this.columns.filter(column => column.level === level) : []);
    }
};
ColumnHandleDirective.ɵfac = function ColumnHandleDirective_Factory(t) { return new (t || ColumnHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DraggableDirective, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService)); };
ColumnHandleDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ColumnHandleDirective, selectors: [["", "kendoGridColumnHandle", ""]], hostVars: 6, hostBindings: function ColumnHandleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("dblclick", function ColumnHandleDirective_dblclick_HostBindingHandler() { return ctx.autoFit(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.visible)("left", ctx.leftStyle)("right", ctx.rightStyle);
    } }, inputs: { columns: "columns", column: "column" } });
__decorate([
    Input(),
    __metadata("design:type", Array)
], ColumnHandleDirective.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", ColumnBase$1)
], ColumnHandleDirective.prototype, "column", void 0);
__decorate([
    HostBinding('style.display'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ColumnHandleDirective.prototype, "visible", null);
__decorate([
    HostBinding('style.left'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], ColumnHandleDirective.prototype, "leftStyle", null);
__decorate([
    HostBinding('style.right'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], ColumnHandleDirective.prototype, "rightStyle", null);
__decorate([
    HostListener('dblclick'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ColumnHandleDirective.prototype, "autoFit", null);
ColumnHandleDirective = __decorate([ __param(0, Host()),
    __metadata("design:paramtypes", [DraggableDirective,
        ElementRef,
        ColumnResizingService,
        NgZone,
        ChangeDetectorRef,
        LocalizationService,
        ColumnInfoService])
], ColumnHandleDirective);

/**
 * Represents the select-all checkbox feature of the Grid ([see example]({% slug selection_grid %}#toc-select-all-feature)).
 */
let SelectAllCheckboxDirective = class SelectAllCheckboxDirective {
    constructor(selectionService, el, renderer, ngZone) {
        this.selectionService = selectionService;
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Fires when the user clicks the `kendoGridSelectAllCheckbox` select-all checkbox
         * ([see example]({% slug selection_grid %}#toc-select-all-feature)).
         */
        this.selectAllChange = new EventEmitter();
        this.type = 'checkbox';
        this.stateSet = false;
        this.ngZone.runOutsideAngular(() => {
            this.destroyClick = this.renderer.listen(this.el.nativeElement, 'click', this.onClick.bind(this));
        });
    }
    ngAfterContentChecked() {
        this.setState();
    }
    ngOnChanges() {
        this.stateSet = true;
    }
    ngOnDestroy() {
        if (this.destroyClick) {
            this.destroyClick();
        }
    }
    /**
     * @hidden
     */
    onClick() {
        // yields consistent cross-browser behavior when clicking an indeterminate checkbox
        const undefinedCheckedStateInIE = detectIE() && this.selectionService.selectAllState === undefined;
        const isChecked = undefinedCheckedStateInIE ? true : this.el.nativeElement.checked;
        const options = this.selectionService.options;
        const enabledAndMultiple = options.enabled && options.mode === 'multiple';
        const shouldEmitSelectAll = hasObservers(this.selectAllChange);
        if (enabledAndMultiple || shouldEmitSelectAll) {
            this.ngZone.run(() => {
                if (enabledAndMultiple) {
                    this.selectionService.updateAll(isChecked);
                }
                if (shouldEmitSelectAll) {
                    this.selectAllChange.emit(isChecked ? 'checked' : 'unchecked');
                }
            });
        }
    }
    /**
     * @hidden
     */
    setState() {
        const state$$1 = this.stateSet ? this.stateToBool() : this.selectionService.selectAllState;
        const elem = this.el.nativeElement;
        this.renderer.setProperty(elem, 'indeterminate', !isPresent(state$$1));
        this.renderer.setProperty(elem, 'checked', isPresent(state$$1) ? state$$1 : false);
    }
    /**
     * @hidden
     */
    stateToBool() {
        switch (this.state) {
            case 'checked':
                return true;
            case 'unchecked':
                return false;
            default:
                return undefined;
        }
    }
};
SelectAllCheckboxDirective.ɵfac = function SelectAllCheckboxDirective_Factory(t) { return new (t || SelectAllCheckboxDirective)(ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
SelectAllCheckboxDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SelectAllCheckboxDirective, selectors: [["", "kendoGridSelectAllCheckbox", ""]], hostVars: 1, hostBindings: function SelectAllCheckboxDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("type", ctx.type);
    } }, inputs: { state: "state" }, outputs: { selectAllChange: "selectAllChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SelectAllCheckboxDirective.prototype, "state", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SelectAllCheckboxDirective.prototype, "selectAllChange", void 0);
__decorate([
    HostBinding('attr.type'),
    __metadata("design:type", String)
], SelectAllCheckboxDirective.prototype, "type", void 0);
SelectAllCheckboxDirective = __decorate([ __metadata("design:paramtypes", [SelectionService,
        ElementRef,
        Renderer2,
        NgZone])
], SelectAllCheckboxDirective);

const isNoValueOperator = operator => (operator === "isnull"
    || operator === "isnotnull"
    || operator === "isempty"
    || operator === "isnotempty");
const validFilters = ({ value, operator }) => !isNullOrEmptyString(value) || isNoValueOperator(operator);
const trimFilters = filter$$1 => {
    filter$$1.filters = filter$$1.filters.filter(validFilters);
    return filter$$1;
};
const findParent = (filters, field, parent) => {
    return filters.reduce((acc, filter$$1) => {
        if (acc) {
            return acc;
        }
        if (filter$$1.filters) {
            return findParent(filter$$1.filters, field, filter$$1);
        }
        else if (filter$$1.field === field) {
            return parent;
        }
        return acc;
    }, undefined); // tslint:disable-line:align
};
const parentLogicOfDefault = (filter$$1, field, def = "and") => {
    const parent = findParent(((filter$$1 || {}).filters || []), field);
    return isPresent(parent) ? parent.logic : def;
};
/**
 * @hidden
 */
let FilterMenuContainerComponent = class FilterMenuContainerComponent {
    constructor(parentService, childService, localization, cd, menuTabbingService) {
        this.parentService = parentService;
        this.childService = childService;
        this.localization = localization;
        this.cd = cd;
        this.close = new EventEmitter();
        /**
         * @hidden
         */
        this.actionsClass = 'k-action-buttons k-button-group';
        this._templateContext = {};
        this.menuTabbingService = menuTabbingService;
    }
    get filter() {
        return this._filter;
    }
    /**
     * The current root filter.
     * @type {CompositeFilterDescriptor}
     */
    set filter(value) {
        this._filter = cloneFilters(value);
    }
    get childFilter() {
        if (!isPresent(this._childFilter)) {
            this._childFilter = {
                filters: filtersByField(this.filter, (this.column || {}).field),
                logic: parentLogicOfDefault(this.filter, (this.column || {}).field)
            };
        }
        return this._childFilter;
    }
    ngOnInit() {
        this.subscription = this.childService.changes.subscribe(filter$$1 => this._childFilter = filter$$1);
        this.subscription.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));
    }
    ngAfterViewChecked() {
        if (!this.menuTabbingService.isColumnMenu || (this.isLast && this.isExpanded)) {
            this.menuTabbingService.lastFocusable = this.disabled ?
                this.resetButton.nativeElement : this.filterButton.nativeElement;
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.menuTabbingService.lastFocusable = undefined;
    }
    get disabled() {
        return !this.childFilter.filters.some(validFilters);
    }
    get templateContext() {
        this._templateContext.column = this.column;
        this._templateContext.filter = this.childFilter;
        this._templateContext.filterService = this.childService;
        // tslint:disable-next-line:no-string-literal
        this._templateContext["$implicit"] = this.childFilter;
        return this._templateContext;
    }
    get hasTemplate() {
        return isPresent(this.column) && isPresent(this.column.filterMenuTemplateRef);
    }
    submit() {
        const filter$$1 = trimFilters(this.childFilter);
        if (filter$$1.filters.length) {
            const root = this.filter || {
                filters: [],
                logic: "and"
            };
            removeFilter(root, this.column.field);
            root.filters.push(filter$$1);
            this.parentService.filter(root);
        }
        this.close.emit();
        return false;
    }
    reset() {
        const root = this.filter || {
            filters: [],
            logic: "and"
        };
        removeFilter(root, this.column.field);
        this.parentService.filter(root);
        this.close.emit();
    }
    onTab(e, buttonType) {
        if (this.menuTabbingService.firstFocusable && (!this.menuTabbingService.isColumnMenu || this.isLast)) {
            e.preventDefault();
            if (buttonType === 'reset') {
                this.disabled ? this.menuTabbingService.firstFocusable.focus() : this.filterButton.nativeElement.focus();
            }
            else {
                this.menuTabbingService.firstFocusable.focus();
            }
        }
    }
    get clearText() {
        return this.localization.get("filterClearButton");
    }
    get filterText() {
        return this.localization.get("filterFilterButton");
    }
};
FilterMenuContainerComponent.ɵfac = function FilterMenuContainerComponent_Factory(t) { return new (t || FilterMenuContainerComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService, 4), ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MenuTabbingService)); };
FilterMenuContainerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FilterMenuContainerComponent, selectors: [["kendo-grid-filter-menu-container"]], viewQuery: function FilterMenuContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c184, 5);
        ɵngcc0.ɵɵviewQuery(_c185, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resetButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterButton = _t.first);
    } }, inputs: { actionsClass: "actionsClass", menuTabbingService: "menuTabbingService", filter: "filter", column: "column", isLast: "isLast", isExpanded: "isExpanded" }, outputs: { close: "close" }, features: [ɵngcc0.ɵɵProvidersFeature([
            FilterService,
            MenuTabbingService
        ])], decls: 12, vars: 7, consts: [[1, "k-filter-menu", "k-group", "k-reset", "k-state-border-up", 3, "submit", "reset"], [1, "k-filter-menu-container"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "ngClass"], ["type", "reset", 1, "k-button", "k-button-solid-base", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "keydown.tab"], ["resetButton", ""], ["type", "submit", 1, "k-button", "k-button-solid-primary", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "disabled", "keydown.tab"], ["filterButton", ""], ["kendoFilterMenuHost", "", 3, "filterService", "column", "filter", "menuTabbingService"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function FilterMenuContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "form", 0);
        ɵngcc0.ɵɵlistener("submit", function FilterMenuContainerComponent_Template_form_submit_0_listener() { return ctx.submit(); })("reset", function FilterMenuContainerComponent_Template_form_reset_0_listener() { return ctx.reset(); });
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵtemplate(3, FilterMenuContainerComponent_ng_container_3_Template, 2, 4, "ng-container", 3);
        ɵngcc0.ɵɵtemplate(4, FilterMenuContainerComponent_ng_container_4_Template, 2, 1, "ng-container", 3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4)(6, "button", 5, 6);
        ɵngcc0.ɵɵlistener("keydown.tab", function FilterMenuContainerComponent_Template_button_keydown_tab_6_listener($event) { return ctx.onTab($event, "reset"); });
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "button", 7, 8);
        ɵngcc0.ɵɵlistener("keydown.tab", function FilterMenuContainerComponent_Template_button_keydown_tab_9_listener($event) { return ctx.onTab($event, "filter"); });
        ɵngcc0.ɵɵtext(11);
        ɵngcc0.ɵɵelementEnd()()()();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.hasTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", false);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.actionsClass);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.clearText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.filterText);
    } }, directives: function () { return [ɵngcc7.ɵNgNoValidate, ɵngcc7.NgControlStatusGroup, ɵngcc7.NgForm, ɵngcc5.NgSwitch, ɵngcc5.NgSwitchCase, FilterMenuHostDirective, ɵngcc5.NgIf, ɵngcc5.NgTemplateOutlet, ɵngcc5.NgClass]; }, encapsulation: 2 });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FilterMenuContainerComponent.prototype, "close", void 0);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], FilterMenuContainerComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FilterMenuContainerComponent.prototype, "isLast", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FilterMenuContainerComponent.prototype, "isExpanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], FilterMenuContainerComponent.prototype, "menuTabbingService", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], FilterMenuContainerComponent.prototype, "filter", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], FilterMenuContainerComponent.prototype, "actionsClass", void 0);
__decorate([
    ViewChild('resetButton', { static: false }),
    __metadata("design:type", ElementRef)
], FilterMenuContainerComponent.prototype, "resetButton", void 0);
__decorate([
    ViewChild('filterButton', { static: false }),
    __metadata("design:type", ElementRef)
], FilterMenuContainerComponent.prototype, "filterButton", void 0);
FilterMenuContainerComponent = __decorate([ __param(0, SkipSelf()),
    __metadata("design:paramtypes", [FilterService,
        FilterService,
        LocalizationService,
        ChangeDetectorRef,
        MenuTabbingService])
], FilterMenuContainerComponent);

/**
 * @hidden
 */
let FilterMenuInputWrapperComponent = class FilterMenuInputWrapperComponent extends FilterInputWrapperComponent {
    constructor(localizationService) {
        super(null);
        this.localizationService = localizationService;
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    ngAfterViewInit() {
        if (this.isFirstDropDown && this.filterService && this.filterService.menuTabbingService) {
            this.filterService.menuTabbingService.firstFocusable = this.firstOperatorDropDown;
            this.firstOperatorDropDown.focus();
        }
    }
    operatorChange(dataItem) {
        this.currentOperator = dataItem;
    }
    filterChange(filter$$1) {
        this.applyFilter(filter$$1);
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this._currentFilter;
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    set currentFilter(value) {
        this._currentFilter = value;
    }
    updateFilter(filter$$1) {
        Object.assign(this.currentFilter, filter$$1);
        return this.filter;
    }
    onChange(value) {
        this.filterChange(this.updateFilter({
            field: this.column.field,
            operator: this.currentOperator,
            value: value
        }));
    }
    onShiftTab(e) {
        e.stopImmediatePropagation();
        if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.isFirstDropDown && this.filterService.menuTabbingService.lastFocusable) {
            e.preventDefault();
            this.filterService.menuTabbingService.lastFocusable.focus();
        }
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.localizationService.get('filterMenuOperatorsDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
FilterMenuInputWrapperComponent.ɵfac = function FilterMenuInputWrapperComponent_Factory(t) { return new (t || FilterMenuInputWrapperComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
FilterMenuInputWrapperComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FilterMenuInputWrapperComponent, selectors: [["kendo-grid-filter-menu-input-wrapper"]], viewQuery: function FilterMenuInputWrapperComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(DropDownListComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.firstOperatorDropDown = _t.first);
    } }, inputs: { currentFilter: "currentFilter", filterService: "filterService", isFirstDropDown: "isFirstDropDown", menuTabbingService: "menuTabbingService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c150, decls: 2, vars: 4, consts: [["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 3, "filterMenuDropDownLabel", "data", "value", "valuePrimitive", "valueChange", "keydown.shift.tab"]], template: function FilterMenuInputWrapperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 0);
        ɵngcc0.ɵɵlistener("valueChange", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) { return ctx.operatorChange($event); })("keydown.shift.tab", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_keydown_shift_tab_0_listener($event) { return ctx.onShiftTab($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("filterMenuDropDownLabel", ctx.filterMenuDropDownLabel)("data", ctx.operators)("value", ctx.currentOperator)("valuePrimitive", true);
    } }, directives: function () { return [ɵngcc8.DropDownListComponent, FilterMenuDropDownListDirective]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", FilterService)
], FilterMenuInputWrapperComponent.prototype, "filterService", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FilterMenuInputWrapperComponent.prototype, "isFirstDropDown", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], FilterMenuInputWrapperComponent.prototype, "menuTabbingService", void 0);
__decorate([
    ViewChild(DropDownListComponent, { static: false }),
    __metadata("design:type", DropDownListComponent)
], FilterMenuInputWrapperComponent.prototype, "firstOperatorDropDown", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], FilterMenuInputWrapperComponent.prototype, "currentFilter", null);
FilterMenuInputWrapperComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], FilterMenuInputWrapperComponent);

/**
 * @hidden
 */
let StringFilterMenuInputComponent = class StringFilterMenuInputComponent {
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.operators = [];
    }
    get columnLabel() {
        const localizationMsg = this.localizationService.get('filterInputLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
StringFilterMenuInputComponent.ɵfac = function StringFilterMenuInputComponent_Factory(t) { return new (t || StringFilterMenuInputComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
StringFilterMenuInputComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StringFilterMenuInputComponent, selectors: [["kendo-grid-string-filter-menu-input"]], inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", isFirstDropDown: "isFirstDropDown", menuTabbingService: "menuTabbingService" }, decls: 2, vars: 11, consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoTextBox", "", "kendoFilterInput", "", 3, "columnLabel", "filterDelay", "ngModel"]], template: function StringFilterMenuInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 0);
        ɵngcc0.ɵɵelement(1, "input", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", 0)("ngModel", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    } }, directives: [FilterMenuInputWrapperComponent, ɵngcc6.TextBoxDirective, ɵngcc7.DefaultValueAccessor, FilterInputDirective, ɵngcc7.NgControlStatus, ɵngcc7.NgModel], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], StringFilterMenuInputComponent.prototype, "operators", void 0);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], StringFilterMenuInputComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], StringFilterMenuInputComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StringFilterMenuInputComponent.prototype, "operator", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], StringFilterMenuInputComponent.prototype, "currentFilter", void 0);
__decorate([
    Input(),
    __metadata("design:type", FilterService)
], StringFilterMenuInputComponent.prototype, "filterService", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], StringFilterMenuInputComponent.prototype, "isFirstDropDown", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], StringFilterMenuInputComponent.prototype, "menuTabbingService", void 0);
StringFilterMenuInputComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], StringFilterMenuInputComponent);

/**
 * Represents a string-filter menu component.
 * ([see example]({% slug builtinfiltertemplate_grid %}#toc-configuration-components-for-filter-templates)).
 */
let StringFilterMenuComponent = class StringFilterMenuComponent extends StringFilterComponent {
    constructor(localization) {
        super(null, localization);
        this.logicOperators = logicOperators(this.localization);
        /**
         * The current menu filter.
         * @type {CompositeFilterDescriptor}
         */
        this.filter = { filters: [], logic: "and" };
        /**
         * Determines if the inputs of second criteria will displayed.
         */
        this.extra = true;
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.localization.get('filterMenuLogicDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.localization);
        super.localizationChange();
    }
};
StringFilterMenuComponent.ɵfac = function StringFilterMenuComponent_Factory(t) { return new (t || StringFilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
StringFilterMenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StringFilterMenuComponent, selectors: [["kendo-grid-string-filter-menu"]], hostVars: 2, hostBindings: function StringFilterMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } }, inputs: { filter: "filter", extra: "extra", column: "column", filterService: "filterService", menuTabbingService: "menuTabbingService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 9, consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "isFirstDropDown", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "class", "k-filter-and", "textField", "text", "valueField", "value", 3, "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "menuTabbingService", 4, "ngIf"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange"], [3, "operators", "currentFilter", "filterService", "column", "filter", "menuTabbingService"]], template: function StringFilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "kendo-grid-string-filter-menu-input", 0);
        ɵngcc0.ɵɵtemplate(1, StringFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 4, "kendo-dropdownlist", 1);
        ɵngcc0.ɵɵtemplate(2, StringFilterMenuComponent_kendo_grid_string_filter_menu_input_2_Template, 1, 6, "kendo-grid-string-filter-menu-input", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("isFirstDropDown", true)("menuTabbingService", ctx.menuTabbingService);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
    } }, directives: function () { return [StringFilterMenuInputComponent, ɵngcc5.NgIf, ɵngcc8.DropDownListComponent, FilterMenuDropDownListDirective]; }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-filtercell'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], StringFilterMenuComponent.prototype, "hostClasses", null);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], StringFilterMenuComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], StringFilterMenuComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], StringFilterMenuComponent.prototype, "extra", void 0);
__decorate([
    Input(),
    __metadata("design:type", FilterService)
], StringFilterMenuComponent.prototype, "filterService", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], StringFilterMenuComponent.prototype, "menuTabbingService", void 0);
StringFilterMenuComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], StringFilterMenuComponent);

/**
 * Represents a numeric-filter menu component.
 *
 * @example
 *  ```html-no-run
 *      <kendo-grid-column field="UnitPrice" title="Unit Price">
 *          <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *          <kendo-grid-numeric-filter-menu
 *              [column]="column"
 *              [filter]="filter"
 *              [filterService]="filterService"
 *              >
 *          </kendo-grid-numeric-filter-menu>
 *          </ng-template>
 *      </kendo-grid-column>
 *   ```
 */
let NumericFilterMenuComponent = class NumericFilterMenuComponent extends NumericFilterComponent {
    constructor(localization) {
        super(null, localization);
        this.logicOperators = logicOperators(this.localization);
        /**
         * The current menu filter.
         * @type {CompositeFilterDescriptor}
         */
        this.filter = { filters: [], logic: "and" };
        /**
         * Determines if the inputs of second criteria will displayed.
         */
        this.extra = true;
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.localization.get('filterMenuLogicDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.localization);
        super.localizationChange();
    }
};
NumericFilterMenuComponent.ɵfac = function NumericFilterMenuComponent_Factory(t) { return new (t || NumericFilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
NumericFilterMenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NumericFilterMenuComponent, selectors: [["kendo-grid-numeric-filter-menu"]], hostVars: 2, hostBindings: function NumericFilterMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } }, inputs: { filter: "filter", extra: "extra", column: "column", filterService: "filterService", menuTabbingService: "menuTabbingService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 15, consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService", "isFirstDropDown"], ["kendoFilterMenuDropDown", "", "class", "k-filter-and", "textField", "text", "valueField", "value", 3, "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService", 4, "ngIf"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange"], [3, "operators", "currentFilter", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService"]], template: function NumericFilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "kendo-grid-numeric-filter-menu-input", 0);
        ɵngcc0.ɵɵtemplate(1, NumericFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 4, "kendo-dropdownlist", 1);
        ɵngcc0.ɵɵtemplate(2, NumericFilterMenuComponent_kendo_grid_numeric_filter_menu_input_2_Template, 1, 12, "kendo-grid-numeric-filter-menu-input", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step)("menuTabbingService", ctx.menuTabbingService)("isFirstDropDown", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
    } }, directives: function () { return [NumericFilterMenuInputComponent, ɵngcc5.NgIf, ɵngcc8.DropDownListComponent, FilterMenuDropDownListDirective]; }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-filtercell'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NumericFilterMenuComponent.prototype, "hostClasses", null);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], NumericFilterMenuComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NumericFilterMenuComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericFilterMenuComponent.prototype, "extra", void 0);
__decorate([
    Input(),
    __metadata("design:type", FilterService)
], NumericFilterMenuComponent.prototype, "filterService", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], NumericFilterMenuComponent.prototype, "menuTabbingService", void 0);
NumericFilterMenuComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], NumericFilterMenuComponent);

/**
 * @hidden
 */
let NumericFilterMenuInputComponent = class NumericFilterMenuInputComponent {
    constructor(localization) {
        this.localization = localization;
        this.operators = [];
        /**
         * Specifies the value which is used to increment or decrement the component value.
         * @type {numeric}
         */
        this.step = 1;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered.
         * @type {boolean}
         */
        this.spinners = true;
    }
    messageFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.localization.get('filterInputLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
NumericFilterMenuInputComponent.ɵfac = function NumericFilterMenuInputComponent_Factory(t) { return new (t || NumericFilterMenuInputComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
NumericFilterMenuInputComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NumericFilterMenuInputComponent, selectors: [["kendo-grid-numeric-filter-menu-input"]], inputs: { operators: "operators", step: "step", spinners: "spinners", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", isFirstDropDown: "isFirstDropDown", menuTabbingService: "menuTabbingService", min: "min", max: "max", decimals: "decimals", format: "format" }, decls: 3, vars: 20, consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "columnLabel", "filterDelay", "autoCorrect", "value", "format", "decimals", "spinners", "min", "max", "step"], [3, "increment", "decrement"]], template: function NumericFilterMenuInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 0)(1, "kendo-numerictextbox", 1);
        ɵngcc0.ɵɵelement(2, "kendo-numerictextbox-messages", 2);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", 0)("autoCorrect", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("increment", ctx.messageFor("filterNumericIncrement"))("decrement", ctx.messageFor("filterNumericDecrement"));
    } }, directives: [FilterMenuInputWrapperComponent, ɵngcc6.NumericTextBoxComponent, FilterInputDirective, ɵngcc6.NumericTextBoxCustomMessagesComponent], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], NumericFilterMenuInputComponent.prototype, "operators", void 0);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], NumericFilterMenuInputComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NumericFilterMenuInputComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericFilterMenuInputComponent.prototype, "operator", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NumericFilterMenuInputComponent.prototype, "currentFilter", void 0);
__decorate([
    Input(),
    __metadata("design:type", FilterService)
], NumericFilterMenuInputComponent.prototype, "filterService", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericFilterMenuInputComponent.prototype, "isFirstDropDown", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], NumericFilterMenuInputComponent.prototype, "menuTabbingService", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericFilterMenuInputComponent.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericFilterMenuInputComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericFilterMenuInputComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericFilterMenuInputComponent.prototype, "spinners", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericFilterMenuInputComponent.prototype, "decimals", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericFilterMenuInputComponent.prototype, "format", void 0);
NumericFilterMenuInputComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], NumericFilterMenuInputComponent);

/**
 * Represents a date-filter menu component.
 *
 * @example
 *  ```html-no-run
 *      <kendo-grid-column field="OrderDate" title="Order Date">
 *          <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *            <kendo-grid-date-filter-menu
 *                [column]="column"
 *                [filter]="filter"
 *                [filterService]="filterService"
 *                >
 *            </kendo-grid-date-filter-menu>
 *          </ng-template>
 *      </kendo-grid-column>
 *   ```
 */
let DateFilterMenuComponent = class DateFilterMenuComponent extends DateFilterComponent {
    constructor(localization) {
        super(null, localization);
        this.logicOperators = logicOperators(this.localization);
        /**
         * The current menu filter.
         * @type {CompositeFilterDescriptor}
         */
        this.filter = { filters: [], logic: "and" };
        /**
         * Determines if the inputs of second criteria will be displayed.
         */
        this.extra = true;
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.localization.get('filterMenuLogicDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.localization);
        super.localizationChange();
    }
};
DateFilterMenuComponent.ɵfac = function DateFilterMenuComponent_Factory(t) { return new (t || DateFilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
DateFilterMenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateFilterMenuComponent, selectors: [["kendo-grid-date-filter-menu"]], hostVars: 2, hostBindings: function DateFilterMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } }, inputs: { filter: "filter", extra: "extra", column: "column", filterService: "filterService", menuTabbingService: "menuTabbingService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 18, consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "isFirstDropDown", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "class", "k-filter-and", "textField", "text", "valueField", "value", 3, "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "menuTabbingService", 4, "ngIf"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange"], [3, "operators", "currentFilter", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "menuTabbingService"]], template: function DateFilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "kendo-grid-date-filter-menu-input", 0);
        ɵngcc0.ɵɵtemplate(1, DateFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 4, "kendo-dropdownlist", 1);
        ɵngcc0.ɵɵtemplate(2, DateFilterMenuComponent_kendo_grid_date_filter_menu_input_2_Template, 1, 15, "kendo-grid-date-filter-menu-input", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber)("isFirstDropDown", true)("menuTabbingService", ctx.menuTabbingService);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
    } }, directives: function () { return [DateFilterMenuInputComponent, ɵngcc5.NgIf, ɵngcc8.DropDownListComponent, FilterMenuDropDownListDirective]; }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-filtercell'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DateFilterMenuComponent.prototype, "hostClasses", null);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], DateFilterMenuComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateFilterMenuComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateFilterMenuComponent.prototype, "extra", void 0);
__decorate([
    Input(),
    __metadata("design:type", FilterService)
], DateFilterMenuComponent.prototype, "filterService", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], DateFilterMenuComponent.prototype, "menuTabbingService", void 0);
DateFilterMenuComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], DateFilterMenuComponent);

/**
 * @hidden
 */
let BooleanFilterRadioButtonDirective = class BooleanFilterRadioButtonDirective {
    constructor(hostElement, renderer) {
        this.hostElement = hostElement;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        this.radioButtonEl = this.hostElement.nativeElement;
        this.renderer.setAttribute(this.hostElement.nativeElement, 'aria-label', this.columnLabel);
    }
};
BooleanFilterRadioButtonDirective.ɵfac = function BooleanFilterRadioButtonDirective_Factory(t) { return new (t || BooleanFilterRadioButtonDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
BooleanFilterRadioButtonDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BooleanFilterRadioButtonDirective, selectors: [["", "kendoFilterMenuRadioButton", ""]], inputs: { columnLabel: "columnLabel" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], BooleanFilterRadioButtonDirective.prototype, "columnLabel", void 0);
BooleanFilterRadioButtonDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2])
], BooleanFilterRadioButtonDirective);

/**
 * Represents a Boolean-filter menu component.
 *
 * @example
 *  ```html-no-run
 *      <kendo-grid-column field="Discontinued" title="Discontinued">
 *          <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *            <kendo-grid-boolean-filter-menu
 *                [column]="column"
 *                [filter]="filter"
 *                [filterService]="filterService"
 *                >
 *            </kendo-grid-boolean-filter-menu>
 *          </ng-template>
 *      </kendo-grid-column>
 *   ```
 */
let BooleanFilterMenuComponent = class BooleanFilterMenuComponent extends BooleanFilterComponent {
    constructor(localization) {
        super(null, localization);
        /**
         * The current menu filter.
         * @type {CompositeFilterDescriptor}
         */
        this.filter = { filters: [], logic: "and" };
        this.idPrefix = guid();
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    ngAfterViewInit() {
        this.filterService.menuTabbingService.firstFocusable = this.radioButtons.first.radioButtonEl;
        this.radioButtons.first.radioButtonEl.focus();
    }
    /**
     * @hidden
     */
    radioId(value) {
        return `${this.idPrefix}_${value}`;
    }
    /**
     * @hidden
     */
    onChange(value, input) {
        this.applyFilter(this.updateFilter({
            field: this.column.field,
            operator: "eq",
            value: value
        }));
        this.filterService.menuTabbingService.firstFocusable = input;
    }
    /**
     * @hidden
     */
    isSelected(radioValue) {
        return this.filtersByField(this.column.field).some(({ value }) => value === radioValue);
    }
    /**
     * @hidden
     */
    onShiftTab(e) {
        if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.filterService.menuTabbingService.lastFocusable) {
            e.preventDefault();
            this.filterService.menuTabbingService.lastFocusable.focus();
        }
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
BooleanFilterMenuComponent.ɵfac = function BooleanFilterMenuComponent_Factory(t) { return new (t || BooleanFilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
BooleanFilterMenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BooleanFilterMenuComponent, selectors: [["kendo-grid-boolean-filter-menu"]], viewQuery: function BooleanFilterMenuComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(BooleanFilterRadioButtonDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.radioButtons = _t);
    } }, hostVars: 2, hostBindings: function BooleanFilterMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } }, inputs: { filter: "filter", filterService: "filterService", menuTabbingService: "menuTabbingService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 1, consts: [[1, "k-radio-list", "k-reset"], [4, "ngFor", "ngForOf"], ["type", "radio", "kendoFilterMenuRadioButton", "", "kendoRadioButton", "", 3, "columnLabel", "name", "checked", "change", "keydown.shift.tab"], ["input", ""], [1, "k-radio-label"]], template: function BooleanFilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, BooleanFilterMenuComponent_li_1_Template, 5, 6, "li", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc5.NgForOf, ɵngcc6.RadioButtonDirective, BooleanFilterRadioButtonDirective], encapsulation: 2 });
__decorate([
    HostBinding('class.k-filtercell'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], BooleanFilterMenuComponent.prototype, "hostClasses", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BooleanFilterMenuComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", FilterService)
], BooleanFilterMenuComponent.prototype, "filterService", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], BooleanFilterMenuComponent.prototype, "menuTabbingService", void 0);
__decorate([
    ViewChildren(BooleanFilterRadioButtonDirective),
    __metadata("design:type", QueryList)
], BooleanFilterMenuComponent.prototype, "radioButtons", void 0);
BooleanFilterMenuComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], BooleanFilterMenuComponent);

/**
 * @hidden
 *
 * > List the following components as `entryComponents` in the GridModule.
 */
const filterMenuComponentFactory = (type) => ({
    "boolean": BooleanFilterMenuComponent,
    "date": DateFilterMenuComponent,
    "numeric": NumericFilterMenuComponent,
    "text": StringFilterMenuComponent
}[type]);

/**
 * @hidden
 */
let FilterMenuHostDirective = class FilterMenuHostDirective extends FilterHostDirective {
    constructor(host, resolver) {
        super(host, resolver);
    }
    componentType() {
        if (isPresent(this.column) && !isNullOrEmptyString(this.column.filter)) {
            return filterMenuComponentFactory(this.column.filter);
        }
        return StringFilterMenuComponent;
    }
    initComponent(ctx) {
        super.initComponent(ctx);
        this.component.instance.filterService = this.filterService;
        this.component.instance.menuTabbingService = this.menuTabbingService;
    }
};
FilterMenuHostDirective.ɵfac = function FilterMenuHostDirective_Factory(t) { return new (t || FilterMenuHostDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver)); };
FilterMenuHostDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilterMenuHostDirective, selectors: [["", "kendoFilterMenuHost", ""]], inputs: { filterService: "filterService", menuTabbingService: "menuTabbingService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", FilterService)
], FilterMenuHostDirective.prototype, "filterService", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], FilterMenuHostDirective.prototype, "menuTabbingService", void 0);
FilterMenuHostDirective = __decorate([ __metadata("design:paramtypes", [ViewContainerRef,
        ComponentFactoryResolver])
], FilterMenuHostDirective);

/**
 * @hidden
 */
let DateFilterMenuInputComponent = class DateFilterMenuInputComponent {
    constructor(popupService, localizationService) {
        this.popupService = popupService;
        this.localizationService = localizationService;
        this.operators = [];
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    open(picker) {
        this.subscription = this.popupService.onClose
            .pipe(filter(() => picker.isActive))
            .subscribe(e => e.preventDefault());
    }
    messageFor(key) {
        return this.localizationService.get(key);
    }
    get columnLabel() {
        const localizationMsg = this.localizationService.get('filterInputLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
};
DateFilterMenuInputComponent.ɵfac = function DateFilterMenuInputComponent_Factory(t) { return new (t || DateFilterMenuInputComponent)(ɵngcc0.ɵɵdirectiveInject(SinglePopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
DateFilterMenuInputComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateFilterMenuInputComponent, selectors: [["kendo-grid-date-filter-menu-input"]], inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", menuTabbingService: "menuTabbingService", format: "format", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder", min: "min", max: "max", activeView: "activeView", bottomView: "bottomView", topView: "topView", weekNumber: "weekNumber", isFirstDropDown: "isFirstDropDown" }, decls: 4, vars: 22, consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "columnLabel", "filterDelay", "value", "placeholder", "formatPlaceholder", "format", "min", "max", "activeView", "bottomView", "topView", "weekNumber", "open"], ["picker", ""], [3, "toggle", "today"]], template: function DateFilterMenuInputComponent_Template(rf, ctx) { if (rf & 1) {
        const _r1 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 0)(1, "kendo-datepicker", 1, 2);
        ɵngcc0.ɵɵlistener("open", function DateFilterMenuInputComponent_Template_kendo_datepicker_open_1_listener() { ɵngcc0.ɵɵrestoreView(_r1); const _r0 = ɵngcc0.ɵɵreference(2); return ctx.open(_r0); });
        ɵngcc0.ɵɵelement(3, "kendo-datepicker-messages", 3);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", 0)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("placeholder", ctx.placeholder)("formatPlaceholder", ctx.formatPlaceholder)("format", ctx.format)("min", ctx.min)("max", ctx.max)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("weekNumber", ctx.weekNumber);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("toggle", ctx.messageFor("filterDateToggle"))("today", ctx.messageFor("filterDateToday"));
    } }, directives: [FilterMenuInputWrapperComponent, ɵngcc9.DatePickerComponent, FilterInputDirective, ɵngcc9.DatePickerCustomMessagesComponent], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], DateFilterMenuInputComponent.prototype, "operators", void 0);
__decorate([
    Input(),
    __metadata("design:type", ColumnComponent)
], DateFilterMenuInputComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateFilterMenuInputComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterMenuInputComponent.prototype, "operator", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateFilterMenuInputComponent.prototype, "currentFilter", void 0);
__decorate([
    Input(),
    __metadata("design:type", FilterService)
], DateFilterMenuInputComponent.prototype, "filterService", void 0);
__decorate([
    Input(),
    __metadata("design:type", MenuTabbingService)
], DateFilterMenuInputComponent.prototype, "menuTabbingService", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterMenuInputComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateFilterMenuInputComponent.prototype, "formatPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterMenuInputComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DateFilterMenuInputComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DateFilterMenuInputComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterMenuInputComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterMenuInputComponent.prototype, "bottomView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateFilterMenuInputComponent.prototype, "topView", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateFilterMenuInputComponent.prototype, "weekNumber", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateFilterMenuInputComponent.prototype, "isFirstDropDown", void 0);
DateFilterMenuInputComponent = __decorate([ __metadata("design:paramtypes", [SinglePopupService,
        LocalizationService])
], DateFilterMenuInputComponent);

/**
 * @hidden
 */
let FilterMenuDropDownListDirective = class FilterMenuDropDownListDirective {
    constructor(host) {
        this.host = host;
        this.keydownHandler = (e) => {
            if (e.keyCode === Keys.Escape && this.host.isOpen) {
                e.stopPropagation();
                this.host.toggle(false);
            }
        };
    }
    ngAfterViewInit() {
        const wrapperElement = this.host.wrapper.nativeElement;
        wrapperElement.setAttribute('aria-label', this.filterMenuDropDownLabel);
        wrapperElement.addEventListener('keydown', this.keydownHandler, true);
    }
    ngOnDestroy() {
        this.host.wrapper.nativeElement.removeEventListener('keydown', this.keydownHandler);
    }
};
FilterMenuDropDownListDirective.ɵfac = function FilterMenuDropDownListDirective_Factory(t) { return new (t || FilterMenuDropDownListDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc8.DropDownListComponent)); };
FilterMenuDropDownListDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilterMenuDropDownListDirective, selectors: [["", "kendoFilterMenuDropDown", ""]], inputs: { filterMenuDropDownLabel: "filterMenuDropDownLabel" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], FilterMenuDropDownListDirective.prototype, "filterMenuDropDownLabel", void 0);
FilterMenuDropDownListDirective = __decorate([ __metadata("design:paramtypes", [DropDownListComponent])
], FilterMenuDropDownListDirective);

const INTERNAL_COMPONENTS$2 = [
    FilterMenuComponent,
    FilterMenuContainerComponent,
    FilterMenuInputWrapperComponent,
    StringFilterMenuInputComponent,
    StringFilterMenuComponent,
    FilterMenuTemplateDirective,
    NumericFilterMenuComponent,
    NumericFilterMenuInputComponent,
    DateFilterMenuInputComponent,
    DateFilterMenuComponent,
    FilterMenuHostDirective,
    BooleanFilterMenuComponent,
    FilterMenuDropDownListDirective,
    BooleanFilterRadioButtonDirective
];
const ENTRY_COMPONENTS$1 = [
    StringFilterMenuComponent,
    NumericFilterMenuComponent,
    DateFilterMenuComponent,
    BooleanFilterMenuComponent
];
/**
 * @hidden
 */
let FilterMenuModule = class FilterMenuModule {
    static exports() {
        return [
            StringFilterMenuComponent,
            FilterMenuTemplateDirective,
            NumericFilterMenuComponent,
            DateFilterMenuComponent,
            BooleanFilterMenuComponent,
            FilterMenuDropDownListDirective,
            BooleanFilterRadioButtonDirective,
            SharedFilterModule.exports()
        ];
    }
};
FilterMenuModule.ɵfac = function FilterMenuModule_Factory(t) { return new (t || FilterMenuModule)(); };
FilterMenuModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: FilterMenuModule });
FilterMenuModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[SharedFilterModule], SharedFilterModule] });

/**
 * @hidden
 */
let ColumnListComponent = class ColumnListComponent {
    constructor(element, ngZone, renderer) {
        this.element = element;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.reset = new EventEmitter();
        this.apply = new EventEmitter();
        this.columnChange = new EventEmitter();
        this.autoSync = true;
        this.allowHideAll = false;
        this.actionsClass = 'k-action-buttons';
        this.unlockedCount = 0;
    }
    get className() {
        return true;
    }
    set columns(value) {
        this._columns = value.filter(column => column.includeInChooser !== false);
        this.allColumns = value;
        this.updateColumnState();
    }
    get columns() {
        return this._columns;
    }
    isDisabled(column) {
        return !(this.allowHideAll || this.hasFiltered || column.hidden || this.columns.find(current => current !== column && !current.hidden)) ||
            (this.hasVisibleLocked && !this.hasUnlockedFiltered && this.unlockedCount === 1 && !column.locked && !column.hidden);
    }
    ngOnInit() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.domSubscriptions = this.renderer.listen(this.element.nativeElement, 'click', (e) => {
                if (hasClasses(e.target, 'k-checkbox')) {
                    if (this.autoSync) {
                        const index = parseInt(e.target.getAttribute('data-index'), 10);
                        const column = this.columns[index];
                        const hidden = !e.target.checked;
                        if (Boolean(column.hidden) !== hidden) {
                            this.ngZone.run(() => {
                                column.hidden = hidden;
                                this.columnChange.emit([column]);
                            });
                        }
                    }
                    else {
                        this.updateDisabled();
                    }
                }
            });
        });
    }
    ngOnChanges(changes) {
        if (!this.service) {
            return;
        }
        if (changes.isLast && this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
        }
        if (changes.isExpanded && this.isExpanded && this.isLast && this.applyButton) {
            this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
        }
    }
    ngOnDestroy() {
        if (this.domSubscriptions) {
            this.domSubscriptions();
        }
    }
    cancelChanges() {
        this.forEachCheckBox((element, index) => {
            element.checked = !this.columns[index].hidden;
        });
        this.updateDisabled();
        this.reset.emit();
    }
    applyChanges() {
        const changed = [];
        this.forEachCheckBox((element, index) => {
            const column = this.columns[index];
            const hidden = !element.checked;
            if (Boolean(column.hidden) !== hidden) {
                column.hidden = hidden;
                changed.push(column);
            }
        });
        this.updateDisabled();
        this.apply.emit(changed);
    }
    onTab(e) {
        if (this.isLast) {
            e.preventDefault();
            if (this.service) {
                this.service.menuTabbingService.firstFocusable.focus();
            }
        }
    }
    forEachCheckBox(callback) {
        const checkboxes = this.element.nativeElement.getElementsByClassName('k-checkbox');
        const length = checkboxes.length;
        for (let idx = 0; idx < length; idx++) {
            callback(checkboxes[idx], idx);
        }
    }
    updateDisabled() {
        if (this.allowHideAll && !this.hasLocked) {
            return;
        }
        const checkedItems = [];
        this.forEachCheckBox((checkbox, index) => {
            if (checkbox.checked) {
                checkedItems.push({ checkbox, index });
            }
            checkbox.disabled = false;
        });
        if (!this.allowHideAll && checkedItems.length === 1 && !this.hasFiltered) {
            checkedItems[0].checkbox.disabled = true;
        }
        else if (this.hasLocked && !this.hasUnlockedFiltered) {
            const columns = this.columns;
            const checkedUnlocked = checkedItems.filter(item => !columns[item.index].locked);
            if (checkedUnlocked.length === 1) {
                checkedUnlocked[0].checkbox.disabled = true;
            }
        }
    }
    updateColumnState() {
        this.hasLocked = this.allColumns.filter(column => column.locked && (!column.hidden || column.includeInChooser !== false)).length > 0;
        this.hasVisibleLocked = this.allColumns.filter(column => column.locked && !column.hidden).length > 0;
        this.unlockedCount = this.columns.filter(column => !column.locked && !column.hidden).length;
        const filteredColumns = this.allColumns.filter(column => column.includeInChooser === false && !column.hidden);
        if (filteredColumns.length) {
            this.hasFiltered = filteredColumns.length > 0;
            this.hasUnlockedFiltered = filteredColumns.filter(column => !column.locked).length > 0;
        }
        else {
            this.hasFiltered = false;
            this.hasUnlockedFiltered = false;
        }
    }
};
ColumnListComponent.ɵfac = function ColumnListComponent_Factory(t) { return new (t || ColumnListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ColumnListComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnListComponent, selectors: [["kendo-grid-columnlist"]], viewQuery: function ColumnListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c186, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.applyButton = _t.first);
    } }, hostVars: 2, hostBindings: function ColumnListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-column-list-wrapper", ctx.className);
    } }, inputs: { autoSync: "autoSync", allowHideAll: "allowHideAll", actionsClass: "actionsClass", columns: "columns", applyText: "applyText", resetText: "resetText", isLast: "isLast", isExpanded: "isExpanded", service: "service" }, outputs: { reset: "reset", apply: "apply", columnChange: "columnChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 2, consts: [[1, "k-column-list"], ["class", "k-column-list-item", 4, "ngFor", "ngForOf"], [3, "ngClass", 4, "ngIf"], [1, "k-column-list-item"], ["type", "checkbox", 1, "k-checkbox", "k-checkbox-md", "k-rounded-md", 3, "checked", "disabled"], [1, "k-checkbox-label"], [3, "ngClass"], ["type", "button", 1, "k-button", "k-button-solid-base", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "click"], ["type", "button", 1, "k-button", "k-button-solid-primary", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "keydown.tab", "click"], ["applyButton", ""]], template: function ColumnListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, ColumnListComponent_label_1_Template, 4, 4, "label", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, ColumnListComponent_div_2_Template, 6, 3, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.columns);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.autoSync);
    } }, directives: [ɵngcc5.NgForOf, ɵngcc5.NgIf, ɵngcc5.NgClass], encapsulation: 2 });
__decorate([
    HostBinding("class.k-column-list-wrapper"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColumnListComponent.prototype, "className", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnListComponent.prototype, "reset", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnListComponent.prototype, "apply", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnListComponent.prototype, "columnChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], ColumnListComponent.prototype, "columns", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnListComponent.prototype, "autoSync", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnListComponent.prototype, "allowHideAll", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnListComponent.prototype, "applyText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnListComponent.prototype, "resetText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnListComponent.prototype, "actionsClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnListComponent.prototype, "isLast", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnListComponent.prototype, "isExpanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", ColumnMenuService)
], ColumnListComponent.prototype, "service", void 0);
__decorate([
    ViewChild('applyButton', { static: false }),
    __metadata("design:type", ElementRef)
], ColumnListComponent.prototype, "applyButton", void 0);
ColumnListComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        NgZone,
        Renderer2])
], ColumnListComponent);

/**
 * Represents the component for selecting columns in the Grid. To enable the user to show or hide columns,
 * add the component inside a [ToolbarTemplate]({% slug api_grid_toolbartemplatedirective %}) directive.
 *
 * @example
 * ```ts-preview
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [data]="data">
 *          <ng-template kendoGridToolbarTemplate>
 *             <kendo-grid-column-chooser></kendo-grid-column-chooser>
 *          </ng-template>
 *          <kendo-grid-column field="Field1"></kendo-grid-column>
 *          <kendo-grid-column field="Field2" [hidden]="true"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
 * }
 * ```
 */
let ColumnChooserComponent = class ColumnChooserComponent {
    constructor(localization, columnInfoService, popupService, ngZone, renderer, changeDetector) {
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.popupService = popupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        /**
         * Specifies if the changes in the visibility of the column will be immediately applied.
         */
        this.autoSync = false;
        /**
         * Specifies if all columns can be hidden.
         */
        this.allowHideAll = true;
    }
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    ngOnDestroy() {
        this.close();
    }
    /**
     * @hidden
     */
    toggle(anchor, template) {
        if (!this.popupRef) {
            const direction = this.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchor: anchor,
                content: template,
                positionMode: 'absolute',
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction }
            });
            this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.localization.rtl ? 'rtl' : 'ltr');
            this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen("document", "click", ({ target }) => {
                if (!closest(target, node => node === this.popupRef.popupElement || node === anchor)) {
                    this.close();
                }
            }));
        }
        else {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onApply(changed) {
        this.close();
        if (changed.length) {
            this.changeDetector.markForCheck();
            this.columnInfoService.changeVisibility(changed);
        }
    }
    /**
     * @hidden
     */
    onChange(changed) {
        this.changeDetector.markForCheck();
        this.columnInfoService.changeVisibility(changed);
    }
    close() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        this.detachClose();
    }
    detachClose() {
        if (this.closeClick) {
            this.closeClick();
            this.closeClick = null;
        }
    }
};
ColumnChooserComponent.ɵfac = function ColumnChooserComponent_Factory(t) { return new (t || ColumnChooserComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ColumnChooserComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnChooserComponent, selectors: [["kendo-grid-column-chooser"]], inputs: { autoSync: "autoSync", allowHideAll: "allowHideAll" }, decls: 5, vars: 1, consts: [["type", "button", 1, "k-button", "k-button-flat-base", "k-button-flat", "k-icon-button", "k-button-md", "k-rounded-md", "k-button-rectangle", "k-icon-button", 3, "click"], ["anchor", ""], [1, "k-button-icon", "k-icon", "k-i-columns"], ["template", ""], [1, "k-column-chooser-title"], [3, "columns", "applyText", "resetText", "autoSync", "allowHideAll", "apply", "columnChange"]], template: function ColumnChooserComponent_Template(rf, ctx) { if (rf & 1) {
        const _r6 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵlistener("click", function ColumnChooserComponent_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const _r0 = ɵngcc0.ɵɵreference(1); const _r1 = ɵngcc0.ɵɵreference(4); return ctx.toggle(_r0, _r1); });
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ColumnChooserComponent_ng_template_3_Template, 3, 6, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("title", ctx.localization.get("columns"));
    } }, directives: [ColumnListComponent], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnChooserComponent.prototype, "autoSync", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnChooserComponent.prototype, "allowHideAll", void 0);
ColumnChooserComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ColumnInfoService,
        PopupService,
        NgZone,
        Renderer2,
        ChangeDetectorRef])
], ColumnChooserComponent);

/**
 * @hidden
 */
class ColumnMenuItemBase {
    constructor() {
        this.hostClass = true;
    }
    ngOnInit() {
        if (isDevMode() && !this.service) {
            throw new Error('The service input of the predefined column menu components is mandatory.');
        }
    }
    /**
     * @hidden
     */
    close() {
        this.service.close();
    }
}
ColumnMenuItemBase.ɵfac = function ColumnMenuItemBase_Factory(t) { return new (t || ColumnMenuItemBase)(); };
ColumnMenuItemBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ColumnMenuItemBase, hostVars: 2, hostBindings: function ColumnMenuItemBase_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-columnmenu-item-wrapper", ctx.hostClass);
    } }, inputs: { service: "service" } });
__decorate([
    Input(),
    __metadata("design:type", ColumnMenuService)
], ColumnMenuItemBase.prototype, "service", void 0);
__decorate([
    HostBinding('class.k-columnmenu-item-wrapper'),
    __metadata("design:type", Boolean)
], ColumnMenuItemBase.prototype, "hostClass", void 0);

/* tslint:disable:max-line-length */
/**
 * Represents the component for selecting columns in the Grid that can be placed
 * inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 *
 * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-grid-columnmenu-chooser` component.
 *
 * @example
 * {% meta height:300 %}
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [data]="data" [columnMenu]="true">
 *          <ng-template kendoGridColumnMenuTemplate let-service="service">
 *              <kendo-grid-columnmenu-chooser [service]="service">
 *              </kendo-grid-columnmenu-chooser>
 *          </ng-template>
 *          <kendo-grid-column field="Field1"></kendo-grid-column>
 *          <kendo-grid-column field="Field2" [hidden]="true"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
 * }
 *
 * ```
 * {% endmeta %}
 */
let ColumnMenuChooserComponent = class ColumnMenuChooserComponent extends ColumnMenuItemBase {
    constructor(localization, columnInfoService, changeDetector, hostElement) {
        super();
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * Fires when the content is expanded.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the content is collapsed.
         */
        this.collapse = new EventEmitter();
        /**
         * Specifies if the content is expanded.
         */
        this.expanded = false;
        /**
         * @hidden
         */
        this.isLast = false;
        /**
         * @hidden
         */
        this.actionsClass = 'k-columnmenu-actions';
    }
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    /**
     * @hidden
     */
    onApply(changed) {
        this.close();
        if (changed.length) {
            this.changeDetector.markForCheck();
            this.columnInfoService.changeVisibility(changed);
        }
    }
    /**
     * @hidden
     */
    onCollapse() {
        this.expanded = false;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');
        }
        this.collapse.emit();
    }
    /**
     * @hidden
     */
    onExpand() {
        this.expanded = true;
        this.expand.emit();
    }
};
ColumnMenuChooserComponent.ɵfac = function ColumnMenuChooserComponent_Factory(t) { return new (t || ColumnMenuChooserComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ColumnMenuChooserComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuChooserComponent, selectors: [["kendo-grid-columnmenu-chooser"]], inputs: { expanded: "expanded", isLast: "isLast" }, outputs: { expand: "expand", collapse: "collapse" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [["icon", "columns", 3, "text", "expanded", "collapse", "expand"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "applyText", "resetText", "columns", "autoSync", "allowHideAll", "actionsClass", "isLast", "isExpanded", "service", "apply"]], template: function ColumnMenuChooserComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("collapse", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() { return ctx.onCollapse(); })("expand", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() { return ctx.onExpand(); });
        ɵngcc0.ɵɵtemplate(1, ColumnMenuChooserComponent_ng_template_1_Template, 1, 9, "ng-template", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.localization.get("columns"))("expanded", ctx.expanded);
    } }, directives: function () { return [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnListComponent]; }, encapsulation: 2 });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnMenuChooserComponent.prototype, "expand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnMenuChooserComponent.prototype, "collapse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuChooserComponent.prototype, "expanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuChooserComponent.prototype, "isLast", void 0);
ColumnMenuChooserComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ColumnInfoService,
        ChangeDetectorRef,
        ElementRef])
], ColumnMenuChooserComponent);

/* tslint:disable:max-line-length */
/**
 * Represents the component for editing column filters in the Grid that can be placed
 * inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 *
 * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-grid-columnmenu-filter` component.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [kendoGridBinding]="data" [columnMenu]="true">
 *          <ng-template kendoGridColumnMenuTemplate let-service="service">
 *              <kendo-grid-columnmenu-filter [service]="service">
 *              </kendo-grid-columnmenu-filter>
 *          </ng-template>
 *          <kendo-grid-column field="Field1"></kendo-grid-column>
 *          <kendo-grid-column field="Field2"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
 * }
 *
 * ```
 */
let ColumnMenuFilterComponent = class ColumnMenuFilterComponent extends ColumnMenuItemBase {
    constructor(localization, hostElement) {
        super();
        this.localization = localization;
        this.hostElement = hostElement;
        /**
         * Fires when the content is expanded.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the content is collapsed.
         */
        this.collapse = new EventEmitter();
        /**
         * Specifies if the content is expanded.
         */
        this.expanded = false;
        /**
         * @hidden
         */
        this.isLast = false;
        /**
         * @hidden
         */
        this.actionsClass = 'k-columnmenu-actions';
    }
    /**
     * @hidden
     */
    onCollapse() {
        this.expanded = false;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');
        }
        this.collapse.emit();
    }
    /**
     * @hidden
     */
    onExpand() {
        this.expanded = true;
        this.expand.emit();
    }
};
ColumnMenuFilterComponent.ɵfac = function ColumnMenuFilterComponent_Factory(t) { return new (t || ColumnMenuFilterComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ColumnMenuFilterComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuFilterComponent, selectors: [["kendo-grid-columnmenu-filter"]], inputs: { expanded: "expanded", isLast: "isLast" }, outputs: { expand: "expand", collapse: "collapse" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [["icon", "filter", 3, "text", "expanded", "collapse", "expand"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "column", "menuTabbingService", "filter", "actionsClass", "isLast", "isExpanded", "keydown.shift.tab", "close"]], template: function ColumnMenuFilterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("collapse", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() { return ctx.onCollapse(); })("expand", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() { return ctx.onExpand(); });
        ɵngcc0.ɵɵtemplate(1, ColumnMenuFilterComponent_ng_template_1_Template, 1, 6, "ng-template", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.localization.get("filter"))("expanded", ctx.expanded);
    } }, directives: function () { return [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, FilterMenuContainerComponent]; }, encapsulation: 2 });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnMenuFilterComponent.prototype, "expand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnMenuFilterComponent.prototype, "collapse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuFilterComponent.prototype, "expanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuFilterComponent.prototype, "isLast", void 0);
ColumnMenuFilterComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ElementRef])
], ColumnMenuFilterComponent);

/* tslint:disable:max-line-length */
/**
 * Represents the content template of the
 * [kendo-grid-columnmenu-item]({% slug api_grid_columnmenuitemcomponent %}) component.
 * Provides an option for specifying the content of a column item.
 * To define the content template, nest an `<ng-template>` tag with the
 * `kendoGridColumnMenuItemContentTemplate` directive inside a `<kendo-grid-columnmenu-item>`.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [data]="data" [columnMenu]="true">
 *          <ng-template kendoGridColumnMenuTemplate>
 *              <kendo-grid-columnmenu-item text="Item Text" [expanded]="true">
 *                  <ng-template kendoGridColumnMenuItemContentTemplate>
 *                      Item Content
 *                  </ng-template>
 *              </kendo-grid-columnmenu-item>
 *          </ng-template>
 *          <kendo-grid-column field="Field1"></kendo-grid-column>
 *          <kendo-grid-column field="Field2"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
 * }
 *
 * ```
 */
let ColumnMenuItemContentTemplateDirective = class ColumnMenuItemContentTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
ColumnMenuItemContentTemplateDirective.ɵfac = function ColumnMenuItemContentTemplateDirective_Factory(t) { return new (t || ColumnMenuItemContentTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ColumnMenuItemContentTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ColumnMenuItemContentTemplateDirective, selectors: [["", "kendoGridColumnMenuItemContentTemplate", ""]] });
ColumnMenuItemContentTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], ColumnMenuItemContentTemplateDirective);

/**
 * Represents an item that can be placed inside a
 * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [data]="data" [columnMenu]="true" [resizable]="true" #grid>
 *          <ng-template kendoGridColumnMenuTemplate let-service="service" let-column="column">
 *              <kendo-grid-columnmenu-item icon="arrows-resizing" text="Fit column"
 *                  (itemClick)="grid.autoFitColumn(column); service.close()">
 *              </kendo-grid-columnmenu-item>
 *          </ng-template>
 *          <kendo-grid-column field="Field1"></kendo-grid-column>
 *          <kendo-grid-column field="Field2"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
 * }
 *
 * ```
 */
let ColumnMenuItemComponent = class ColumnMenuItemComponent {
    /**
     * Represents an item that can be placed inside a
     * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
     *
     * @example
     * ```ts-preview
     *
     * _@Component({
     *     selector: 'my-app',
     *     template: `
     *       <kendo-grid [data]="data" [columnMenu]="true" [resizable]="true" #grid>
     *          <ng-template kendoGridColumnMenuTemplate let-service="service" let-column="column">
     *              <kendo-grid-columnmenu-item icon="arrows-resizing" text="Fit column"
     *                  (itemClick)="grid.autoFitColumn(column); service.close()">
     *              </kendo-grid-columnmenu-item>
     *          </ng-template>
     *          <kendo-grid-column field="Field1"></kendo-grid-column>
     *          <kendo-grid-column field="Field2"></kendo-grid-column>
     *       </kendo-grid>
     *     `
     * })
     *
     * class AppComponent {
     *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
     * }
     *
     * ```
     */
    constructor() {
        /**
         * Fires when the item is clicked.
         */
        this.itemClick = new EventEmitter();
        /**
         * Fires when the content is expanded.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the content is collapsed.
         */
        this.collapse = new EventEmitter();
        this.contentState = 'collapsed';
    }
    get iconClass() {
        return `k-i-${this.icon}`;
    }
    ngOnChanges(changes) {
        if (changes.expanded) {
            this.updateContentState();
        }
    }
    /**
     * @hidden
     */
    onClick(e) {
        this.itemClick.emit(e);
        if (this.contentTemplate) {
            this.expanded = !this.expanded;
            this.updateContentState();
            if (this.expanded) {
                this.expand.emit();
            }
            else {
                this.collapse.emit();
            }
        }
    }
    updateContentState() {
        this.contentState = this.expanded ? 'expanded' : 'collapsed';
    }
};
ColumnMenuItemComponent.ɵfac = function ColumnMenuItemComponent_Factory(t) { return new (t || ColumnMenuItemComponent)(); };
ColumnMenuItemComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuItemComponent, selectors: [["kendo-grid-columnmenu-item"]], contentQueries: function ColumnMenuItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnMenuItemContentTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    } }, inputs: { expanded: "expanded", icon: "icon", text: "text", selected: "selected", disabled: "disabled" }, outputs: { itemClick: "itemClick", expand: "expand", collapse: "collapse" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 8, consts: [["role", "button", 1, "k-columnmenu-item", 3, "click", "keydown.enter"], ["class", "k-icon", 3, "ngClass", 4, "ngIf"], ["style", "overflow:hidden;", "class", "k-columnmenu-item-content", 4, "ngIf"], [1, "k-icon", 3, "ngClass"], [1, "k-columnmenu-item-content", 2, "overflow", "hidden"], [3, "ngTemplateOutlet"]], template: function ColumnMenuItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function ColumnMenuItemComponent_Template_div_click_0_listener($event) { return ctx.onClick($event); })("keydown.enter", function ColumnMenuItemComponent_Template_div_keydown_enter_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵtemplate(1, ColumnMenuItemComponent_span_1_Template, 1, 1, "span", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ColumnMenuItemComponent_div_3_Template, 3, 2, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-state-selected", ctx.selected)("k-state-disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.expanded);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.text, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contentTemplate);
    } }, directives: [ɵngcc5.NgIf, ɵngcc5.NgClass, ɵngcc5.NgTemplateOutlet], encapsulation: 2, data: { animation: [
            trigger('state', [
                state('collapsed', style({ display: 'none' })),
                state('expanded', style({ display: 'block' })),
                transition('collapsed => expanded', [
                    style({
                        height: '0px',
                        display: 'block'
                    }),
                    animate('100ms ease-in', style({
                        height: '*'
                    }))
                ]),
                transition('expanded => collapsed', [
                    style({
                        height: '*'
                    }),
                    animate('100ms ease-in', style({
                        height: '0px'
                    }))
                ])
            ])
        ] } });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnMenuItemComponent.prototype, "itemClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnMenuItemComponent.prototype, "expand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnMenuItemComponent.prototype, "collapse", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnMenuItemComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnMenuItemComponent.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuItemComponent.prototype, "selected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuItemComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuItemComponent.prototype, "expanded", void 0);
__decorate([
    ContentChild(ColumnMenuItemContentTemplateDirective, { static: false }),
    __metadata("design:type", ColumnMenuItemContentTemplateDirective)
], ColumnMenuItemComponent.prototype, "contentTemplate", void 0);

/* tslint:disable:max-line-length */
/**
 * Represents a column-menu item for sorting Grid columns that can be placed inside a
 * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * Allows the user to sort the column.
 *
 * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-grid-columnmenu-sort` component.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [kendoGridBinding]="data" [sortable]="true" [columnMenu]="true">
 *          <ng-template kendoGridColumnMenuTemplate let-service="service">
 *              <kendo-grid-columnmenu-sort [service]="service">
 *              </kendo-grid-columnmenu-sort>
 *          </ng-template>
 *          <kendo-grid-column field="Field1" [width]="100"></kendo-grid-column>
 *          <kendo-grid-column field="Field2" [width]="100"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }, { Field1: 'Foo1', Field2: 'Bar1' }];
 * }
 *
 * ```
 */
let ColumnMenuSortComponent = class ColumnMenuSortComponent extends ColumnMenuItemBase {
    constructor(localization, sortService, renderer) {
        super();
        this.localization = localization;
        this.sortService = sortService;
        this.renderer = renderer;
    }
    get sortedAsc() {
        const descriptor = this.descriptor;
        return descriptor && (!descriptor.dir || descriptor.dir === 'asc');
    }
    get sortedDesc() {
        const descriptor = this.descriptor;
        return descriptor && descriptor.dir === 'desc';
    }
    /**
     * @hidden
     */
    toggleSort(dir) {
        const field = this.service.column.field;
        const { mode, allowUnsort } = normalize$1(this.service.sortable);
        const descriptor = this.descriptor;
        const sort = mode === 'multiple' ? this.service.sort.filter(s => s.field !== field) : [];
        if (descriptor && descriptor.dir === dir) {
            if (!allowUnsort) {
                return;
            }
        }
        else {
            sort.push({ field, dir });
        }
        this.sortService.sort(sort);
        this.close();
    }
    get descriptor() {
        return [].concat(this.service.sort || []).find(s => s.field === this.service.column.field);
    }
};
ColumnMenuSortComponent.ɵfac = function ColumnMenuSortComponent_Factory(t) { return new (t || ColumnMenuSortComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(SortService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ColumnMenuSortComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuSortComponent, selectors: [["kendo-grid-columnmenu-sort"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 4, consts: [["icon", "sort-asc-sm", 3, "text", "selected", "itemClick"], ["icon", "sort-desc-sm", 3, "text", "selected", "itemClick"]], template: function ColumnMenuSortComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() { return ctx.toggleSort("asc"); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(1, "kendo-grid-columnmenu-item", 1);
        ɵngcc0.ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_1_listener() { return ctx.toggleSort("desc"); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.localization.get("sortAscending"))("selected", ctx.sortedAsc);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("text", ctx.localization.get("sortDescending"))("selected", ctx.sortedDesc);
    } }, directives: [ColumnMenuItemComponent], encapsulation: 2 });
ColumnMenuSortComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        SortService,
        Renderer2])
], ColumnMenuSortComponent);

/* tslint:disable:max-line-length */
/**
 * Represents a column-menu item that can be placed inside a
 * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * Allows the user to lock or unlock the columns.
 *
 * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-grid-columnmenu-lock` component.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [data]="data" [columnMenu]="true">
 *          <ng-template kendoGridColumnMenuTemplate let-service="service">
 *              <kendo-grid-columnmenu-lock [service]="service">
 *              </kendo-grid-columnmenu-lock>
 *          </ng-template>
 *          <kendo-grid-column field="Field1" [width]="100"></kendo-grid-column>
 *          <kendo-grid-column field="Field2" [width]="100"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
 * }
 *
 * ```
 */
let ColumnMenuLockComponent = class ColumnMenuLockComponent extends ColumnMenuItemBase {
    constructor(localization, columnInfoService, changeDetector) {
        super();
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
    }
    get text() {
        return this.localization.get(this.locked ? 'unlock' : 'lock');
    }
    get icon() {
        return this.locked ? 'unlock' : 'lock';
    }
    get disabled() {
        return !this.locked && this.columnInfoService.unlockedRootCount < 2;
    }
    /**
     * @hidden
     */
    toggleColumn() {
        this.toggleHierarchy(!this.locked);
        this.close();
        this.changeDetector.markForCheck();
    }
    toggleHierarchy(locked) {
        let root = this.service.column;
        while (root.parent) {
            root = root.parent;
        }
        const columns = [root];
        const allChanged = [];
        while (columns.length) {
            const column = columns.shift();
            column.locked = locked;
            allChanged.push(column);
            if (column.hasChildren) {
                columns.push(...column.childrenArray);
            }
        }
        this.columnInfoService.changeLocked(allChanged);
    }
    get locked() {
        return this.service.column.locked;
    }
};
ColumnMenuLockComponent.ɵfac = function ColumnMenuLockComponent_Factory(t) { return new (t || ColumnMenuLockComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ColumnMenuLockComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuLockComponent, selectors: [["kendo-grid-columnmenu-lock"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 3, consts: [[3, "text", "icon", "disabled", "itemClick"]], template: function ColumnMenuLockComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("itemClick", function ColumnMenuLockComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() { return ctx.toggleColumn(); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.text)("icon", ctx.icon)("disabled", ctx.disabled);
    } }, directives: [ColumnMenuItemComponent], encapsulation: 2 });
ColumnMenuLockComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ColumnInfoService,
        ChangeDetectorRef])
], ColumnMenuLockComponent);

/* tslint:disable:max-line-length */
/**
 * Represents the component for editing column filters in the Grid that can be placed
 * inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 *
 * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-grid-columnmenu-filter` component.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [kendoGridBinding]="data" [columnMenu]="true">
 *          <ng-template kendoGridColumnMenuTemplate let-service="service">
 *              <kendo-grid-columnmenu-filter [service]="service">
 *              </kendo-grid-columnmenu-filter>
 *          </ng-template>
 *          <kendo-grid-column field="Field1"></kendo-grid-column>
 *          <kendo-grid-column field="Field2"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
 * }
 *
 * ```
 */
let ColumnMenuPositionComponent = class ColumnMenuPositionComponent extends ColumnMenuItemBase {
    constructor(localization, hostElement) {
        super();
        this.localization = localization;
        this.hostElement = hostElement;
        /**
         * Fires when the content is expanded.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the content is collapsed.
         */
        this.collapse = new EventEmitter();
        /**
         * Specifies if the content is expanded.
         */
        this.expanded = false;
        /**
         * @hidden
         */
        this.actionsClass = 'k-columnmenu-actions';
        this._isLast = false;
    }
    /**
     * @hidden
     */
    set isLast(value) {
        this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
        this._isLast = value;
    }
    /**
     * @hidden
     */
    get isLast() {
        return this._isLast;
    }
    /**
     * @hidden
     */
    onTab(e, isLastItem) {
        if (this.isLast && isLastItem) {
            e.preventDefault();
            e.stopImmediatePropagation();
            if (this.service) {
                this.service.menuTabbingService.firstFocusable.focus();
            }
        }
    }
    /**
     * @hidden
     */
    onCollapse() {
        this.expanded = false;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
        }
        this.collapse.emit();
    }
    /**
     * @hidden
     */
    onExpand() {
        this.expanded = true;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
        }
        this.expand.emit();
    }
    getLastFocusableItem() {
        const menuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');
        const lastFocusableIndex = this.expanded ? menuItems.length - 1 : 0;
        return menuItems[lastFocusableIndex];
    }
};
ColumnMenuPositionComponent.ɵfac = function ColumnMenuPositionComponent_Factory(t) { return new (t || ColumnMenuPositionComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ColumnMenuPositionComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuPositionComponent, selectors: [["kendo-grid-columnmenu-position"]], inputs: { expanded: "expanded", isLast: "isLast", showLock: "showLock", showStick: "showStick" }, outputs: { expand: "expand", collapse: "collapse" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [["icon", "set-column-position", 3, "text", "expanded", "keydown.tab", "collapse", "expand"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "service", "keydown.tab", 4, "ngIf"], [3, "service", "keydown.tab"]], template: function ColumnMenuPositionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_keydown_tab_0_listener($event) { return ctx.onTab($event, !ctx.expanded); })("collapse", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() { return ctx.onCollapse(); })("expand", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() { return ctx.onExpand(); });
        ɵngcc0.ɵɵtemplate(1, ColumnMenuPositionComponent_ng_template_1_Template, 2, 2, "ng-template", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.localization.get("setColumnPosition"))("expanded", ctx.expanded);
    } }, directives: function () { return [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ɵngcc5.NgIf, ColumnMenuLockComponent, ColumnMenuStickComponent]; }, encapsulation: 2 });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnMenuPositionComponent.prototype, "expand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColumnMenuPositionComponent.prototype, "collapse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuPositionComponent.prototype, "expanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuPositionComponent.prototype, "showLock", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnMenuPositionComponent.prototype, "showStick", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], ColumnMenuPositionComponent.prototype, "isLast", null);
ColumnMenuPositionComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ElementRef])
], ColumnMenuPositionComponent);

/**
 * @hidden
 */
let ColumnMenuItemDirective = class ColumnMenuItemDirective {
    constructor(hostElement, renderer, ngZone) {
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this._isFirst = false;
        this._isLast = false;
        this.subs = new Subscription();
        this.onTab = (e) => {
            if (e.keyCode !== Keys.Tab) {
                return;
            }
            if (this.isFirst && e.shiftKey && e.target === this.columnMenuItems[0]) {
                e.preventDefault();
                this.menuItemComponent.service.menuTabbingService.lastFocusable.focus();
            }
            if (this.isLast && !e.shiftKey) {
                const lastColumnMenuItem = this.getLastColumnMenuItem();
                const isExpanded = this.menuItemComponent.expanded;
                if (lastColumnMenuItem === e.target && !isExpanded) {
                    e.preventDefault();
                    this.menuItemComponent.service.menuTabbingService.firstFocusable.focus();
                }
            }
        };
    }
    set isFirst(value) {
        if (value) {
            const focusableElement = this.columnMenuItems[0];
            this.menuItemComponent.service.menuTabbingService.firstFocusable = focusableElement;
            this.ngZone.runOutsideAngular(() => {
                const firstItemKeydownSub = this.renderer.listen(focusableElement, 'keydown', this.onTab);
                this.subs.add(firstItemKeydownSub);
            });
        }
        this._isFirst = value;
    }
    get isFirst() {
        return this._isFirst;
    }
    set isLast(value) {
        if (!this.columnMenuItems) {
            return;
        }
        if (value) {
            const lastFocusableElement = this.getLastColumnMenuItem();
            this.menuItemComponent.service.menuTabbingService.lastFocusable = lastFocusableElement;
            this.ngZone.runOutsideAngular(() => {
                const lastItemKeydownSub = this.renderer.listen(lastFocusableElement, 'keydown', this.onTab);
                this.subs.add(lastItemKeydownSub);
            });
            if (this.isExpandableItem()) {
                this.menuItemComponent.isLast = true;
            }
        }
        this._isLast = value;
    }
    get isLast() {
        return this._isLast;
    }
    ngAfterViewInit() {
        this.columnMenuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');
        [].slice.apply(this.columnMenuItems).forEach(el => this.renderer.setAttribute(el, 'tabindex', '0'));
        if (this.menuItemComponent instanceof ColumnMenuFilterComponent) {
            this.menuItemComponent.service.menuTabbingService.isColumnMenu = true;
        }
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    getLastColumnMenuItem() {
        return (this.columnMenuItems.length === 1 ? this.columnMenuItems[0] : this.columnMenuItems[1]);
    }
    isExpandableItem() {
        return this.menuItemComponent instanceof ColumnMenuFilterComponent ||
            this.menuItemComponent instanceof ColumnMenuChooserComponent ||
            this.menuItemComponent instanceof ColumnMenuPositionComponent;
    }
};
ColumnMenuItemDirective.ɵfac = function ColumnMenuItemDirective_Factory(t) { return new (t || ColumnMenuItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ColumnMenuItemDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ColumnMenuItemDirective, selectors: [["", "kendoGridColumnMenuItem", ""]], inputs: { menuItemComponent: ["kendoGridColumnMenuItem", "menuItemComponent"] } });
__decorate([
    Input('kendoGridColumnMenuItem'),
    __metadata("design:type", Object)
], ColumnMenuItemDirective.prototype, "menuItemComponent", void 0);
ColumnMenuItemDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        NgZone])
], ColumnMenuItemDirective);

/**
 * @hidden
 */
let ColumnMenuContainerComponent = class ColumnMenuContainerComponent {
    constructor(service, ngZone) {
        this.service = service;
        this.ngZone = ngZone;
    }
    ngAfterContentInit() {
        if (!this.columnMenuItems.length) {
            return;
        }
        this.columnMenuItems.first.isFirst = true;
        this.columnMenuItems.last.isLast = true;
        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.service.menuTabbingService.firstFocusable.focus());
    }
};
ColumnMenuContainerComponent.ɵfac = function ColumnMenuContainerComponent_Factory(t) { return new (t || ColumnMenuContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnMenuService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ColumnMenuContainerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuContainerComponent, selectors: [["kendo-grid-columnmenu-container"]], contentQueries: function ColumnMenuContainerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnMenuItemDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnMenuItems = _t);
    } }, ngContentSelectors: _c150, decls: 1, vars: 0, template: function ColumnMenuContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    ContentChildren(ColumnMenuItemDirective, { descendants: true }),
    __metadata("design:type", QueryList)
], ColumnMenuContainerComponent.prototype, "columnMenuItems", void 0);
ColumnMenuContainerComponent = __decorate([ __metadata("design:paramtypes", [ColumnMenuService,
        NgZone])
], ColumnMenuContainerComponent);

/* tslint:disable:max-line-length */
/**
 * Represents a column-menu item that can be placed inside a
 * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * Allows the user to stick or unstick the columns.
 *
 * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-grid-columnmenu-stick` component.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *       <kendo-grid [data]="data" [columnMenu]="true">
 *          <ng-template kendoGridColumnMenuTemplate let-service="service">
 *              <kendo-grid-columnmenu-stick [service]="service">
 *              </kendo-grid-columnmenu-stick>
 *          </ng-template>
 *          <kendo-grid-column field="Field1" [width]="100"></kendo-grid-column>
 *          <kendo-grid-column field="Field2" [width]="100"></kendo-grid-column>
 *       </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];
 * }
 *
 * ```
 */
let ColumnMenuStickComponent = class ColumnMenuStickComponent extends ColumnMenuItemBase {
    constructor(localization, columnInfoService, changeDetector) {
        super();
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
    }
    get text() {
        return this.localization.get(this.sticky ? 'unstick' : 'stick');
    }
    get icon() {
        return this.sticky ? 'unstick' : 'stick';
    }
    get disabled() {
        return !this.sticky && this.columnInfoService.unlockedRootCount < 2;
    }
    /**
     * @hidden
     */
    toggleColumn() {
        this.toggleHierarchy(!this.sticky);
        this.close();
        this.changeDetector.markForCheck();
    }
    toggleHierarchy(sticky) {
        let root = this.service.column;
        while (root.parent) {
            root = root.parent;
        }
        const columns = [root];
        const allChanged = [];
        while (columns.length) {
            const column = columns.shift();
            column.sticky = sticky;
            allChanged.push(column);
            if (column.hasChildren) {
                columns.push(...column.childrenArray);
            }
        }
        this.columnInfoService.changeStuck(allChanged);
    }
    get sticky() {
        return this.service.column.sticky;
    }
};
ColumnMenuStickComponent.ɵfac = function ColumnMenuStickComponent_Factory(t) { return new (t || ColumnMenuStickComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ColumnMenuStickComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuStickComponent, selectors: [["kendo-grid-columnmenu-stick"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 3, consts: [[3, "text", "icon", "disabled", "itemClick"]], template: function ColumnMenuStickComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("itemClick", function ColumnMenuStickComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() { return ctx.toggleColumn(); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.text)("icon", ctx.icon)("disabled", ctx.disabled);
    } }, directives: [ColumnMenuItemComponent], encapsulation: 2 });
ColumnMenuStickComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        ColumnInfoService,
        ChangeDetectorRef])
], ColumnMenuStickComponent);

const COMPONENTS$1 = [
    ColumnListComponent,
    ColumnChooserComponent,
    ColumnMenuChooserComponent,
    ColumnMenuFilterComponent,
    ColumnMenuItemComponent,
    ColumnMenuItemContentTemplateDirective,
    ColumnMenuSortComponent,
    ColumnMenuComponent,
    ColumnMenuLockComponent,
    ColumnMenuTemplateDirective,
    ColumnMenuContainerComponent,
    ColumnMenuItemDirective,
    ColumnMenuStickComponent,
    ColumnMenuPositionComponent
];
/**
 * @hidden
 */
let ColumnMenuModule = class ColumnMenuModule {
    static exports() {
        return [
            ColumnChooserComponent,
            ColumnMenuFilterComponent,
            ColumnMenuItemComponent,
            ColumnMenuItemContentTemplateDirective,
            ColumnMenuSortComponent,
            ColumnMenuLockComponent,
            ColumnMenuStickComponent,
            ColumnMenuPositionComponent,
            ColumnMenuChooserComponent,
            ColumnMenuTemplateDirective,
            ColumnMenuContainerComponent,
            ColumnMenuItemDirective,
            ColumnMenuComponent
        ];
    }
};
ColumnMenuModule.ɵfac = function ColumnMenuModule_Factory(t) { return new (t || ColumnMenuModule)(); };
ColumnMenuModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ColumnMenuModule });
ColumnMenuModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, FilterMenuModule]] });

const exportedModules$2 = [
    HeaderComponent,
    HeaderTemplateDirective,
    ColumnHandleDirective,
    SelectAllCheckboxDirective
];
const importedModules$2 = [
    CommonModule,
    GroupModule,
    RowFilterModule,
    FilterMenuModule,
    SharedModule,
    DragAndDropModule,
    ColumnMenuModule
];
/**
 * @hidden
 */
let HeaderModule = class HeaderModule {
    static exports() {
        return [
            HeaderTemplateDirective,
            SelectAllCheckboxDirective
        ];
    }
};
HeaderModule.ɵfac = function HeaderModule_Factory(t) { return new (t || HeaderModule)(); };
HeaderModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: HeaderModule });
HeaderModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[...importedModules$2]] });

var CommandColumnComponent_1;
/**
 * Represents the command columns of the Grid. You have to define the content of the
 * column inside an `<ng-template>` tag. The template context is set to the current
 * data item. For more information and examples on using the passed fields
 * and the command directives, refer to the article on
 * [editing the Grid in Angular Reactive Forms]({% slug editing_reactive_forms_grid %}).
 *
 * The following additional fields are passed:
 * - `columnIndex`&mdash;The current column index.
 * - `rowIndex`&mdash;The current data row index. If inside a new item row, `rowIndex`is `-1`.
 * - `dataItem`&mdash;The current data item.
 * - `column`&mdash;The current column instance.
 * - `isNew`&mdash;The state of the current item.
 *
 * Usually, the template contains CRUD command directives such as:
 * - [EditCommandDirective]({% slug api_grid_editcommanddirective %})
 * - [RemoveCommandDirective]({% slug api_grid_removecommanddirective %})
 * - [CancelCommandDirective]({% slug api_grid_cancelcommanddirective %})
 * - [SaveCommandDirective]({% slug api_grid_savecommanddirective %})
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-grid [data]="gridData">
 *          <kendo-grid-column field="ProductID" title="Product ID" width="120">
 *          </kendo-grid-column>
 *          <kendo-grid-column field="ProductName" title="Product Name">
 *          </kendo-grid-column>
 *          <kendo-grid-column field="UnitPrice" title="Unit Price" width="230">
 *          </kendo-grid-column>
 *          <kendo-grid-command-column title="command" width="220">
 *               <ng-template kendoGridCellTemplate>
 *                   <button kendoGridEditCommand class="k-primary">Edit</button>
 *                   <button kendoGridRemoveCommand>Remove</button>
 *               </ng-template>
 *           </kendo-grid-command-column>
 *        </kendo-grid>
 *    `
 * })
 *
 * class AppComponent {
 *    public gridData: any[];
 *
 *    constructor() {
 *        this.gridData = products;
 *    }
 * }
 *
 * const products = [{
 *    "ProductID": 1,
 *    "ProductName": "Chai",
 *    "UnitPrice": 18.0000,
 *    "Discontinued": true
 *  }, {
 *    "ProductID": 2,
 *    "ProductName": "Chang",
 *    "UnitPrice": 19.0000,
 *    "Discontinued": false
 *  }
 * ];
 *
 * ```
 */
let CommandColumnComponent = CommandColumnComponent_1 = class CommandColumnComponent extends ColumnBase$1 {
    constructor(parent, idService) {
        super(parent, idService);
        this.parent = parent;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
};
CommandColumnComponent.ɵfac = function CommandColumnComponent_Factory(t) { return new (t || CommandColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13), ɵngcc0.ɵɵdirectiveInject(IdService, 8)); };
CommandColumnComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CommandColumnComponent, selectors: [["kendo-grid-command-column"]], contentQueries: function CommandColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => CommandColumnComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CommandColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChild(CellTemplateDirective, { static: false }),
    __metadata("design:type", CellTemplateDirective)
], CommandColumnComponent.prototype, "template", void 0);
CommandColumnComponent = CommandColumnComponent_1 = __decorate([ __param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()), __param(1, Optional()),
    __metadata("design:paramtypes", [ColumnBase$1, IdService])
], CommandColumnComponent);

var CheckboxColumnComponent_1;
/**
 * Represents the checkbox for selecting columns in the Grid. If the column is
 * defined as empty, it renders a default checkbox for row selection.
 * You can also define the content of the column inside an `<ng-template>` tag.
 * The input requires you to include the `SelectionCheckbox` option.
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `columnIndex`&mdash;The current column index.
 * - `rowIndex`&mdash;The current data row index. If inside a new item row, it will be `-1`.
 * - `dataItem`&mdash;The current data item.
 * - `column`&mdash;The current column instance.
 * - `isNew`&mdash;The state of the current item.
 *
 * For more examples, refer to:
 * - [Selecting or deselecting all items on a page]({% slug selection_grid %}#toc-select-all-feature)
 * - [Persisting the selection]({% slug selection_grid %}#toc-in-combination-with-the-select-all-feature)
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-grid [data]="gridData" [selectable]="{enabled: true, checkboxOnly: true}">
 *          <kendo-grid-column field="ProductID" title="Product ID" width="120">
 *          </kendo-grid-column>
 *          <kendo-grid-column field="ProductName" title="Product Name">
 *          </kendo-grid-column>
 *          <kendo-grid-checkbox-column title="Default checkbox">
 *          </kendo-grid-checkbox-column>
 *          <kendo-grid-checkbox-column title="Custom checkbox">
 *            <ng-template kendoGridCellTemplate let-idx="rowIndex">
 *              Select row <input [kendoGridSelectionCheckbox]="idx" />
 *            </ng-template>
 *          </kendo-grid-checkbox-column>
 *        </kendo-grid>
 *    `
 * })
 *
 * class AppComponent {
 *    public gridData: any[];
 *
 *    constructor() {
 *        this.gridData = products;
 *    }
 * }
 *
 * const products = [{
 *    "ProductID": 1,
 *    "ProductName": "Chai",
 *    "UnitPrice": 18.0000,
 *    "Discontinued": true
 *  }, {
 *    "ProductID": 2,
 *    "ProductName": "Chang",
 *    "UnitPrice": 19.0000,
 *    "Discontinued": false
 *  }
 * ];
 *
 * ```
 */
let CheckboxColumnComponent = CheckboxColumnComponent_1 = class CheckboxColumnComponent extends ColumnBase$1 {
    constructor(parent, idService) {
        super(parent, idService);
        this.parent = parent;
        /*
         * @hidden
         */
        this.isCheckboxColumn = true;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
};
CheckboxColumnComponent.ɵfac = function CheckboxColumnComponent_Factory(t) { return new (t || CheckboxColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13), ɵngcc0.ɵɵdirectiveInject(IdService, 8)); };
CheckboxColumnComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CheckboxColumnComponent, selectors: [["kendo-grid-checkbox-column"]], contentQueries: function CheckboxColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, inputs: { showSelectAll: "showSelectAll" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => CheckboxColumnComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CheckboxColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CheckboxColumnComponent.prototype, "showSelectAll", void 0);
__decorate([
    ContentChild(CellTemplateDirective, { static: false }),
    __metadata("design:type", CellTemplateDirective)
], CheckboxColumnComponent.prototype, "template", void 0);
CheckboxColumnComponent = CheckboxColumnComponent_1 = __decorate([ __param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()), __param(1, Optional()),
    __metadata("design:paramtypes", [ColumnBase$1, IdService])
], CheckboxColumnComponent);

/**
 * Represents the row-selection checkbox of the Grid. The directive expects the
 * index of the current row as an input parameter. Inside the
 * [CheckboxColumnComponent]({% slug api_grid_checkboxcolumncomponent %}), apply the
 * directive to an `input` element. When the user clicks the checkbox that is associated
 * with the directive, a [selectionChange]({% slug api_grid_gridcomponent %}#toc-selectionChange)
 * event is triggered.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-grid [data]="gridData" [selectable]="{enabled: true, checkboxOnly: true}">
 *          <kendo-grid-checkbox-column title="Custom checkbox">
 *            <ng-template kendoGridCellTemplate let-idx="rowIndex">
 *              Select row <input [kendoGridSelectionCheckbox]="idx" />
 *            </ng-template>
 *          </kendo-grid-checkbox-column>
 *          <kendo-grid-column field="ProductID" title="Product ID" width="120">
 *          </kendo-grid-column>
 *          <kendo-grid-column field="ProductName" title="Product Name">
 *          </kendo-grid-column>
 *        </kendo-grid>
 *    `
 * })
 *
 * class AppComponent {
 *    public gridData: any[];
 *
 *    constructor() {
 *        this.gridData = products;
 *    }
 * }
 *
 * const products = [{
 *    "ProductID": 1,
 *    "ProductName": "Chai",
 *    "UnitPrice": 18.0000,
 *    "Discontinued": true
 *  }, {
 *    "ProductID": 2,
 *    "ProductName": "Chang",
 *    "UnitPrice": 19.0000,
 *    "Discontinued": false
 *  }
 * ];
 *
 * ```
 */
let SelectionCheckboxDirective = class SelectionCheckboxDirective {
    constructor(selectionService, el, renderer, ngZone) {
        this.selectionService = selectionService;
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.type = "checkbox";
        this.ngZone.runOutsideAngular(() => {
            this.destroyClick = this.renderer.listen(this.el.nativeElement, "click", this.onClick.bind(this));
            this.destroyKeyDown = this.renderer.listen(this.el.nativeElement, "keydown", this.onKeyDown.bind(this));
        });
    }
    ngAfterContentChecked() {
        this.setCheckedState();
    }
    ngOnDestroy() {
        if (this.destroyClick) {
            this.destroyClick();
        }
        if (this.destroyKeyDown) {
            this.destroyKeyDown();
        }
    }
    onClick() {
        if (this.selectionService.options.enabled) {
            this.ngZone.run(() => {
                const ev = this.selectionService.toggleByIndex(this.itemIndex);
                ev.ctrlKey = true;
                ev.shiftKey = false;
                this.selectionService.changes.emit(ev);
            });
        }
    }
    onKeyDown(e) {
        if (e.keyCode === Keys.Enter) {
            this.onClick();
        }
    }
    /*
     * @hidden
     */
    setCheckedState() {
        this.renderer.setProperty(this.el.nativeElement, "checked", this.selectionService.isSelected(this.itemIndex));
    }
};
SelectionCheckboxDirective.ɵfac = function SelectionCheckboxDirective_Factory(t) { return new (t || SelectionCheckboxDirective)(ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
SelectionCheckboxDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SelectionCheckboxDirective, selectors: [["", "kendoGridSelectionCheckbox", ""]], hostVars: 1, hostBindings: function SelectionCheckboxDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("type", ctx.type);
    } }, inputs: { itemIndex: ["kendoGridSelectionCheckbox", "itemIndex"] } });
__decorate([
    Input("kendoGridSelectionCheckbox"),
    __metadata("design:type", Number)
], SelectionCheckboxDirective.prototype, "itemIndex", void 0);
__decorate([
    HostBinding('attr.type'),
    __metadata("design:type", String)
], SelectionCheckboxDirective.prototype, "type", void 0);
SelectionCheckboxDirective = __decorate([ __metadata("design:paramtypes", [SelectionService,
        ElementRef,
        Renderer2,
        NgZone])
], SelectionCheckboxDirective);

const columnCellIndex = (cell, cells) => {
    let cellIndex = 0;
    for (let idx = 0; idx < cells.length; idx++) {
        if (cells[idx] === cell) {
            return cellIndex;
        }
        if (!hasClasses(cells[idx], 'k-hierarchy-cell k-group-cell')) {
            cellIndex++;
        }
    }
};
/**
 * @hidden
 */
let TableBodyComponent = class TableBodyComponent {
    constructor(detailsService, groupsService, changeNotification, editService, localization, ngZone, renderer, element, domEvents, selectionService, cellSelectionService, columnInfoService, navigationService) {
        this.detailsService = detailsService;
        this.groupsService = groupsService;
        this.changeNotification = changeNotification;
        this.editService = editService;
        this.localization = localization;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.element = element;
        this.domEvents = domEvents;
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.columnInfoService = columnInfoService;
        this.navigationService = navigationService;
        this.columns = [];
        this.groups = [];
        this.skip = 0;
        this.noRecordsText = this.localization.get('noRecords');
        this.isLocked = false;
        this.skipGroupDecoration = false;
        this.showGroupFooters = false;
        this.lockedColumnsCount = 0;
        this.totalColumnsCount = 0;
        this.trackBy = defaultTrackBy;
        this.rowClass = () => null;
        this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe((args) => this.cellKeydownHandler(args));
        this.trackByWrapper = this.trackByWrapper.bind(this);
        this.trackByColumns = this.trackByColumns.bind(this);
    }
    get newDataItem() {
        return this.editService.newDataItem;
    }
    // Number of unlocked columns in the next table, if any
    get unlockedColumnsCount() {
        return this.totalColumnsCount - this.lockedColumnsCount - (this.allColumns || this.columns).length;
    }
    isAriaSelected(item, column) {
        return this.cellSelectionService.isCellSelected(item, column) ||
            this.isRowSelected(item) ? 'true' : 'false';
    }
    toggleRow(index, dataItem) {
        this.detailsService.toggleRow(index, dataItem);
        return false;
    }
    isExpanded(viewItem) {
        return this.detailsService.isExpanded(viewItem.index, viewItem.data);
    }
    detailButtonStyles(viewItem) {
        const expanded = this.isExpanded(viewItem);
        return expanded ? 'k-i-minus' : 'k-i-plus';
    }
    detailButtonTitle(viewItem) {
        const messageKey = this.isExpanded(viewItem) ? 'detailCollapse' : 'detailExpand';
        return this.localization.get(messageKey);
    }
    isGroup(item) {
        return item.type === 'group';
    }
    isDataItem(item) {
        return !this.isGroup(item) && !this.isFooter(item);
    }
    isFooter(item) {
        return item.type === 'footer';
    }
    isFooterItemInExpandedGroup(item) {
        const footerItem = { data: item.data, index: item.groupIndex, parentGroup: item.group.parentGroup };
        return this.isInExpandedGroup(footerItem);
    }
    isDataItemInExpandedGroup(item) {
        const dataItem = { data: item.group.data, index: item.groupIndex, parentGroup: item.group.parentGroup };
        return this.isInExpandedGroup(dataItem);
    }
    isInExpandedGroup(item) {
        return this.groupsService.isInExpandedGroup(item);
    }
    isParentGroupExpanded(item) {
        return this.groupsService.isInExpandedGroup(item.parentGroup);
    }
    isOdd(item) {
        return item.index % 2 !== 0;
    }
    isSelectable() {
        return this.selectable && this.selectable.enabled !== false;
    }
    isRowSelected(item) {
        return this.selectionService.isSelected(item.index);
    }
    trackByWrapper(index, item) {
        if (item.type === 'data') {
            item.isEditing = this.editService.hasEdited(item.index);
        }
        return this.trackBy(index, item);
    }
    trackByColumns(index, item) {
        return this.virtualColumns ? index : item;
    }
    ngDoCheck() {
        if (this.hasGroupHeaderColumn) {
            this.groupHeaderColumns = columnsToRender(this.skipGroupDecoration ? this.columns : this.columns.toArray().slice(1));
        }
        else {
            this.groupHeaderColumns = [];
        }
        if (this.isLocked) {
            this.groupHeaderSlaveCellsCount =
                this.hasGroupHeaderColumn ? this.columnsContainer.nonLockedColumnsToRender.length : 1;
        }
        else {
            this.groupHeaderSlaveCellsCount = 0;
        }
    }
    ngAfterViewChecked() {
        if (this.rowSticky) {
            this.applyStickyRowsStyling();
        }
    }
    ngOnChanges(changes) {
        if (isChanged('columns', changes, false)) {
            this.changeNotification.notify();
        }
    }
    logicalRowIndex(rowIndex) {
        let pos = this.skip + rowIndex;
        if (this.hasDetailTemplate) {
            pos *= 2;
        }
        const absoluteRowIndex = 1 + pos;
        const addRowOffset = this.editService.hasNewItem ? 1 : 0;
        const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
        const headerRowCount = this.columnInfoService.totalLevels + filterRowOffset + addRowOffset;
        return absoluteRowIndex + headerRowCount;
    }
    addRowLogicalIndex() {
        return this.columnInfoService.totalLevels + 1 +
            (hasFilterRow(this.filterable) ? 1 : 0);
    }
    logicalColIndex(column) {
        if (!isPresent(column.leafIndex)) {
            return -1;
        }
        return column.leafIndex + (this.hasDetailTemplate ? 1 : 0);
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            const clickHandler = this.clickHandler.bind(this);
            const mousedownSubscription = this.renderer.listen(this.element.nativeElement, 'mousedown', clickHandler);
            const mouseupSubscription = this.renderer.listen(this.element.nativeElement, 'mouseup', clickHandler);
            const clickSubscription = this.renderer.listen(this.element.nativeElement, 'click', clickHandler);
            const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, 'contextmenu', clickHandler);
            const touchstartSubscription = this.renderer.listen(this.element.nativeElement, 'touchstart', clickHandler);
            const touchendSubscription = this.renderer.listen(this.element.nativeElement, 'touchend', clickHandler);
            this.clickSubscription = () => {
                mousedownSubscription();
                mouseupSubscription();
                clickSubscription();
                contextmenuSubscription();
            };
            this.touchSubscription = () => {
                touchstartSubscription();
                touchendSubscription();
            };
        });
        let originalNoRecordText = this.localization.get('noRecords');
        this.localization.changes.subscribe(() => {
            if (this.noRecordsText === originalNoRecordText) {
                this.noRecordsText = this.localization.get('noRecords');
                originalNoRecordText = this.noRecordsText;
            }
        });
    }
    ngOnDestroy() {
        if (this.clickSubscription) {
            this.clickSubscription();
        }
        if (this.touchSubscription) {
            this.touchSubscription();
        }
        this.cellKeydownSubscription.unsubscribe();
        clearTimeout(this.clickTimeout);
    }
    isEditingCell(index, column) {
        return this.editService.isEditing() && this.editService.isEditedColumn(index, column);
    }
    isEditingRow(index) {
        return this.editService.isEditing() && this.editService.hasEdited(index);
    }
    get hasGroupHeaderColumn() {
        return this.columnsContainer.hasGroupHeaderColumn;
    }
    get columnsContainer() {
        return this.columnInfoService.columnsContainer;
    }
    get columnsSpan() {
        return columnsSpan(this.columns);
    }
    get allColumnsSpan() {
        return columnsSpan(this.allColumns || this.columns);
    }
    get colSpan() {
        return this.columnsSpan + this.groups.length + (this.hasDetailTemplate ? 1 : 0);
    }
    get footerColumns() {
        return this.isLocked ? this.columnsContainer.lockedColumnsToRender : this.columnsContainer.nonLockedColumnsToRender;
    }
    showGroupHeader(item) {
        return !item.data.skipHeader;
    }
    addStickyColumnStyles(column) {
        const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
        return Object.assign({}, column.style, stickyStyles);
    }
    resizeHandler() {
        this.applyStickyRowsStyling();
    }
    get hasDetailTemplate() {
        return isPresent(this.detailTemplate);
    }
    clickHandler(eventArg) {
        const element = this.element.nativeElement;
        const target = this.eventTarget(eventArg);
        let cell, row, body, gridElement;
        let currentTarget = target;
        do {
            cell = closest(currentTarget, matchesNodeName('td'));
            row = closest(cell, matchesNodeName('tr'));
            body = closest(row, matchesNodeName('tbody'));
            currentTarget = body;
            gridElement = closestInScope(currentTarget, matchesClasses('k-grid'), element);
        } while (body && body !== element && !gridElement);
        if (cell && !hasClasses(cell, NON_DATA_CELL_CLASSES) &&
            !hasClasses(row, NON_DATA_ROW_CLASSES) &&
            body === element && !gridElement) {
            this.editService.preventCellClose();
            const focusable = target !== cell && isFocusableWithTabKey(target, false);
            if (!focusable && !matchesNodeName('label')(target) && !hasClasses(target, IGNORE_TARGET_CLASSSES) &&
                !closestInScope(target, matchesClasses(IGNORE_CONTAINER_CLASSES), cell)) {
                const args = this.cellClickArgs(cell, row, eventArg);
                if (eventArg.type === 'mousedown' || eventArg.type === 'touchstart') {
                    this.domEvents.cellMousedown.emit(args);
                }
                else if (eventArg.type === 'mouseup' || eventArg.type === 'touchend') {
                    this.domEvents.cellMouseup.emit(args);
                }
                else {
                    if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {
                        if (eventArg.type === 'click') {
                            this.clickTimeout = setTimeout(() => {
                                this.emitCellClick(args);
                            }, 0);
                        }
                        else {
                            this.emitCellClick(args);
                        }
                    }
                }
            }
        }
    }
    emitCellClick(args) {
        this.domEvents.cellClick.emit(Object.assign(args, {
            isEdited: args.isEditedRow || args.isEditedColumn
        }));
    }
    cellKeydownHandler(args) {
        if (args.keyCode === Keys.Enter) {
            this.clickHandler(args);
        }
    }
    cellClickArgs(cell, row, eventArg) {
        const index = columnCellIndex(cell, row.cells);
        const column = this.columns.toArray()[index];
        const columnIndex = this.lockedColumnsCount + index;
        let rowIndex = row.getAttribute('data-kendo-grid-item-index');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
        const dataItem = rowIndex === -1 ? this.editService.newDataItem : this.data.at(rowIndex - this.skip);
        const isEditedColumn = this.editService.isEditedColumn(rowIndex, column);
        const isEditedRow = this.editService.isEdited(rowIndex);
        const type = eventArg.type === 'keydown' ? 'click' : eventArg.type;
        return {
            column: column,
            columnIndex: columnIndex,
            dataItem: dataItem,
            isEditedColumn: isEditedColumn,
            isEditedRow: isEditedRow,
            originalEvent: eventArg,
            rowIndex: rowIndex,
            type: type
        };
    }
    eventTarget(args) {
        if (args.type === 'touchend') {
            const touch = args.changedTouches[0];
            return document.elementFromPoint(touch.clientX, touch.clientY);
        }
        return args.target;
    }
    applyStickyRowsStyling() {
        const stickyRows = nodesToArray(this.element.nativeElement.querySelectorAll('.k-grid-row-sticky'));
        const length = stickyRows.length;
        if (length) {
            let accumulatedHeight = 0;
            const stickyRowsOffsets = [];
            stickyRows.forEach(row => {
                const rowHeight = row.getBoundingClientRect().height;
                stickyRowsOffsets.push({ accumulatedHeight, rowHeight });
                accumulatedHeight += rowHeight;
            });
            stickyRows.forEach((row, index) => {
                this.renderer.setStyle(row, 'top', `${stickyRowsOffsets[index].accumulatedHeight}px`);
                this.renderer.setStyle(row, 'bottom', `${accumulatedHeight - stickyRowsOffsets[index].accumulatedHeight - stickyRowsOffsets[index].rowHeight}px`);
            });
        }
    }
};
TableBodyComponent.ɵfac = function TableBodyComponent_Factory(t) { return new (t || TableBodyComponent)(ɵngcc0.ɵɵdirectiveInject(DetailsService), ɵngcc0.ɵɵdirectiveInject(GroupsService), ɵngcc0.ɵɵdirectiveInject(ChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DomEventsService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(CellSelectionService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
TableBodyComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TableBodyComponent, selectors: [["", "kendoGridTableBody", ""]], inputs: { columns: "columns", groups: "groups", skip: "skip", noRecordsText: "noRecordsText", isLocked: "isLocked", skipGroupDecoration: "skipGroupDecoration", showGroupFooters: "showGroupFooters", lockedColumnsCount: "lockedColumnsCount", totalColumnsCount: "totalColumnsCount", trackBy: "trackBy", rowClass: "rowClass", allColumns: "allColumns", detailTemplate: "detailTemplate", noRecordsTemplate: "noRecordsTemplate", data: "data", selectable: "selectable", filterable: "filterable", isLoading: "isLoading", isVirtual: "isVirtual", cellLoadingTemplate: "cellLoadingTemplate", virtualColumns: "virtualColumns", rowSticky: "rowSticky" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c187, decls: 4, vars: 5, consts: [[3, "ngIf"], ["class", "k-grid-norecords", 4, "ngIf"], ["ngFor", "", 3, "ngForOf", "ngForTrackBy"], [3, "resize", 4, "ngIf"], ["kendoGridLogicalRow", "", 1, "k-grid-add-row", "k-grid-edit-row", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount"], ["class", "k-hierarchy-cell", "kendoGridLogicalCell", "", "aria-selected", "false", 3, "logicalRowIndex", "logicalColIndex", 4, "ngIf"], ["kendoGridCell", "", "kendoGridLogicalCell", "", "role", "gridcell", 3, "rowIndex", "columnIndex", "isNew", "column", "dataItem", "k-grid-content-sticky", "ngClass", "left", "ngStyle", "logicalRowIndex", "logicalColIndex", "colSpan", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "k-group-cell", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "k-group-cell"], ["kendoGridLogicalCell", "", "aria-selected", "false", 1, "k-hierarchy-cell", 3, "logicalRowIndex", "logicalColIndex"], ["kendoGridCell", "", "kendoGridLogicalCell", "", "role", "gridcell", 3, "rowIndex", "columnIndex", "isNew", "column", "dataItem", "ngClass", "ngStyle", "logicalRowIndex", "logicalColIndex", "colSpan"], [1, "k-grid-norecords"], [3, "ngIf", "templateContext"], [4, "ngIf"], ["kendoGridGroupHeader", "", "kendoGridLogicalRow", "", 3, "columns", "groups", "item", "hasDetails", "skipGroupDecoration", "hasGroupHeaderColumn", "groupHeaderColumns", "rowIndex", "totalColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngIf"], ["kendoGridLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "k-grid-row-sticky", "ngClass", "k-alt", "k-master-row", "k-grid-edit-row", "k-state-selected", 4, "ngIf"], ["class", "k-detail-row", "kendoGridLogicalRow", "", 3, "k-alt", "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", 4, "ngIf"], ["class", "k-group-footer", "kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngIf"], ["kendoGridGroupHeader", "", "kendoGridLogicalRow", "", 3, "columns", "groups", "item", "hasDetails", "skipGroupDecoration", "hasGroupHeaderColumn", "groupHeaderColumns", "rowIndex", "totalColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "ngClass"], ["class", "k-hierarchy-cell", "kendoGridLogicalCell", "", "aria-selected", "false", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "detailExpandCell", 4, "ngIf"], ["kendoGridCell", "", "kendoGridLogicalCell", "", "role", "gridcell", 3, "rowIndex", "columnIndex", "column", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "k-grid-content-sticky", "k-touch-action-none", "k-touch-action-auto", "ngClass", "k-grid-edit-cell", "ngStyle", "k-state-selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["kendoGridLogicalCell", "", "aria-selected", "false", 1, "k-hierarchy-cell", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "detailExpandCell"], ["class", "k-icon", "href", "#", "tabindex", "-1", 3, "ngClass", "click", 4, "ngIf"], ["href", "#", "tabindex", "-1", 1, "k-icon", 3, "ngClass", "click"], ["kendoGridCell", "", "kendoGridLogicalCell", "", "role", "gridcell", 3, "rowIndex", "columnIndex", "column", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "ngClass", "ngStyle"], ["kendoGridLogicalRow", "", 1, "k-detail-row", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount"], ["class", "k-group-cell", 4, "ngFor", "ngForOf"], [1, "k-hierarchy-cell"], ["kendoGridLogicalCell", "", "role", "gridcell", "aria-selected", "false", 1, "k-detail-cell", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "colIndex", "colSpan"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-group-cell"], ["kendoGridLogicalRow", "", 1, "k-group-footer", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex"], [3, "templateContext"], [3, "resize"]], template: function TableBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TableBodyComponent_ng_template_0_Template, 4, 8, "ng-template", 0);
        ɵngcc0.ɵɵtemplate(1, TableBodyComponent_tr_1_Template, 4, 6, "tr", 1);
        ɵngcc0.ɵɵtemplate(2, TableBodyComponent_ng_template_2_Template, 4, 4, "ng-template", 2);
        ɵngcc0.ɵɵtemplate(3, TableBodyComponent_kendo_resize_sensor_3_Template, 1, 0, "kendo-resize-sensor", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.editService.hasNewItem);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", (ctx.data == null ? null : ctx.data.length) === 0 || ctx.data == null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackByWrapper);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowSticky);
    } }, directives: function () { return [ɵngcc5.NgIf, LogicalRowDirective, ɵngcc5.NgForOf, LogicalCellDirective, CellComponent, ɵngcc5.NgClass, ɵngcc5.NgStyle, TemplateContextDirective, GroupHeaderComponent, ɵngcc5.NgTemplateOutlet, ɵngcc2.ResizeSensorComponent]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], TableBodyComponent.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], TableBodyComponent.prototype, "allColumns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], TableBodyComponent.prototype, "groups", void 0);
__decorate([
    Input(),
    __metadata("design:type", DetailTemplateDirective)
], TableBodyComponent.prototype, "detailTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", NoRecordsTemplateDirective)
], TableBodyComponent.prototype, "noRecordsTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], TableBodyComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TableBodyComponent.prototype, "skip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TableBodyComponent.prototype, "selectable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TableBodyComponent.prototype, "filterable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TableBodyComponent.prototype, "noRecordsText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TableBodyComponent.prototype, "isLocked", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TableBodyComponent.prototype, "isLoading", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TableBodyComponent.prototype, "isVirtual", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], TableBodyComponent.prototype, "cellLoadingTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TableBodyComponent.prototype, "skipGroupDecoration", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TableBodyComponent.prototype, "showGroupFooters", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TableBodyComponent.prototype, "lockedColumnsCount", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TableBodyComponent.prototype, "totalColumnsCount", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TableBodyComponent.prototype, "virtualColumns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TableBodyComponent.prototype, "trackBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TableBodyComponent.prototype, "rowSticky", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TableBodyComponent.prototype, "rowClass", void 0);
TableBodyComponent = __decorate([ __metadata("design:paramtypes", [DetailsService,
        GroupsService,
        ChangeNotificationService,
        EditService,
        LocalizationService,
        NgZone,
        Renderer2,
        ElementRef,
        DomEventsService,
        SelectionService,
        CellSelectionService,
        ColumnInfoService,
        NavigationService])
], TableBodyComponent);

/**
 * @hidden
 */
let CellComponent = class CellComponent {
    constructor(editService, idService, localizationService, cellContext) {
        this.editService = editService;
        this.idService = idService;
        this.localizationService = localizationService;
        this.cellContext = cellContext;
        this.isNew = false;
        this.isLoading = false;
        this.isVirtual = false;
        this._templateContext = {};
        this._editTemplateContext = {};
    }
    get commandCellClass() {
        return this.isCommand(this.column);
    }
    set rowIndex(index) {
        this._rowIndex = index;
        this.updateCellContext();
    }
    get rowIndex() {
        return this._rowIndex;
    }
    get isEdited() {
        if (!(this.editService.isEditing() || this.isNew) || !this.isColumnEditable) {
            return false;
        }
        const editContext = this.editService.columnContext(this.rowIndex, this.column);
        return this.isFieldEditable(editContext, this.column);
    }
    get showLoading() {
        return this.isVirtual && this.isLoading;
    }
    get formGroup() {
        return this.editService.context(this.rowIndex).group;
    }
    get templateContext() {
        return this._templateContext;
    }
    get editTemplateContext() {
        this._editTemplateContext.$implicit = this.formGroup;
        this._editTemplateContext.isNew = this.isNew;
        this._editTemplateContext.column = this.column;
        this._editTemplateContext.dataItem = this.dataItem;
        this._editTemplateContext.formGroup = this.formGroup;
        this._editTemplateContext.rowIndex = this.rowIndex;
        return this._editTemplateContext;
    }
    get format() {
        if (isColumnComponent(this.column) && !isNullOrEmptyString(this.column.format)) {
            return extractFormat(this.column.format);
        }
        return undefined;
    }
    get isBoundColumn() {
        return this.column.field && !this.column.templateRef;
    }
    get isCheckboxColumn() {
        return isCheckboxColumn(this.column) && !this.column.templateRef;
    }
    get selectionCheckboxId() {
        return this.idService.selectionCheckboxId(this.rowIndex);
    }
    get selectionCheckboxLabel() {
        return this.localizationService.get('selectionCheckboxLabel');
    }
    get isSpanColumn() {
        return isSpanColumn(this.column) && !this.column.templateRef;
    }
    get childColumns() {
        return columnsToRender([this.column]);
    }
    get isColumnEditable() {
        if (!this.column || this.isCommand(this.column)) {
            return false;
        }
        return this.column.editable !== false;
    }
    ngDoCheck() {
        this.updateCellContext();
    }
    ngOnChanges(_changes) {
        this.updateTemplateContext();
    }
    ngAfterContentChecked() {
        this.updateTemplateContext();
    }
    isCommand(column) {
        return column instanceof CommandColumnComponent;
    }
    isFieldEditable(editContext, column) {
        if (!isPresent(editContext)) {
            return false;
        }
        if (isPresent(column.editTemplate)) {
            return true;
        }
        return isPresent(editContext.group) && isPresent(editContext.group.get(column.field));
    }
    updateCellContext() {
        if (this.cellContext) {
            this.cellContext.rowIndex = this._rowIndex;
        }
    }
    updateTemplateContext() {
        if (!this.column.templateRef) {
            return;
        }
        const context = this._templateContext;
        context.isNew = this.isNew;
        context.column = this.column;
        context.dataItem = this.dataItem;
        context.rowIndex = this.rowIndex;
        context.columnIndex = this.columnIndex;
        context.$implicit = this.dataItem;
    }
};
CellComponent.ɵfac = function CellComponent_Factory(t) { return new (t || CellComponent)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(IdService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(CELL_CONTEXT, 8)); };
CellComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CellComponent, selectors: [["", "kendoGridCell", ""]], hostVars: 2, hostBindings: function CellComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-command-cell", ctx.commandCellClass);
    } }, inputs: { isNew: "isNew", isLoading: "isLoading", isVirtual: "isVirtual", rowIndex: "rowIndex", column: "column", columnIndex: "columnIndex", loadingTemplate: "loadingTemplate", dataItem: "dataItem" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c192, decls: 3, vars: 3, consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngIf", "ngIfElse"], ["loading", ""], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngIf"], ["ngFor", "", 3, "ngForOf"], [1, "k-checkbox", "k-checkbox-md", "k-rounded-md", 3, "kendoGridSelectionCheckbox"], [4, "ngIf"], ["class", "k-skeleton-text k-skeleton", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-skeleton-text", "k-skeleton"], [3, "ngSwitch", 4, "ngIf"], ["kendoGridFocusable", "", 3, "format", "formControl", 4, "ngSwitchCase"], ["type", "checkbox", "class", "k-checkbox k-checkbox-md k-rounded-md", "kendoGridFocusable", "", 3, "formControl", 4, "ngSwitchCase"], ["type", "text", "class", "k-textbox k-input k-rounded-md", "kendoGridFocusable", "", 3, "formControl", 4, "ngSwitchDefault"], ["kendoGridFocusable", "", 3, "format", "formControl"], ["type", "checkbox", "kendoGridFocusable", "", 1, "k-checkbox", "k-checkbox-md", "k-rounded-md", 3, "formControl"], ["type", "text", "kendoGridFocusable", "", 1, "k-textbox", "k-input", "k-rounded-md", 3, "formControl"]], template: function CellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_1_Template, 4, 2, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, CellComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.isEdited);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", false);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", true);
    } }, directives: [ɵngcc5.NgSwitch, ɵngcc5.NgSwitchCase, ɵngcc5.NgIf, ɵngcc5.NgTemplateOutlet, ɵngcc5.NgForOf, FocusableDirective, SelectionCheckboxDirective, ɵngcc6.NumericTextBoxComponent, ɵngcc7.NgControlStatus, ɵngcc7.FormControlDirective, ɵngcc9.DatePickerComponent, ɵngcc7.CheckboxControlValueAccessor, ɵngcc5.NgSwitchDefault, ɵngcc7.DefaultValueAccessor], pipes: [FieldAccessorPipe], encapsulation: 2 });
__decorate([
    HostBinding('class.k-command-cell'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CellComponent.prototype, "commandCellClass", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CellComponent.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CellComponent.prototype, "columnIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CellComponent.prototype, "isNew", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CellComponent.prototype, "isLoading", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CellComponent.prototype, "isVirtual", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], CellComponent.prototype, "loadingTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], CellComponent.prototype, "rowIndex", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CellComponent.prototype, "dataItem", void 0);
CellComponent = __decorate([ __param(3, Optional()), __param(3, Inject(CELL_CONTEXT)),
    __metadata("design:paramtypes", [EditService,
        IdService,
        LocalizationService, Object])
], CellComponent);

/**
 * Represents the `edit` command of the Grid. You can apply this directive to any `button`
 * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [edit]({% slug api_grid_gridcomponent %}#toc-edit) event
 * is triggered ([see example]({% slug editing_grid %})).
 *
 * > When the row is in the edit mode, the button with `kendoGridEditCommand` is automatically hidden.
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate>
 *       <button kendoGridEditCommand class="k-primary">Edit</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 *
 */
let EditCommandDirective = class EditCommandDirective extends Button {
    constructor(editService, cellContext, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
        /**
         * @hidden
         */
        this.commandClass = true;
    }
    /**
     * @hidden
     */
    get visible() {
        return this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.beginEdit(this.rowIndex);
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
};
EditCommandDirective.ɵfac = function EditCommandDirective_Factory(t) { return new (t || EditCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(CELL_CONTEXT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
EditCommandDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: EditCommandDirective, selectors: [["", "kendoGridEditCommand", ""]], hostVars: 4, hostBindings: function EditCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function EditCommandDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.visible);
        ɵngcc0.ɵɵclassProp("k-grid-edit-command", ctx.commandClass);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    HostBinding('style.display'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], EditCommandDirective.prototype, "visible", null);
__decorate([
    HostBinding('class.k-grid-edit-command'),
    __metadata("design:type", Boolean)
], EditCommandDirective.prototype, "commandClass", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], EditCommandDirective.prototype, "onClick", null);
EditCommandDirective = __decorate([ __param(1, Inject(CELL_CONTEXT)),
    __metadata("design:paramtypes", [EditService, Object, ElementRef,
        Renderer2,
        LocalizationService,
        NgZone])
], EditCommandDirective);

/**
 * Represents the `cancel` command of the Grid. You can apply this directive to any `button`
 * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [cancel]({% slug api_grid_gridcomponent %}#toc-cancel) event
 * is triggered ([see example]({% slug editing_grid %})).
 *
 * > When the row is not in the edit mode, the button with the `kendoGridCancelCommand` is automatically hidden.
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate>
 *       <button kendoGridCancelCommand>Cancel changes</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 *
 * You can control the content of the button based on the state of the row.
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate let-isNew="isNew">
 *       <button kendoGridCancelCommand>{{isNew ? 'Discard' : 'Cancel changes'}}</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
let CancelCommandDirective = class CancelCommandDirective extends Button {
    constructor(editService, cellContext, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
        /**
         * @hidden
         */
        this.commandClass = true;
    }
    /**
     * @hidden
     */
    get visible() {
        return !this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.isEdited) {
            this.editService.endEdit(this.rowIndex);
        }
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
};
CancelCommandDirective.ɵfac = function CancelCommandDirective_Factory(t) { return new (t || CancelCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(CELL_CONTEXT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
CancelCommandDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CancelCommandDirective, selectors: [["", "kendoGridCancelCommand", ""]], hostVars: 4, hostBindings: function CancelCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function CancelCommandDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.visible);
        ɵngcc0.ɵɵclassProp("k-grid-cancel-command", ctx.commandClass);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    HostBinding('style.display'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], CancelCommandDirective.prototype, "visible", null);
__decorate([
    HostBinding('class.k-grid-cancel-command'),
    __metadata("design:type", Boolean)
], CancelCommandDirective.prototype, "commandClass", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], CancelCommandDirective.prototype, "onClick", null);
CancelCommandDirective = __decorate([ __param(1, Inject(CELL_CONTEXT)),
    __metadata("design:paramtypes", [EditService, Object, ElementRef,
        Renderer2,
        LocalizationService,
        NgZone])
], CancelCommandDirective);

/**
 * Represents the `save` command of the Grid. You can apply this directive to any `button`
 * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [save]({% slug api_grid_gridcomponent %}#toc-save) event
 * is triggered ([see example]({% slug editing_grid %})).
 *
 * > When the row is not in the edit mode, the button with `kendoGridSaveCommand` is automatically hidden.
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate>
 *       <button kendoGridSaveCommand>Save changes</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 *
 * You can control the content of the button based on the state of the row.
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate let-isNew="isNew">
 *       <button kendoGridSaveCommand>{{isNew ? 'Add' : 'Update'}}</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
let SaveCommandDirective = class SaveCommandDirective extends Button {
    constructor(editService, cellContext, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
        /**
         * @hidden
         */
        this.commandClass = true;
    }
    /**
     * @hidden
     */
    get visible() {
        return !this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.isEdited) {
            this.editService.save(this.rowIndex);
        }
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
};
SaveCommandDirective.ɵfac = function SaveCommandDirective_Factory(t) { return new (t || SaveCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(CELL_CONTEXT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
SaveCommandDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SaveCommandDirective, selectors: [["", "kendoGridSaveCommand", ""]], hostVars: 4, hostBindings: function SaveCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function SaveCommandDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.visible);
        ɵngcc0.ɵɵclassProp("k-grid-save-command", ctx.commandClass);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    HostBinding('style.display'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], SaveCommandDirective.prototype, "visible", null);
__decorate([
    HostBinding('class.k-grid-save-command'),
    __metadata("design:type", Boolean)
], SaveCommandDirective.prototype, "commandClass", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SaveCommandDirective.prototype, "onClick", null);
SaveCommandDirective = __decorate([ __param(1, Inject(CELL_CONTEXT)),
    __metadata("design:paramtypes", [EditService, Object, ElementRef,
        Renderer2,
        LocalizationService,
        NgZone])
], SaveCommandDirective);

/**
 * Represents the `remove` command of the Grid. You can apply this directive to any `button` element
 * inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [remove event]({% slug api_grid_gridcomponent %}#toc-remove)
 * is triggered ([see example]({% slug editing_reactive_forms_grid %})).
 *
 * > When the row is in the edit mode, the button with the `kendoGridRemoveCommand` is automatically hidden.
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate>
 *       <button kendoGridRemoveCommand>Remove row</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
let RemoveCommandDirective = class RemoveCommandDirective extends Button {
    constructor(editService, cellContext, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
        /**
         * @hidden
         */
        this.commandClass = true;
    }
    /**
     * @hidden
     */
    get visible() {
        return this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.remove(this.rowIndex);
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
};
RemoveCommandDirective.ɵfac = function RemoveCommandDirective_Factory(t) { return new (t || RemoveCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(CELL_CONTEXT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
RemoveCommandDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: RemoveCommandDirective, selectors: [["", "kendoGridRemoveCommand", ""]], hostVars: 4, hostBindings: function RemoveCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function RemoveCommandDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.visible);
        ɵngcc0.ɵɵclassProp("k-grid-remove-command", ctx.commandClass);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    HostBinding('style.display'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], RemoveCommandDirective.prototype, "visible", null);
__decorate([
    HostBinding('class.k-grid-remove-command'),
    __metadata("design:type", Boolean)
], RemoveCommandDirective.prototype, "commandClass", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], RemoveCommandDirective.prototype, "onClick", null);
RemoveCommandDirective = __decorate([ __param(1, Inject(CELL_CONTEXT)),
    __metadata("design:paramtypes", [EditService, Object, ElementRef,
        Renderer2,
        LocalizationService,
        NgZone])
], RemoveCommandDirective);

/**
 * Represents the command for adding a new item to the Grid. You can apply this directive to any
 * `button` element inside a [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [add]({% slug api_grid_gridcomponent %}#toc-add) event is triggered
 * ([see example]({% slug editing_grid %})).
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *    <ng-template kendoGridToolbarTemplate>
 *       <button kendoGridAddCommand>Add new</button>
 *    </ng-template>
 * </kendo-grid>
 * ```
 */
let AddCommandDirective = class AddCommandDirective extends Button {
    constructor(editService, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.editService = editService;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.beginAdd();
    }
    /**
     * @hidden
     */
    get commandClass() {
        return true;
    }
};
AddCommandDirective.ɵfac = function AddCommandDirective_Factory(t) { return new (t || AddCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AddCommandDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: AddCommandDirective, selectors: [["", "kendoGridAddCommand", ""]], hostVars: 2, hostBindings: function AddCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function AddCommandDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-add-command", ctx.commandClass);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], AddCommandDirective.prototype, "onClick", null);
__decorate([
    HostBinding('class.k-grid-add-command'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], AddCommandDirective.prototype, "commandClass", null);
AddCommandDirective = __decorate([ __metadata("design:paramtypes", [EditService,
        ElementRef,
        Renderer2,
        LocalizationService,
        NgZone])
], AddCommandDirective);

const exported$1 = [
    CommandColumnComponent,
    CheckboxColumnComponent,
    SelectionCheckboxDirective,
    CellTemplateDirective,
    EditTemplateDirective,
    TableBodyComponent,
    NoRecordsTemplateDirective,
    CellComponent,
    EditCommandDirective,
    CancelCommandDirective,
    SaveCommandDirective,
    RemoveCommandDirective,
    AddCommandDirective,
    CellLoadingTemplateDirective,
    LoadingTemplateDirective
];
const importedModules$3 = [
    CommonModule,
    ReactiveFormsModule,
    FormsModule,
    SharedModule,
    GroupModule,
    NumericTextBoxModule,
    DatePickerModule,
    ResizeSensorModule
];
/**
 * @hidden
 */
let BodyModule = class BodyModule {
    static exports() {
        return [
            CommandColumnComponent,
            CheckboxColumnComponent,
            SelectionCheckboxDirective,
            CellTemplateDirective,
            NoRecordsTemplateDirective,
            EditTemplateDirective,
            EditCommandDirective,
            CancelCommandDirective,
            SaveCommandDirective,
            RemoveCommandDirective,
            AddCommandDirective,
            CellLoadingTemplateDirective,
            LoadingTemplateDirective
        ];
    }
};
BodyModule.ɵfac = function BodyModule_Factory(t) { return new (t || BodyModule)(); };
BodyModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BodyModule });
BodyModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[...importedModules$3]] });

/**
 * @hidden
 */
let FooterComponent = class FooterComponent {
    constructor(columnInfoService) {
        this.columnInfoService = columnInfoService;
        this.columns = [];
        this.groups = [];
        this.lockedColumnsCount = 0;
        this.logicalRowIndex = 0;
    }
    get footerClass() {
        return !this.scrollable;
    }
    get columnsToRender() {
        return columnsToRender(this.columns || []);
    }
    logicalColumnIndex(column) {
        const index = column.leafIndex;
        if (isPresent(index)) {
            return index + (isPresent(this.detailTemplate) ? 1 : 0);
        }
        return -1;
    }
    addStickyStyles(column) {
        const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
        return Object.assign({}, column.style, stickyStyles);
    }
};
FooterComponent.ɵfac = function FooterComponent_Factory(t) { return new (t || FooterComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnInfoService)); };
FooterComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FooterComponent, selectors: [["", "kendoGridFooter", ""]], hostVars: 2, hostBindings: function FooterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-footer", ctx.footerClass);
    } }, inputs: { columns: "columns", groups: "groups", lockedColumnsCount: "lockedColumnsCount", logicalRowIndex: "logicalRowIndex", detailTemplate: "detailTemplate", scrollable: "scrollable" }, attrs: _c194, decls: 1, vars: 1, consts: [[3, "ngIf"], ["kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount"], ["role", "presentation", 3, "k-group-cell", 4, "ngFor", "ngForOf"], ["role", "presentation", 3, "k-hierarchy-cell", 4, "ngIf"], ["kendoGridLogicalCell", "", "role", "columnfooter", "aria-selected", "false", 3, "logicalRowIndex", "logicalColIndex", "k-grid-footer-sticky", "ngClass", "ngStyle", 4, "ngFor", "ngForOf"], ["role", "presentation"], ["kendoGridLogicalCell", "", "role", "columnfooter", "aria-selected", "false", 3, "logicalRowIndex", "logicalColIndex", "ngClass", "ngStyle"], [3, "templateContext"]], template: function FooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FooterComponent_ng_template_0_Template, 4, 9, "ng-template", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", true);
    } }, directives: [ɵngcc5.NgIf, LogicalRowDirective, ɵngcc5.NgForOf, LogicalCellDirective, ɵngcc5.NgClass, ɵngcc5.NgStyle, TemplateContextDirective], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], FooterComponent.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], FooterComponent.prototype, "groups", void 0);
__decorate([
    Input(),
    __metadata("design:type", DetailTemplateDirective)
], FooterComponent.prototype, "detailTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FooterComponent.prototype, "scrollable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FooterComponent.prototype, "lockedColumnsCount", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FooterComponent.prototype, "logicalRowIndex", void 0);
__decorate([
    HostBinding('class.k-grid-footer'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FooterComponent.prototype, "footerClass", null);
FooterComponent = __decorate([ __metadata("design:paramtypes", [ColumnInfoService])
], FooterComponent);

const exportedModules$3 = [
    FooterComponent
];
const importedModules$4 = [
    CommonModule,
    SharedModule
];
/**
 * @hidden
 */
let FooterModule = class FooterModule {
    static exports() {
        return [];
    }
};
FooterModule.ɵfac = function FooterModule_Factory(t) { return new (t || FooterModule)(); };
FooterModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: FooterModule });
FooterModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[...importedModules$4]] });

/**
 * @hidden
 */
let ToolbarComponent = class ToolbarComponent {
    constructor(grid) {
        this.grid = grid;
        this.context = {};
    }
    set position(value) {
        this.context.position = value;
    }
    get toolbarTemplateRef() {
        return this.grid.toolbarTemplate ? this.grid.toolbarTemplate.templateRef : undefined;
    }
};
ToolbarComponent.ɵfac = function ToolbarComponent_Factory(t) { return new (t || ToolbarComponent)(ɵngcc0.ɵɵdirectiveInject(GridComponent)); };
ToolbarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ToolbarComponent, selectors: [["kendo-grid-toolbar"]], inputs: { position: "position" }, decls: 1, vars: 1, consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function ToolbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ToolbarComponent_0_Template, 1, 2, null, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.toolbarTemplateRef);
    } }, directives: [ɵngcc5.NgIf, ɵngcc5.NgTemplateOutlet], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ToolbarComponent.prototype, "position", null);
ToolbarComponent = __decorate([ __metadata("design:paramtypes", [GridComponent])
], ToolbarComponent);

/**
 * @hidden
 */
class LocalEditService {
    constructor(grid, localDataChangesService) {
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
    }
    create(item) {
        if (this.hasLocalData && this.grid.skip) {
            this.localDataChangesService.data.splice(this.grid.skip, 0, item);
        }
        else {
            this.data.unshift(item);
        }
        this.dataChanged();
    }
    update(_item) { } // tslint:disable-line:no-empty
    remove(item) {
        const data = this.data;
        for (let idx = 0; idx < data.length; idx++) {
            if (item === data[idx]) {
                data.splice(idx, 1);
                this.dataChanged({ action: 'remove', item: item });
                break;
            }
        }
    }
    assignValues(target, source) {
        Object.assign(target, source);
    }
    dataChanged(args = {}) {
        if (this.hasLocalData) {
            this.localDataChangesService.changes.emit(args);
        }
    }
    get hasLocalData() {
        return Array.isArray(this.localDataChangesService.data);
    }
    get data() {
        if (this.hasLocalData) {
            return this.localDataChangesService.data;
        }
        const data = this.grid.data;
        if (Array.isArray(data)) {
            return data;
        }
        if (isDevMode()) {
            throw new Error('The default edit service of the editing directives works only when binding to plain array.' +
                'Please provide an editService.');
        }
        return [];
    }
}

/**
 * @hidden
 */
class EditingDirectiveBase {
    constructor(grid, localDataChangesService) {
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
        this.defaultEditService = this.createDefaultService();
    }
    // Consider adding support for the dependency injection of the service to allow for specifying a generic service without code.
    // The Input should still be kept.
    /**
     * The edit service that will handle the operations.
     */
    set editService(value) {
        this.userEditService = value;
    }
    get editService() {
        return this.userEditService || this.defaultEditService;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subscriptions = this.grid.add.subscribe(this.addHandler.bind(this));
        this.subscriptions.add(this.grid.remove.subscribe(this.removeHandler.bind(this)));
        this.subscriptions.add(this.grid.cancel.subscribe(this.cancelHandler.bind(this)));
        this.subscriptions.add(this.grid.save.subscribe(this.saveHandler.bind(this)));
        this.subscriptions.add(this.grid.dataStateChange.subscribe(this.onStateChange.bind(this)));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    createDefaultService() {
        return new LocalEditService(this.grid, this.localDataChangesService);
    }
    addHandler() {
        this.grid.addRow(this.createModel({ isNew: true }));
    }
    saveHandler(args) {
        const item = this.saveModel(args);
        if (item) {
            if (args.isNew) {
                this.editService.create(item);
            }
            else {
                this.editService.update(item);
            }
        }
        this.grid.closeRow(args.rowIndex);
    }
    cancelHandler({ rowIndex }) {
        this.closeEditor(rowIndex);
    }
    removeHandler({ dataItem }) {
        const removeItem = (shouldRemove) => {
            if (shouldRemove) {
                this.editService.remove(dataItem);
            }
        };
        if (this.removeConfirmation) {
            const result = this.removeConfirmation(dataItem);
            if (result instanceof Promise) {
                result.then(removeItem);
            }
            else if (result instanceof Observable) {
                result.pipe(take(1)).subscribe(removeItem);
            }
            else {
                removeItem(result);
            }
        }
        else {
            removeItem(true);
        }
    }
    onStateChange() {
        this.closeEditor();
    }
    closeEditor(rowIndex) {
        this.grid.closeRow(rowIndex);
    }
}
EditingDirectiveBase.ɵfac = function EditingDirectiveBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
EditingDirectiveBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: EditingDirectiveBase, inputs: { editService: "editService", removeConfirmation: "removeConfirmation" } });
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], EditingDirectiveBase.prototype, "editService", null);
__decorate([
    Input(),
    __metadata("design:type", Function)
], EditingDirectiveBase.prototype, "removeConfirmation", void 0);

/**
 * @hidden
 */
class LocalRowEditService extends LocalEditService {
    update(_item) {
        this.dataChanged();
    }
}

/**
 * @hidden
 */
class RowEditingDirectiveBase extends EditingDirectiveBase {
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions
            .add(this.grid.edit.subscribe(this.editHandler.bind(this)));
    }
    createDefaultService() {
        return new LocalRowEditService(this.grid, this.localDataChangesService);
    }
    addHandler() {
        this.closeEditor();
        super.addHandler();
    }
    editHandler(args) {
        this.closeEditor();
        this.rowIndex = args.rowIndex;
        this.grid.editRow(args.rowIndex, this.createModel(args));
    }
    saveHandler(args) {
        super.saveHandler(args);
        this.clean();
    }
    closeEditor(rowIndex = this.rowIndex) {
        super.closeEditor(rowIndex);
        this.clean();
    }
    clean() {
        delete this.rowIndex;
    }
}
RowEditingDirectiveBase.ɵfac = /*@__PURE__*/ function () { let ɵRowEditingDirectiveBase_BaseFactory; return function RowEditingDirectiveBase_Factory(t) { return (ɵRowEditingDirectiveBase_BaseFactory || (ɵRowEditingDirectiveBase_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(RowEditingDirectiveBase)))(t || RowEditingDirectiveBase); }; }();
RowEditingDirectiveBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: RowEditingDirectiveBase, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });

/**
 * A directive which encapsulates the editing operations of the Grid when using
 * the Template-Driven Angular Forms ([see example]({% slug editing_directives_grid %}#toc-the-template-directive)).
 */
let TemplateEditingDirective = class TemplateEditingDirective extends RowEditingDirectiveBase {
    constructor(grid, localDataChangesService) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
    }
    editHandler(args) {
        super.editHandler(args);
        this.dataItem = args.dataItem;
        this.originalValues = {};
        this.editService.assignValues(this.originalValues, this.dataItem);
    }
    closeEditor(rowIndex) {
        if (this.dataItem) {
            this.editService.assignValues(this.dataItem, this.originalValues);
        }
        super.closeEditor(rowIndex);
    }
    createModel(args) {
        if (args.isNew) {
            return this.createNewItem();
        }
    }
    saveModel(args) {
        return args.dataItem;
    }
    clean() {
        super.clean();
        delete this.dataItem;
    }
};
TemplateEditingDirective.ɵfac = function TemplateEditingDirective_Factory(t) { return new (t || TemplateEditingDirective)(ɵngcc0.ɵɵdirectiveInject(GridComponent), ɵngcc0.ɵɵdirectiveInject(LocalDataChangesService)); };
TemplateEditingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TemplateEditingDirective, selectors: [["", "kendoGridTemplateEditing", ""]], inputs: { createNewItem: ["kendoGridTemplateEditing", "createNewItem"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input('kendoGridTemplateEditing'),
    __metadata("design:type", Function)
], TemplateEditingDirective.prototype, "createNewItem", void 0);
TemplateEditingDirective = __decorate([ __metadata("design:paramtypes", [GridComponent, LocalDataChangesService])
], TemplateEditingDirective);

/**
 * @hidden
 */
const markAllAsTouched = (control) => {
    control.markAsTouched();
    if (control.hasOwnProperty('controls')) {
        let controls = control.controls;
        for (let inner in controls) {
            if (controls.hasOwnProperty(inner)) {
                markAllAsTouched(controls[inner]);
            }
        }
    }
};

/**
 * A directive which encapsulates the editing operations of the Grid when using the
 * Reactive Forms ([see example]({% slug editing_directives_grid %}#toc-the-reactive-directive)).
 */
let ReactiveEditingDirective = class ReactiveEditingDirective extends RowEditingDirectiveBase {
    constructor(grid, localDataChangesService) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
    }
    createModel(args) {
        return this.createFormGroup(args);
    }
    saveModel({ dataItem, formGroup, isNew }) {
        if (!formGroup.dirty && !isNew) {
            return;
        }
        if (formGroup.valid) {
            this.editService.assignValues(dataItem, formGroup.value);
            return dataItem;
        }
        markAllAsTouched(formGroup);
    }
};
ReactiveEditingDirective.ɵfac = function ReactiveEditingDirective_Factory(t) { return new (t || ReactiveEditingDirective)(ɵngcc0.ɵɵdirectiveInject(GridComponent), ɵngcc0.ɵɵdirectiveInject(LocalDataChangesService)); };
ReactiveEditingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ReactiveEditingDirective, selectors: [["", "kendoGridReactiveEditing", ""]], inputs: { createFormGroup: ["kendoGridReactiveEditing", "createFormGroup"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input('kendoGridReactiveEditing'),
    __metadata("design:type", Function)
], ReactiveEditingDirective.prototype, "createFormGroup", void 0);
ReactiveEditingDirective = __decorate([ __metadata("design:paramtypes", [GridComponent, LocalDataChangesService])
], ReactiveEditingDirective);

/**
 * A directive which encapsulates the editing operations of the Grid when using the in-cell
 * editing with Reactive Forms ([see example]({% slug editing_directives_grid %}#toc-the-incell-directive)).
 */
let InCellEditingDirective = class InCellEditingDirective extends EditingDirectiveBase {
    constructor(grid, localDataChangesService, cdr) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
        this.cdr = cdr;
    }
    // Need mixin
    createModel(args) {
        return this.createFormGroup(args);
    }
    saveModel({ dataItem, formGroup, isNew }) {
        if (!formGroup.dirty && !isNew) {
            return;
        }
        if (formGroup.valid) {
            this.editService.assignValues(dataItem, formGroup.value);
            return dataItem;
        }
        markAllAsTouched(formGroup);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions.add(this.grid.cellClick.subscribe(this.cellClickHandler.bind(this)));
        this.subscriptions.add(this.grid.cellClose.subscribe(this.cellCloseHandler.bind(this)));
    }
    removeHandler(args) {
        super.removeHandler(args);
        this.grid.cancelCell();
    }
    cellClickHandler(args) {
        if (!args.isEdited && args.type !== 'contextmenu') {
            this.grid.editCell(args.rowIndex, args.columnIndex, this.createFormGroup(args));
            this.cdr.markForCheck();
        }
    }
    cellCloseHandler(args) {
        const { formGroup, dataItem } = args;
        if (!formGroup.valid) {
            args.preventDefault();
        }
        else if (formGroup.dirty) {
            if (args.originalEvent && args.originalEvent.keyCode === Keys.Escape) {
                return;
            }
            this.editService.assignValues(dataItem, formGroup.value);
            this.editService.update(dataItem);
        }
    }
};
InCellEditingDirective.ɵfac = function InCellEditingDirective_Factory(t) { return new (t || InCellEditingDirective)(ɵngcc0.ɵɵdirectiveInject(GridComponent), ɵngcc0.ɵɵdirectiveInject(LocalDataChangesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
InCellEditingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: InCellEditingDirective, selectors: [["", "kendoGridInCellEditing", ""]], inputs: { createFormGroup: ["kendoGridInCellEditing", "createFormGroup"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input('kendoGridInCellEditing'),
    __metadata("design:type", Function)
], InCellEditingDirective.prototype, "createFormGroup", void 0);
InCellEditingDirective = __decorate([ __metadata("design:paramtypes", [GridComponent,
        LocalDataChangesService,
        ChangeDetectorRef])
], InCellEditingDirective);

const hasGroups = (items) => items && items.length && items[0].field && items[0].items;
const groupDescriptorsPresent = (descriptors) => isPresent(descriptors) && descriptors.length > 0;
const processGroups = (data, state$$1) => process(data, state$$1).data;
const removeParentDescriptors = (parents, owner) => g => g.field !== owner.field && !parents.some(y => y.field === g.field);
const findGroup = (groupIndex, groups) => {
    const parents = [];
    return {
        group: groupIndex.split("_").reduce((acc, x) => {
            const idx = parseInt(x, 10);
            if (acc.items) {
                parents.push(acc);
                return acc.items[idx];
            }
            return isArray(acc) ? acc[idx] : acc;
        }, groups),
        parents
    };
};
const findChildren = (data, parents) => {
    const filters = parents.map(p => ({ field: p.field, operator: "eq", value: p.value }));
    return filterBy(data, {
        filters: filters,
        logic: "and"
    });
};
/**
 * @hidden
 */
const count = (groups, includeFooters = false) => (groups.reduce((acc, group) => {
    if (!group.skipHeader) {
        acc++;
    }
    if (group.items) {
        const children = count(group.items, includeFooters);
        if (includeFooters && children && !group.hideFooter) {
            acc++;
        }
        acc += children;
    }
    return acc;
}, 0) // tslint:disable-line:align
);
/**
 * @hidden
 */
const slice = (groups, skip, take$$1, includeFooters = false) => {
    if (!isPresent(take$$1)) {
        return groups;
    }
    const result = [];
    for (let idx = 0, length = groups.length; idx < length; idx++) {
        if (take$$1 <= 0) {
            break;
        }
        const group = groups[idx];
        const groupItems = group.items;
        let itemCount = count(groupItems, includeFooters);
        if (includeFooters && groupItems.length) {
            itemCount++;
        }
        const skipHeader = skip > 0;
        if (skip) {
            skip--;
            if (itemCount && skip >= itemCount) {
                skip -= itemCount;
                continue;
            }
        }
        if (!skipHeader || itemCount) {
            const items = [];
            let hideFooter = true;
            if (!skipHeader) {
                take$$1--;
            }
            if (take$$1) {
                if (hasGroups(groupItems)) {
                    const children = slice(groupItems, skip, take$$1, includeFooters);
                    items.push(...children);
                    take$$1 -= count(children, includeFooters);
                }
                else {
                    items.push(...groupItems.slice(skip, Math.min(skip + take$$1, groupItems.length)));
                    take$$1 -= items.length;
                }
                if (take$$1 && includeFooters) {
                    hideFooter = false;
                    take$$1--;
                }
                skip = 0;
            }
            result.push({
                aggregates: group.aggregates,
                field: group.field,
                hideFooter,
                items,
                offset: idx,
                skipHeader,
                value: group.value
            });
        }
    }
    return result;
};
const skippedHeaders = (groupItem) => {
    let total = 0;
    while (groupItem) {
        if (groupItem.skipHeader) {
            total++;
        }
        groupItem = groupItem.items && groupItem.items[0] || null;
    }
    return total;
};
/**
 * A directive which encapsulates the in-memory handling of grouping with virtual scrolling.
 */
let GroupBindingDirective = class GroupBindingDirective extends DataBindingDirective {
    constructor(grid, changeDetector, localDataChangesService) {
        super(grid, changeDetector, localDataChangesService);
    }
    /**
     * The array of data which will be used to populate the Grid.
     */
    set kendoGridGroupBinding(value) {
        this.groups = null;
        this.grid.resetGroupsState();
        this.data = value;
    }
    /**
     * @hidden
     */
    set data(value) {
        this.originalData = value || [];
        this.dataChanged = true;
    }
    /**
     * Defines the descriptors by which the data will be sorted.
     */
    set sort(value) {
        const clear = this.state.sort !== value;
        this.grid.sort = this.state.sort = value;
        if (clear) {
            this.groups = null;
            this.grid.resetGroupsState();
        }
    }
    /**
     * Defines the descriptor by which the data will be filtered.
     */
    set filter(value) {
        const clear = diffFilters(this.state.filter, value);
        if (clear) {
            this.state.filter = value;
            this.grid.filter = cloneFilters(value);
            this.groups = null;
            this.grid.resetGroupsState();
        }
    }
    /**
     * Defines the descriptors by which the data will be grouped.
     */
    set group(value) {
        // don't clear if no groups are present in previous and current value
        const groupsPresent = groupDescriptorsPresent(this.state.group) || groupDescriptorsPresent(value);
        const clear = this.state.group !== value && groupsPresent;
        this.grid.group = this.state.group = value;
        if (clear) {
            this.groups = null;
            this.grid.resetGroupsState();
            this.skip = 0;
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.grid.groupExpand.subscribe(this.groupExpand.bind(this));
        this.grid.groupCollapse.subscribe(this.groupCollapse.bind(this));
    }
    ngAfterContentInit() {
        if (isDevMode() && this.grid.isGroupExpanded) {
            throw new Error('Using the `kendoGridGroupBinding` directive in combination with the `kendoGridExpandGroupBy` directive ' +
                'or the `isGroupExpanded` callback is not supported. To use grouping with the `kendoGridGroupBinding` directive, ' +
                'set the Grid `groupable` property to `true`.');
        }
    }
    groupExpand({ groupIndex }) {
        this.grid.expandGroupChildren(groupIndex);
        const { group, parents } = findGroup(groupIndex, this.groups);
        if (!group.items.length) {
            const descriptors = this.state.group.filter(removeParentDescriptors(parents, group));
            const children = findChildren(this.originalData, parents.concat(group));
            group.items = processGroups(children, {
                filter: this.state.filter,
                group: descriptors,
                sort: this.state.sort
            });
        }
        this.grid.data = this.dataResult(this.state.skip, this.state.take);
    }
    groupCollapse({ groupIndex }) {
        const { group } = findGroup(groupIndex, this.groups);
        if (group) {
            group.items = [];
        }
        this.grid.data = this.dataResult(this.state.skip, this.state.take);
    }
    process(state$$1) {
        if (state$$1.group && state$$1.group.length) {
            const groups = this.processGroups(state$$1);
            this.grid.skip -= skippedHeaders(groups.data[0]);
            return groups;
        }
        else {
            this.groups = null;
        }
        return super.process(state$$1);
    }
    processGroups(state$$1) {
        if (!this.groups || !this.groups.length) {
            this.groups = processGroups(this.originalData, {
                filter: state$$1.filter,
                group: state$$1.group,
                sort: state$$1.sort
            });
        }
        return this.dataResult(state$$1.skip, state$$1.take);
    }
    dataResult(skip, take$$1) {
        const includeFooters = this.grid.showGroupFooters;
        return {
            data: slice(this.groups, skip, take$$1, includeFooters),
            total: count(this.groups, includeFooters)
        };
    }
    applyState({ skip, take: take$$1, sort, group, filter: filter$$1 }) {
        this.skip = skip;
        this.state.take = take$$1;
        // this.pageSize = take; // do need to update take as the process with slice correctly
        this.sort = sort;
        this.group = group;
        this.filter = filter$$1;
    }
};
GroupBindingDirective.ɵfac = function GroupBindingDirective_Factory(t) { return new (t || GroupBindingDirective)(ɵngcc0.ɵɵdirectiveInject(GridComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(LocalDataChangesService)); };
GroupBindingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: GroupBindingDirective, selectors: [["", "kendoGridGroupBinding", ""]], inputs: { kendoGridGroupBinding: "kendoGridGroupBinding", sort: "sort", filter: "filter", group: "group" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input("kendoGridGroupBinding"),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], GroupBindingDirective.prototype, "kendoGridGroupBinding", null);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], GroupBindingDirective.prototype, "sort", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], GroupBindingDirective.prototype, "filter", null);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], GroupBindingDirective.prototype, "group", null);
GroupBindingDirective = __decorate([ __metadata("design:paramtypes", [GridComponent, ChangeDetectorRef, LocalDataChangesService])
], GroupBindingDirective);

const exportedModules$4 = [
    GridComponent,
    ToolbarTemplateDirective,
    ToolbarComponent,
    GridSpacerComponent,
    DataBindingDirective,
    SelectionDirective,
    CustomMessagesComponent,
    GroupBindingDirective,
    TemplateEditingDirective,
    ReactiveEditingDirective,
    InCellEditingDirective,
    ExpandDetailsDirective,
    ExpandGroupDirective,
    ...GroupModule.exports(),
    ...SharedModule.exports(),
    ...BodyModule.exports(),
    ...HeaderModule.exports(),
    ...FooterModule.exports(),
    ...PagerModule.exports(),
    ...RowFilterModule.exports(),
    ...FilterMenuModule.exports(),
    ...ColumnMenuModule.exports()
];
const declarations = [
    GridComponent,
    ListComponent,
    ToolbarComponent,
    LocalizedMessagesDirective,
    CustomMessagesComponent,
    DataBindingDirective,
    ToolbarTemplateDirective,
    SelectionDirective,
    TemplateEditingDirective,
    ReactiveEditingDirective,
    InCellEditingDirective,
    ExpandDetailsDirective,
    ExpandGroupDirective,
    GroupBindingDirective,
    GridMarqueeDirective,
    GridSpacerComponent
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Grid component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Grid module
 * import { GridModule } from '@progress/kendo-angular-grid';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, GridModule], // import Grid module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let GridModule = class GridModule {
};
GridModule.ɵfac = function GridModule_Factory(t) { return new (t || GridModule)(); };
GridModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: GridModule });
GridModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            GroupModule,
            SharedModule,
            BodyModule,
            HeaderModule,
            FooterModule,
            PagerModule,
            RowFilterModule,
            FilterMenuModule,
            ResizeSensorModule,
            ColumnMenuModule
        ]] });

let PDFMarginComponent = class PDFMarginComponent extends PDFExportMarginComponent {
};
PDFMarginComponent.ɵfac = /*@__PURE__*/ function () { let ɵPDFMarginComponent_BaseFactory; return function PDFMarginComponent_Factory(t) { return (ɵPDFMarginComponent_BaseFactory || (ɵPDFMarginComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PDFMarginComponent)))(t || PDFMarginComponent); }; }();
PDFMarginComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PDFMarginComponent, selectors: [["kendo-grid-pdf-margin"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PDFMarginComponent_Template(rf, ctx) { }, encapsulation: 2 });

/**
 * Represents the PDF page template of the Grid that helps to customize the PDF pages. To define a page template,
 * nest an `<ng-template>` tag with the `kendoGridPDFTemplate` directive inside `<kendo-grid-pdf>`.
 *
 * The template context provides the following fields:
 * - `pageNumber`&mdash;Defines PDF page number.
 * - `totalPages`&mdash;Defines the total number of PDF pages.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-grid [data]="gridData">
 *             <ng-template kendoGridToolbarTemplate>
 *                 <button kendoGridPDFCommand icon="file-pdf">Export to PDF</button>
 *             </ng-template>
 *             <kendo-grid-column field="ProductName">
 *             </kendo-grid-column>
 *              <kendo-grid-column field="UnitPrice">
 *             </kendo-grid-column>
 *             <kendo-grid-pdf fileName="Products.pdf" paperSize="A4" [margin]="{ top: '1cm', left: '1cm', right: '1cm', bottom: '1cm' }">
 *                 <ng-template kendoGridPDFTemplate let-pageNum="pageNum" let-totalPages="totalPages">
 *                     <div style="position: absolute;top: 5px; left: 5px;">
 *                         Page {{ pageNum }} of {{ totalPages }}
 *                     </div>
 *                 </ng-template>
 *             </kendo-grid-pdf>
 *         </kendo-grid>
 *     `
 * })
 *
 * class AppComponent {
 *     public gridData = [{
 *         "ProductID": 1,
 *         "ProductName": "Chai",
 *         "UnitPrice": 18.0000
 *       }, {
 *         "ProductID": 2,
 *         "ProductName": "Chang",
 *         "UnitPrice": 19.0000
 *       }
 *     ];
 * }
 *
 * ```
 */
let PDFTemplateDirective = class PDFTemplateDirective extends PDFExportTemplateDirective {
    constructor(templateRef) {
        super(templateRef);
    }
};
PDFTemplateDirective.ɵfac = function PDFTemplateDirective_Factory(t) { return new (t || PDFTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PDFTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PDFTemplateDirective, selectors: [["", "kendoGridPDFTemplate", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
PDFTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], PDFTemplateDirective);

/**
 * @hidden
 */
const HEADER_CLASS = 'k-grid-header';
/**
 * @hidden
 */
const FOOTER_CLASS = 'k-grid-footer';
const GRID_LIST = 'KENDO-GRID-LIST';
const TABLE = 'TABLE';
const matchesList = matchesNodeName(GRID_LIST);
const matchesTable = matchesNodeName(TABLE);
const suffix = (locked) => locked ? 'locked' : 'wrap';
/**
 * @hidden
 */
class GridQuery {
    constructor(element) {
        this.element = element;
        this.list = findElement(element, matchesList);
    }
    content(locked) {
        return findElement(this.list, matchesClasses(`k-grid-content${locked ? '-locked' : ''}`));
    }
    header(locked) {
        this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses(HEADER_CLASS));
        return findElement(this.headerWrap, matchesClasses(`${HEADER_CLASS}-${suffix(locked)}`));
    }
    footer(locked) {
        this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses(FOOTER_CLASS));
        return findElement(this.footerWrap, matchesClasses(`${FOOTER_CLASS}-${suffix(locked)}`));
    }
    table() {
        return findElement(this.element, matchesTable);
    }
}

const FIRST_CLASS = 'k-first';
const INPUTS = ['input', 'select', 'textarea', 'option'];
/** @hidden */
const cloneNode = (node) => {
    const clone = node.cloneNode(false);
    if (node._kendoExportVisual) {
        clone._kendoExportVisual = node._kendoExportVisual;
    }
    if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {
        clone.removeAttribute("id");
        clone.removeAttribute("name");
        clone.value = node.value;
        clone.checked = node.checked;
        clone.selected = node.selected;
    }
    let child = node.firstChild;
    while (child) {
        clone.appendChild(cloneNode(child));
        child = child.nextSibling;
    }
    return clone;
};
const appendNodes = (element, nodes) => {
    const length = nodes.length;
    for (let idx = 0; idx < length; idx++) {
        element.appendChild(cloneNode(nodes[idx]));
    }
};
const wrapTable = (table) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'k-grid';
    wrapper.appendChild(table);
    return wrapper;
};
const createTableElement = (sources) => {
    const sourceCount = sources.length;
    const element = cloneNode(sources[0]);
    const rowsCount = element.rows.length;
    if (sourceCount > 1) {
        for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
            for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {
                appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);
            }
        }
    }
    return element;
};
const setFirstCellClass = (header, headers) => {
    if (headers.length > 1 && header.rows.length > 1) {
        for (let idx = 1; idx < header.rows.length; idx++) {
            const firstCellIndex = headers[0].rows[idx].cells.length;
            const cell = header.rows[idx].cells[firstCellIndex];
            if (String(cell.className).indexOf(FIRST_CLASS) === -1) {
                cell.className += ` ${FIRST_CLASS}`;
            }
        }
    }
};
const createTable = (colGroups, headers, bodies, footers) => {
    const table = document.createElement('table');
    const colGroup = colGroups[0].cloneNode(true);
    for (let idx = 1; idx < colGroups.length; idx++) {
        appendNodes(colGroup, colGroups[idx].querySelectorAll('col'));
    }
    const header = createTableElement(headers);
    const body = createTableElement(bodies);
    header.className = HEADER_CLASS;
    setFirstCellClass(header, headers);
    table.appendChild(colGroup);
    table.appendChild(header);
    table.appendChild(body);
    if (footers.length) {
        const footer = createTableElement(footers);
        footer.className = FOOTER_CLASS;
        table.appendChild(footer);
    }
    return wrapTable(table);
};
/**
 * @hidden
 */
const exportElement = (wrapper) => {
    const query = new GridQuery(wrapper);
    const content = query.content();
    let result;
    if (content) {
        const colGroups = [content.querySelector('colgroup')];
        const headers = [query.header().querySelector('thead')];
        const bodies = [content.querySelector('tbody')];
        const footer = query.footer();
        const footers = [];
        if (footer) {
            footers.push(footer.querySelector('tfoot'));
        }
        const lockedContent = query.content(true);
        if (lockedContent) {
            colGroups.unshift(lockedContent.querySelector('colgroup'));
            headers.unshift(query.header(true).querySelector('thead'));
            bodies.unshift(lockedContent.querySelector('tbody'));
            if (footer) {
                footers.unshift(query.footer(true).querySelector('tfoot'));
            }
        }
        result = createTable(colGroups, headers, bodies, footers);
    }
    else {
        result = wrapTable(query.table().cloneNode(true));
    }
    return result;
};

const createElement$1 = (tagName, className) => {
    const element = document.createElement(tagName);
    if (className) {
        element.className = className;
    }
    return element;
};
const createDiv = (className) => {
    return createElement$1('div', className);
};
/**
 * Configures the settings for the export of Grid in PDF ([see example]({% slug pdfexport_grid %})).
 */
let PDFComponent = class PDFComponent extends PDFExportComponent {
    constructor(pdfService, suspendService, ngZone, element) {
        super(element);
        this.pdfService = pdfService;
        this.suspendService = suspendService;
        this.ngZone = ngZone;
        /**
         * The delay in milliseconds before exporting the Grid content.
         * Useful for scenarios which involve exporting complex components used in the Grid
         * templates such as charts or data-bound components with asynchronous data retrieval ([see example]({% slug pdfexport_grid %}#toc-exporting-all-pages)).
         *
         * @default 0
         */
        this.delay = 0;
        this.columns = new QueryList();
        this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));
        this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));
        this.reset = this.reset.bind(this);
        this.draw = this.draw.bind(this);
    }
    ngOnDestroy() {
        this.saveSubscription.unsubscribe();
        this.drawSubscription.unsubscribe();
        this.reset();
    }
    /**
     * @hidden
     */
    saveAs(_) {
        throw new Error('Not supported. Use GridComponent.saveAsPDF');
    }
    /**
     * @hidden
     */
    export() {
        throw new Error('Not supported. Use GridComponent.drawPDF');
    }
    savePDF(component) {
        this.createPDF(component, this.draw);
    }
    drawPDF({ component, promise }) {
        this.createPDF(component, () => {
            this.createExportGroup(promise);
        });
    }
    createPDF(component, callback) {
        const pageSize = component.pageSize;
        const total = component.view.total;
        const columns = this.columns.toArray();
        if (columns.length) {
            this.originalColumns = component.columns.toArray();
        }
        this.component = component;
        this.suspendService.scroll = true;
        this.pdfService.exporting = true;
        this.initProgress();
        this.renderAllPages = this.allPages && pageSize < total;
        if (this.renderAllPages) {
            this.skip = component.skip;
            this.pageSize = pageSize;
            this.changePage(0, total, callback, columns);
        }
        else if (columns.length || component.virtualColumns) {
            this.changeColumns(columns, callback);
        }
        else {
            callback();
        }
    }
    initProgress() {
        const wrapperElement = this.component.wrapper.nativeElement;
        const progress = this.progress = createDiv('k-loading-pdf-mask');
        const overlay = cloneNode(wrapperElement);
        progress.appendChild(overlay);
        progress.appendChild(createDiv('k-loading-color'));
        progress.appendChild(createElement$1('span', 'k-i-loading k-icon'));
        this.originalHeight = wrapperElement.style.height;
        this.originalOverflow = wrapperElement.style.overflow;
        wrapperElement.style.height = wrapperElement.offsetHeight + 'px';
        wrapperElement.style.overflow = 'hidden';
        wrapperElement.appendChild(progress);
        this.applyScroll(overlay);
    }
    applyScroll(overlay) {
        const query = new GridQuery(this.component.wrapper.nativeElement);
        const content = query.content();
        if (content) {
            const overlayQuery = new GridQuery(overlay);
            const overlayContent = overlayQuery.content();
            overlayContent.scrollTop = content.scrollTop;
            overlayContent.scrollLeft = content.scrollLeft;
            overlayQuery.header().scrollLeft = query.header().scrollLeft;
            const footer = query.footer();
            if (footer) {
                overlayQuery.footer().scrollLeft = footer.scrollLeft;
            }
            const lockedContent = query.content(true);
            if (lockedContent) {
                const overlayLockedContent = overlayQuery.content(true);
                overlayLockedContent.scrollTop = lockedContent.scrollTop;
                overlayLockedContent.scrollLeft = lockedContent.scrollLeft;
            }
        }
    }
    draw() {
        this.createExportElement((element) => {
            this.save(element, this.fileName);
        });
    }
    createExportGroup(promise) {
        this.createExportElement((element) => {
            this.exportElement(element).then(group => promise.resolve(group));
        });
    }
    createExportElement(callback) {
        this.ngZone.runOutsideAngular(() => {
            const container = this.container = createDiv('k-grid-pdf-export-element');
            const element = exportElement(this.component.wrapper.nativeElement);
            container.appendChild(element);
            document.body.appendChild(container);
            callback(element);
        });
    }
    drawOptions() {
        const options = super.drawOptions();
        options._destructive = true;
        return options;
    }
    cleanup() {
        super.cleanup();
        this.pdfService.exporting = false;
        if (this.component) {
            const originalColumns = this.originalColumns;
            delete this.originalColumns;
            if (this.renderAllPages) {
                this.changePage(this.skip, this.pageSize, this.reset, originalColumns);
            }
            else if (originalColumns || this.component.virtualColumns) {
                this.changeColumns(originalColumns, this.reset);
            }
            else {
                this.reset();
            }
        }
        else {
            this.reset();
        }
        this.removeContainer();
    }
    removeContainer() {
        if (this.container) {
            document.body.removeChild(this.container);
            delete this.container;
        }
    }
    changePage(skip, _take, callback, columns) {
        this.ngZone.run(() => {
            this.pdfService.dataChanged.pipe(take(1)).subscribe(() => {
                if ((columns && columns.length) || this.component.virtualColumns) {
                    this.changeColumns(columns, callback);
                }
                else {
                    this.onStable(callback);
                }
            });
            this.component.notifyPageChange('pdf', { skip: skip, take: _take });
        });
    }
    changeColumns(columns, callback) {
        this.ngZone.run(() => {
            this.onStable(callback);
            if (columns && columns.length) {
                this.component.columns.reset(columns);
            }
        });
    }
    reset() {
        this.suspendService.scroll = false;
        this.renderAllPages = false;
        if (!this.component) {
            return;
        }
        const wrapperElement = this.component.wrapper.nativeElement;
        wrapperElement.removeChild(this.progress);
        wrapperElement.style.height = this.originalHeight;
        wrapperElement.style.overflow = this.originalOverflow;
        delete this.progress;
        delete this.component;
    }
    onStable(callback) {
        // not sure if it is an actual scenario. occurs in the tests.
        // onStable is triggered in the same pass without the change detection.
        // thus, the callback is called before the changes are applied without the timeout.
        setTimeout(() => {
            let onStable = this.ngZone.onStable.asObservable().pipe(take(1));
            if (this.delay > 0) {
                onStable = onStable.pipe(delay(this.delay));
            }
            onStable.subscribe(callback);
        }, 0); // tslint:disable-line: align
    }
};
PDFComponent.ɵfac = function PDFComponent_Factory(t) { return new (t || PDFComponent)(ɵngcc0.ɵɵdirectiveInject(PDFService), ɵngcc0.ɵɵdirectiveInject(SuspendService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
PDFComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PDFComponent, selectors: [["kendo-grid-pdf"]], contentQueries: function PDFComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PDFMarginComponent, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PDFTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase$1, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.marginComponent = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, inputs: { delay: "delay", allPages: "allPages" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PDFComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PDFComponent.prototype, "allPages", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], PDFComponent.prototype, "delay", void 0);
__decorate([
    ContentChildren(ColumnBase$1),
    __metadata("design:type", QueryList)
], PDFComponent.prototype, "columns", void 0);
__decorate([
    ContentChild(PDFMarginComponent, { static: false }),
    __metadata("design:type", PDFMarginComponent)
], PDFComponent.prototype, "marginComponent", void 0);
__decorate([
    ContentChild(PDFTemplateDirective, { static: false }),
    __metadata("design:type", PDFTemplateDirective)
], PDFComponent.prototype, "pageTemplateDirective", void 0);
PDFComponent = __decorate([ __metadata("design:paramtypes", [PDFService,
        SuspendService,
        NgZone,
        ElementRef])
], PDFComponent);

/**
 * Represents the `export-to-PDF` command of the Grid.
 * You can apply this directive to any `button` element inside a
 * [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).
 * When the user clicks a button that is associated with the directive, the
 * [pdfExport]({% slug api_grid_gridcomponent %}#toc-pdfexport) event
 * fires ([see example]({% slug pdfexport_grid %})).
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *      <ng-template kendoGridToolbarTemplate>
 *          <button kendoGridPDFCommand>Export to PDF</button>
 *      </ng-template>
 *      <kendo-grid-pdf fileName="Grid.pdf">
 *      </kendo-grid-pdf>
 * </kendo-grid>
 * ```
 */
let PDFCommandDirective = class PDFCommandDirective extends Button {
    constructor(pdfService, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.pdfService = pdfService;
        this.ngZone = ngZone;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.pdfService.exportClick.emit();
    }
    /**
     * @hidden
     */
    get pdfClass() {
        return true;
    }
};
PDFCommandDirective.ɵfac = function PDFCommandDirective_Factory(t) { return new (t || PDFCommandDirective)(ɵngcc0.ɵɵdirectiveInject(PDFService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
PDFCommandDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PDFCommandDirective, selectors: [["", "kendoGridPDFCommand", ""]], hostVars: 2, hostBindings: function PDFCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function PDFCommandDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-pdf", ctx.pdfClass);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PDFCommandDirective.prototype, "onClick", null);
__decorate([
    HostBinding('class.k-grid-pdf'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PDFCommandDirective.prototype, "pdfClass", null);
PDFCommandDirective = __decorate([ __metadata("design:paramtypes", [PDFService,
        ElementRef,
        Renderer2,
        LocalizationService,
        NgZone])
], PDFCommandDirective);

const exportedModules$5 = [
    PDFComponent,
    PDFMarginComponent,
    PDFCommandDirective,
    PDFTemplateDirective
];
const declarations$1 = [
    PDFComponent,
    PDFMarginComponent,
    PDFCommandDirective,
    PDFTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Grid PDF component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Grid and PDF modules
 * import { GridModule, PDFModule } from '@progress/kendo-angular-grid';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, GridModule, PDFModule], // import Grid and PDF modules
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let PDFModule = class PDFModule {
};
PDFModule.ɵfac = function PDFModule_Factory(t) { return new (t || PDFModule)(); };
PDFModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: PDFModule });
PDFModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});

/**
 * Arguments for the `excelExport` event.
 */
class ExcelExportEvent extends PreventableEvent {
    constructor(workbook) {
        super();
        this.workbook = workbook;
    }
}

/* tslint:disable object-literal-sort-keys */
const fetchComponentData = (component) => {
    return {
        data: component.view.map(item => item),
        group: component.group
    };
};
const toExcelColumn = (column) => {
    return {
        title: column.title,
        field: column.field,
        locked: Boolean(column.locked),
        width: column.width,
        level: column.level,
        hidden: !column.isVisible,
        groupHeaderTemplate: column.groupHeaderTemplate,
        groupHeaderColumnTemplate: column.groupHeaderColumnTemplate,
        groupFooterTemplate: column.groupFooterTemplate,
        footerTemplate: column.footerTemplate
    };
};
const toExcelColumns = (columns) => {
    const result = [];
    sortColumns(columns)
        .forEach((column) => {
        if (column.isSpanColumn) {
            result.push(...toExcelColumns(column.childrenArray));
        }
        else {
            const excelColumn = toExcelColumn(column);
            if (column.isColumnGroup) {
                excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));
            }
            result.push(excelColumn);
        }
    });
    return result;
};
const componentColumns = (component) => {
    const columns = toExcelColumns(component.columns.toArray());
    return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);
};
/**
 * Configures the settings for the export of Grid in Excel ([see example]({% slug excelexport_grid %})).
 */
let ExcelComponent = class ExcelComponent {
    constructor(excelService, localization, zone) {
        this.localization = localization;
        this.zone = zone;
        /**
         * Specifies the file name of the exported Excel file.
         * @default "Export.xlsx"
         */
        this.fileName = 'Export.xlsx';
        /**
         * @hidden
         */
        this.columns = new QueryList();
        this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));
    }
    ngOnDestroy() {
        this.saveSubscription.unsubscribe();
        if (this.dataSubscription) {
            this.dataSubscription.unsubscribe();
        }
    }
    save(component) {
        const data = (this.fetchData || fetchComponentData)(component);
        const exportData = (result) => {
            delete this.dataSubscription;
            this.exportData(component, result);
        };
        if (data instanceof Promise) {
            data.then(exportData);
        }
        else if (data instanceof Observable) {
            this.dataSubscription = data.pipe(take(1)).subscribe(exportData);
        }
        else {
            exportData(data);
        }
    }
    exportData(component, result) {
        const options = workbookOptions({
            columns: this.columns.length ? this.columns : componentColumns(component),
            data: result.data,
            group: result.group,
            filterable: this.filterable,
            creator: this.creator,
            date: this.date,
            paddingCellOptions: this.paddingCellOptions,
            headerPaddingCellOptions: this.headerPaddingCellOptions,
            rtl: this.localization.rtl,
            collapsible: this.collapsible
        });
        const args = new ExcelExportEvent(options);
        component.excelExport.emit(args);
        if (!args.isDefaultPrevented()) {
            this.zone.runOutsideAngular(() => this.saveFile(options));
        }
    }
    saveFile(options) {
        toDataURL(options).then((dataURL) => {
            saveAs(dataURL, this.fileName, {
                forceProxy: this.forceProxy,
                proxyURL: this.proxyURL
            });
        });
    }
};
ExcelComponent.ɵfac = function ExcelComponent_Factory(t) { return new (t || ExcelComponent)(ɵngcc0.ɵɵdirectiveInject(ExcelService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ExcelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ExcelComponent, selectors: [["kendo-grid-excel"]], contentQueries: function ExcelComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, inputs: { fileName: "fileName", filterable: "filterable", creator: "creator", date: "date", forceProxy: "forceProxy", proxyURL: "proxyURL", fetchData: "fetchData", paddingCellOptions: "paddingCellOptions", headerPaddingCellOptions: "headerPaddingCellOptions", collapsible: "collapsible" }, decls: 0, vars: 0, template: function ExcelComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ExcelComponent.prototype, "fileName", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ExcelComponent.prototype, "filterable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ExcelComponent.prototype, "creator", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], ExcelComponent.prototype, "date", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ExcelComponent.prototype, "forceProxy", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ExcelComponent.prototype, "proxyURL", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ExcelComponent.prototype, "fetchData", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ExcelComponent.prototype, "paddingCellOptions", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ExcelComponent.prototype, "headerPaddingCellOptions", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ExcelComponent.prototype, "collapsible", void 0);
__decorate([
    ContentChildren(ColumnBase, { descendants: true }),
    __metadata("design:type", QueryList)
], ExcelComponent.prototype, "columns", void 0);
ExcelComponent = __decorate([ __metadata("design:paramtypes", [ExcelService,
        LocalizationService,
        NgZone])
], ExcelComponent);

/**
 * Represents the `export-to-Excel` command of the Grid. You can apply this
 * directive to any `button` element inside a
 * [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).
 * When the user clicks a button associated with the directive, the
 * [excelExport]({% slug api_grid_gridcomponent %}#toc-excelexport) event
 * fires ([see example]({% slug excelexport_grid %})).
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *      <ng-template kendoGridToolbarTemplate>
 *          <button kendoGridExcelCommand>Export to PDF</button>
 *      </ng-template>
 *      <kendo-grid-excel fileName="Grid.xlsx">
 *      </kendo-grid-excel>
 * </kendo-grid>
 * ```
 */
let ExcelCommandDirective = class ExcelCommandDirective extends Button {
    constructor(excelService, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.excelService = excelService;
        this.ngZone = ngZone;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.excelService.exportClick.emit();
    }
    /**
     * @hidden
     */
    get excelClass() {
        return true;
    }
};
ExcelCommandDirective.ɵfac = function ExcelCommandDirective_Factory(t) { return new (t || ExcelCommandDirective)(ɵngcc0.ɵɵdirectiveInject(ExcelService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ExcelCommandDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ExcelCommandDirective, selectors: [["", "kendoGridExcelCommand", ""]], hostVars: 2, hostBindings: function ExcelCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ExcelCommandDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-excel", ctx.excelClass);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ExcelCommandDirective.prototype, "onClick", null);
__decorate([
    HostBinding('class.k-grid-excel'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ExcelCommandDirective.prototype, "excelClass", null);
ExcelCommandDirective = __decorate([ __metadata("design:paramtypes", [ExcelService,
        ElementRef,
        Renderer2,
        LocalizationService,
        NgZone])
], ExcelCommandDirective);

const declarations$2 = [ExcelComponent, ExcelCommandDirective];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Excel component of the Grid.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Grid and Excel modules
 * import { GridModule, ExcelModule } from '@progress/kendo-angular-grid';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, GridModule, ExcelModule], // import Grid and Excel modules
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let ExcelModule = class ExcelModule {
};
ExcelModule.ɵfac = function ExcelModule_Factory(t) { return new (t || ExcelModule)(); };
ExcelModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ExcelModule });
ExcelModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [ExcelExportModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridSpacerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-spacer, kendo-pager-spacer',
                template: ``
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-spacer']
        }], sizedClass: [{
            type: HostBinding,
            args: ['class.k-spacer-sized']
        }], flexBasisStyle: [{
            type: HostBinding,
            args: ['style.flexBasis']
        }], width: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DomEventsService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalDataChangesService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FocusRoot, [{
        type: Injectable
    }], function () { return [{ type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [FOCUS_ROOT_ACTIVE]
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FocusableDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridFocusable]' + `,
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridCancelCommand],
        [kendoGridSelectionCheckbox]
    `
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CELL_CONTEXT]
            }, {
                type: SkipSelf
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { enabled: [{
            type: Input,
            args: ['kendoGridFocusable']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EditService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupsService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DetailsService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollRequestService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: DomEventsService }, { type: PagerContextService }, { type: ScrollRequestService }, { type: GroupsService }, { type: DetailsService }, { type: FocusRoot }, { type: EditService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.LocalizationService }, { type: FocusableDirective, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SelectionService, [{
        type: Injectable
    }], function () { return [{ type: DomEventsService }, { type: LocalDataChangesService }, { type: NavigationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CellSelectionService, [{
        type: Injectable
    }], function () { return [{ type: DomEventsService }, { type: LocalDataChangesService }, { type: NavigationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridMarqueeDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridSelectionMarquee]'
            }]
    }], function () { return [{ type: ɵngcc2.DraggableDirective }, { type: SelectionService }, { type: CellSelectionService }, { type: DomEventsService }]; }, { webkitUserSelection: [{
            type: HostBinding,
            args: ['style.-webkit-user-select']
        }], userSelection: [{
            type: HostBinding,
            args: ['class.user-select-none']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridGroupHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupHeaderColumnTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridGroupHeaderColumnTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EditTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridEditTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridGroupFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridColumnMenuTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridFilterCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterMenuTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridFilterMenuTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IdService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => ColumnComponent_1)
                    }
                ],
                selector: 'kendo-grid-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: IdService, decorators: [{
                type: Optional
            }] }]; }, { sortable: [{
            type: Input
        }], groupable: [{
            type: Input
        }], editor: [{
            type: Input
        }], filter: [{
            type: Input
        }], filterable: [{
            type: Input
        }], editable: [{
            type: Input
        }], field: [{
            type: Input
        }], format: [{
            type: Input
        }], template: [{
            type: ContentChild,
            args: [CellTemplateDirective, { static: false }]
        }], groupHeaderTemplate: [{
            type: ContentChild,
            args: [GroupHeaderTemplateDirective, { static: false }]
        }], groupHeaderColumnTemplate: [{
            type: ContentChild,
            args: [GroupHeaderColumnTemplateDirective, { static: false }]
        }], groupFooterTemplate: [{
            type: ContentChild,
            args: [GroupFooterTemplateDirective, { static: false }]
        }], editTemplate: [{
            type: ContentChild,
            args: [EditTemplateDirective, { static: false }]
        }], filterCellTemplate: [{
            type: ContentChild,
            args: [FilterCellTemplateDirective, { static: false }]
        }], filterMenuTemplate: [{
            type: ContentChild,
            args: [FilterMenuTemplateDirective, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SpanColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => SpanColumnComponent_1)
                    }
                ],
                selector: 'kendo-grid-span-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: IdService, decorators: [{
                type: Optional
            }] }]; }, { template: [{
            type: ContentChildren,
            args: [CellTemplateDirective, { descendants: false }]
        }], editTemplate: [{
            type: ContentChildren,
            args: [EditTemplateDirective, { descendants: false }]
        }], childColumns: [{
            type: ContentChildren,
            args: [ColumnComponent]
        }], editable: [{
            type: Input
        }], locked: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnGroupComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => ColumnGroupComponent_1)
                    }
                ],
                selector: 'kendo-grid-column-group',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: IdService, decorators: [{
                type: Optional
            }] }]; }, { children: [{
            type: ContentChildren,
            args: [ColumnBase$1]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DetailTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridDetailTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, { showIf: [{
            type: Input,
            args: ["kendoGridDetailTemplateShowIf"]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BrowserSupportService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChangeNotificationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NoRecordsTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridNoRecordsTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MenuTabbingService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoPagerTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PDFService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SuspendService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResponsiveService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExcelService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToolbarTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridToolbarTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, { position: [{
            type: Input,
            args: ["position"]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollSyncService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResizeService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnResizingService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SinglePopupService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc3.PopupService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ScrollSyncService }, { type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragAndDropService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragHintService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc4.DomSanitizer }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropCueService, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnReorderService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnInfoService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CellLoadingTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridCellLoadingTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoadingTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridLoadingTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridComponent, [{
        type: Component,
        args: [{
                encapsulation: ViewEncapsulation.None,
                exportAs: 'kendoGrid',
                providers: [
                    BrowserSupportService,
                    LocalizationService,
                    ColumnInfoService,
                    SelectionService,
                    CellSelectionService,
                    DetailsService,
                    GroupsService,
                    GroupInfoService,
                    ChangeNotificationService,
                    EditService,
                    PDFService,
                    SuspendService,
                    {
                        provide: CELL_CONTEXT,
                        useValue: ɵ5$1
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.grid'
                    },
                    FilterService,
                    ResponsiveService,
                    PagerContextService,
                    ExcelService,
                    ScrollSyncService,
                    ResizeService,
                    LocalDataChangesService,
                    DomEventsService,
                    ColumnResizingService,
                    SinglePopupService,
                    DragAndDropService,
                    DragHintService,
                    DropCueService,
                    ColumnReorderService,
                    NavigationService,
                    FocusRoot,
                    IdService,
                    ScrollRequestService,
                    SortService
                ],
                selector: 'kendo-grid',
                styles: [
                    // Styles for backwards compatibility with kendo-theme-default@v2.46.0 and earlier.
                    `   .k-grid .k-grid-aria-root {
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            overflow: hidden;
        }

        .k-grid .k-filter-row td {
            white-space: nowrap;
        }`
                ],
                template: `
        <ng-container kendoGridLocalizedMessages
            i18n-groupPanelEmpty="kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty"
            groupPanelEmpty="Drag a column header and drop it here to group by that column"

            i18n-noRecords="kendo.grid.noRecords|The label visible in the Grid when there are no records"
            noRecords="No records available."

            i18n-pagerLabel="kendo.grid.pagerLabel|The label for the Grid pager"
            pagerLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

            i18n-pagerFirstPage="kendo.grid.pagerFirstPage|The label for the first page button in Grid pager"
            pagerFirstPage="Go to the first page"

            i18n-pagerPreviousPage="kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager"
            pagerPreviousPage="Go to the previous page"

            i18n-pagerNextPage="kendo.grid.pagerNextPage|The label for the next page button in Grid pager"
            pagerNextPage="Go to the next page"

            i18n-pagerLastPage="kendo.grid.pagerLastPage|The label for the last page button in Grid pager"
            pagerLastPage="Go to the last page"

            i18n-pagerPage="kendo.grid.pagerPage|The label before the current page number in the Grid pager"
            pagerPage="Page"

            i18n-pagerOf="kendo.grid.pagerOf|The label before the total pages number in the Grid pager"
            pagerOf="of"

            i18n-pagerItems="kendo.grid.pagerItems|The label after the total pages number in the Grid pager"
            pagerItems="items"

            i18n-pagerPageNumberInputTitle="kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager"
            pagerPageNumberInputTitle="Page Number"

            i18n-pagerItemsPerPage="kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager"
            pagerItemsPerPage="items per page"

            i18n-filter="kendo.grid.filter|The label of the filter cell or icon"
            filter="Filter"

            i18n-filterInputLabel="kendo.grid.filterInputLabel|The label of the filter row and menu inputs"
            filterInputLabel="{{ '{columnName} Filter' }}"

            i18n-filterMenuTitle="kendo.grid.filterMenuTitle|The title of the filter menu icon"
            filterMenuTitle="{{ '{columnName} Filter Menu' }}"

            i18n-filterMenuOperatorsDropDownLabel="kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown"
            filterMenuOperatorsDropDownLabel="{{ '{columnName} Filter Operators' }}"

            i18n-filterMenuLogicDropDownLabel="kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown"
            filterMenuLogicDropDownLabel="{{ '{columnName} Filter Logic' }}"

            i18n-filterEqOperator="kendo.grid.filterEqOperator|The text of the equal filter operator"
            filterEqOperator="Is equal to"

            i18n-filterNotEqOperator="kendo.grid.filterNotEqOperator|The text of the not equal filter operator"
            filterNotEqOperator="Is not equal to"

            i18n-filterIsNullOperator="kendo.grid.filterIsNullOperator|The text of the is null filter operator"
            filterIsNullOperator="Is null"

            i18n-filterIsNotNullOperator="kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator"
            filterIsNotNullOperator="Is not null"

            i18n-filterIsEmptyOperator="kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator"
            filterIsEmptyOperator="Is empty"

            i18n-filterIsNotEmptyOperator="kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator"
            filterIsNotEmptyOperator="Is not empty"

            i18n-filterStartsWithOperator="kendo.grid.filterStartsWithOperator|The text of the starts with filter operator"
            filterStartsWithOperator="Starts with"

            i18n-filterContainsOperator="kendo.grid.filterContainsOperator|The text of the contains filter operator"
            filterContainsOperator="Contains"

            i18n-filterNotContainsOperator="kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator"
            filterNotContainsOperator="Does not contain"

            i18n-filterEndsWithOperator="kendo.grid.filterEndsWithOperator|The text of the ends with filter operator"
            filterEndsWithOperator="Ends with"

            i18n-filterGteOperator="kendo.grid.filterGteOperator|The text of the greater than or equal filter operator"
            filterGteOperator="Is greater than or equal to"

            i18n-filterGtOperator="kendo.grid.filterGtOperator|The text of the greater than filter operator"
            filterGtOperator="Is greater than"

            i18n-filterLteOperator="kendo.grid.filterLteOperator|The text of the less than or equal filter operator"
            filterLteOperator="Is less than or equal to"

            i18n-filterLtOperator="kendo.grid.filterLtOperator|The text of the less than filter operator"
            filterLtOperator="Is less than"

            i18n-filterIsTrue="kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option"
            filterIsTrue="Is True"

            i18n-filterIsFalse="kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option"
            filterIsFalse="Is False"

            i18n-filterBooleanAll="kendo.grid.filterBooleanAll|The text of the (All) boolean filter option"
            filterBooleanAll="(All)"

            i18n-filterAfterOrEqualOperator="kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator"
            filterAfterOrEqualOperator="Is after or equal to"

            i18n-filterAfterOperator="kendo.grid.filterAfterOperator|The text of the after date filter operator"
            filterAfterOperator="Is after"

            i18n-filterBeforeOperator="kendo.grid.filterBeforeOperator|The text of the before date filter operator"
            filterBeforeOperator="Is before"

            i18n-filterBeforeOrEqualOperator="kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator"
            filterBeforeOrEqualOperator="Is before or equal to"

            i18n-filterFilterButton="kendo.grid.filterFilterButton|The text of the filter button"
            filterFilterButton="Filter"

            i18n-filterClearButton="kendo.grid.filterClearButton|The text of the clear filter button"
            filterClearButton="Clear"

            i18n-filterAndLogic="kendo.grid.filterAndLogic|The text of the And filter logic"
            filterAndLogic="And"

            i18n-filterOrLogic="kendo.grid.filterOrLogic|The text of the Or filter logic"
            filterOrLogic="Or"

            i18n-loading="kendo.grid.loading|The loading text"
            loading="Loading"

            i18n-gridLabel="kendo.grid.gridLabel|The Grid aria-label"
            gridLabel="Data table"

            i18n-columnMenu="kendo.grid.columnMenu|The title of the column menu icon"
            columnMenu="{{ '{columnName} Column Menu' }}"

            i18n-columns="kendo.grid.columns|The text shown in the column menu for the columns item"
            columns="Columns"

            i18n-lock="kendo.grid.lock|The text shown in the column menu for the lock item"
            lock="Lock"

            i18n-unlock="kendo.grid.unlock|The text shown in the column menu for the unlock item"
            unlock="Unlock"

            i18n-setColumnPosition="kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item"
            setColumnPosition="Set Column Position"

            i18n-stick="kendo.grid.stick|The text shown in the column menu for the stick item"
            stick="Stick"

            i18n-unstick="kendo.grid.unstick|The text shown in the column menu for the unstick item"
            unstick="Unstick"

            i18n-sortable="kendo.grid.sortable|The label of the sort icon"
            sortable="Sortable"

            i18n-sortAscending="kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item"
            sortAscending="Sort Ascending"

            i18n-sortDescending="kendo.grid.sortDescending|The text shown in the column menu for the sort descending item"
            sortDescending="Sort Descending"

            i18n-sortedAscending="kendo.grid.sortedAscending|The status announcement when a column is sorted ascending"
            sortedAscending="Sorted Ascending"

            i18n-sortedDescending="kendo.grid.sortedDescending|The status announcement when a column is sorted descending"
            sortedDescending="Sorted Descending"

            i18n-sortedDefault="kendo.grid.sortedDefault|The status announcement when a column is no longer sorted"
            sortedDefault="Not Sorted"

            i18n-columnsApply="kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button"
            columnsApply="Apply"

            i18n-columnsReset="kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button"
            columnsReset="Reset"

            i18n-detailExpand="kendo.grid.detailExpand|The title of the expand icon of detail rows."
            detailExpand="Expand Details"

            i18n-detailCollapse="kendo.grid.detailCollapse|The title of the collapse icon of detail rows."
            detailCollapse="Collapse Details"

            i18n-filterDateToday="kendo.grid.filterDateToday|The text of the Today button of the Date filter."
            filterDateToday="TODAY"

            i18n-filterDateToggle="kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter."
            filterDateToggle="Toggle Calendar"

            i18n-filterNumericDecrement="kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter."
            filterNumericDecrement="Decrement"

            i18n-filterNumericIncrement="kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter."
            filterNumericIncrement="Increment"

            i18n-selectionCheckboxLabel="kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes."
            selectionCheckboxLabel="Select Row"

            i18n-selectAllCheckboxLabel="kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox."
            selectAllCheckboxLabel="Select All Rows"

            i18n-groupCollapse="kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows."
            groupCollapse="Collapse Group"

            i18n-groupExpand="kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows."
            groupExpand="Expand Group"
        >
        </ng-container>
        <kendo-grid-toolbar class="k-toolbar k-grid-toolbar" *ngIf="showTopToolbar" position="top"></kendo-grid-toolbar>
        <kendo-pager
            *ngIf="showTopPager"
            [tabindex]="navigable ? '0' : '-1'"
            [attr.role]="navigable ? 'navigation' : undefined"
            class="k-grid-pager-top"
            [template]="pagerTemplate"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [options]="pageable"
            (pageChange)="notifyPageChange('pager', $event)">
        </kendo-pager>
        <kendo-grid-group-panel
            *ngIf="showGroupPanel"
            [text]="groupableEmptyText"
            [groups]="group"
            (change)="groupChange.emit($event)">
        </kendo-grid-group-panel>
        <div #ariaRoot
            class="k-grid-aria-root"
            role="grid"
            [attr.aria-label]="ariaLabel"
            [attr.aria-rowcount]="ariaRowCount"
            [attr.aria-colcount]="ariaColCount">
        <ng-template [ngIf]="isScrollable">
            <div *ngIf="!hideHeader"
                class="k-grid-header"
                role="presentation"
                [style.padding]="headerPadding">
                <div *ngIf="isLocked"
                     #lockedHeader
                     role="presentation"
                     class="k-grid-header-locked"
                     [style.width.px]="lockedWidth">
                    <table [locked]="true" role="presentation" [style.width.px]="lockedWidth">
                        <colgroup kendoGridColGroup
                            role="presentation"
                            [columns]="lockedLeafColumns"
                            [groups]="group"
                            [detailTemplate]="detailTemplate">
                        </colgroup>
                        <thead kendoGridHeader
                            [resizable]="resizable"
                            [scrollable]="true"
                            [columns]="lockedColumns"
                            [totalColumnLevels]="totalColumnLevels"
                            [sort]="sort"
                            [groups]="group"
                            [filter]="filter"
                            [filterable]="filterable"
                            [groupable]="showGroupPanel"
                            [reorderable]="reorderable"
                            [sortable]="sortable"
                            [columnMenu]="columnMenuOptions"
                            [columnMenuTemplate]="columnMenuTemplate"
                            [totalColumnsCount]="leafColumns.length"
                            [detailTemplate]="detailTemplate"
                            [tabIndex]="navigable ? '-1' : '0'">
                        </thead>
                    </table>
                </div><div #header class="k-grid-header-wrap" role="presentation" data-scrollable
                    [kendoGridResizableContainer]="lockedLeafColumns.length"
                    [lockedWidth]="lockedWidth + scrollbarWidth + 2">
                    <table role="presentation" [style.width.px]="nonLockedWidth" [virtualColumns]="virtualColumns">
                        <colgroup kendoGridColGroup
                            role="presentation"
                            [columns]="headerLeafColumns"
                            [groups]="isLocked ? [] : group"
                            [detailTemplate]="detailTemplate">
                        </colgroup>
                        <thead kendoGridHeader
                            [resizable]="resizable"
                            role="presentation"
                            [scrollable]="true"
                            [columns]="headerColumns"
                            [totalColumnLevels]="totalColumnLevels"
                            [sort]="sort"
                            [filter]="filter"
                            [filterable]="filterable"
                            [groupable]="showGroupPanel"
                            [reorderable]="reorderable"
                            [groups]="isLocked ? [] : group"
                            [sortable]="sortable"
                            [columnMenu]="columnMenuOptions"
                            [columnMenuTemplate]="columnMenuTemplate"
                            [lockedColumnsCount]="lockedLeafColumns.length"
                            [totalColumnsCount]="leafColumns.length"
                            [detailTemplate]="detailTemplate"
                            [tabIndex]="navigable ? '-1' : '0'">
                        </thead>
                    </table>
                    <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
                        <div [style.width.px]="columnsContainer.unlockedWidth"></div>
                    </div>
                </div>
            </div>
            <kendo-grid-list
                [data]="view"
                [rowHeight]="rowHeight"
                [detailRowHeight]="detailRowHeight"
                [total]="totalCount"
                [take]="pageSize"
                [groups]="group"
                [groupable]="groupable"
                [skip]="skip"
                [trackBy]="trackBy"
                [columns]="columnsContainer"
                [selectable]="selectable"
                [filterable]="filterable"
                [detailTemplate]="detailTemplate"
                [noRecordsTemplate]="noRecordsTemplate"
                (pageChange)="notifyPageChange('list', $event)"
                [rowClass]="rowClass"
                [rowSticky]="rowSticky"
                [loading]="loading"
                [isVirtual]="isVirtual"
                [cellLoadingTemplate]="cellLoadingTemplate?.templateRef"
                [loadingTemplate]="loadingTemplate?.templateRef"
                [virtualColumns]="virtualColumns"
                (scrollBottom)="notifyScrollBottom()"
                (contentScroll)="contentScroll.emit($event)"
                kendoDraggable
                kendoGridSelectionMarquee
                [enableDrag]="marqueeSelection"
                >
            </kendo-grid-list>
            <div
                *ngIf="showFooter"
                class="k-grid-footer"
                [style.padding]="headerPadding">
                <div
                    *ngIf="lockedLeafColumns.length"
                    class="k-grid-footer-locked"
                    [style.width.px]="lockedWidth">
                    <table role="presentation" [locked]="true" [style.width.px]="lockedWidth">
                        <colgroup kendoGridColGroup
                            [columns]="lockedLeafColumns"
                            [groups]="group"
                            [detailTemplate]="detailTemplate">
                        </colgroup>
                        <tfoot kendoGridFooter
                            [scrollable]="true"
                            [groups]="group"
                            [columns]="lockedLeafColumns"
                            [detailTemplate]="detailTemplate"
                            [logicalRowIndex]="ariaRowCount">
                        </tfoot>
                    </table>
                </div><div #footer
                    class="k-grid-footer-wrap" data-scrollable
                    [kendoGridResizableContainer]="lockedLeafColumns.length"
                    [lockedWidth]="lockedWidth + scrollbarWidth + 3">
                    <table role="presentation" [style.width.px]="nonLockedWidth">
                        <colgroup kendoGridColGroup
                            [columns]="nonLockedLeafColumns"
                            [groups]="isLocked ? [] : group"
                            [detailTemplate]="detailTemplate">
                        </colgroup>
                        <tfoot kendoGridFooter
                            [logicalRowIndex]="ariaRowCount"
                            [scrollable]="true"
                            [groups]="isLocked ? [] : group"
                            [columns]="nonLockedLeafColumns"
                            [lockedColumnsCount]="lockedLeafColumns.length"
                            [detailTemplate]="detailTemplate">
                        </tfoot>
                    </table>
                </div>
            </div>
        </ng-template>
        <ng-template [ngIf]="!isScrollable">
            <table [style.table-layout]="resizable ? 'fixed' : null">
                <colgroup kendoGridColGroup
                    [columns]="leafColumns"
                    [groups]="group"
                    [detailTemplate]="detailTemplate">
                </colgroup>
                <thead kendoGridHeader
                    *ngIf="!hideHeader"
                    [resizable]="resizable"
                    [scrollable]="false"
                    [columns]="visibleColumns"
                    [totalColumnLevels]="totalColumnLevels"
                    [groups]="group"
                    [groupable]="showGroupPanel"
                    [reorderable]="reorderable"
                    [sort]="sort"
                    [sortable]="sortable"
                    [filter]="filter"
                    [filterable]="filterable"
                    [columnMenu]="columnMenuOptions"
                    [columnMenuTemplate]="columnMenuTemplate"
                    [detailTemplate]="detailTemplate"
                    [tabIndex]="navigable ? '-1' : '0'">
                </thead>
                <tbody kendoGridTableBody
                    [isLoading]="loading"
                    [groups]="group"
                    [data]="view"
                    [skip]="skip"
                    [columns]="leafColumns"
                    [selectable]="selectable"
                    [filterable]="filterable"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [detailTemplate]="detailTemplate"
                    [showGroupFooters]="showGroupFooters"
                    [trackBy]="trackBy"
                    [rowClass]="rowClass"
                    kendoDraggable
                    kendoGridSelectionMarquee
                    [enableDrag]="marqueeSelection">
                </tbody>
                <tfoot kendoGridFooter
                    *ngIf="showFooter"
                    [scrollable]="false"
                    [logicalRowIndex]="ariaRowCount"
                    [groups]="group"
                    [columns]="leafColumns"
                    [detailTemplate]="detailTemplate">
                </tfoot>
            </table>
        </ng-template>
        <div [loadingTemplate]="loadingTemplate" *ngIf="loading" kendoGridLoading>
        </div>
        </div>
        <kendo-pager
            *ngIf="showBottomPager"
            [tabindex]="navigable ? '0' : '-1'"
            [attr.role]="navigable ? 'navigation' : undefined"
            [template]="pagerTemplate"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [options]="pageable"
            (pageChange)="notifyPageChange('pager', $event)">
        </kendo-pager>
        <kendo-grid-toolbar class="k-toolbar k-grid-toolbar k-grid-toolbar-bottom" *ngIf="showBottomToolbar" position="bottom"></kendo-grid-toolbar>
    `
            }]
    }], function () { return [{ type: BrowserSupportService }, { type: SelectionService }, { type: CellSelectionService }, { type: ɵngcc0.ElementRef }, { type: GroupInfoService }, { type: GroupsService }, { type: ChangeNotificationService }, { type: DetailsService }, { type: EditService }, { type: FilterService }, { type: PDFService }, { type: ResponsiveService }, { type: ɵngcc0.Renderer2 }, { type: ExcelService }, { type: ɵngcc0.NgZone }, { type: ScrollSyncService }, { type: DomEventsService }, { type: ColumnResizingService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ColumnReorderService }, { type: ColumnInfoService }, { type: NavigationService }, { type: SortService }, { type: ScrollRequestService }, { type: ɵngcc1.LocalizationService }]; }, { data: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], selectable: [{
            type: Input
        }], trackBy: [{
            type: Input
        }], virtualColumns: [{
            type: Input
        }], filterable: [{
            type: Input
        }], sortable: [{
            type: Input
        }], pageable: [{
            type: Input
        }], groupable: [{
            type: Input
        }], navigable: [{
            type: Input
        }], autoSize: [{
            type: Input
        }], resizable: [{
            type: Input
        }], reorderable: [{
            type: Input
        }], loading: [{
            type: Input
        }], columnMenu: [{
            type: Input
        }], hideHeader: [{
            type: Input
        }], filterChange: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], groupChange: [{
            type: Output
        }], sortChange: [{
            type: Output
        }], selectionChange: [{
            type: Output
        }], dataStateChange: [{
            type: Output
        }], groupExpand: [{
            type: Output
        }], groupCollapse: [{
            type: Output
        }], detailExpand: [{
            type: Output
        }], detailCollapse: [{
            type: Output
        }], edit: [{
            type: Output
        }], cancel: [{
            type: Output
        }], save: [{
            type: Output
        }], remove: [{
            type: Output
        }], add: [{
            type: Output
        }], cellClose: [{
            type: Output
        }], cellClick: [{
            type: Output
        }], pdfExport: [{
            type: Output
        }], excelExport: [{
            type: Output
        }], columnResize: [{
            type: Output
        }], columnReorder: [{
            type: Output
        }], columnVisibilityChange: [{
            type: Output
        }], columnLockedChange: [{
            type: Output
        }], columnStickyChange: [{
            type: Output
        }], scrollBottom: [{
            type: Output
        }], contentScroll: [{
            type: Output
        }], columns: [{
            type: ContentChildren,
            args: [ColumnBase$1]
        }], footer: [{
            type: ViewChildren,
            args: ['footer']
        }], skip: [{
            type: Input
        }], sort: [{
            type: Input
        }], group: [{
            type: Input
        }], navigatable: [{
            type: Input
        }], rowClass: [{
            type: Input
        }], rowSticky: [{
            type: Input
        }], rowSelected: [{
            type: Input
        }], cellSelected: [{
            type: Input
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-grid']
        }], lockedClasses: [{
            type: HostBinding,
            args: ['class.k-grid-lockedcolumns']
        }], virtualClasses: [{
            type: HostBinding,
            args: ['class.k-grid-virtual']
        }], noScrollbarClass: [{
            type: HostBinding,
            args: ['class.k-grid-no-scrollbar']
        }], isDetailExpanded: [{
            type: Input
        }], isGroupExpanded: [{
            type: Input
        }], pageSize: [{
            type: Input
        }], height: [{
            type: Input
        }], rowHeight: [{
            type: Input
        }], detailRowHeight: [{
            type: Input
        }], filter: [{
            type: Input
        }], detailTemplateChildren: [{
            type: ContentChildren,
            args: [DetailTemplateDirective]
        }], cellLoadingTemplateChildren: [{
            type: ContentChildren,
            args: [CellLoadingTemplateDirective]
        }], loadingTemplateChildren: [{
            type: ContentChildren,
            args: [LoadingTemplateDirective]
        }], noRecordsTemplateChildren: [{
            type: ContentChildren,
            args: [NoRecordsTemplateDirective]
        }], pagerTemplateChildren: [{
            type: ContentChildren,
            args: [PagerTemplateDirective]
        }], toolbarTemplateChildren: [{
            type: ContentChildren,
            args: [ToolbarTemplateDirective]
        }], columnMenuTemplates: [{
            type: ContentChildren,
            args: [ColumnMenuTemplateDirective]
        }], lockedHeader: [{
            type: ViewChild,
            args: ['lockedHeader', { static: false }]
        }], header: [{
            type: ViewChild,
            args: ['header', { static: false }]
        }], ariaRoot: [{
            type: ViewChild,
            args: ['ariaRoot', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ListComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: SCROLLER_FACTORY_TOKEN,
                        useValue: DEFAULT_SCROLLER_FACTORY
                    }
                ],
                selector: 'kendo-grid-list',
                template: `
    <div #lockedContainer class="k-grid-content-locked" role="presentation"
        *ngIf="isLocked" [style.width.px]="lockedWidth" tabindex="-1"
        [kendoEventsOutsideAngular]="{
            keydown: lockedKeydown,
            scroll: lockedScroll,
            mousewheel: lockedMousewheel,
            DOMMouseScroll: lockedMousewheel
        }"
        [scope]="this"
        >
        <div role="presentation" class="k-grid-table-wrap">
            <table [locked]="true" #lockedTable class="k-grid-table" role="presentation" [style.width.px]="lockedWidth">
                <colgroup kendoGridColGroup
                    role="presentation"
                    [groups]="groups"
                    [columns]="lockedLeafColumns"
                    [detailTemplate]="detailTemplate">
                </colgroup>
                <tbody kendoGridTableBody
                    role="presentation"
                    [groups]="groups"
                    [isLocked]="true"
                    [data]="data"
                    [noRecordsText]="''"
                    [columns]="lockedLeafColumns"
                    [totalColumnsCount]="leafColumns.length"
                    [detailTemplate]="detailTemplate"
                    [showGroupFooters]="showFooter"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor></kendo-resize-sensor>
        </div>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
    </div><div #container
               class="k-grid-content k-virtual-content"
               role="presentation" tabindex="-1"
               [kendoGridResizableContainer]="lockedLeafColumns.length"
               [lockedWidth]="lockedWidth + 1">
        <div role="presentation" class="k-grid-table-wrap">
            <table [style.width.px]="nonLockedWidth" #table [virtualColumns]="virtualColumns"
              class="k-grid-table" role="presentation">
                <colgroup kendoGridColGroup
                    role="presentation"
                    [groups]="isLocked ? [] : groups"
                    [columns]="nonLockedColumnsToRender"
                    [detailTemplate]="detailTemplate">
                </colgroup>
                <tbody kendoGridTableBody
                    role="presentation"
                    [skipGroupDecoration]="isLocked"
                    [data]="data"
                    [groups]="groups"
                    [showGroupFooters]="showFooter"
                    [columns]="nonLockedColumnsToRender"
                    [allColumns]="nonLockedLeafColumns"
                    [detailTemplate]="detailTemplate"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [lockedColumnsCount]="lockedLeafColumns.length"
                    [totalColumnsCount]="leafColumns.length"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [rowSticky]="rowSticky"
                    [virtualColumns]="virtualColumns"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor *ngIf="isLocked"></kendo-resize-sensor>
        </div>
        <kendo-resize-sensor *ngIf="isLocked || virtualColumns"></kendo-resize-sensor>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
            <div [style.width.px]="totalWidth"></div>
        </div>
    </div>
    `
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [SCROLLER_FACTORY_TOKEN]
            }] }, { type: DetailsService }, { type: ChangeNotificationService }, { type: SuspendService }, { type: GroupsService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ScrollSyncService }, { type: ResizeService }, { type: EditService }, { type: BrowserSupportService }, { type: NavigationService }, { type: ScrollRequestService }, { type: ɵngcc1.LocalizationService }, { type: ColumnResizingService }, { type: ɵngcc0.ChangeDetectorRef }, { type: PDFService }, { type: ColumnInfoService }]; }, { groups: [{
            type: Input
        }], skip: [{
            type: Input
        }], columns: [{
            type: Input
        }], selectable: [{
            type: Input
        }], groupable: [{
            type: Input
        }], trackBy: [{
            type: Input
        }], contentScroll: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], scrollBottom: [{
            type: Output
        }], resizeSensors: [{
            type: ViewChildren,
            args: [ResizeSensorComponent]
        }], hostClass: [{
            type: HostBinding,
            args: ["class.k-grid-container"]
        }], hostRole: [{
            type: HostBinding,
            args: ["attr.role"]
        }], data: [{
            type: Input
        }], total: [{
            type: Input
        }], rowHeight: [{
            type: Input
        }], stickyRowHeight: [{
            type: Input
        }], detailRowHeight: [{
            type: Input
        }], take: [{
            type: Input
        }], detailTemplate: [{
            type: Input
        }], noRecordsTemplate: [{
            type: Input
        }], filterable: [{
            type: Input
        }], rowClass: [{
            type: Input
        }], rowSticky: [{
            type: Input
        }], loading: [{
            type: Input
        }], virtualColumns: [{
            type: Input
        }], isVirtual: [{
            type: Input
        }], cellLoadingTemplate: [{
            type: Input
        }], loadingTemplate: [{
            type: Input
        }], container: [{
            type: ViewChild,
            args: ['container', { static: true }]
        }], lockedContainer: [{
            type: ViewChild,
            args: ['lockedContainer', { static: false }]
        }], lockedTable: [{
            type: ViewChild,
            args: ['lockedTable', { static: false }]
        }], table: [{
            type: ViewChild,
            args: ['table', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DataBindingDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridBinding]'
            }]
    }], function () { return [{ type: GridComponent }, { type: ɵngcc0.ChangeDetectorRef }, { type: LocalDataChangesService }]; }, { skip: [{
            type: Input
        }], sort: [{
            type: Input
        }], filter: [{
            type: Input
        }], pageSize: [{
            type: Input
        }], group: [{
            type: Input
        }], data: [{
            type: Input,
            args: ["kendoGridBinding"]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SelectionDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridSelectBy]'
            }]
    }], function () { return [{ type: GridComponent }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpandDetailsDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridExpandDetailsBy]',
                exportAs: 'kendoGridExpandDetailsBy'
            }]
    }], function () { return [{ type: GridComponent }]; }, { expandedDetailKeysChange: [{
            type: Output
        }], expandedDetailKeys: [{
            type: Input
        }], initiallyExpanded: [{
            type: Input
        }], expandDetailsKey: [{
            type: Input,
            args: ['kendoGridExpandDetailsBy']
        }], expandDetailBy: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpandGroupDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridExpandGroupBy]',
                exportAs: 'kendoGridExpandGroupBy'
            }]
    }], function () { return [{ type: GridComponent }]; }, { expandedGroupKeysChange: [{
            type: Output
        }], groupsInitiallyExpanded: [{
            type: Input
        }], expandGroupBy: [{
            type: Input,
            args: ['kendoGridExpandGroupBy']
        }], expandedGroupKeys: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => LocalizedMessagesDirective_1)
                    }
                ],
                selector: '[kendoGridLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => CustomMessagesComponent_1)
                    }
                ],
                selector: 'kendo-grid-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterRowComponent, [{
        type: Component,
        args: [{
                selector: '[kendoGridFilterRow]',
                template: `
        <td
            [class.k-group-cell]="true"
            *ngFor="let g of groups"
            role="presentation">
        </td>
        <td
            [class.k-hierarchy-cell]="true"
            *ngIf="detailTemplate?.templateRef"
            role="presentation">
        </td>
        <td *ngFor="let column of columns; let columnIndex = index"
            [class.k-grid-header-sticky]="column.sticky"
            [ngStyle]="addStickyStyles(column)"
            [ngClass]="column.filterClass"
            [attr.aria-label]="filterLabel(column)"
            kendoGridFilterCell
                [column]="column"
                [filter]="filter"
            kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="lockedColumnsCount + columnIndex"
      ></td>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ColumnInfoService }]; }, { columns: [{
            type: Input
        }], groups: [{
            type: Input
        }], filterRowClass: [{
            type: HostBinding,
            args: ['class.k-filter-row']
        }], filter: [{
            type: Input
        }], detailTemplate: [{
            type: Input
        }], logicalRowIndex: [{
            type: Input
        }], lockedColumnsCount: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterCellComponent, [{
        type: Component,
        args: [{
                selector: '[kendoGridFilterCell]',
                template: `
        <ng-template [ngIf]="isFilterable">
            <ng-container [ngSwitch]="hasTemplate">
                <ng-container *ngSwitchCase="false">
                    <ng-container kendoFilterCellHost [column]="column" [filter]="filter"></ng-container>
                </ng-container>
                <ng-container *ngSwitchCase="true">
                    <ng-template
                        *ngIf="column.filterCellTemplateRef"
                        [ngTemplateOutlet]="column.filterCellTemplateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                </ng-container>
            </ng-container>
        </ng-template>
    `
            }]
    }], function () { return []; }, { filter: [{
            type: Input
        }], column: [{
            type: Input
        }] }); })();



(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumericFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-numeric-filter-cell',
                template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-numerictextbox
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step"
            >
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                >
                </kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ɵngcc1.LocalizationService }]; }, { filterDelay: [{
            type: Input
        }], showOperators: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterInputDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFilterInput]'
            }]
    }], function () { return [{ type: Array, decorators: [{
                type: Self
            }, {
                type: Inject,
                args: [NG_VALUE_ACCESSOR]
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { filterDelay: [{
            type: Input
        }], value: [{
            type: Input
        }], kendoInput: [{
            type: ContentChild,
            args: [KendoInput, { static: true }]
        }], columnLabel: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterCellWrapperComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-filter-wrapper-cell',
                template: `
        <ng-content></ng-content>
        <kendo-grid-filter-cell-operators
            [showOperators]="showOperators"
            [operators]="operators"
            (clear)="onClear()"
            [showButton]="showButton"
            [(value)]="currentOperator">
        </kendo-grid-filter-cell-operators>
    `
            }]
    }], function () { return [{ type: FilterService }]; }, { showOperators: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell-wrapper']
        }], overrideBaseClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StringFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-string-filter-cell',
                template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <input
                kendoTextBox
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [ngModel]="currentFilter?.value" />
        </kendo-grid-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ɵngcc1.LocalizationService }]; }, { filterDelay: [{
            type: Input
        }], showOperators: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterCellOperatorsComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-filter-cell-operators',
                template: `
        <kendo-dropdownlist
            #dropdown
            *ngIf="showOperators"
            kendoGridFocusable
            [data]="operators"
            class="k-dropdown-operator"
            (valueChange)="onChange($event)"
            [value]="value"
            iconClass="k-i-filter"
            [valuePrimitive]="true"
            textField="text"
            [popupSettings]="{ width: 'auto' }"
            valueField="value"
            (keydown)="dropdownKeydown($event)">
        </kendo-dropdownlist>
        <button type="button"
            kendoGridFocusable
            *ngIf="showButton"
            class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle k-icon-button"
            [title]="clearText"
            (click)="clearClick()"
            (keydown)="clearKeydown($event)">
                <span class="k-icon k-button-icon k-i-filter-clear"></span>
        </button>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { operators: [{
            type: Input
        }], showOperators: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], clear: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell-operator']
        }], dropdown: [{
            type: ViewChild,
            args: ['dropdown', { static: false }]
        }], showButton: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AutoCompleteFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-autocomplete-filter-cell',
                template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [showOperators]="showOperators">
            <kendo-autocomplete
                kendoFilterInput
                [data]="data"
                [valueField]="valueField"
                [value]="currentFilter?.value">
            </kendo-autocomplete>
        </kendo-grid-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ColumnComponent }, { type: ɵngcc1.LocalizationService }]; }, { showOperators: [{
            type: Input
        }], column: [{
            type: Input
        }], valueField: [{
            type: Input
        }], filter: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BooleanFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-boolean-filter-cell',
                template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [showOperators]="false"
            [defaultOperator]="operator">
            <kendo-dropdownlist
                kendoFilterInput
                kendoGridFocusable
                [columnLabel]="columnLabel"
                [defaultItem]="defaultItem"
                [data]="items"
                textField="text"
                valueField="value"
                [popupSettings]="{ width: 'auto' }"
                [valuePrimitive]="true"
                [value]="currentFilter?.value">
            </kendo-dropdownlist>
        </kendo-grid-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-date-filter-cell',
                template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-datepicker
                kendoFilterInput
                kendoGridFocusable
                [columnLabel]="columnLabel"
                [value]="currentFilter?.value"
                [format]="format"
                [formatPlaceholder]="formatPlaceholder"
                [placeholder]="placeholder"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [min]="min"
                [max]="max"
                [weekNumber]="weekNumber"
            >
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                >
                </kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ɵngcc1.LocalizationService }]; }, { showOperators: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColGroupComponent, [{
        type: Component,
        args: [{
                selector: '[kendoGridColGroup]',
                template: `
    <ng-template [ngIf]="true">
        <col [class.k-group-col]="true" *ngFor="let g of groups" />
        <col [class.k-hierarchy-col]="true" *ngIf="detailTemplate?.templateRef"/>
        <col *ngFor="let column of columnsToRender; trackBy: trackBy;" [style.width.px]="column.width"/>
    </ng-template>
    `
            }]
    }], function () { return []; }, { columns: [{
            type: Input
        }], groups: [{
            type: Input
        }], detailTemplate: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoadingComponent, [{
        type: Component,
        args: [{
                selector: '[kendoGridLoading]',
                template: `
        <ng-container *ngIf="!loadingTemplate">
            <span class="k-loading-text">{{ loadingText }}</span>
            <div class="k-loading-image"></div>
            <div class="k-loading-color"></div>
        </ng-container>
        <ng-template *ngIf="loadingTemplate" [ngTemplateOutlet]="loadingTemplate?.templateRef">
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-loading-mask']
        }], loadingTemplate: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResizableContainerDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridResizableContainer]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ResizeService }, { type: GridComponent, decorators: [{
                type: Optional
            }] }]; }, { lockedWidth: [{
            type: Input,
            args: ['lockedWidth']
        }], kendoGridResizableContainer: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TemplateContextDirective, [{
        type: Directive,
        args: [{
                selector: '[templateContext]' // tslint:disable-line:directive-selector
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { templateContext: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FocusGroup, [{
        type: Injectable
    }], function () { return [{ type: FocusRoot }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LogicalCellDirective, [{
        type: Directive,
        args: [{
                providers: [{
                        provide: FocusGroup,
                        deps: [FocusRoot],
                        useClass: FocusGroup
                    }],
                selector: '[kendoGridLogicalCell]'
            }]
    }], function () { return [{ type: FocusGroup }, { type: ɵngcc0.ElementRef }, { type: ColumnInfoService }, { type: IdService }, { type: NavigationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: Object, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CELL_CONTEXT]
            }] }]; }, { logicalSlaveCell: [{
            type: Input
        }], colSpan: [{
            type: Input
        }], rowSpan: [{
            type: Input
        }], dataRowIndex: [{
            type: Input
        }], detailExpandCell: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }], ariaColIndex: [{
            type: HostBinding,
            args: ['attr.aria-colindex']
        }], logicalColIndex: [{
            type: Input
        }], logicalRowIndex: [{
            type: Input
        }], colIndex: [{
            type: Input
        }], groupItem: [{
            type: Input
        }], dataItem: [{
            type: Input
        }], headerLabelText: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LogicalRowDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridLogicalRow]'
            }]
    }], function () { return [{ type: IdService }, { type: NavigationService }]; }, { logicalSlaveRow: [{
            type: Input
        }], logicalSlaveCellsCount: [{
            type: Input
        }], dataRowIndex: [{
            type: Input
        }], hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaRowIndex: [{
            type: HostBinding,
            args: ['attr.aria-rowindex']
        }], ariaOwns: [{
            type: HostBinding,
            args: ['attr.aria-owns']
        }], logicalRowIndex: [{
            type: Input
        }], logicalCellsCount: [{
            type: Input
        }], dataItem: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FieldAccessorPipe, [{
        type: Pipe,
        args: [{
                name: 'valueOf',
                pure: false
            }]
    }], function () { return [{ type: ɵngcc10.IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableDirective, [{
        type: Directive,
        args: [{
                selector: 'table' // tslint:disable-line:directive-selector
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ColumnResizingService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, { locked: [{
            type: Input
        }], minWidth: [{
            type: HostBinding,
            args: ['style.min-width']
        }], virtualColumns: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                declarations: [exportedModules],
                exports: [exportedModules, DraggableModule, EventsModule],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { declarations: function () { return [ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, TableDirective, LoadingComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, TableDirective, LoadingComponent, DraggableModule, EventsModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContainsFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => ContainsFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-contains-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DoesNotContainFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-not-contains-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EndsWithFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => EndsWithFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-endswith-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EqualFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => EqualFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-eq-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IsEmptyFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => IsEmptyFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-isempty-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IsNotEmptyFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-isnotempty-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IsNotNullFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => IsNotNullFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-isnotnull-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IsNullFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => IsNullFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-isnull-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotEqualFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => NotEqualFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-neq-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StartsWithFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => StartsWithFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-startswith-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GreaterFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => GreaterFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-gt-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GreaterOrEqualToFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-gte-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LessFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => LessFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-lt-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LessOrEqualToFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-lte-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AfterFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => AfterFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-after-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AfterEqFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => AfterEqFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-after-eq-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BeforeEqFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => BeforeEqFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-before-eq-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BeforeFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => BeforeFilterOperatorComponent_1)
                    }
                ],
                selector: 'kendo-filter-before-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SharedFilterModule, [{
        type: NgModule,
        args: [{
                declarations: [FILTER_OPERATORS, COMPONENTS],
                exports: [FILTER_OPERATORS, importedModules, COMPONENTS],
                imports: [...importedModules]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedFilterModule, { declarations: [FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective], imports: [CommonModule,
        ReactiveFormsModule,
        FormsModule,
        DropDownListModule,
        AutoCompleteModule,
        InputsModule,
        DatePickerModule,
        PopupModule, SharedModule], exports: [FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, CommonModule,
        ReactiveFormsModule,
        FormsModule,
        DropDownListModule,
        AutoCompleteModule,
        InputsModule,
        DatePickerModule,
        PopupModule, SharedModule, FilterInputDirective] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterCellHostDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFilterCellHost]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RowFilterModule, [{
        type: NgModule,
        args: [{
                declarations: [INTERNAL_COMPONENTS],
                entryComponents: ENTRY_COMPONENTS,
                exports: [INTERNAL_COMPONENTS, SharedFilterModule],
                imports: [SharedFilterModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RowFilterModule, { declarations: [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent], imports: [SharedFilterModule], exports: [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, SharedFilterModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerInputDirective, [{
        type: Directive,
        args: [{ selector: '[kendoGridPagerInput]' }]
    }], function () { return [{ type: ɵngcc6.NumericTextBoxComponent }, { type: ɵngcc0.Renderer2 }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerDropDownListDirective, [{
        type: Directive,
        args: [{ selector: '[kendoGridPagerDropDown]' }]
    }], function () { return [{ type: ɵngcc8.DropDownListComponent }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-pager',
                providers: [{
                        provide: FOCUS_ROOT_ACTIVE,
                        useValue: true
                    }, {
                        provide: FocusRoot,
                        deps: [FOCUS_ROOT_ACTIVE],
                        useClass: FocusRoot
                    }, {
                        provide: FocusGroup,
                        deps: [FocusRoot],
                        useClass: FocusGroup
                    }],
                template: `
        <div
            *ngIf="navigationService.enabled"
            class="k-sr-only"
            [tabindex]="focusTrapTabIndex"
            [attr.aria-hidden]="true"
            (focusin)="onInnerFocusIn($event, 'start')">
        </div>
        <ng-container
            *ngIf="template?.templateRef"
            [ngTemplateOutlet]="template.templateRef"
            [ngTemplateOutletContext]="templateContext">
        </ng-container>
        <ng-container *ngIf="!template?.templateRef">
            <kendo-pager-prev-buttons *ngIf="settings.previousNext"></kendo-pager-prev-buttons>
            <kendo-pager-numeric-buttons
                *ngIf="settings.type === 'numeric'"
                [buttonCount]="settings.buttonCount">
            </kendo-pager-numeric-buttons>
            <kendo-pager-input *ngIf="settings.type === 'input'"></kendo-pager-input>
            <kendo-pager-next-buttons *ngIf="settings.previousNext"></kendo-pager-next-buttons>
            <kendo-pager-info *ngIf='settings.info'></kendo-pager-info>
            <kendo-pager-page-sizes
                *ngIf="settings.pageSizes"
                [pageSizes]="settings.pageSizes"
                #pageSizes
            ></kendo-pager-page-sizes>
        </ng-container>
        <div
            *ngIf="navigationService.enabled"
            class="k-sr-only"
            [tabindex]="focusTrapTabIndex"
            [attr.aria-hidden]="true"
            (focusin)="onInnerFocusIn($event, 'end')">
        </div>
        <kendo-resize-sensor *ngIf="settings.responsive" (resize)="resizeHandler()"></kendo-resize-sensor>
  `
            }]
    }], function () { return [{ type: PagerContextService }, { type: NavigationService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.LocalizationService }, { type: Object, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CELL_CONTEXT]
            }] }, { type: FocusRoot }, { type: FocusGroup }]; }, { total: [{
            type: Input
        }], skip: [{
            type: Input
        }], pageChange: [{
            type: Output
        }], pagerWrapClass: [{
            type: HostBinding,
            args: ['class.k-pager-wrap']
        }], gridPagerClass: [{
            type: HostBinding,
            args: ['class.k-grid-pager']
        }], options: [{
            type: Input
        }], isFocused: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], pagerAriaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], onFocusIn: [{
            type: HostListener,
            args: ['focusin', ['$event']]
        }], onFocusOut: [{
            type: HostListener,
            args: ['focusout']
        }], onEscape: [{
            type: HostListener,
            args: ['keydown.escape']
        }], onEnter: [{
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], navigateToPreviousPage: [{
            type: HostListener,
            args: ['keydown.arrowleft', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.pageup', ['$event']]
        }], navigateToNextPage: [{
            type: HostListener,
            args: ['keydown.arrowright', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.pagedown', ['$event']]
        }], navigateToFirstPage: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], navigateToLastPage: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], pageSize: [{
            type: Input
        }], template: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerPrevButtonsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-pager-prev-buttons',
                template: `
        <span
            [kendoGridFocusable]="!disabled"
            [title]="textFor('pagerFirstPage')"
            (click)="currentPage !== 1 ? changePage(0) : false"
            (keydown.enter)="currentPage !== 1 ? changePage(0) : false"
            role="button"
            [ngClass]="{
                'k-link': true,
                'k-pager-nav': true,
                'k-state-disabled': disabled,
                'k-pager-first': true
            }">
            <span role="note"
                  [attr.aria-label]="textFor('pagerFirstPage')"
                  [ngClass]="{
                    'k-icon': true,
                    'k-i-seek-w': true
                  }">
            </span>
        </span>
        <span
            [kendoGridFocusable]="!disabled"
            [title]="textFor('pagerPreviousPage')"
            role="button"
            (click)="currentPage !== 1 ? changePage(currentPage-2) : false"
            (keydown.enter)="currentPage !== 1 ? changePage(currentPage-2) : false"
            [ngClass]="{
                'k-link': true,
                'k-pager-nav': true,
                'k-state-disabled': disabled,
                '': true
            }">
            <span role="note"
                  [attr.aria-label]="textFor('pagerPreviousPage')"
                  [ngClass]="{
                    'k-icon': true,
                    'k-i-arrow-w': true
                  }">
            </span>
        </span>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: PagerContextService }, { type: ɵngcc0.ChangeDetectorRef }, { type: NavigationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerNextButtonsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-pager-next-buttons',
                template: `
        <span
            [kendoGridFocusable]="!disabled"
            tabindex="0"
            [title]="textFor('pagerNextPage')"
            (click)="currentPage !== totalPages ? changePage(currentPage) : false"
            (keydown.enter)="currentPage !== totalPages ? changePage(currentPage) : false"
            role="button"
            [ngClass]="{
                'k-link': true,
                'k-pager-nav': true,
                'k-state-disabled': disabled,
                '': true
            }">
            <span role="note" [attr.aria-label]="textFor('pagerNextPage')"
                [ngClass]="{
                    'k-icon':true,
                    'k-i-arrow-e': true
                }">
            </span>
        </span>
        <span
            [kendoGridFocusable]="!disabled"
            tabindex="0"
            [title]="textFor('pagerLastPage')"
            (click)="currentPage !== totalPages ? changePage(totalPages-1) : false"
            (keydown.enter)="currentPage !== totalPages ? changePage(totalPages-1) : false"
            role="button"
            [ngClass]="{
                'k-link': true,
                'k-pager-nav': true,
                'k-state-disabled': disabled,
                'k-pager-last': true
            }">
            <span role="note" [attr.aria-label]="textFor('pagerLastPage')"
                [ngClass]="{
                    'k-icon':true,
                    'k-i-seek-e': true
                }">
            </span>
        </span>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: PagerContextService }, { type: ɵngcc0.ChangeDetectorRef }, { type: NavigationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerNumericButtonsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-pager-numeric-buttons',
                template: `
        <select
            class="k-dropdownlist k-pager-nav"
            kendoGridFocusable
            tabindex="0"
            [value]="(currentPage).toString()"
            (change)="onSelectChange($event)">
            <option *ngIf="start > 1"
                class="k-link"
                value="previousButtons"
                [attr.aria-label]="pageLabel(start - 1)">...
            </option>
            <option *ngFor="let num of buttons"
                [value]="num.toString()"
                [attr.aria-label]="pageLabel(num)"
                [attr.aria-current]="currentPage == num ? 'page' : undefined"
                [ngClass]="{'k-link': true, 'k-state-selected':currentPage == num}">
                {{num}}
            </option>
            <option *ngIf="end < totalPages"
                value="nextButtons"
                class="k-link"
                [attr.aria-label]="pageLabel(end + 1)">...
            </option>
        </select>
        <ul [ngClass]="{'k-pager-numbers': true, 'k-reset': true}">
            <li *ngIf="start > 1">
                <span
                    kendoGridFocusable
                    tabindex="0"
                    class="k-link k-pager-nav"
                    role="button"
                    [attr.aria-label]="pageLabel(start - 1)"
                    (click)="changePage(start - 2)"
                    (keydown.enter)="changePage(start - 2)">...</span>
            </li>
            <li *ngFor="let num of buttons">
                <span
                    kendoGridFocusable
                    tabindex="0"
                    role="button"
                    [attr.aria-label]="pageLabel(num)"
                    [ngClass]="{'k-link': true, 'k-state-selected':currentPage == num, 'k-pager-nav': true}"
                    (click)="changePage(num - 1)"
                    (keydown.enter)="changePage(num - 1)">
                    {{num}}
                </span>
            </li>
            <li *ngIf="end < totalPages">
                <span
                    kendoGridFocusable
                    tabindex="0"
                    class="k-link k-pager-nav"
                    role="button"
                    [attr.aria-label]="pageLabel(end + 1)"
                    (click)="changePage(end)"
                    (keydown.enter)="changePage(end)">...</span>
            </li>
        </ul>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: PagerContextService }]; }, { numbersWrapClass: [{
            type: HostBinding,
            args: ['class.k-pager-numbers-wrap']
        }], buttonCount: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-pager-input',
                template: `
     <span [ngClass]="{'k-pager-input': true, 'k-label': true}">
        {{textFor('pagerPage')}}
        <kendo-numerictextbox
            kendoGridPagerInput
            [kendoGridFocusable]="hasPages"
            tabindex="0"
            [spinners]="false"
            [decimals]="0"
            format="n0"
            [disabled]="!hasPages"
            [value]="current"
            [min]="hasPages ? 1 : 0"
            [max]="totalPages"
            [autoCorrect]="true"
            [title]="textFor('pagerPageNumberInputTitle')"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                focusout: handleBlur
            }"
        >
        </kendo-numerictextbox>
        {{textFor('pagerOf')}} {{totalPages}}
     </span>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: PagerContextService }, { type: ɵngcc0.NgZone }, { type: NavigationService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { numericInput: [{
            type: ViewChild,
            args: [NumericTextBoxComponent, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerInfoComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-pager-info',
                template: `{{currentPageText}} - {{maxItems}} {{textFor('pagerOf')}} {{total}} {{textFor('pagerItems')}}`
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: PagerContextService }]; }, { classes: [{
            type: HostBinding,
            args: ["class.k-pager-info"]
        }, {
            type: HostBinding,
            args: ["class.k-label"]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerPageSizesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-pager-page-sizes',
                template: `
        <kendo-dropdownlist
            #dropdownlist
            kendoGridPagerDropDown
            tabindex="0"
            kendoGridFocusable
            [data]="pageSizes"
            textField="text"
            valueField="value"
            [valuePrimitive]="true"
            [value]="pageSize"
            (valueChange)="pageSizeChange($event)"></kendo-dropdownlist>
        <kendo-label [for]="dropdownlist" [text]="textFor('pagerItemsPerPage')"></kendo-label>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: PagerContextService }, { type: NavigationService }]; }, { pageSizes: [{
            type: Input
        }], classes: [{
            type: HostBinding,
            args: ['class.k-pager-sizes']
        }, {
            type: HostBinding,
            args: ['class.k-label']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PagerModule, [{
        type: NgModule,
        args: [{
                declarations: [INTERNAL_COMPONENTS$1],
                exports: [INTERNAL_COMPONENTS$1],
                imports: [...importedModules$1]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PagerModule, { declarations: [PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective], imports: [CommonModule,
        InputsModule,
        LabelModule,
        DropDownsModule,
        ResizeSensorModule, SharedModule], exports: [PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupHeaderComponent, [{
        type: Component,
        args: [{
                selector: '[kendoGridGroupHeader]',
                template: `
        <ng-template [ngIf]="!skipGroupDecoration">
            <td class="k-group-cell"
                role="presentation"
                *ngFor="let g of prefixGroupCell(item)"></td>
        </ng-template>
        <td [attr.colspan]="groupSpan(item)" *ngIf="!(skipGroupDecoration && hasGroupHeaderColumn)"
            [attr.role]="ariaRole()"
            aria-selected="false"
            [attr.aria-expanded]="isExpanded"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="0"
            [logicalSlaveCell]="skipGroupDecoration"
            [groupItem]="item"
            [colSpan]="logicalColSpan()">
            <p class="k-reset">
                <ng-template [ngIf]="!skipGroupDecoration">
                    <a href="#" tabindex="-1" (click)="toggleGroup(item)"
                        class="k-icon"
                        [ngClass]="{ 'k-i-collapse': isExpanded, 'k-i-expand': !isExpanded }" role="presentation"
                        [attr.title]="groupButtonTitle"
                        [attr.aria-label]="groupButtonTitle">
                    </a>
                    <ng-template [ngIf]="!groupHeaderTemplate(item)">
                    {{groupTitle(item)}}: {{item.data | valueOf:"value": formatForGroup(item)}}
                    </ng-template>
                    <ng-template
                        [templateContext]="{
                            templateRef: groupHeaderTemplate(item),
                            group: item.data,
                            aggregates: item.data?.aggregates,
                            value: item.data?.value,
                            field: item.data?.field,
                            index: item.index,
                            expanded: isExpanded,
                            $implicit: item.data
                            }">
                    </ng-template>
                </ng-template>
            </p>
        </td>
        <ng-container *ngIf="hasGroupHeaderColumn">
            <td *ngFor="let column of groupHeaderColumns; let index = index"
                role="gridcell"
                aria-selected="false"
                kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="index + 1"
                [logicalSlaveCell]="false"
                [groupItem]="item"
                [colSpan]="1"
            >
                <ng-container *ngIf="column.groupHeaderColumnTemplateRef" [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                    [ngTemplateOutletContext]="{
                        group: item.data,
                        aggregates: item.data?.aggregates,
                        value: item.data?.value,
                        field: item.data?.field,
                        index: item.index,
                        $implicit: item.data
                        }">
                </ng-container>
            </td>
        </ng-container>
    `
            }]
    }], function () { return [{ type: GroupsService }, { type: GroupInfoService }, { type: ɵngcc1.LocalizationService }]; }, { skipGroupDecoration: [{
            type: Input
        }], hasDetails: [{
            type: Input
        }], totalColumnsCount: [{
            type: Input
        }], groups: [{
            type: Input
        }], groupItemClass: [{
            type: HostBinding,
            args: ['class.k-grouping-row']
        }], rowIndex: [{
            type: Input
        }], logicalRowIndex: [{
            type: Input
        }], item: [{
            type: Input
        }], hasGroupHeaderColumn: [{
            type: Input
        }], groupHeaderColumns: [{
            type: Input
        }], columns: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropTargetDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropTarget]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DragAndDropService }]; }, { context: [{
            type: Input
        }], enter: [{
            type: Output
        }], leave: [{
            type: Output
        }], drop: [{
            type: Output
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupPanelComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-grid-group-panel',
                template: `
        <ng-template [ngIf]="groups.length === 0">
            <div
                class="k-indicator-container"
                [context]="{
                    lastTarget: true
                }"
                kendoDropTarget>
                {{ text }}
            </div>
        </ng-template>
        <div *ngFor="let group of groups; let index = index;"
            class="k-indicator-container"
            [context]="{
                field: group.field
            }"
            kendoDropTarget>
            <div
                kendoDraggableColumn
                [enableDrag]="true"
                [context]="{
                    field: group.field,
                    type: 'groupIndicator',
                    hint:  groupTitles[index]
                }"
                kendoGroupIndicator
                kendoDraggable
                [group]="group"
                [groupTitle]="groupTitles[index]"
                (directionChange)="directionChange($event)"
                (remove)="remove($event)">
            </div>
        </div>
        <div class="k-indicator-container"
            *ngIf="groups.length !== 0"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget>&nbsp;</div>
    `
            }]
    }], function () { return [{ type: DragHintService }, { type: DropCueService }, { type: GroupInfoService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { change: [{
            type: Output
        }], groups: [{
            type: Input
        }], dropTargets: [{
            type: ViewChildren,
            args: [DropTargetDirective]
        }], groupHeaderClass: [{
            type: HostBinding,
            args: ["class.k-grouping-header"]
        }, {
            type: HostBinding,
            args: ["class.k-grouping-header-flex"]
        }], text: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupIndicatorComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: '[kendoGroupIndicator]',
                template: `
        <a href="#" class="k-link" tabindex="-1" (click)="toggleDirection()">
            <span class="k-icon"
                [class.k-i-sort-asc-sm]="dir === 'asc'"
                [class.k-i-sort-desc-sm]="dir === 'desc'"></span>
            {{groupTitle}}</a>
        <a class="k-button k-button-flat-base k-button-flat k-icon-button k-button-md k-rounded-md k-button-rectangle k-icon-button" tabindex="-1" (click)="removeDescriptor()">
            <span class="k-button-icon k-icon k-i-group-delete"></span>
        </a>
    `
            }]
    }], function () { return []; }, { directionChange: [{
            type: Output
        }], remove: [{
            type: Output
        }], groupIndicatorClass: [{
            type: HostBinding,
            args: ["class.k-group-indicator"]
        }], group: [{
            type: Input
        }], groupTitle: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableColumnDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDraggableColumn]'
            }]
    }], function () { return [{ type: ɵngcc2.DraggableDirective, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: DragAndDropService }, { type: DragHintService }, { type: DropCueService }, { type: NavigationService }, { type: ɵngcc0.Renderer2 }]; }, { context: [{
            type: Input
        }], drag: [{
            type: Output
        }], enableDrag: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-grid-draggable-header']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragAndDropModule, [{
        type: NgModule,
        args: [{
                declarations: [exported],
                exports: [exported]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, { declarations: [DraggableColumnDirective, DropTargetDirective], exports: [DraggableColumnDirective, DropTargetDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupModule, [{
        type: NgModule,
        args: [{
                declarations: [exportedModules$1],
                exports: [exportedModules$1],
                imports: [CommonModule, SharedModule, DragAndDropModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GroupModule, { declarations: function () { return [GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, GroupHeaderComponent, GroupPanelComponent, GroupIndicatorComponent]; }, imports: function () { return [CommonModule, SharedModule, DragAndDropModule]; }, exports: function () { return [GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, GroupHeaderComponent, GroupPanelComponent, GroupIndicatorComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-filter-menu',
                template: `
        <a #anchor
            [ngClass]="{'k-grid-filter':true, 'k-state-active': hasFilters}"
            [tabindex]="tabIndex"
            (click)="toggle(anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [attr.title]="filterLabel">
            <span class="k-icon k-i-filter"></span>
        </a>
        <ng-template #template>
            <kendo-grid-filter-menu-container
                [column]="column"
                [filter]="filter"
                (close)="close()"
                (keydown.escape)="close()"
                (keydown.enter)="$event.stopImmediatePropagation()"
                >
            </kendo-grid-filter-menu-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: SinglePopupService }, { type: ɵngcc1.LocalizationService }, { type: NavigationService }]; }, { tabIndex: [{
            type: Input
        }], column: [{
            type: Input
        }], filter: [{
            type: Input
        }], anchor: [{
            type: ViewChild,
            args: ['anchor', { static: true }]
        }], template: [{
            type: ViewChild,
            args: ['template', { static: true, read: TemplateRef }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuService, [{
        type: Injectable
    }], function () { return [{ type: MenuTabbingService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuComponent, [{
        type: Component,
        args: [{
                providers: [
                    ColumnMenuService,
                    MenuTabbingService
                ],
                selector: 'kendo-grid-column-menu',
                template: `
        <a #anchor
            class="k-grid-column-menu k-grid-filter"
            [ngClass]="{ 'k-state-active': isActive }"
            (click)="toggle($event, anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [tabindex]="tabIndex"
            [attr.title]="columnMenuTitle">
            <span class="k-icon k-i-more-vertical"></span>
        </a>
        <ng-template #template>
            <ng-container
                [ngTemplateOutlet]="column.columnMenuTemplateRef || columnMenuTemplate || defaultTemplate"
                [ngTemplateOutletContext]="{ service: service, column: column }">
            </ng-container>
        </ng-template>
        <ng-template #defaultTemplate>
            <kendo-grid-columnmenu-container
                (keydown.escape)="close()"
                (keydown.enter)="$event.stopImmediatePropagation()">
                <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="service">
                </kendo-grid-columnmenu-sort>
                <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="service">
                </kendo-grid-columnmenu-stick>
                <kendo-grid-columnmenu-position
                    #positionItem
                    *ngIf="hasPosition"
                    [showLock]="hasLock"
                    [showStick]="hasStick"
                    [kendoGridColumnMenuItem]="positionItem"
                    [service]="service"
                    [expanded]="expandedPosition">
                </kendo-grid-columnmenu-position>
                <kendo-grid-columnmenu-chooser
                    #chooserItem
                    *ngIf="hasColumnChooser"
                    [kendoGridColumnMenuItem]="chooserItem"
                    [service]="service"
                    [expanded]="expandedColumns">
                </kendo-grid-columnmenu-chooser>
                <kendo-grid-columnmenu-filter
                    #filterItem
                    *ngIf="hasFilter"
                    [kendoGridColumnMenuItem]="filterItem"
                    [service]="service"
                    [expanded]="expandedFilter">
                </kendo-grid-columnmenu-filter>
            </kendo-grid-columnmenu-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: SinglePopupService }, { type: ɵngcc1.LocalizationService }, { type: ColumnMenuService }, { type: NavigationService }]; }, { standalone: [{
            type: HostBinding,
            args: ['class.k-grid-column-menu-standalone']
        }, {
            type: Input
        }], settings: [{
            type: Input
        }], sortable: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], column: [{
            type: Input
        }], sort: [{
            type: Input
        }], filter: [{
            type: Input
        }], columnMenuTemplate: [{
            type: Input
        }], anchor: [{
            type: ViewChild,
            args: ['anchor', { static: true }]
        }], template: [{
            type: ViewChild,
            args: ['template', { static: true, read: TemplateRef }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeaderComponent, [{
        type: Component,
        args: [{
                selector: '[kendoGridHeader]',
                styles: [`
        .k-column-resizer {
            cursor: col-resize;
            display: block;
            height: 1000%;
            position: absolute;
            top: 0;
            width: .5em;
        }
    `],
                template: `
    <ng-template [ngIf]="true">
        <tr *ngFor="let i of columnLevels; let levelIndex = index"
            kendoGridLogicalRow
                [logicalRowIndex]="levelIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount">
            <th
                class="k-group-cell k-header"
                role="presentation"
                *ngFor="let g of groups">
            </th>
            <th class="k-hierarchy-cell k-header"
                role="presentation"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="0"
                    aria-selected="false"
            >
            </th>
            <ng-template ngFor let-column [ngForOf]="columnsForLevel(levelIndex)" [ngForTrackBy]="trackByIndex" let-columnIndex="index" let-last="last">
                <th *ngIf="!isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [headerLabelText]="column.title || column.field"
                    [colSpan]="column.colspan"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    role="columnheader"
                    aria-selected="false"
                    [attr.aria-sort]="sortState(column)"
                    (keydown)="onHeaderKeydown(column, $event)"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        field: column.field,
                        type: 'column',
                        column: column,
                        hint: column.title || column.field,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header"
                    [class.k-filterable]="(showFilterMenu && isFilterable(column)) || showColumnMenu(column)"
                    [class.k-first]="isFirstOnRow(column, columnIndex)"
                    [class.k-grid-header-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.sticky ? addStickyStyles(column) : column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan">

                    <ng-template [ngIf]="!isSortable(column)">
                        <kendo-grid-filter-menu
                            *ngIf="showFilterMenu && isFilterable(column)"
                            [column]="column"
                            [filter]="filter"
                            [tabIndex]="tabIndex">
                        </kendo-grid-filter-menu>
                        <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                            [standalone]="false"
                            [settings]="columnMenu"
                            [column]="column"
                            [columnMenuTemplate]="columnMenuTemplate"
                            [sort]="sort"
                            [filter]="filter"
                            [sortable]="sortable"
                            [tabIndex]="tabIndex">
                        </kendo-grid-column-menu>
                        <ng-template
                            [templateContext]="{
                                templateRef: column.headerTemplateRef,
                                columnIndex: column.leafIndex,
                                column: column,
                                $implicit: column
                            }">
                        </ng-template>
                        <ng-template [ngIf]="!column.headerTemplateRef">{{column.displayTitle}}</ng-template>
                    </ng-template>

                    <ng-template [ngIf]="isSortable(column)">
                        <span class="k-cell-inner">
                            <span #link class="k-link" (click)="onSortClick(column, $event, link)">
                                <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                                </ng-template>
                                <ng-template [ngIf]="!column.headerTemplateRef">
                                    <span class="k-column-title">{{column.displayTitle}}</span>
                                </ng-template>
                                <span role="note" [attr.aria-label]="sortableLabel" [ngClass]="sortIcon(column.field)"></span>
                                <span *ngIf="showSortNumbering(column)" class="k-sort-order">{{sortOrder(column.field)}}</span>
                            </span>
                            <span role="status"
                                class="k-sort-status"
                                style="position: absolute; left: -10000px;"
                                [innerHtml]="sortStatus(column)">
                            </span>
                            <kendo-grid-filter-menu
                                *ngIf="showFilterMenu && isFilterable(column)"
                                [column]="column"
                                [filter]="filter"
                                [tabIndex]="tabIndex">
                            </kendo-grid-filter-menu>
                            <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                                [standalone]="false"
                                [settings]="columnMenu"
                                [column]="column"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [sort]="sort"
                                [filter]="filter"
                                [sortable]="sortable"
                                [tabIndex]="tabIndex">
                            </kendo-grid-column-menu>
                        </span>
                    </ng-template>

                    <ng-template [ngIf]="isCheckboxColumn(column) && !column.headerTemplateRef && column.showSelectAll">
                        <input
                            class="k-checkbox k-checkbox-md k-rounded-md"
                            [attr.id]="selectAllCheckboxId()"
                            [attr.aria-label]="selectAllCheckboxLabel"
                            kendoGridSelectAllCheckbox
                            kendoGridFocusable>
                    </ng-template>
                    <span kendoGridColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
                <th *ngIf="isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    [colSpan]="column.colspan"
                    [headerLabelText]="column.title || column.field"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        type: 'columnGroup',
                        column: column,
                        hint: column.title,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header"
                    [class.k-first]="isFirstOnRow(column, columnIndex)"
                    [class.k-filterable]="showColumnMenu(column)"
                    [class.k-grid-content-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan">
                        <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                            [standalone]="false"
                            [settings]="columnMenu"
                            [column]="column"
                            [columnMenuTemplate]="columnMenuTemplate">
                        </kendo-grid-column-menu>
                        <ng-template
                            [templateContext]="{
                                templateRef: column.headerTemplateRef,
                                columnIndex: lockedColumnsCount + columnIndex,
                                column: column,
                                $implicit: column
                            }">
                        </ng-template>
                        <ng-template [ngIf]="!column.headerTemplateRef">{{column.displayTitle}}</ng-template>
                        <span kendoGridColumnHandle
                            kendoDraggable
                            class="k-column-resizer"
                            *ngIf="resizable"
                            [column]="column"
                            [columns]="columns">
                        </span>
                </th>
            </ng-template>
        </tr>
        <tr *ngIf="showFilterRow"
            kendoGridFilterRow
                [columns]="leafColumns"
                [filter]="filter"
                [groups]="groups"
                [detailTemplate]="detailTemplate"
                [lockedColumnsCount]="lockedColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="totalColumnLevels + 1"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
        ></tr>
    </ng-template>
    `
            }]
    }], function () { return [{ type: SinglePopupService }, { type: DragHintService }, { type: DropCueService }, { type: ColumnReorderService }, { type: IdService }, { type: SortService }, { type: ɵngcc1.LocalizationService }, { type: ColumnInfoService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { columns: [{
            type: Input
        }], groups: [{
            type: Input
        }], sort: [{
            type: Input
        }], sortable: [{
            type: Input
        }], groupable: [{
            type: Input
        }], lockedColumnsCount: [{
            type: Input
        }], resizable: [{
            type: Input
        }], reorderable: [{
            type: Input
        }], columnMenu: [{
            type: Input
        }], totalColumnsCount: [{
            type: Input
        }], dropTargets: [{
            type: ViewChildren,
            args: [DropTargetDirective]
        }], headerClass: [{
            type: HostBinding,
            args: ['class.k-grid-header']
        }], totalColumnLevels: [{
            type: Input
        }], detailTemplate: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], filterable: [{
            type: Input
        }], filter: [{
            type: Input
        }], columnMenuTemplate: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], filterMenus: [{
            type: ViewChildren,
            args: [FilterMenuComponent]
        }], columnMenus: [{
            type: ViewChildren,
            args: [ColumnMenuComponent]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnHandleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridColumnHandle]'
            }]
    }], function () { return [{ type: ɵngcc2.DraggableDirective, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }, { type: ColumnResizingService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.LocalizationService }, { type: ColumnInfoService }]; }, { columns: [{
            type: Input
        }], visible: [{
            type: HostBinding,
            args: ['style.display']
        }], leftStyle: [{
            type: HostBinding,
            args: ['style.left']
        }], rightStyle: [{
            type: HostBinding,
            args: ['style.right']
        }], autoFit: [{
            type: HostListener,
            args: ['dblclick']
        }], column: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SelectAllCheckboxDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridSelectAllCheckbox]'
            }]
    }], function () { return [{ type: SelectionService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { selectAllChange: [{
            type: Output
        }], type: [{
            type: HostBinding,
            args: ['attr.type']
        }], state: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterMenuContainerComponent, [{
        type: Component,
        args: [{
                providers: [
                    FilterService,
                    MenuTabbingService
                ],
                selector: 'kendo-grid-filter-menu-container',
                template: `
        <form (submit)="submit()" (reset)="reset()"
            class="k-filter-menu k-group k-reset k-state-border-up">
            <div class="k-filter-menu-container">
                <ng-container [ngSwitch]="hasTemplate">
                    <ng-container *ngSwitchCase="false">
                        <ng-container
                            kendoFilterMenuHost
                            [filterService]="childService"
                            [column]="column"
                            [filter]="childFilter"
                            [menuTabbingService]="menuTabbingService">
                        </ng-container>
                    </ng-container>
                    <ng-container *ngSwitchCase="true">
                        <ng-template
                            *ngIf="column.filterMenuTemplateRef"
                            [ngTemplateOutlet]="column.filterMenuTemplateRef"
                            [ngTemplateOutletContext]="templateContext"
                            >
                        </ng-template>
                    </ng-container>
                </ng-container>
                <div [ngClass]="actionsClass">
                    <button
                        #resetButton
                        type="reset"
                        class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        (keydown.tab)="onTab($event, 'reset')">{{clearText}}</button>
                    <button #filterButton
                        type="submit"
                        class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        [disabled]="disabled"
                        (keydown.tab)="onTab($event, 'filter')">{{filterText}}</button>
                </div>
            </div>
        </form>
    `
            }]
    }], function () { return [{ type: FilterService, decorators: [{
                type: SkipSelf
            }] }, { type: FilterService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: MenuTabbingService }]; }, { close: [{
            type: Output
        }], actionsClass: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }], filter: [{
            type: Input
        }], column: [{
            type: Input
        }], isLast: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], resetButton: [{
            type: ViewChild,
            args: ['resetButton', { static: false }]
        }], filterButton: [{
            type: ViewChild,
            args: ['filterButton', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterMenuInputWrapperComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-filter-menu-input-wrapper',
                template: `
        <kendo-dropdownlist
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            [data]="operators"
            (valueChange)="operatorChange($event)"
            [value]="currentOperator"
            [valuePrimitive]="true"
            textField="text"
            valueField="value"
            (keydown.shift.tab)="onShiftTab($event)">
        </kendo-dropdownlist>
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { currentFilter: [{
            type: Input
        }], filterService: [{
            type: Input
        }], isFirstDropDown: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }], firstOperatorDropDown: [{
            type: ViewChild,
            args: [DropDownListComponent, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StringFilterMenuInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-string-filter-menu-input',
                template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
            >
            <input
                kendoTextBox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                [ngModel]="currentFilter?.value" />
        </kendo-grid-filter-menu-input-wrapper>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { operators: [{
            type: Input
        }], column: [{
            type: Input
        }], filter: [{
            type: Input
        }], operator: [{
            type: Input
        }], currentFilter: [{
            type: Input
        }], filterService: [{
            type: Input
        }], isFirstDropDown: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StringFilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-string-filter-menu',
                template: `
        <kendo-grid-string-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [isFirstDropDown]="true"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true" (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-string-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { filter: [{
            type: Input
        }], extra: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }], column: [{
            type: Input
        }], filterService: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumericFilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-numeric-filter-menu',
                template: `
        <kendo-grid-numeric-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [isFirstDropDown]="true"
            >
        </kendo-grid-numeric-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-numeric-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-numeric-filter-menu-input>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { filter: [{
            type: Input
        }], extra: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }], column: [{
            type: Input
        }], filterService: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumericFilterMenuInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-numeric-filter-menu-input',
                template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
        >
            <kendo-numerictextbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step"
            >
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                >
                </kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-menu-input-wrapper>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { operators: [{
            type: Input
        }], step: [{
            type: Input
        }], spinners: [{
            type: Input
        }], column: [{
            type: Input
        }], filter: [{
            type: Input
        }], operator: [{
            type: Input
        }], currentFilter: [{
            type: Input
        }], filterService: [{
            type: Input
        }], isFirstDropDown: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], decimals: [{
            type: Input
        }], format: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateFilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-date-filter-menu',
                template: `
        <kendo-grid-date-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [isFirstDropDown]="true"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-date-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-date-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-date-filter-menu-input>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { filter: [{
            type: Input
        }], extra: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }], column: [{
            type: Input
        }], filterService: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BooleanFilterRadioButtonDirective, [{
        type: Directive,
        args: [{ selector: '[kendoFilterMenuRadioButton]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { columnLabel: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BooleanFilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-boolean-filter-menu',
                template: `
        <ul class="k-radio-list k-reset">
            <li *ngFor="let item of items">
                <input type="radio"
                    kendoFilterMenuRadioButton
                    [columnLabel]="columnLabel"
                    #input
                    [name]="idPrefix"
                    kendoRadioButton
                    [checked]="isSelected(item.value)"
                    [attr.id]="radioId(item.value)"
                    (change)="onChange(item.value, input)"
                    (keydown.shift.tab)="onShiftTab($event)"
                />
                <label class="k-radio-label" [attr.for]="radioId(item.value)">{{item.text}}</label>
            </li>
        </ul>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { filter: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }], filterService: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }], radioButtons: [{
            type: ViewChildren,
            args: [BooleanFilterRadioButtonDirective]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterMenuHostDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFilterMenuHost]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }]; }, { filterService: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateFilterMenuInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-date-filter-menu-input',
                template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
        >
            <kendo-datepicker
                #picker
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                (open)="open(picker)"
                [value]="currentFilter?.value"
                [placeholder]="placeholder"
                [formatPlaceholder]="formatPlaceholder"
                [format]="format"
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber"
            >
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                >
                </kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-menu-input-wrapper>
    `
            }]
    }], function () { return [{ type: SinglePopupService }, { type: ɵngcc1.LocalizationService }]; }, { operators: [{
            type: Input
        }], column: [{
            type: Input
        }], filter: [{
            type: Input
        }], operator: [{
            type: Input
        }], currentFilter: [{
            type: Input
        }], filterService: [{
            type: Input
        }], menuTabbingService: [{
            type: Input
        }], format: [{
            type: Input
        }], formatPlaceholder: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], activeView: [{
            type: Input
        }], bottomView: [{
            type: Input
        }], topView: [{
            type: Input
        }], weekNumber: [{
            type: Input
        }], isFirstDropDown: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterMenuDropDownListDirective, [{
        type: Directive,
        args: [{ selector: '[kendoFilterMenuDropDown]' }]
    }], function () { return [{ type: ɵngcc8.DropDownListComponent }]; }, { filterMenuDropDownLabel: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FilterMenuModule, [{
        type: NgModule,
        args: [{
                declarations: [INTERNAL_COMPONENTS$2],
                entryComponents: ENTRY_COMPONENTS$1,
                exports: [INTERNAL_COMPONENTS$2, SharedFilterModule],
                imports: [SharedFilterModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FilterMenuModule, { declarations: [FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective], imports: [SharedFilterModule], exports: [FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, SharedFilterModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnListComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-columnlist',
                template: `
        <div class="k-column-list">
            <label *ngFor="let column of columns; let index = index;" class='k-column-list-item'>
                <input class="k-checkbox k-checkbox-md k-rounded-md" type="checkbox" [attr.data-index]="index" [checked]="!column.hidden" [disabled]="isDisabled(column)" /><span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
        </div>
        <div [ngClass]="actionsClass" *ngIf="!autoSync">
            <button type="button" class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle" (click)="cancelChanges()">{{ resetText }}</button>
            <button #applyButton type="button" (keydown.tab)="onTab($event)" class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle" (click)="applyChanges()">{{ applyText }}</button>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { reset: [{
            type: Output
        }], apply: [{
            type: Output
        }], columnChange: [{
            type: Output
        }], autoSync: [{
            type: Input
        }], allowHideAll: [{
            type: Input
        }], actionsClass: [{
            type: Input
        }], className: [{
            type: HostBinding,
            args: ["class.k-column-list-wrapper"]
        }], columns: [{
            type: Input
        }], applyText: [{
            type: Input
        }], resetText: [{
            type: Input
        }], isLast: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], service: [{
            type: Input
        }], applyButton: [{
            type: ViewChild,
            args: ['applyButton', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnChooserComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-column-chooser',
                template: `
        <button #anchor
            type="button"
            (click)="toggle(anchor, template)"
            class="k-button k-button-flat-base k-button-flat k-icon-button k-button-md k-rounded-md k-button-rectangle k-icon-button"
            [attr.title]="localization.get('columns')">
            <span class="k-button-icon k-icon k-i-columns"></span>
        </button>
        <ng-template #template>
            <span class='k-column-chooser-title'>{{ localization.get('columns') }}</span>
            <kendo-grid-columnlist
                [columns]="columns"
                [applyText]="localization.get('columnsApply')"
                [resetText]="localization.get('columnsReset')"
                [autoSync]="autoSync"
                [allowHideAll]="allowHideAll"
                (apply)="onApply($event)"
                (columnChange)="onChange($event)">
            </kendo-grid-columnlist>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ColumnInfoService }, { type: ɵngcc3.PopupService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { autoSync: [{
            type: Input
        }], allowHideAll: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuChooserComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-columnmenu-chooser',
                template: `
        <kendo-grid-columnmenu-item
            [text]="localization.get('columns')"
            icon="columns"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnlist
                    [applyText]="localization.get('columnsApply')"
                    [resetText]="localization.get('columnsReset')"
                    [columns]="columns"
                    [autoSync]="false"
                    [allowHideAll]="false"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    [service]="service"
                    (apply)="onApply($event)">
                </kendo-grid-columnlist>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ColumnInfoService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], expanded: [{
            type: Input
        }], isLast: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuFilterComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-columnmenu-filter',
                template: `
        <kendo-grid-columnmenu-item
            [text]="localization.get('filter')"
            icon="filter"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                </kendo-grid-filter-menu-container>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ElementRef }]; }, { expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], expanded: [{
            type: Input
        }], isLast: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuItemContentTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridColumnMenuItemContentTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuItemComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('state', [
                        state('collapsed', style({ display: 'none' })),
                        state('expanded', style({ display: 'block' })),
                        transition('collapsed => expanded', [
                            style({
                                height: '0px',
                                display: 'block'
                            }),
                            animate('100ms ease-in', style({
                                height: '*'
                            }))
                        ]),
                        transition('expanded => collapsed', [
                            style({
                                height: '*'
                            }),
                            animate('100ms ease-in', style({
                                height: '0px'
                            }))
                        ])
                    ])
                ],
                selector: 'kendo-grid-columnmenu-item',
                template: `
        <div
            class="k-columnmenu-item"
            (click)="onClick($event)"
            (keydown.enter)="onClick($event)"
            [class.k-state-selected]="selected"
            [class.k-state-disabled]="disabled"
            role="button"
            [attr.aria-expanded]="expanded">
           <span *ngIf="icon" class="k-icon" [ngClass]="iconClass">
           </span>
           {{ text }}
        </div>
        <div *ngIf="contentTemplate" [@state]="contentState" style="overflow:hidden;" class="k-columnmenu-item-content">
            <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
            </ng-container>
        <div>
    `
            }]
    }], function () { return []; }, { itemClick: [{
            type: Output
        }], expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], expanded: [{
            type: Input
        }], icon: [{
            type: Input
        }], text: [{
            type: Input
        }], selected: [{
            type: Input
        }], disabled: [{
            type: Input
        }], contentTemplate: [{
            type: ContentChild,
            args: [ColumnMenuItemContentTemplateDirective, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuSortComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-columnmenu-sort',
                template: `
        <kendo-grid-columnmenu-item
            [text]="localization.get('sortAscending')"
            icon="sort-asc-sm"
            (itemClick)="toggleSort('asc')"
            [selected]="sortedAsc">
        </kendo-grid-columnmenu-item>
        <kendo-grid-columnmenu-item
            [text]="localization.get('sortDescending')"
            icon="sort-desc-sm"
            (itemClick)="toggleSort('desc')"
            [selected]="sortedDesc">
        </kendo-grid-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: SortService }, { type: ɵngcc0.Renderer2 }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuLockComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-columnmenu-lock',
                template: `
       <kendo-grid-columnmenu-item
            [text]="text"
            [icon]="icon"
            (itemClick)="toggleColumn()"
            [disabled]="disabled">
       </kendo-grid-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ColumnInfoService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuPositionComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-columnmenu-position',
                template: `
        <kendo-grid-columnmenu-item
            [text]="localization.get('setColumnPosition')"
            icon="set-column-position"
            [expanded]="expanded"
            (keydown.tab)="onTab($event, !expanded)"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnmenu-lock
                    *ngIf="showLock"
                    (keydown.tab)="onTab($event, !showStick)"
                    [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick
                    *ngIf="showStick"
                    (keydown.tab)="onTab($event, true)"
                    [service]="service">
                </kendo-grid-columnmenu-stick>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ElementRef }]; }, { expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], expanded: [{
            type: Input
        }], isLast: [{
            type: Input
        }], showLock: [{
            type: Input
        }], showStick: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuItemDirective, [{
        type: Directive,
        args: [{ selector: '[kendoGridColumnMenuItem]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { menuItemComponent: [{
            type: Input,
            args: ['kendoGridColumnMenuItem']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuContainerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-columnmenu-container',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ColumnMenuService }, { type: ɵngcc0.NgZone }]; }, { columnMenuItems: [{
            type: ContentChildren,
            args: [ColumnMenuItemDirective, { descendants: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuStickComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-columnmenu-stick',
                template: `
       <kendo-grid-columnmenu-item [text]="text" [icon]="icon" (itemClick)="toggleColumn()" [disabled]="disabled">
       </kendo-grid-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ColumnInfoService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnMenuModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENTS$1],
                imports: [CommonModule, FilterMenuModule],
                exports: [COMPONENTS$1]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ColumnMenuModule, { declarations: function () { return [ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent]; }, imports: function () { return [CommonModule, FilterMenuModule]; }, exports: function () { return [ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeaderModule, [{
        type: NgModule,
        args: [{
                declarations: [exportedModules$2],
                exports: [exportedModules$2],
                imports: [...importedModules$2]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HeaderModule, { declarations: [HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective], imports: [CommonModule, GroupModule, RowFilterModule, FilterMenuModule, SharedModule, DragAndDropModule, ColumnMenuModule], exports: [HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CommandColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => CommandColumnComponent_1)
                    }
                ],
                selector: 'kendo-grid-command-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: IdService, decorators: [{
                type: Optional
            }] }]; }, { template: [{
            type: ContentChild,
            args: [CellTemplateDirective, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CheckboxColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => CheckboxColumnComponent_1)
                    }
                ],
                selector: 'kendo-grid-checkbox-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: IdService, decorators: [{
                type: Optional
            }] }]; }, { showSelectAll: [{
            type: Input
        }], template: [{
            type: ContentChild,
            args: [CellTemplateDirective, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SelectionCheckboxDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridSelectionCheckbox]'
            }]
    }], function () { return [{ type: SelectionService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { type: [{
            type: HostBinding,
            args: ['attr.type']
        }], itemIndex: [{
            type: Input,
            args: ["kendoGridSelectionCheckbox"]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableBodyComponent, [{
        type: Component,
        args: [{
                selector: '[kendoGridTableBody]',
                template: `
    <ng-template [ngIf]="editService.hasNewItem">
        <tr class="k-grid-add-row k-grid-edit-row"
            kendoGridLogicalRow
                [logicalRowIndex]="addRowLogicalIndex()"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount">
            <ng-template [ngIf]="!skipGroupDecoration">
                <td class="k-group-cell" *ngFor="let g of groups" role="presentation"></td>
            </ng-template>
            <td class="k-hierarchy-cell"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;"
                kendoGridCell
                    [rowIndex]="-1"
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [isNew]="true"
                    [column]="column"
                    [dataItem]="newDataItem"
                [class.k-grid-content-sticky]="column.sticky"
                [ngClass]="column.cssClass"
                [style.left]="column.sticky ? '0' : undefined"
                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                [attr.colspan]="column.colspan"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="logicalColIndex(column)"
                    [colSpan]="column.colspan"
                role="gridcell">
            </td>
        </tr>
    </ng-template>
    <tr *ngIf="data?.length === 0 || data == null" class="k-grid-norecords">
        <td [attr.colspan]="colSpan">
            <ng-template
                [ngIf]="noRecordsTemplate?.templateRef"
                [templateContext]="{
                    templateRef: noRecordsTemplate?.templateRef
                 }">
            </ng-template>
            <ng-container *ngIf="!noRecordsTemplate?.templateRef">
                {{noRecordsText}}
            </ng-container>
        </td>
    </tr>

    <ng-template ngFor
        [ngForOf]="data"
        [ngForTrackBy]="trackByWrapper"
        let-item
        let-rowIndex="index">
        <tr *ngIf="isGroup(item) && isParentGroupExpanded(item) && showGroupHeader(item)"
            kendoGridGroupHeader
                [columns]="columns"
                [groups]="groups"
                [item]="item"
                [hasDetails]="detailTemplate?.templateRef"
                [skipGroupDecoration]="skipGroupDecoration"
                [hasGroupHeaderColumn]="hasGroupHeaderColumn"
                [groupHeaderColumns]="groupHeaderColumns"
                [rowIndex]="rowIndex + 1"
                [totalColumnsCount]="totalColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="groupHeaderSlaveCellsCount">
        </tr>
        <tr
            *ngIf="isDataItem(item) && (!item.group || isDataItemInExpandedGroup(item))"
            kendoGridLogicalRow
                [dataRowIndex]="item.index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
            [class.k-grid-row-sticky]="rowSticky ? rowSticky({ dataItem: item.data, index: item.index }) : false"
            [ngClass]="rowClass({ dataItem: item.data, index: item.index })"
            [class.k-alt]="isOdd(item)"
            [class.k-master-row]="detailTemplate?.templateRef"
            [class.k-grid-edit-row]="isEditingRow(item.index)"
            [attr.data-kendo-grid-item-index]="item.index"
            [class.k-state-selected]="isSelectable() && isRowSelected(item)">
            <ng-template [ngIf]="!skipGroupDecoration">
                <td class="k-group-cell" *ngFor="let g of groups" role="presentation"></td>
            </ng-template>
            <td class="k-hierarchy-cell"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    [dataRowIndex]="item.index"
                    [dataItem]="item.data"
                    [detailExpandCell]="true"
                    aria-selected="false"
                >
                <a class="k-icon"
                    *ngIf="detailTemplate.showIf(item.data, item.index)"
                    [ngClass]="detailButtonStyles(item)"
                    [attr.title]="detailButtonTitle(item)"
                    [attr.aria-label]="detailButtonTitle(item)"
                    href="#" tabindex="-1" (click)="toggleRow(item.index, item.data)"></a>
            </td>
            <td
                kendoGridCell
                    [rowIndex]="item.index"
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [attr.data-kendo-grid-column-index]="lockedColumnsCount + columnIndex"
                    [column]="column"
                    [dataItem]="item.data"
                    [isLoading]="isLoading"
                    [isVirtual]="isVirtual"
                    [loadingTemplate]="cellLoadingTemplate"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                    [dataRowIndex]="item.index"
                    [dataItem]="item.data"
                    [colIndex]="columnIndex"
                    [colSpan]="column.colspan"
                    role="gridcell"
                    [attr.aria-selected]="isSelectable() ? isAriaSelected(item, column) : undefined"
                    [class.k-grid-content-sticky]="column.sticky"
                    [class.k-touch-action-none]="isSelectable() && $any(selectable).drag"
                    [class.k-touch-action-auto]="!(isSelectable() && $any(selectable).drag)"
                [ngClass]="column.cssClass"
                [class.k-grid-edit-cell]="isEditingCell(item.index, column)"
                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                [attr.colspan]="column.colspan"
                [class.k-state-selected]="isSelectable && cellSelectionService.isCellSelected(item, column)"
                *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;">
            </td>
        </tr>
        <tr *ngIf="isDataItem(item) &&
                (!item.group || isDataItemInExpandedGroup(item)) &&
                detailTemplate?.templateRef &&
                detailTemplate.showIf(item.data, item.index) &&
                isExpanded(item)"
            class="k-detail-row"
            [class.k-alt]="isOdd(item)"
            kendoGridLogicalRow
                [dataRowIndex]="item.index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                [logicalSlaveRow]="false"
                [logicalCellsCount]="1"
            >
            <td class="k-group-cell" *ngFor="let g of groups"></td>
            <td class="k-hierarchy-cell"></td>
            <td class="k-detail-cell"
                [attr.colspan]="columnsSpan"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                    [logicalColIndex]="0"
                    [dataRowIndex]="item.index"
                    [dataItem]="item.data"
                    [colIndex]="0"
                    [colSpan]="allColumnsSpan + 1"
                    role="gridcell" aria-selected="false"
                >
                <ng-template
                    [ngTemplateOutlet]="detailTemplate.templateRef"
                    [ngTemplateOutletContext]="{
                        dataItem: item.data,
                        rowIndex: item.index,
                        $implicit: item.data
                    }">
                </ng-template>
            </td>
        </tr>
        <tr *ngIf="isFooter(item) &&
                item.group &&
                (isFooterItemInExpandedGroup(item) || (showGroupFooters && isParentGroupExpanded(item.group))) &&
                !item.data.hideFooter"
            class="k-group-footer"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount">
            <ng-template [ngIf]="!skipGroupDecoration">
                <td class="k-group-cell" *ngFor="let g of groups"></td>
            </ng-template>
            <td class="k-hierarchy-cell"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                [attr.data-skip]="skipGroupDecoration"
                *ngFor="let column of footerColumns; let columnIndex = index; trackBy: trackByColumns;">
                <ng-template
                    [templateContext]="{
                        templateRef: column.groupFooterTemplateRef,
                        group: item.data,
                        field: column.field,
                        column: column,
                        aggregates: item.data?.aggregates,
                        $implicit: item.data?.aggregates
                    }">
                </ng-template>
           </td>
        </tr>
    </ng-template>
    <kendo-resize-sensor *ngIf="rowSticky" (resize)="resizeHandler()"></kendo-resize-sensor>
    `
            }]
    }], function () { return [{ type: DetailsService }, { type: GroupsService }, { type: ChangeNotificationService }, { type: EditService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: DomEventsService }, { type: SelectionService }, { type: CellSelectionService }, { type: ColumnInfoService }, { type: NavigationService }]; }, { columns: [{
            type: Input
        }], groups: [{
            type: Input
        }], skip: [{
            type: Input
        }], noRecordsText: [{
            type: Input
        }], isLocked: [{
            type: Input
        }], skipGroupDecoration: [{
            type: Input
        }], showGroupFooters: [{
            type: Input
        }], lockedColumnsCount: [{
            type: Input
        }], totalColumnsCount: [{
            type: Input
        }], trackBy: [{
            type: Input
        }], rowClass: [{
            type: Input
        }], allColumns: [{
            type: Input
        }], detailTemplate: [{
            type: Input
        }], noRecordsTemplate: [{
            type: Input
        }], data: [{
            type: Input
        }], selectable: [{
            type: Input
        }], filterable: [{
            type: Input
        }], isLoading: [{
            type: Input
        }], isVirtual: [{
            type: Input
        }], cellLoadingTemplate: [{
            type: Input
        }], virtualColumns: [{
            type: Input
        }], rowSticky: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CellComponent, [{
        type: Component,
        args: [{
                selector: '[kendoGridCell]',
                template: `
        <ng-container [ngSwitch]="isEdited">
            <ng-container *ngSwitchCase="false">
                <ng-container *ngIf="!showLoading; else loading">
                    <ng-template [ngIf]="column.templateRef"
                        [ngTemplateOutlet]="column.templateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                    <ng-template [ngIf]="isSpanColumn">
                        <ng-template ngFor let-childColumn [ngForOf]="childColumns">
                            {{ dataItem | valueOf: childColumn.field: childColumn.format}}
                        </ng-template>
                    </ng-template>
                    <ng-template [ngIf]="isBoundColumn">{{ dataItem | valueOf: column.field: column.format}}</ng-template>
                    <ng-template [ngIf]="isCheckboxColumn && !isNew">
                        <input
                            class="k-checkbox k-checkbox-md k-rounded-md"
                            [kendoGridSelectionCheckbox]="rowIndex"
                            [attr.id]="selectionCheckboxId"
                            [attr.aria-label]="selectionCheckboxLabel" />
                    </ng-template>
                </ng-container>
                <ng-template #loading>
                    <ng-template
                        *ngIf="loadingTemplate"
                        [ngTemplateOutlet]="loadingTemplate"
                        [ngTemplateOutletContext]="{$implicit: column}">
                    </ng-template>
                    <div *ngIf="!loadingTemplate" class="k-skeleton-text k-skeleton"></div>
                </ng-template>
            </ng-container>
            <ng-container *ngSwitchCase="true">
                <ng-template
                    *ngIf="column.editTemplateRef"
                    [ngTemplateOutlet]="column.editTemplateRef"
                    [ngTemplateOutletContext]="editTemplateContext">
                </ng-template>
                <ng-container [ngSwitch]="column.editor" *ngIf="!column.editTemplateRef">
                    <kendo-numerictextbox
                        *ngSwitchCase="'numeric'"
                        [format]="format"
                        [formControl]="formGroup.get(column.field)"
                        kendoGridFocusable
                    ></kendo-numerictextbox>

                    <kendo-datepicker
                        *ngSwitchCase="'date'"
                        [format]="format"
                        [formControl]="formGroup.get(column.field)"
                        kendoGridFocusable
                    ></kendo-datepicker>

                    <input
                        *ngSwitchCase="'boolean'"
                        type="checkbox"
                        class="k-checkbox k-checkbox-md k-rounded-md"
                        [formControl]="formGroup.get(column.field)"
                        kendoGridFocusable
                    />

                    <input
                        *ngSwitchDefault
                        type="text"
                        class="k-textbox k-input k-rounded-md"
                        [formControl]="formGroup.get(column.field)"
                        kendoGridFocusable
                    />
                </ng-container>
            </ng-container>
        </ng-container>
    `
            }]
    }], function () { return [{ type: EditService }, { type: IdService }, { type: ɵngcc1.LocalizationService }, { type: Object, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CELL_CONTEXT]
            }] }]; }, { isNew: [{
            type: Input
        }], isLoading: [{
            type: Input
        }], isVirtual: [{
            type: Input
        }], commandCellClass: [{
            type: HostBinding,
            args: ['class.k-command-cell']
        }], rowIndex: [{
            type: Input
        }], column: [{
            type: Input
        }], columnIndex: [{
            type: Input
        }], loadingTemplate: [{
            type: Input
        }], dataItem: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EditCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridEditCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: Object, decorators: [{
                type: Inject,
                args: [CELL_CONTEXT]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-edit-command']
        }], visible: [{
            type: HostBinding,
            args: ['style.display']
        }], 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CancelCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridCancelCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: Object, decorators: [{
                type: Inject,
                args: [CELL_CONTEXT]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-cancel-command']
        }], visible: [{
            type: HostBinding,
            args: ['style.display']
        }], 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SaveCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridSaveCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: Object, decorators: [{
                type: Inject,
                args: [CELL_CONTEXT]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-save-command']
        }], visible: [{
            type: HostBinding,
            args: ['style.display']
        }], 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RemoveCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridRemoveCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: Object, decorators: [{
                type: Inject,
                args: [CELL_CONTEXT]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-remove-command']
        }], visible: [{
            type: HostBinding,
            args: ['style.display']
        }], 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AddCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridAddCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-add-command']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BodyModule, [{
        type: NgModule,
        args: [{
                declarations: [exported$1],
                exports: [exported$1],
                imports: [...importedModules$3]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BodyModule, { declarations: [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective], imports: [CommonModule,
        ReactiveFormsModule,
        FormsModule, SharedModule, GroupModule, NumericTextBoxModule,
        DatePickerModule,
        ResizeSensorModule], exports: [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FooterComponent, [{
        type: Component,
        args: [{
                selector: '[kendoGridFooter]',
                template: `
    <ng-template [ngIf]="true">
        <tr
            [class.k-footer-template]="true"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="columns.length - lockedColumnsCount"
            >
            <td
                [class.k-group-cell]="true"
                role="presentation"
                *ngFor="let g of groups">
            </td>
            <td
                [class.k-hierarchy-cell]="true"
                role="presentation"
                *ngIf="detailTemplate?.templateRef">
            </td>
            <td
                *ngFor="let column of columnsToRender; let columnIndex = index"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    role="columnfooter"
                    aria-selected="false"
                [class.k-grid-footer-sticky]="column.sticky"
                [ngClass]="column.footerClass"
                [ngStyle]="column.sticky ? addStickyStyles(column) : column.footerStyle">
                <ng-template
                    [templateContext]="{
                        templateRef: column.footerTemplateRef,
                        columnIndex: lockedColumnsCount + columnIndex,
                        column: column,
                        $implicit: column
                    }">
                </ng-template>
            </td>
        </tr>
    </ng-template>
    `
            }]
    }], function () { return [{ type: ColumnInfoService }]; }, { columns: [{
            type: Input
        }], groups: [{
            type: Input
        }], lockedColumnsCount: [{
            type: Input
        }], logicalRowIndex: [{
            type: Input
        }], footerClass: [{
            type: HostBinding,
            args: ['class.k-grid-footer']
        }], detailTemplate: [{
            type: Input
        }], scrollable: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FooterModule, [{
        type: NgModule,
        args: [{
                declarations: [exportedModules$3],
                exports: [exportedModules$3],
                imports: [...importedModules$4]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FooterModule, { declarations: [FooterComponent], imports: [CommonModule, SharedModule], exports: [FooterComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToolbarComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-toolbar',
                template: `
        <ng-template
            *ngIf="toolbarTemplateRef"
            [ngTemplateOutlet]="toolbarTemplateRef"
            [ngTemplateOutletContext]="context"
            >
        </ng-template>
    `
            }]
    }], function () { return [{ type: GridComponent }]; }, { position: [{
            type: Input
        }] }); })();


(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TemplateEditingDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridTemplateEditing]'
            }]
    }], function () { return [{ type: GridComponent }, { type: LocalDataChangesService }]; }, { createNewItem: [{
            type: Input,
            args: ['kendoGridTemplateEditing']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ReactiveEditingDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridReactiveEditing]'
            }]
    }], function () { return [{ type: GridComponent }, { type: LocalDataChangesService }]; }, { createFormGroup: [{
            type: Input,
            args: ['kendoGridReactiveEditing']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InCellEditingDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridInCellEditing]'
            }]
    }], function () { return [{ type: GridComponent }, { type: LocalDataChangesService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { createFormGroup: [{
            type: Input,
            args: ['kendoGridInCellEditing']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupBindingDirective, [{
        type: Directive,
        args: [{ selector: '[kendoGridGroupBinding]' }]
    }], function () { return [{ type: GridComponent }, { type: ɵngcc0.ChangeDetectorRef }, { type: LocalDataChangesService }]; }, { kendoGridGroupBinding: [{
            type: Input,
            args: ["kendoGridGroupBinding"]
        }], sort: [{
            type: Input
        }], filter: [{
            type: Input
        }], group: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations],
                exports: [exportedModules$4],
                imports: [
                    CommonModule,
                    GroupModule,
                    SharedModule,
                    BodyModule,
                    HeaderModule,
                    FooterModule,
                    PagerModule,
                    RowFilterModule,
                    FilterMenuModule,
                    ResizeSensorModule,
                    ColumnMenuModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GridModule, { declarations: function () { return [GridComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective, CustomMessagesComponent, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GroupBindingDirective, GridMarqueeDirective, GridSpacerComponent]; }, imports: function () { return [CommonModule, GroupModule, SharedModule, BodyModule, HeaderModule, FooterModule, PagerModule, RowFilterModule, FilterMenuModule, ResizeSensorModule, ColumnMenuModule]; }, exports: function () { return [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, DataBindingDirective, SelectionDirective, CustomMessagesComponent, GroupBindingDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, ColumnComponent, SpanColumnComponent, ColumnGroupComponent, FooterTemplateDirective, DetailTemplateDirective, FocusableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, NoRecordsTemplateDirective, EditTemplateDirective, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, HeaderTemplateDirective, SelectAllCheckboxDirective, PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, FilterCellOperatorsComponent, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, DateFilterCellComponent, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, ColumnChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PDFMarginComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-pdf-margin',
                template: ''
            }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PDFTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridPDFTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PDFComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-pdf',
                template: ''
            }]
    }], function () { return [{ type: PDFService }, { type: SuspendService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }]; }, { delay: [{
            type: Input
        }], columns: [{
            type: ContentChildren,
            args: [ColumnBase$1]
        }], allPages: [{
            type: Input
        }], marginComponent: [{
            type: ContentChild,
            args: [PDFMarginComponent, { static: false }]
        }], pageTemplateDirective: [{
            type: ContentChild,
            args: [PDFTemplateDirective, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PDFCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridPDFCommand]'
            }]
    }], function () { return [{ type: PDFService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], pdfClass: [{
            type: HostBinding,
            args: ['class.k-grid-pdf']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PDFModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$1],
                exports: [exportedModules$5]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PDFModule, { declarations: [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective], exports: [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExcelComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-grid-excel',
                template: ``
            }]
    }], function () { return [{ type: ExcelService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { fileName: [{
            type: Input
        }], columns: [{
            type: ContentChildren,
            args: [ColumnBase, { descendants: true }]
        }], filterable: [{
            type: Input
        }], creator: [{
            type: Input
        }], date: [{
            type: Input
        }], forceProxy: [{
            type: Input
        }], proxyURL: [{
            type: Input
        }], fetchData: [{
            type: Input
        }], paddingCellOptions: [{
            type: Input
        }], headerPaddingCellOptions: [{
            type: Input
        }], collapsible: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExcelCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoGridExcelCommand]'
            }]
    }], function () { return [{ type: ExcelService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], excelClass: [{
            type: HostBinding,
            args: ['class.k-grid-excel']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExcelModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$2],
                exports: [declarations$2, ExcelExportModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ExcelModule, { declarations: function () { return [ExcelComponent, ExcelCommandDirective]; }, exports: function () { return [ExcelComponent, ExcelCommandDirective, ExcelExportModule]; } }); })();





/**
 * Generated bundle index. Do not edit.
 */

export { ColumnChooserComponent, ColumnListComponent, ColumnMenuChooserComponent, ColumnMenuContainerComponent, ColumnMenuFilterComponent, ColumnMenuItemBase, ColumnMenuItemContentTemplateDirective, ColumnMenuItemComponent, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuPositionComponent, ColumnMenuSortComponent, ColumnMenuStickComponent, ColumnMenuTemplateDirective, ColumnMenuModule, ColumnMenuService, ColumnHandleDirective, ColumnResizingService, TableDirective, ColumnInfoService, DomEventsService, IdService, PreventableEvent, SortService, ChangeNotificationService, ColumnReorderService, DragAndDropModule, DragAndDropService, DragHintService, DraggableColumnDirective, DropCueService, DropTargetDirective, EditingDirectiveBase, RowEditingDirectiveBase, AddCommandDirective, CancelCommandDirective, EditCommandDirective, EditService as EditService$1, LocalDataChangesService, RemoveCommandDirective, SaveCommandDirective, ExcelCommandDirective, BooleanFilterComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellOperatorsComponent, FilterCellWrapperComponent, DateFilterComponent, FilterHostDirective, FilterInputWrapperComponent, FilterInputDirective, FilterRowComponent, DateFilterMenuInputComponent, FilterMenuContainerComponent, FilterMenuDropDownListDirective, FilterMenuHostDirective, FilterMenuInputWrapperComponent, FilterMenuComponent, BooleanFilterRadioButtonDirective, NumericFilterMenuInputComponent, StringFilterMenuInputComponent, NumericFilterComponent, FilterOperatorBase, SharedFilterModule, StringFilterComponent, GroupHeaderComponent, GroupIndicatorComponent, GroupInfoService, GroupPanelComponent, GroupsService, BrowserSupportService, ResizeService, ResponsiveService, LocalizedMessagesDirective, Messages, FocusGroup, FOCUS_ROOT_ACTIVE, FocusRoot, LogicalCellDirective, LogicalRowDirective, NavigationService, PagerContextService, PagerDropDownListDirective, PagerElementComponent, PagerInputDirective, PDFCommandDirective, PDFTemplateDirective, CellComponent, CELL_CONTEXT, EMPTY_CELL_CONTEXT, FieldAccessorPipe, DetailsService, DEFAULT_SCROLLER_FACTORY, SCROLLER_FACTORY_TOKEN, ScrollRequestService, ScrollSyncService, ScrollerService, CellSelectionService, GridMarqueeDirective, SelectAllCheckboxDirective, SelectionCheckboxDirective, Selection, SelectionService, GridModule, SharedModule, GridComponent, ColumnBase$1 as ColumnBase, ColumnComponent, CommandColumnComponent, SpanColumnComponent, ColumnGroupComponent, CheckboxColumnComponent, ToolbarComponent, ToolbarTemplateDirective, CellTemplateDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, PagerTemplateDirective, GridSpacerComponent, ExpandDetailsDirective, ExpandGroupDirective, DetailTemplateDirective, DetailExpandEvent, DetailCollapseEvent, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, ResizableContainerDirective, TemplateContextDirective, NoRecordsTemplateDirective, DataBindingDirective, SelectionDirective, FilterService, FilterCellTemplateDirective, FilterCellComponent, StringFilterCellComponent, DateFilterCellComponent, BaseFilterCellComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, StringFilterMenuComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, AfterEqFilterOperatorComponent, AfterFilterOperatorComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, RowFilterModule, FilterMenuModule, BodyModule, GroupModule, HeaderModule, FooterModule, PagerModule, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, EditTemplateDirective, ColGroupComponent, HeaderComponent, ListComponent, FooterComponent, TableBodyComponent, PagerComponent, CustomMessagesComponent, LoadingComponent, PDFModule, PDFComponent, PDFMarginComponent, PDFService, ExcelModule, ExcelComponent, ExcelService, ExcelExportEvent, CellCloseEvent, SuspendService, GroupBindingDirective, slice, count, Skip, ColumnReorderEvent, FocusableDirective, ColumnVisibilityChangeEvent, ColumnMenuComponent, ColumnLockedChangeEvent, ColumnStickyChangeEvent, SinglePopupService, PopupCloseEvent, MenuTabbingService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7MElBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBTXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBKQUdxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytLQUc0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUlBQUU7QUFDRix3QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3WEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MklBQUU7QUFDRiwwQkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpSkFHa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VJQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29KQUdtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NLQUd5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkpBQUU7QUFDRixnQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswSkFBRTtBQUNGLCtCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NLQUFFO0FBQ0YsbUNBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O1dBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxSkFBRTtBQUNGLG9DQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswS0FBRTtBQUNGLDJDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0TEFBRTtBQUNGLGlEQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FKQUFFO0FBQ0Ysb0NBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswS0FBRTtBQUNGLDJDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsySkFBRTtBQUNGLHNDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsySkFBRTtBQUNGLHNDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VLQUFFO0FBQ0YsMENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7c2pCQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUtBQUU7QUFDRiwwQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUtBQUU7QUFDRiwwQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxSUFBRTtBQUNGLHdCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpSkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7cUpBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7c0pBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0TkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eUtBQUU7QUFDRixvQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1NBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhIQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUxBQUU7QUFDRix3Q0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29LQUFFO0FBQ0YseUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0tBR3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpSkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0pBQUU7QUFDRixxQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0lBR2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29KQUdtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkpBR3NCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhJQUdpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dNQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkpBQUU7QUFDRixnQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aUpBR2tCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5S0FHMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnS0FBRTtBQUNGLGlDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dLQUd1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VKQUFFO0FBQ0YsOEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0pBR21CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c0tBR3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZKQUdzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytHQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswS0FBRTtBQUNGLDJDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhKQUFFO0FBQ0YsdUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tuQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkE2Zkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d09BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQXVHRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJUQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswTEFBRTtBQUNGLGlDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a2ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUtHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytaQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OG9GQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFBRTtBQUNGLHdFQVVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7eUpBQUU7QUFDRixrRUFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OzJLQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0E0Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7d0tBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBcUJ3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eUhBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztXQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z1VBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3VOQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQWtDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt3SUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7bU1BQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztpR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FjRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswTkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7K01BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBb0JHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7MEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0E4Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzsySEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQWtCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OzBHQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OytJQUFFO0FBQ0YseUNBd0JHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzYUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozt1TEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBbUNHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7d0VBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBWXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztpRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFhRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyUUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxTUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0lBQUU7QUFDRix5QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7aURBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FTRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3NSQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1SEFBRTtBQUNGLGdDQUtHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7MkVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozt3SEFPaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2lLQUFFO0FBQ0Ysa0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt1S0FBRTtBQUNGLDhGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7aUtBQUU7QUFDRixrRkFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzhKQUFFO0FBQ0YsNEVBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztnS0FBRTtBQUNGLGdGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7bUtBQUU7QUFDRixzRkFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tLQUFFO0FBQ0Ysb0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzsrSkFBRTtBQUNGLDhFQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7aUtBQUU7QUFDRixrRkFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O21LQUFFO0FBQ0Ysc0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztnS0FBRTtBQUNGLGdGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7eUtBQUU7QUFDRixrR0FXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzZKQUFFO0FBQ0YsMEVBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztzS0FBRTtBQUNGLDRGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OEpBQUU7QUFDRiw0RUFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2dLQUFFO0FBQ0YsZ0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztpS0FBRTtBQUNGLGtGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7K0pBQUU7QUFDRiw4RUFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7c0NBT3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MExBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzTUFBRTtBQUNGLHNDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztzSEFRb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K0lBQUU7QUFDRixrQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0tBQUU7QUFDRix5Q0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2UkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQXFERztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUdBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUdBQUU7QUFDRix3Q0ErQ0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttR0FBRTtBQUNGLHdDQStDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0lBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBaUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEtBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQTZCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2lEQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O3FLQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQW1CRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztnR0FPZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7NkxBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FzRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c09BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VOQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQTZDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aURBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBZ0I0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Z0dBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7bUVBTXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O3lIQU9nQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lIQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQXlCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2SkFBRTtBQUNGLGdDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dWQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQTZERztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Mm1CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkEwTkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs2REFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztpSUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MFBBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQThDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7a0lBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FrQkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztnTUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0F1Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OytLQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FtQ0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Z0xBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQWtERztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztnTEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FvQ0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7NktBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQXdERztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7ME5BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OzJIQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBc0JHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0UkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozt3S0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0F3Q0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Mk9BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O3VIQVFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3RkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBZUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Z0VBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBeUJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzsyQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozt5SkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBMkJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O2tLQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0F5Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dNQUFFO0FBQ0YscURBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBOEM0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O29FQUFFO0FBQ0Ysc0NBa0JHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztvRUFBRTtBQUNGLHNDQVlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztvTUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBMEJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0T0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7NkJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7b0VBQUU7QUFDRix1Q0FRRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OytHQU9xQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztpR0FPaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3dKQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7eUpBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7K0VBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O2lTQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0ErTkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OzhaQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQTJFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MERBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MERBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MERBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MERBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzswREFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7K0ZBT2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OzZLQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQThDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztpR0FPaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztpRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFZRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FMQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dKQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1UkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyUkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttUkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dUQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O2NBbUJlO0FBQ2Y7QUFDQTtBQUNBOzt3UkFNdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpTUFBRTtBQUNGLG1DQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozt3TUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFLRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzswREFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzJEQU1jO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MllBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzBEQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIxIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgSG9zdEJpbmRpbmcsIElucHV0LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIEluamVjdCwgRGlyZWN0aXZlLCBTa2lwU2VsZiwgRWxlbWVudFJlZiwgUmVuZGVyZXIyLCBOZ1pvbmUsIENoYW5nZURldGVjdG9yUmVmLCBUZW1wbGF0ZVJlZiwgUXVlcnlMaXN0LCBpc0Rldk1vZGUsIENvbnRlbnRDaGlsZHJlbiwgQ29udGVudENoaWxkLCBmb3J3YXJkUmVmLCBIb3N0LCBPdXRwdXQsIFNlY3VyaXR5Q29udGV4dCwgVmlld0NoaWxkLCBWaWV3Q2hpbGRyZW4sIFZpZXdFbmNhcHN1bGF0aW9uLCBTZWxmLCBWaWV3Q29udGFpbmVyUmVmLCBQaXBlLCBOZ01vZHVsZSwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBIb3N0TGlzdGVuZXIsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc0RvY3VtZW50QXZhaWxhYmxlLCBLZXlzLCBEcmFnZ2FibGVEaXJlY3RpdmUsIGlzQ2hhbmdlZCwgYW55Q2hhbmdlZCwgaGFzT2JzZXJ2ZXJzLCBSZXNpemVTZW5zb3JDb21wb25lbnQsIEtlbmRvSW5wdXQsIERyYWdnYWJsZU1vZHVsZSwgRXZlbnRzTW9kdWxlLCBSZXNpemVTZW5zb3JNb2R1bGUsIGd1aWQgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuaW1wb3J0IHsgbWVyZ2UsIG9mLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24sIGZyb20sIGludGVydmFsLCBmcm9tRXZlbnQsIHppcCwgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCwgQ29tcG9uZW50TWVzc2FnZXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IHN3aXRjaE1hcCwgdGFrZSwgZmlsdGVyLCB0YWtlVW50aWwsIG1hcCwgc3dpdGNoTWFwVG8sIGRlbGF5LCBhdWRpdFRpbWUsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCB0YXAsIHRocm90dGxlVGltZSwgZGVib3VuY2VUaW1lLCBidWZmZXJDb3VudCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwLCBOR19WQUxVRV9BQ0NFU1NPUiwgUmVhY3RpdmVGb3Jtc01vZHVsZSwgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZVBhY2thZ2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tbGljZW5zaW5nJztcbmltcG9ydCB7IG9yZGVyQnksIHByb2Nlc3MsIGlzQ29tcG9zaXRlRmlsdGVyRGVzY3JpcHRvciwgZmlsdGVyQnkgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tZGF0YS1xdWVyeSc7XG5pbXBvcnQgeyBQb3B1cFNlcnZpY2UsIFBvcHVwTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcG9wdXAnO1xuaW1wb3J0IHsgRG9tU2FuaXRpemVyIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBnZXR0ZXIgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tY29tbW9uJztcbmltcG9ydCB7IERyb3BEb3duTGlzdENvbXBvbmVudCwgRHJvcERvd25MaXN0TW9kdWxlLCBBdXRvQ29tcGxldGVNb2R1bGUsIERyb3BEb3duc01vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWRyb3Bkb3ducyc7XG5pbXBvcnQgeyBJbnB1dHNNb2R1bGUsIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LCBOdW1lcmljVGV4dEJveE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWlucHV0cyc7XG5pbXBvcnQgeyBEYXRlUGlja2VyTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZGF0ZWlucHV0cyc7XG5pbXBvcnQgeyBJbnRsU2VydmljZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWludGwnO1xuaW1wb3J0IHsgTGFiZWxNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sYWJlbCc7XG5pbXBvcnQgeyB0cmlnZ2VyLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIGFuaW1hdGUgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWJ1dHRvbnMnO1xuaW1wb3J0IHsgUERGRXhwb3J0TWFyZ2luQ29tcG9uZW50LCBQREZFeHBvcnRUZW1wbGF0ZURpcmVjdGl2ZSwgUERGRXhwb3J0Q29tcG9uZW50IH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcGRmLWV4cG9ydCc7XG5pbXBvcnQgeyBzYXZlQXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tZmlsZS1zYXZlcic7XG5pbXBvcnQgeyB3b3JrYm9va09wdGlvbnMsIHRvRGF0YVVSTCwgQ29sdW1uQmFzZSwgRXhjZWxFeHBvcnRNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1leGNlbC1leHBvcnQnO1xuXG5jb25zdCBFTVBUWV9SRUdFWCA9IC9eXFxzKiQvO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzUHJlc2VudCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0JsYW5rID0gKHZhbHVlKSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQXJyYXkgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzVHJ1dGh5ID0gKHZhbHVlKSA9PiAhIXZhbHVlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzTnVsbE9yRW1wdHlTdHJpbmcgPSAodmFsdWUpID0+IGlzQmxhbmsodmFsdWUpIHx8IEVNUFRZX1JFR0VYLnRlc3QodmFsdWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG9ic2VydmUgPSAobGlzdCkgPT4gbWVyZ2Uob2YobGlzdCksIGxpc3QuY2hhbmdlcyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNVbml2ZXJzYWwgPSAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHZhbHVlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBleHRyYWN0Rm9ybWF0ID0gKGZvcm1hdCkgPT4ge1xuICAgIGlmIChpc1N0cmluZyhmb3JtYXQpICYmICFpc051bGxPckVtcHR5U3RyaW5nKGZvcm1hdCkgJiYgZm9ybWF0LnN0YXJ0c1dpdGgoJ3swOicpKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQuc2xpY2UoMywgZm9ybWF0Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3QgPSAoZm4pID0+ICguLi5hcmdzKSA9PiAhZm4uYXBwbHkobnVsbCwgYXJncyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgb3IgPSAoLi4uY29uZGl0aW9ucykgPT4gKHZhbHVlKSA9PiBjb25kaXRpb25zLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgfHwgeCh2YWx1ZSksIGZhbHNlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBhbmQgPSAoLi4uY29uZGl0aW9ucykgPT4gKHZhbHVlKSA9PiBjb25kaXRpb25zLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgJiYgeCh2YWx1ZSksIHRydWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFNraXAgPSBuZXcgSW5qZWN0aW9uVG9rZW4oXCJTa2lwXCIpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOnZhcmlhYmxlLW5hbWVcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjcmVhdGVQcm9taXNlID0gKCkgPT4ge1xuICAgIGxldCByZXNvbHZlRm4sIHJlamVjdEZuO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmVGbiA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJlamVjdEZuID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHByb21pc2UucmVzb2x2ZSA9IHJlc29sdmVGbjtcbiAgICBwcm9taXNlLnJlamVjdCA9IHJlamVjdEZuO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcbi8qKiBAaGlkZGVuICovXG5jb25zdCBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKCk7XG4vLyBUT0RPOiBNb3ZlIHRvIGtlbmRvLWNvbW1vblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXAucHJvdG90eXBlKTtcbiAgICBjb25zdCBwcm90byA9IE1hcC5wcm90b3R5cGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJiBwcm90b1trZXldID09PSBwcm90by5lbnRyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgRlJBTUVfRFVSQVRJT04gPSAxMDAwIC8gNjA7XG5jb25zdCB3bmQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHduZC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd25kLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IChjYWxsYmFjayA9PiBzZXRUaW1lb3V0KGNhbGxiYWNrLCBGUkFNRV9EVVJBVElPTikpO1xuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd25kLmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHduZC5tc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBjbGVhclRpbWVvdXQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGV0ZWN0SUUgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIGNvbnN0IG1zaWUgPSB1YS5pbmRleE9mKCdNU0lFICcpO1xuICAgIGNvbnN0IHRyaWRlbnQgPSB1YS5pbmRleE9mKCdUcmlkZW50LycpO1xuICAgIHJldHVybiBtc2llID4gMCB8fCB0cmlkZW50ID4gMDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9kZXNUb0FycmF5ID0gKG5vZGVzKSA9PiBbXS5zbGljZS5jYWxsKG5vZGVzKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByZXBsYWNlTWVzc2FnZVBsYWNlaG9sZGVyID0gKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSA9PiBtZXNzYWdlLnJlcGxhY2UobmV3IFJlZ0V4cChgXFx7XFxcXHMqJHtuYW1lfVxcXFxzKlxcfWAsICdnJyksIHZhbHVlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBLZW5kbyBVSSBHcmlkU3BhY2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhci5cbiAqIFVzZWQgdG8gZ2l2ZSBhZGRpdGlvbmFsIHdoaXRlIHNwYWNlIGJldHdlZW4gdGhlIFBhZ2VyIGlubmVyIGVsZW1lbnRzLFxuICogYW5kIHByb3ZpZGVzIGEgd2F5IGZvciBjdXN0b21pemluZyB0aGUgc3BhY2VyIHdpZHRoLlxuICogSXQgY2FuIGFsc28gYmUgdXNlZCBpbiBhbnkgZmxleCBjb250YWluZXIgd2l0aGluIHRoZSBHcmlkLlxuICovXG5sZXQgR3JpZFNwYWNlckNvbXBvbmVudCA9IGNsYXNzIEdyaWRTcGFjZXJDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIEtlbmRvIFVJIEdyaWRTcGFjZXIgY29tcG9uZW50IGZvciBBbmd1bGFyLlxuICAgICAqIFVzZWQgdG8gZ2l2ZSBhZGRpdGlvbmFsIHdoaXRlIHNwYWNlIGJldHdlZW4gdGhlIFBhZ2VyIGlubmVyIGVsZW1lbnRzLFxuICAgICAqIGFuZCBwcm92aWRlcyBhIHdheSBmb3IgY3VzdG9taXppbmcgdGhlIHNwYWNlciB3aWR0aC5cbiAgICAgKiBJdCBjYW4gYWxzbyBiZSB1c2VkIGluIGFueSBmbGV4IGNvbnRhaW5lciB3aXRoaW4gdGhlIEdyaWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHNpemVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy53aWR0aCk7XG4gICAgfVxuICAgIGdldCBmbGV4QmFzaXNTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXNwYWNlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgR3JpZFNwYWNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zcGFjZXItc2l6ZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgR3JpZFNwYWNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4QmFzaXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBHcmlkU3BhY2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmbGV4QmFzaXNTdHlsZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEdyaWRTcGFjZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG5HcmlkU3BhY2VyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLXNwYWNlciwga2VuZG8tcGFnZXItc3BhY2VyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSlcbl0sIEdyaWRTcGFjZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERvbUV2ZW50c1NlcnZpY2UgPSBjbGFzcyBEb21FdmVudHNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2VsbENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNlbGxNb3VzZWRvd24gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2VsbE1vdXNldXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMua2V5ZG93biA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5mb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5mb2N1c0luID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmZvY3VzT3V0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLndpbmRvd0JsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxufTtcbkRvbUV2ZW50c1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIERvbUV2ZW50c1NlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IExvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlID0gY2xhc3MgTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbn07XG5Mb2NhbERhdGFDaGFuZ2VzU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgRk9DVVNfUk9PVF9BQ1RJVkUgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ2ZvY3VzLXJvb3QtaW5pdGlhbC1hY3RpdmUtc3RhdGUnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRm9jdXNSb290ID0gY2xhc3MgRm9jdXNSb290IHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyR3JvdXAoZ3JvdXApIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwcy5hZGQoZ3JvdXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVnaXN0ZXJHcm91cChncm91cCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzLmRlbGV0ZShncm91cCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHMuZm9yRWFjaChmID0+IGYuYWN0aXZhdGUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwcy5mb3JFYWNoKGYgPT4gZi5kZWFjdGl2YXRlKCkpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkZvY3VzUm9vdCA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDAsIEluamVjdChGT0NVU19ST09UX0FDVElWRSkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBGb2N1c1Jvb3QpO1xuXG5jb25zdCBmb2N1c2FibGVSZWdleCA9IC9eKD86YXxpbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pO1xuY29uc3QgTk9ERV9OQU1FX1BSRURJQ0FURVMgPSB7fTtcbmNvbnN0IHRvQ2xhc3NMaXN0ID0gKGNsYXNzTmFtZXMpID0+IFN0cmluZyhjbGFzc05hbWVzKS50cmltKCkuc3BsaXQoJyAnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNDbGFzc2VzID0gKGVsZW1lbnQsIGNsYXNzTmFtZXMpID0+IHtcbiAgICBjb25zdCBuYW1lc0xpc3QgPSB0b0NsYXNzTGlzdChjbGFzc05hbWVzKTtcbiAgICByZXR1cm4gQm9vbGVhbih0b0NsYXNzTGlzdChlbGVtZW50LmNsYXNzTmFtZSkuZmluZCgoY2xhc3NOYW1lKSA9PiBuYW1lc0xpc3QuaW5kZXhPZihjbGFzc05hbWUpID49IDApKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWF0Y2hlc0NsYXNzZXMgPSAoY2xhc3NOYW1lcykgPT4gKGVsZW1lbnQpID0+IGhhc0NsYXNzZXMoZWxlbWVudCwgY2xhc3NOYW1lcyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWF0Y2hlc05vZGVOYW1lID0gKG5vZGVOYW1lKSA9PiB7XG4gICAgaWYgKCFOT0RFX05BTUVfUFJFRElDQVRFU1tub2RlTmFtZV0pIHtcbiAgICAgICAgTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdID0gKGVsZW1lbnQpID0+IFN0cmluZyhlbGVtZW50Lm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0ID0gKG5vZGUsIHByZWRpY2F0ZSkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmICFwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RJblNjb3BlID0gKG5vZGUsIHByZWRpY2F0ZSwgc2NvcGUpID0+IHtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBzY29wZSAmJiAhcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlICE9PSBzY29wZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNvbnRhaW5zID0gKHBhcmVudCwgbm9kZSwgbWF0Y2hTZWxmID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBvdXRzaWRlID0gIWNsb3Nlc3Qobm9kZSwgKGNoaWxkKSA9PiBjaGlsZCA9PT0gcGFyZW50KTtcbiAgICBpZiAob3V0c2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gY2xvc2VzdChub2RlLCAoY2hpbGQpID0+IGNoaWxkID09PSBub2RlKTtcbiAgICByZXR1cm4gZWwgJiYgKG1hdGNoU2VsZiB8fCBlbCAhPT0gcGFyZW50KTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNWaXNpYmxlID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBoYXNTaXplID0gcmVjdC53aWR0aCA+IDAgJiYgcmVjdC5oZWlnaHQgPiAwO1xuICAgIGNvbnN0IGhhc1Bvc2l0aW9uID0gcmVjdC54ICE9PSAwICYmIHJlY3QueSAhPT0gMDtcbiAgICAvLyBFbGVtZW50cyBjYW4gaGF2ZSB6ZXJvIHNpemUgZHVlIHRvIHN0eWxpbmcsIGJ1dCB0aGV5IHdpbGwgc3RpbGwgY291bnQgYXMgdmlzaWJsZS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgdGhlIHNlbGVjdGlvbiBjaGVja2JveCBoYXMgbm8gc2l6ZSwgYnV0IGlzIG1hZGUgdmlzaWJsZSB0aHJvdWdoIHN0eWxpbmcuXG4gICAgcmV0dXJuIChoYXNTaXplIHx8IGhhc1Bvc2l0aW9uKSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS52aXNpYmlsaXR5ICE9PSAnaGlkZGVuJztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNGb2N1c2FibGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIGlmICghZWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGhhc1RhYkluZGV4ID0gQm9vbGVhbihlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKSk7XG4gICAgY29uc3QgZm9jdXNhYmxlID0gIWVsZW1lbnQuZGlzYWJsZWQgJiYgZm9jdXNhYmxlUmVnZXgudGVzdCh0YWdOYW1lKTtcbiAgICByZXR1cm4gZm9jdXNhYmxlIHx8IGhhc1RhYkluZGV4O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghaXNGb2N1c2FibGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB2aXNpYmxlID0gIWNoZWNrVmlzaWJpbGl0eSB8fCBpc1Zpc2libGUoZWxlbWVudCk7XG4gICAgY29uc3QgYXJpYUhpZGRlbiA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpID09PSAndHJ1ZSc7XG4gICAgY29uc3QgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICByZXR1cm4gdmlzaWJsZSAmJiAhYXJpYUhpZGRlbiAmJiB0YWJJbmRleCAhPT0gJy0xJztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZmluZEVsZW1lbnQgPSAobm9kZSwgcHJlZGljYXRlLCBtYXRjaFNlbGYgPSB0cnVlKSA9PiB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoU2VsZiAmJiBwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBmaW5kRWxlbWVudChub2RlLCBwcmVkaWNhdGUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpbmRMYXN0RWxlbWVudCA9IChub2RlLCBwcmVkaWNhdGUsIG1hdGNoU2VsZiA9IHRydWUpID0+IHtcbiAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgZmluZEVsZW1lbnQobm9kZSwgKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgbGFzdCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIG1hdGNoU2VsZik7XG4gICAgcmV0dXJuIGxhc3Q7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpbmRGb2N1c2FibGUgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIHJldHVybiBmaW5kRWxlbWVudChlbGVtZW50LCAobm9kZSkgPT4gaXNGb2N1c2FibGVXaXRoVGFiS2V5KG5vZGUsIGNoZWNrVmlzaWJpbGl0eSkpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmaW5kRm9jdXNhYmxlQ2hpbGQgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIHJldHVybiBmaW5kRWxlbWVudChlbGVtZW50LCAobm9kZSkgPT4gaXNGb2N1c2FibGVXaXRoVGFiS2V5KG5vZGUsIGNoZWNrVmlzaWJpbGl0eSksIGZhbHNlKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZmluZExhc3RGb2N1c2FibGVDaGlsZCA9IChlbGVtZW50LCBjaGVja1Zpc2liaWxpdHkgPSB0cnVlKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRMYXN0RWxlbWVudChlbGVtZW50LCAobm9kZSkgPT4gaXNGb2N1c2FibGVXaXRoVGFiS2V5KG5vZGUsIGNoZWNrVmlzaWJpbGl0eSksIGZhbHNlKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gcnRsU2Nyb2xsUG9zaXRpb24ocG9zaXRpb24sIGVsZW1lbnQsIGluaXRpYWwpIHtcbiAgICBsZXQgcmVzdWx0ID0gcG9zaXRpb247XG4gICAgaWYgKGluaXRpYWwgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IC1wb3NpdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5pdGlhbCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQub2Zmc2V0V2lkdGggLSBwb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgaXNCdXR0b24gPSBtYXRjaGVzTm9kZU5hbWUoJ2J1dHRvbicpO1xuY29uc3QgaXNJbnB1dFRhZyA9IG1hdGNoZXNOb2RlTmFtZSgnaW5wdXQnKTtcbmNvbnN0IG5hdmlnYWJsZVJlZ2V4ID0gLyhidXR0b258Y2hlY2tib3h8Y29sb3J8ZmlsZXxyYWRpb3xyZXNldHxzdWJtaXQpL2k7XG5jb25zdCBpc05hdmlnYWJsZUlucHV0ID0gZWxlbWVudCA9PiBpc0lucHV0VGFnKGVsZW1lbnQpICYmIG5hdmlnYWJsZVJlZ2V4LnRlc3QoZWxlbWVudC50eXBlKTtcbmNvbnN0IGlzTmF2aWdhYmxlID0gZWxlbWVudCA9PiAhZWxlbWVudC5kaXNhYmxlZCAmJiAoaXNCdXR0b24oZWxlbWVudCkgfHwgaXNOYXZpZ2FibGVJbnB1dChlbGVtZW50KSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRGVmYXVsdEZvY3VzYWJsZUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gaG9zdC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmZvY3VzYWJsZSA9IGZpbmRGb2N1c2FibGUodGhpcy5lbGVtZW50LCBmYWxzZSkgfHwgdGhpcy5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgZW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNhYmxlICYmICF0aGlzLmZvY3VzYWJsZS5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzYWJsZSAmJiBpc1Zpc2libGUodGhpcy5mb2N1c2FibGUpO1xuICAgIH1cbiAgICBpc05hdmlnYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuRm9jdXMoKSAmJiBpc05hdmlnYWJsZSh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgICB0b2dnbGUoYWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZm9jdXNhYmxlLCAndGFiSW5kZXgnLCBhY3RpdmUgPyAnMCcgOiAnLTEnKTtcbiAgICB9XG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2FibGUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5Gb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZSAmJiB0aGlzLmVuYWJsZWQ7XG4gICAgfVxuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGhpcy5lbGVtZW50ICYmIGNsb3Nlc3QoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgZSA9PiBlID09PSB0aGlzLmVsZW1lbnQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IENFTExfQ09OVEVYVCA9IG5ldyBJbmplY3Rpb25Ub2tlbignZ3JpZC1jZWxsLWNvbnRleHQnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBFTVBUWV9DRUxMX0NPTlRFWFQgPSB7fTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNvbnRyb2xzIHRoZSB3YXkgZm9jdXNhYmxlIGVsZW1lbnRzIHJlY2VpdmVcbiAqIFtmb2N1cyBpbiBhIG5hdmlnYWJsZSBHcmlkXSh7JSBzbHVnIGtleWJvYXJkX25hdmlnYXRpb25fZ3JpZCAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiVGFiIHN0b3AgIzBcIiBzdHlsZT1cIm1hcmdpbi1ib3R0b206IDhweDtcIiAvPlxuICogICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJkYXRhXCIgW25hdmlnYWJsZV09XCJ0cnVlXCI+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0SURcIiB0aXRsZT1cIlByb2R1Y3QgSURcIiB3aWR0aD1cIjEwMFwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIiB3aWR0aD1cIjE1MFwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkQ2VsbFRlbXBsYXRlIGxldC1kYXRhSXRlbT5cbiAqICAgICAgICAgICAgICAgICAgPCEtLSBUaGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgd2lsbCBiZSBmb2N1c2VkIHdoZW4gcHJlc3NpbmcgRW50ZXIgb24gdGhlIGNlbGwgLS0+XG4gKiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGtlbmRvR3JpZEZvY3VzYWJsZSBbdmFsdWVdPVwiZGF0YUl0ZW0uUHJvZHVjdE5hbWVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogOHB4O1wiIC8+XG4gKiAgICAgICAgICAgICAgICAgIDxidXR0b24ga2VuZG9HcmlkRm9jdXNhYmxlPlVwZGF0ZTwvYnV0dG9uPlxuICogICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIHdpZHRoPVwiMTAwXCI+XG4gKiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENlbGxUZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICAgICAgPCEtLSBBIHNpbmdsZSBmb2N1c2FibGUgZWxlbWVudCB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIG5hdmlnYXRpb24gLS0+XG4gKiAgICAgICAgICAgICAgICAgIDxidXR0b24ga2VuZG9HcmlkRm9jdXNhYmxlPkRlbGV0ZTwvYnV0dG9uPlxuICogICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiVGFiIHN0b3AgIzJcIiBzdHlsZT1cIm1hcmdpbi10b3A6IDhweDtcIiAvPlxuICogICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgIHB1YmxpYyByZWFkb25seSBkYXRhOiBhbnkgPSBbe1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAxLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICogICAgICAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICogICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gKiAgICAgfSwge1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAqICAgICAgICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAqICAgICAgICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAqICAgICB9XTtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgRm9jdXNhYmxlRGlyZWN0aXZlID0gY2xhc3MgRm9jdXNhYmxlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihjZWxsQ29udGV4dCwgaG9zdEVsZW1lbnQsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuY2VsbENvbnRleHQgPSBjZWxsQ29udGV4dDtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmNlbGxDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwID0gdGhpcy5jZWxsQ29udGV4dC5mb2N1c0dyb3VwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlZ2lzdGVyRWxlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGVuYWJsZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBCb29sZWFuKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC50b2dnbGUodGhpcy5hY3RpdmUgJiYgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbmV3IERlZmF1bHRGb2N1c2FibGVFbGVtZW50KHRoaXMuaG9zdEVsZW1lbnQsIHRoaXMucmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUodGhpcy5ncm91cC5pc0FjdGl2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnVucmVnaXN0ZXJFbGVtZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0b2dnbGUoYWN0aXZlKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQgJiYgYWN0aXZlICE9PSB0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRvZ2dsZSh0aGlzLmVuYWJsZWQgJiYgYWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjYW5Gb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZCAmJiB0aGlzLmVsZW1lbnQgJiYgdGhpcy5lbGVtZW50LmNhbkZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc05hdmlnYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZCAmJiB0aGlzLmVsZW1lbnQgJiYgdGhpcy5lbGVtZW50LmlzTmF2aWdhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYXNGb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZCAmJiB0aGlzLmVsZW1lbnQgJiYgdGhpcy5lbGVtZW50Lmhhc0ZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3RlckVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgna2VuZG9HcmlkRm9jdXNhYmxlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgRm9jdXNhYmxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIG51bGwpO1xuRm9jdXNhYmxlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkRm9jdXNhYmxlXScgKyBgLFxuICAgICAgICBba2VuZG9HcmlkRWRpdENvbW1hbmRdLFxuICAgICAgICBba2VuZG9HcmlkUmVtb3ZlQ29tbWFuZF0sXG4gICAgICAgIFtrZW5kb0dyaWRTYXZlQ29tbWFuZF0sXG4gICAgICAgIFtrZW5kb0dyaWRDYW5jZWxDb21tYW5kXSxcbiAgICAgICAgW2tlbmRvR3JpZFNlbGVjdGlvbkNoZWNrYm94XVxuICAgIGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDAsIEluamVjdChDRUxMX0NPTlRFWFQpKSwgX19wYXJhbSgwLCBTa2lwU2VsZigpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdCwgRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIEZvY3VzYWJsZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBHcmlkRm9jdXNhYmxlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmF2aWdhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgIH1cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5mb2N1c0NlbGwoKTtcbiAgICB9XG4gICAgdG9nZ2xlKGFjdGl2ZSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnRvZ2dsZShhY3RpdmUpO1xuICAgIH1cbiAgICBjYW5Gb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5oYXNGb2N1cygpO1xuICAgIH1cbiAgICBpc05hdmlnYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE5hdmlnYXRpb25DdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVSb3cgPSAwO1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbCA9IDA7XG4gICAgICAgIHRoaXMudmlydHVhbENvbCA9IDA7XG4gICAgICAgIHRoaXMudmlydHVhbFJvdyA9IDA7XG4gICAgfVxuICAgIGdldCByb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZpbmRSb3codGhpcy5hY3RpdmVSb3cpO1xuICAgIH1cbiAgICBnZXQgY2VsbCgpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5yb3c7XG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZpbmRDZWxsKHRoaXMuYWN0aXZlQ29sLCByb3cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkYXRhUm93SW5kZXgoKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMucm93O1xuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gcm93LmRhdGFSb3dJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc3VtZXMgYW5kIGFubm91bmNlcyBhIG5ldyBjdXJzb3IgcG9zaXRpb24uXG4gICAgICovXG4gICAgcmVzZXQocm93SW5kZXggPSB0aGlzLmFjdGl2ZVJvdywgY29sSW5kZXggPSB0aGlzLmFjdGl2ZUNvbCwgZm9yY2UgPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRlKHJvd0luZGV4LCBjb2xJbmRleCwgZm9yY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSb3cgPSByb3dJbmRleDtcbiAgICAgICAgICAgIHRoaXMudmlydHVhbENvbCA9IGNvbEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2YXRlKHJvd0luZGV4LCBjb2xJbmRleCwgZm9yY2UpIHtcbiAgICAgICAgaWYgKCFmb3JjZSAmJiB0aGlzLmlzQWN0aXZlUmFuZ2Uocm93SW5kZXgsIGNvbEluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZDb2xJbmRleCA9IHRoaXMuYWN0aXZlQ29sO1xuICAgICAgICBjb25zdCBwcmV2Um93SW5kZXggPSB0aGlzLmFjdGl2ZVJvdztcbiAgICAgICAgdGhpcy5hY3RpdmVDb2wgPSBjb2xJbmRleDtcbiAgICAgICAgdGhpcy5hY3RpdmVSb3cgPSByb3dJbmRleDtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoe1xuICAgICAgICAgICAgY29sSW5kZXgsXG4gICAgICAgICAgICBwcmV2Q29sSW5kZXgsXG4gICAgICAgICAgICBwcmV2Um93SW5kZXgsXG4gICAgICAgICAgICByb3dJbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzQWN0aXZlUmFuZ2Uocm93SW5kZXgsIGNvbEluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVJvdyAhPT0gcm93SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5jZWxsO1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMubW9kZWwuY2VsbFJhbmdlKGNlbGwpO1xuICAgICAgICByZXR1cm4gIUJvb2xlYW4oY2VsbCkgfHwgKHN0YXJ0IDw9IGNvbEluZGV4ICYmIGNvbEluZGV4IDw9IGVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc3VtZXMgYSBuZXcgY3Vyc29yIHBvc2l0aW9uIHdpdGhvdXQgYW5ub3VuY2luZyBpdC5cbiAgICAgKi9cbiAgICBhc3N1bWUocm93SW5kZXggPSB0aGlzLmFjdGl2ZVJvdywgY29sSW5kZXggPSB0aGlzLmFjdGl2ZUNvbCkge1xuICAgICAgICB0aGlzLnZpcnR1YWxSb3cgPSByb3dJbmRleDtcbiAgICAgICAgdGhpcy52aXJ0dWFsQ29sID0gY29sSW5kZXg7XG4gICAgICAgIHRoaXMuYWN0aXZlQ29sID0gY29sSW5kZXg7XG4gICAgICAgIHRoaXMuYWN0aXZlUm93ID0gcm93SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFubm91bmNlcyBhIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIHRvIHN1YnNjcmliZXJzLlxuICAgICAqL1xuICAgIGFubm91bmNlKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7XG4gICAgICAgICAgICBjb2xJbmRleDogdGhpcy5hY3RpdmVDb2wsXG4gICAgICAgICAgICBwcmV2Q29sSW5kZXg6IHRoaXMuYWN0aXZlQ29sLFxuICAgICAgICAgICAgcHJldlJvd0luZGV4OiB0aGlzLmFjdGl2ZVJvdyxcbiAgICAgICAgICAgIHJvd0luZGV4OiB0aGlzLmFjdGl2ZVJvd1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWN0aXZhdGVWaXJ0dWFsQ2VsbChjZWxsKSB7XG4gICAgICAgIGNvbnN0IHJvd1JhbmdlID0gdGhpcy5tb2RlbC5yb3dSYW5nZShjZWxsKTtcbiAgICAgICAgY29uc3QgY2VsbFJhbmdlID0gdGhpcy5tb2RlbC5jZWxsUmFuZ2UoY2VsbCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUNvbCA9IHRoaXMuYWN0aXZlQ29sO1xuICAgICAgICBjb25zdCBhY3RpdmVSb3cgPSB0aGlzLmFjdGl2ZVJvdztcbiAgICAgICAgaWYgKHJvd1JhbmdlLnN0YXJ0IDw9IGFjdGl2ZVJvdyAmJiBhY3RpdmVSb3cgPD0gcm93UmFuZ2UuZW5kICYmXG4gICAgICAgICAgICBjZWxsUmFuZ2Uuc3RhcnQgPD0gYWN0aXZlQ29sICYmIGFjdGl2ZUNvbCA8PSBjZWxsUmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVJvdyA9IGNlbGwucm93SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbCA9IGNlbGwuY29sSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0FjdGl2ZShyb3dJbmRleCwgY29sSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlQ29sID09PSBjb2xJbmRleCAmJiB0aGlzLmFjdGl2ZVJvdyA9PT0gcm93SW5kZXg7XG4gICAgfVxuICAgIG1vdmVVcChvZmZzZXQgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldFJvdygtb2Zmc2V0KTtcbiAgICB9XG4gICAgbW92ZURvd24ob2Zmc2V0ID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXRSb3cob2Zmc2V0KTtcbiAgICB9XG4gICAgbW92ZUxlZnQob2Zmc2V0ID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXRDb2woLW9mZnNldCk7XG4gICAgfVxuICAgIG1vdmVSaWdodChvZmZzZXQgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldENvbChvZmZzZXQpO1xuICAgIH1cbiAgICBsYXN0Q2VsbEluZGV4KHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YS5jb2x1bW5zLmxlYWZDb2x1bW5zVG9SZW5kZXIubGVuZ3RoIC0gMSArXG4gICAgICAgICAgICAodGhpcy5tZXRhZGF0YS5oYXNEZXRhaWxUZW1wbGF0ZSAmJiAoIXJvdyB8fCAhcm93Lmdyb3VwSXRlbSkgPyAxIDogMCk7XG4gICAgfVxuICAgIG9mZnNldENvbChvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgcHJldlJvdyA9IHRoaXMubW9kZWwuZmluZFJvdyh0aGlzLnZpcnR1YWxSb3cpO1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLmxhc3RDZWxsSW5kZXgocHJldlJvdyk7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxDb2wgPSB0aGlzLnZpcnR1YWxDb2w7XG4gICAgICAgIHRoaXMudmlydHVhbENvbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZpcnR1YWxDb2wgKyBvZmZzZXQsIGxhc3RJbmRleCkpO1xuICAgICAgICBsZXQgbmV4dENvbEluZGV4ID0gdGhpcy52aXJ0dWFsQ29sO1xuICAgICAgICBsZXQgbmV4dFJvd0luZGV4ID0gdGhpcy52aXJ0dWFsUm93O1xuICAgICAgICBsZXQgY2VsbCA9IHRoaXMubW9kZWwuZmluZENlbGwodGhpcy52aXJ0dWFsQ29sLCBwcmV2Um93KTtcbiAgICAgICAgaWYgKCFjZWxsICYmIHRoaXMubWV0YWRhdGEudmlydHVhbENvbHVtbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlKG5leHRSb3dJbmRleCwgbmV4dENvbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbC5jb2xTcGFuID4gMSAmJiBjZWxsLmNvbEluZGV4IDw9IHZpcnR1YWxDb2wgJiYgdmlydHVhbENvbCA8IGNlbGwuY29sSW5kZXggKyBjZWxsLmNvbFNwYW4pIHtcbiAgICAgICAgICAgIG5leHRDb2xJbmRleCA9IG9mZnNldCA+IDAgPyBNYXRoLm1pbihjZWxsLmNvbEluZGV4ICsgY2VsbC5jb2xTcGFuLCBsYXN0SW5kZXgpIDogTWF0aC5tYXgoMCwgY2VsbC5jb2xJbmRleCArIG9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2VsbCA9IHRoaXMubW9kZWwuZmluZENlbGwobmV4dENvbEluZGV4LCBwcmV2Um93KTtcbiAgICAgICAgICAgIGlmIChjZWxsICE9PSBuZXh0Q2VsbCkge1xuICAgICAgICAgICAgICAgIGNlbGwgPSBuZXh0Q2VsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxDb2wgPSBjZWxsLmNvbEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXJ0dWFsQ29sID0gdmlydHVhbENvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZShjZWxsLnJvd0luZGV4LCBjZWxsLmNvbEluZGV4KTtcbiAgICB9XG4gICAgb2Zmc2V0Um93KG9mZnNldCkge1xuICAgICAgICBsZXQgbmV4dENvbEluZGV4ID0gdGhpcy52aXJ0dWFsQ29sO1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSAmJiB0aGlzLm1ldGFkYXRhLmlzVmlydHVhbCkge1xuICAgICAgICAgICAgY29uc3QgbWF4SW5kZXggPSB0aGlzLm1ldGFkYXRhLm1heExvZ2ljYWxSb3dJbmRleDtcbiAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmFjdGl2ZVJvdyArIG9mZnNldCwgbWF4SW5kZXgpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmhhc0RldGFpbFRlbXBsYXRlICYmICF0aGlzLm1vZGVsLmZpbmRSb3cobmV4dEluZGV4KSkge1xuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IG9mZnNldCA+IDAgPyBuZXh0SW5kZXggKyAxIDogbmV4dEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuZXh0SW5kZXgsIG1heEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5oYXNEZXRhaWxUZW1wbGF0ZSAmJiBuZXh0SW5kZXggPT09IG1heEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwubGFzdFJvdy5pbmRleCAhPT0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYXR0ZW1wdCB0byBuYXZpZ2F0ZSBwYXN0IHRoZSBsYXN0IGNvbGxhcHNlZCByb3cuXG4gICAgICAgICAgICAgICAgICAgIG5leHRJbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRSb3cgPSB0aGlzLm1vZGVsLmZpbmRSb3cobmV4dEluZGV4KTtcbiAgICAgICAgICAgIGlmIChuZXh0Um93KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0aW9uXG4gICAgICAgICAgICAgICAgbGV0IGNlbGwgPSB0aGlzLm1vZGVsLmZpbmRDZWxsKHRoaXMudmlydHVhbENvbCwgbmV4dFJvdyk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwucm93SW5kZXggPD0gdGhpcy52aXJ0dWFsUm93ICYmIG9mZnNldCA+IDAgJiYgY2VsbC5yb3dTcGFuID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsID0gdGhpcy5tb2RlbC5maW5kQ2VsbCh0aGlzLnZpcnR1YWxDb2wsIHRoaXMubW9kZWwuZmluZFJvdyhjZWxsLnJvd0luZGV4ICsgY2VsbC5yb3dTcGFuIC0gMSArIG9mZnNldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBjZWxsLnJvd0luZGV4O1xuICAgICAgICAgICAgICAgIG5leHRDb2xJbmRleCA9IGNlbGwuY29sSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSb3cgPSBuZXh0SW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZShuZXh0SW5kZXgsIG5leHRDb2xJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFJvdyA9IHRoaXMubW9kZWwuZmluZFJvdyh0aGlzLnZpcnR1YWxSb3cgKyBvZmZzZXQpIHx8IHRoaXMubW9kZWwubmV4dFJvdyh0aGlzLnZpcnR1YWxSb3csIG9mZnNldCk7XG4gICAgICAgIGlmICghbmV4dFJvdykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjZWxsID0gdGhpcy5tb2RlbC5maW5kQ2VsbCh0aGlzLnZpcnR1YWxDb2wsIG5leHRSb3cpO1xuICAgICAgICBpZiAoY2VsbCAmJiBjZWxsLnJvd0luZGV4IDw9IHRoaXMudmlydHVhbFJvdyAmJiBvZmZzZXQgPiAwICYmIGNlbGwucm93U3BhbiA+IDEpIHsgLy8gc3Bhbm5lZCBjZWxsIGdvIHRvIG5leHRcbiAgICAgICAgICAgIGNvbnN0IG5leHRQb3MgPSBjZWxsLnJvd0luZGV4ICsgY2VsbC5yb3dTcGFuIC0gMSArIG9mZnNldDtcbiAgICAgICAgICAgIGNlbGwgPSB0aGlzLm1vZGVsLmZpbmRDZWxsKHRoaXMudmlydHVhbENvbCwgdGhpcy5tb2RlbC5maW5kUm93KG5leHRQb3MpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNlbGwgJiYgdGhpcy5tZXRhZGF0YS52aXJ0dWFsQ29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGUodGhpcy52aXJ0dWFsUm93ICsgb2Zmc2V0LCB0aGlzLnZpcnR1YWxDb2wpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlydHVhbFJvdyA9IGNlbGwucm93SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlKHRoaXMudmlydHVhbFJvdywgY2VsbC5jb2xJbmRleCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgSXRlbU1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLml0ZW1zID0ge307XG4gICAgfVxuICAgIGdldCBmaXJzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGxhc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ID4gMCkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaXRlbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNba2V5c1trZXlzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVJdGVtKGtleSkge1xuICAgICAgICBpZiAodGhpcy5pdGVtc1trZXldKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pdGVtc1trZXldO1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEl0ZW0oa2V5LCBpdGVtKSB7XG4gICAgICAgIGlmICghdGhpcy5pdGVtc1trZXldKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtc1trZXldID0gaXRlbTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNba2V5XTtcbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjYWxsYmFjayh0aGlzLml0ZW1zW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgcm93cyBhbmQgY2VsbHMuXG4gKi9cbmNsYXNzIE5hdmlnYXRpb25Nb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucm93cyA9IG5ldyBJdGVtTWFwKCk7XG4gICAgfVxuICAgIGdldCBmaXJzdFJvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cy5maXJzdDtcbiAgICB9XG4gICAgZ2V0IGxhc3RSb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3MubGFzdDtcbiAgICB9XG4gICAgcmVnaXN0ZXJDZWxsKGNlbGwpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzLmdldEl0ZW0oY2VsbC5sb2dpY2FsUm93SW5kZXgpO1xuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbEluZGV4ID0gY2VsbC5sb2dpY2FsQ29sSW5kZXg7XG4gICAgICAgIGNvbnN0IG1vZGVsQ2VsbCA9IHtcbiAgICAgICAgICAgIHVpZDogY2VsbC51aWQsXG4gICAgICAgICAgICBjb2xJbmRleCxcbiAgICAgICAgICAgIHJvd0luZGV4OiByb3cuaW5kZXgsXG4gICAgICAgICAgICBjb2xTcGFuOiBjZWxsLmNvbFNwYW4sXG4gICAgICAgICAgICByb3dTcGFuOiBjZWxsLnJvd1NwYW4sXG4gICAgICAgICAgICBkZXRhaWxFeHBhbmRDZWxsOiBjZWxsLmRldGFpbEV4cGFuZENlbGwsXG4gICAgICAgICAgICBkYXRhSXRlbTogcm93LmRhdGFJdGVtLFxuICAgICAgICAgICAgZGF0YVJvd0luZGV4OiByb3cuZGF0YVJvd0luZGV4LFxuICAgICAgICAgICAgZm9jdXNHcm91cDogY2VsbC5mb2N1c0dyb3VwXG4gICAgICAgIH07XG4gICAgICAgIHJvdy5jZWxscy5zZXRJdGVtKGNvbEluZGV4LCBtb2RlbENlbGwpO1xuICAgICAgICBpZiAoY2VsbC5ncm91cEl0ZW0pIHtcbiAgICAgICAgICAgIHJvdy5ncm91cEl0ZW0gPSBjZWxsLmdyb3VwSXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZWxDZWxsO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyQ2VsbChpbmRleCwgcm93SW5kZXgsIGNlbGwpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzLmdldEl0ZW0ocm93SW5kZXgpO1xuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJvdy5jZWxscy5nZXRJdGVtKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC51aWQgPT09IGNlbGwudWlkKSB7XG4gICAgICAgICAgICAgICAgcm93LmNlbGxzLnJlbW92ZUl0ZW0oaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyUm93KHJvdykge1xuICAgICAgICBjb25zdCBtb2RlbFJvdyA9IHtcbiAgICAgICAgICAgIHVpZDogcm93LnVpZCxcbiAgICAgICAgICAgIGluZGV4OiByb3cubG9naWNhbFJvd0luZGV4LFxuICAgICAgICAgICAgZGF0YUl0ZW06IHJvdy5kYXRhSXRlbSxcbiAgICAgICAgICAgIGRhdGFSb3dJbmRleDogcm93LmRhdGFSb3dJbmRleCxcbiAgICAgICAgICAgIGNlbGxzOiBuZXcgSXRlbU1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucm93cy5zZXRJdGVtKHJvdy5sb2dpY2FsUm93SW5kZXgsIG1vZGVsUm93KTtcbiAgICB9XG4gICAgdXBkYXRlUm93KHJvdykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5yb3dzLmdldEl0ZW0ocm93LmxvZ2ljYWxSb3dJbmRleCk7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICBkYXRhSXRlbTogcm93LmRhdGFJdGVtLFxuICAgICAgICAgICAgICAgIGRhdGFSb3dJbmRleDogcm93LmRhdGFSb3dJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5yZWdpc3RlclJvdyhpbmRleCwgcm93KSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5yb3dzLmdldEl0ZW0oaW5kZXgpO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gudWlkID09PSByb3cudWlkKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3MucmVtb3ZlSXRlbShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2VsbFJhbmdlKGNlbGwpIHtcbiAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2VsbC5jb2xJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGNlbGwuY29sSW5kZXggKyAoY2VsbC5jb2xTcGFuIHx8IDEpIC0gMTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcm93UmFuZ2UoY2VsbCkge1xuICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBjZWxsLnJvd0luZGV4O1xuICAgICAgICAgICAgY29uc3QgZW5kID0gY2VsbC5yb3dJbmRleCArIChjZWxsLnJvd1NwYW4gfHwgMSkgLSAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBuZXh0Um93KHJvd0luZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMucm93cy50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMucm93cy5nZXRJdGVtKHJvd0luZGV4KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSByb3dzLmluZGV4T2Yocm93KTtcbiAgICAgICAgY29uc3QgbmV4dCA9IHJvd3NbcG9zaXRpb24gKyBvZmZzZXRdO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgZmluZFJvdyhpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzLmdldEl0ZW0oaW5kZXgpO1xuICAgIH1cbiAgICBmaW5kQ2VsbChpbmRleCwgcm93KSB7XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93SW5kZXggPSByb3cuaW5kZXg7XG4gICAgICAgIGxldCBjZWxsID0gcm93LmNlbGxzLmdldEl0ZW0oaW5kZXgpO1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gcm93SW5kZXg7XG4gICAgICAgIHdoaWxlICghY2VsbCAmJiByb3cpIHtcbiAgICAgICAgICAgIHJvdyA9IHRoaXMucm93cy5nZXRJdGVtKGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBjZWxsID0gdGhpcy5yb3dDZWxsKGluZGV4LCByb3cpO1xuICAgICAgICAgICAgY3VycmVudEluZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGwgJiYgcm93SW5kZXggPD0gcm93LmluZGV4ICsgKGNlbGwucm93U3BhbiB8fCAxKSAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJvd0NlbGwoaW5kZXgsIHJvdykge1xuICAgICAgICBpZiAoIXJvdyB8fCAhcm93LmNlbGxzLmNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gcm93LmNlbGxzLmZpcnN0O1xuICAgICAgICBsZXQgY2VsbCwgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHdoaWxlICghY2VsbCAmJiBjdXJyZW50SW5kZXggPj0gZmlyc3RDZWxsLmNvbEluZGV4KSB7XG4gICAgICAgICAgICBjZWxsID0gcm93LmNlbGxzLmdldEl0ZW0oY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsICYmIGluZGV4IDw9IGNlbGwuY29sSW5kZXggKyAoY2VsbC5jb2xTcGFuIHx8IDEpIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3Nlc1xuICAgICAqIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBldmVudCB3YXMgcHJldmVudGVkXG4gICAgICogYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGNlbGxDbG9zZWAgZXZlbnQuXG4gKi9cbmNsYXNzIENlbGxDbG9zZUV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3Rpb24gPSAnY2VsbENsb3NlJztcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0VxdWFsID0gKGluZGV4KSA9PiAoaXRlbSkgPT4gaXRlbS5pbmRleCA9PT0gaW5kZXg7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNOb3RFcXVhbCA9IChpbmRleCkgPT4gKGl0ZW0pID0+IGl0ZW0uaW5kZXggIT09IGluZGV4O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzTmV3Um93ID0gKGluZGV4KSA9PiBpbmRleCA9PT0gLTEgfHwgaW5kZXggPT09IHVuZGVmaW5lZDtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRWRpdFNlcnZpY2UgPSBjbGFzcyBFZGl0U2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iobmdab25lKSB7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZWRpdGVkSW5kaWNlcyA9IFtdO1xuICAgICAgICB0aGlzLmtlZXBFZGl0Q2VsbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsb3NpbmdDZWxsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhbmdlZFNvdXJjZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRoaXMuY2hhbmdlZFNvdXJjZS5hc09ic2VydmFibGUoKS5waXBlKHN3aXRjaE1hcCgoKSA9PiB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpKSk7XG4gICAgfVxuICAgIGVkaXRSb3coaW5kZXgsIGdyb3VwID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZWRpdGVkSW5kaWNlcy5wdXNoKHsgaW5kZXgsIGdyb3VwIH0pO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBhZGRSb3coZ3JvdXApIHtcbiAgICAgICAgdGhpcy5uZXdJdGVtR3JvdXAgPSB7IGdyb3VwIH07XG4gICAgICAgIHRoaXMub25DaGFuZ2VkKCk7XG4gICAgfVxuICAgIGVkaXRDZWxsKHJvd0luZGV4LCBjb2x1bW4sIGdyb3VwKSB7XG4gICAgICAgIGlmIChpc05ld1Jvdyhyb3dJbmRleCkgfHwgY29sdW1uLmVkaXRhYmxlID09PSBmYWxzZSB8fCAhKGNvbHVtbi5lZGl0VGVtcGxhdGUgfHwgY29sdW1uLmZpZWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldmVudENlbGxDbG9zZSgpO1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VDZWxsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdFJvdyhyb3dJbmRleCwgZ3JvdXApO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRWRpdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGVkSW5kaWNlcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBpc0VkaXRpbmdDZWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VkaXRpbmcoKSAmJiB0aGlzLmNvbHVtbiAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgaGFzTmV3SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm5ld0l0ZW1Hcm91cCk7XG4gICAgfVxuICAgIGdldCBuZXdEYXRhSXRlbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTmV3SXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3SXRlbUdyb3VwLmdyb3VwLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY2xvc2UoaW5kZXgpIHtcbiAgICAgICAgaWYgKGlzTmV3Um93KGluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5uZXdJdGVtR3JvdXAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0ZWRJbmRpY2VzID0gdGhpcy5lZGl0ZWRJbmRpY2VzLmZpbHRlcihpc05vdEVxdWFsKGluZGV4KSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZWQoKTtcbiAgICB9XG4gICAgY2xvc2VDZWxsKG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uICYmICF0aGlzLmNsb3NpbmdDZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZGV4LCBncm91cCB9ID0gdGhpcy5lZGl0ZWRJbmRpY2VzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBuZXcgQ2VsbENsb3NlRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBmb3JtR3JvdXA6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICByb3dJbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NpbmdDZWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NpbmdDZWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsQ2VsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbENlbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbikge1xuICAgICAgICAgICAgdGhpcy5lZGl0ZWRJbmRpY2VzID0gW107XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZENsb3NlQ2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uICYmICF0aGlzLmtlZXBFZGl0Q2VsbDtcbiAgICB9XG4gICAgcHJldmVudENlbGxDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmtlZXBDZWxsVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmtlZXBFZGl0Q2VsbCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmtlZXBDZWxsVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBFZGl0Q2VsbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgMCk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnRleHQoaW5kZXgpIHtcbiAgICAgICAgaWYgKGlzTmV3Um93KGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3SXRlbUdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRCeUluZGV4KGluZGV4KTtcbiAgICB9XG4gICAgY29sdW1uQ29udGV4dChpbmRleCwgY29sdW1uKSB7XG4gICAgICAgIGlmIChpc05ld1JvdyhpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld0l0ZW1Hcm91cDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29sdW1uIHx8IGNvbHVtbiA9PT0gdGhpcy5jb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRCeUluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0VkaXRlZChpbmRleCkge1xuICAgICAgICBpZiAoaXNOZXdSb3coaW5kZXgpICYmIGlzUHJlc2VudCh0aGlzLm5ld0l0ZW1Hcm91cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy5jb2x1bW4gJiYgaXNQcmVzZW50KHRoaXMuZmluZEJ5SW5kZXgoaW5kZXgpKTtcbiAgICB9XG4gICAgaGFzRWRpdGVkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250ZXh0KGluZGV4KSk7XG4gICAgfVxuICAgIGlzRWRpdGVkQ29sdW1uKGluZGV4LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uICYmIHRoaXMuY29sdW1uID09PSBjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5maW5kQnlJbmRleChpbmRleCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYmVnaW5FZGl0KHJvd0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KHsgYWN0aW9uOiAnZWRpdCcsIHJvd0luZGV4IH0pO1xuICAgIH1cbiAgICBiZWdpbkFkZCgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoeyBhY3Rpb246ICdhZGQnIH0pO1xuICAgIH1cbiAgICBlbmRFZGl0KHJvd0luZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgZ3JvdXA6IGZvcm1Hcm91cCB9ID0gdGhpcy5jb250ZXh0KHJvd0luZGV4KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoeyBhY3Rpb246ICdjYW5jZWwnLCByb3dJbmRleCwgZm9ybUdyb3VwLCBpc05ldzogaXNOZXdSb3cocm93SW5kZXgpIH0pO1xuICAgIH1cbiAgICBzYXZlKHJvd0luZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgZ3JvdXA6IGZvcm1Hcm91cCB9ID0gdGhpcy5jb250ZXh0KHJvd0luZGV4KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoeyBhY3Rpb246ICdzYXZlJywgcm93SW5kZXgsIGZvcm1Hcm91cCwgaXNOZXc6IGlzTmV3Um93KHJvd0luZGV4KSB9KTtcbiAgICB9XG4gICAgcmVtb3ZlKHJvd0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KHsgYWN0aW9uOiAncmVtb3ZlJywgcm93SW5kZXggfSk7XG4gICAgfVxuICAgIGZpbmRCeUluZGV4KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRlZEluZGljZXMuZmluZChpc0VxdWFsKGluZGV4KSk7XG4gICAgfVxuICAgIG9uQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkU291cmNlLm5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbkVkaXRTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmdab25lXSlcbl0sIEVkaXRTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldEdyb3VwUm93QXJncyA9IChncm91cEl0ZW0pID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudChncm91cEl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBncm91cDogZ3JvdXBJdGVtLmRhdGEsIGdyb3VwSW5kZXg6IGdyb3VwSXRlbS5pbmRleCwgcGFyZW50R3JvdXA6IGdldEdyb3VwUm93QXJncyhncm91cEl0ZW0ucGFyZW50R3JvdXApIH07XG59O1xuXG5jb25zdCBpc0NoaWxkSW5kZXggPSAodGFyZ2V0SW5kZXgsIHBhcmVudEluZGV4KSA9PiBwYXJlbnRJbmRleCAhPT0gdGFyZ2V0SW5kZXggJiYgdGFyZ2V0SW5kZXguc3RhcnRzV2l0aChwYXJlbnRJbmRleCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEdyb3Vwc1NlcnZpY2UgPSBjbGFzcyBHcm91cHNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMucm93U3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnJvd1N0YXRlLmNsZWFyKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIGlzRXhwYW5kZWQoZ3JvdXBBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckNhbGxiYWNrKGdyb3VwQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnJvd1N0YXRlLmhhcyhncm91cEFyZ3MuZ3JvdXBJbmRleCk7XG4gICAgfVxuICAgIGlzSW5FeHBhbmRlZEdyb3VwKGdyb3VwSXRlbSkge1xuICAgICAgICBsZXQgZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoZ3JvdXBJdGVtICYmIGV4cGFuZGVkKSB7XG4gICAgICAgICAgICBleHBhbmRlZCA9IHRoaXMuaXNFeHBhbmRlZCh7XG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwSXRlbS5kYXRhLFxuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSXRlbS5pbmRleCxcbiAgICAgICAgICAgICAgICBwYXJlbnRHcm91cDogZ2V0R3JvdXBSb3dBcmdzKGdyb3VwSXRlbS5wYXJlbnRHcm91cClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBJdGVtID0gZ3JvdXBJdGVtLnBhcmVudEdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICB9XG4gICAgdG9nZ2xlUm93KGdyb3VwSXRlbSkge1xuICAgICAgICBjb25zdCBwYXJlbnRHcm91cCA9IGdldEdyb3VwUm93QXJncyhncm91cEl0ZW0ucGFyZW50R3JvdXApO1xuICAgICAgICBjb25zdCBleHBhbmQgPSAhdGhpcy5pc0V4cGFuZGVkKHsgZ3JvdXA6IGdyb3VwSXRlbS5kYXRhLCBncm91cEluZGV4OiBncm91cEl0ZW0uaW5kZXgsIHBhcmVudEdyb3VwIH0pO1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7IGdyb3VwOiBncm91cEl0ZW0uZGF0YSwgZXhwYW5kLCBncm91cEluZGV4OiBncm91cEl0ZW0uaW5kZXgsIHBhcmVudEdyb3VwIH0pO1xuICAgICAgICAvLyBpZiB1c2VyY2FsbGJhY2sgaXMgZ2l2ZW4sIHRoZSByb3dTdGF0ZSBzaG91bGQgYmUgaWdub3JlZFxuICAgICAgICBpZiAodGhpcy51c2VyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwYW5kKSB7XG4gICAgICAgICAgICB0aGlzLnJvd1N0YXRlLmRlbGV0ZShncm91cEl0ZW0uaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3dTdGF0ZS5hZGQoZ3JvdXBJdGVtLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBhbmRDaGlsZHJlbihwYXJlbnRJbmRleCkge1xuICAgICAgICB0aGlzLnJvd1N0YXRlLmZvckVhY2goaW5kZXggPT4gaXNDaGlsZEluZGV4KGluZGV4LCBwYXJlbnRJbmRleCkgJiYgdGhpcy5yb3dTdGF0ZS5kZWxldGUoaW5kZXgpKTtcbiAgICB9XG59O1xuR3JvdXBzU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgR3JvdXBzU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQYWdlckNvbnRleHRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5za2lwIC8gdGhpcy5wYWdlU2l6ZTtcbiAgICB9XG4gICAgbm90aWZ5Q2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudG90YWwgPSBjaGFuZ2VzLnRvdGFsO1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gY2hhbmdlcy5wYWdlU2l6ZTtcbiAgICAgICAgdGhpcy5za2lwID0gY2hhbmdlcy5za2lwO1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dChjaGFuZ2VzKTtcbiAgICB9XG4gICAgY2hhbmdlUGFnZShwYWdlKSB7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZS5uZXh0KHsgc2tpcDogcGFnZSAqIHRoaXMucGFnZVNpemUsIHRha2U6IHRoaXMucGFnZVNpemUgfSk7XG4gICAgfVxuICAgIGNoYW5nZVBhZ2VTaXplKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZS5uZXh0KHsgc2tpcDogMCwgdGFrZTogdmFsdWUgfSk7XG4gICAgfVxuICAgIG5leHRQYWdlKCkge1xuICAgICAgICBjb25zdCBuZXh0UGFnZSA9IHRoaXMuY3VycmVudFBhZ2UgKyAxO1xuICAgICAgICBpZiAobmV4dFBhZ2UgKiB0aGlzLnBhZ2VTaXplIDwgdGhpcy50b3RhbCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VQYWdlKG5leHRQYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2UGFnZSgpIHtcbiAgICAgICAgY29uc3QgcHJldlBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlIC0gMTtcbiAgICAgICAgaWYgKHByZXZQYWdlICogdGhpcy5wYWdlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVBhZ2UocHJldlBhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBkZXRhaWxDb2xsYXBzZWAgZXZlbnQuXG4gKi9cbmNsYXNzIERldGFpbENvbGxhcHNlRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgYXJncyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBkZXRhaWxFeHBhbmRgIGV2ZW50LlxuICovXG5jbGFzcyBEZXRhaWxFeHBhbmRFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRGV0YWlsc1NlcnZpY2UgPSBjbGFzcyBEZXRhaWxzU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnJvd1N0YXRlID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yb3dTdGF0ZS5jbGVhcigpO1xuICAgIH1cbiAgICBpc0V4cGFuZGVkKGluZGV4LCBkYXRhSXRlbSkge1xuICAgICAgICBpZiAodGhpcy51c2VyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJDYWxsYmFjayh7IGluZGV4LCBkYXRhSXRlbSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb3dTdGF0ZS5oYXMoaW5kZXgpO1xuICAgIH1cbiAgICB0b2dnbGVSb3coaW5kZXgsIGRhdGFJdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXhwYW5kZWQoaW5kZXgsIGRhdGFJdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZVJvdyhpbmRleCwgZGF0YUl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRSb3coaW5kZXgsIGRhdGFJdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBhbmRSb3coaW5kZXgsIGRhdGFJdGVtKSB7XG4gICAgICAgIGNvbnN0IHByZXZlbnRlZCA9IHRoaXMuZW1pdEV2ZW50KHsgZGF0YUl0ZW0sIGluZGV4LCBleHBhbmQ6IHRydWUgfSk7XG4gICAgICAgIGlmICghcHJldmVudGVkICYmICF0aGlzLnVzZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yb3dTdGF0ZS5hZGQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxhcHNlUm93KGluZGV4LCBkYXRhSXRlbSkge1xuICAgICAgICBjb25zdCBwcmV2ZW50ZWQgPSB0aGlzLmVtaXRFdmVudCh7IGRhdGFJdGVtLCBpbmRleCwgZXhwYW5kOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCFwcmV2ZW50ZWQgJiYgIXRoaXMudXNlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd1N0YXRlLmRlbGV0ZShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdEV2ZW50KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgZXZlbnRBcmcgPSBuZXcgKGFyZ3MuZXhwYW5kID8gRGV0YWlsRXhwYW5kRXZlbnQgOiBEZXRhaWxDb2xsYXBzZUV2ZW50KShhcmdzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoZXZlbnRBcmcpO1xuICAgICAgICByZXR1cm4gZXZlbnRBcmcuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfVxufTtcbkRldGFpbHNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBEZXRhaWxzU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2Nyb2xsUmVxdWVzdFNlcnZpY2UgPSBjbGFzcyBTY3JvbGxSZXF1ZXN0U2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RzID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgc2Nyb2xsVG8ocmVxdWVzdCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RzLm5leHQocmVxdWVzdCk7XG4gICAgfVxufTtcblNjcm9sbFJlcXVlc3RTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBTY3JvbGxSZXF1ZXN0U2VydmljZSk7XG5cbmNvbnN0IGlzSW5TYW1lR3JpZCA9IChlbGVtZW50LCBncmlkRWxlbWVudCkgPT4gY2xvc2VzdChlbGVtZW50LCBtYXRjaGVzTm9kZU5hbWUoJ2tlbmRvLWdyaWQnKSkgPT09IGdyaWRFbGVtZW50O1xuY29uc3QgbWF0Y2hIZWFkZXJDZWxsID0gbWF0Y2hlc05vZGVOYW1lKCd0aCcpO1xuY29uc3QgbWF0Y2hEYXRhQ2VsbCA9IG1hdGNoZXNOb2RlTmFtZSgndGQnKTtcbmNvbnN0IG1hdGNoRm9vdGVyQ2VsbCA9IG1hdGNoZXNOb2RlTmFtZSgnLmstZ3JpZC1mb290ZXIgdGQnKTtcbmNvbnN0IG1hdGNoQ2VsbCA9IChlbGVtZW50KSA9PiBtYXRjaERhdGFDZWxsKGVsZW1lbnQpIHx8IG1hdGNoSGVhZGVyQ2VsbChlbGVtZW50KSB8fCBtYXRjaEZvb3RlckNlbGwoZWxlbWVudCk7XG5jb25zdCBncmlkQ2VsbCA9IChlbGVtZW50LCBncmlkRWxlbWVudCkgPT4ge1xuICAgIGxldCB0YXJnZXQgPSBjbG9zZXN0KGVsZW1lbnQsIG1hdGNoQ2VsbCk7XG4gICAgd2hpbGUgKHRhcmdldCAmJiAhaXNJblNhbWVHcmlkKHRhcmdldCwgZ3JpZEVsZW1lbnQpKSB7XG4gICAgICAgIHRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LnBhcmVudEVsZW1lbnQsIG1hdGNoQ2VsbCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuY29uc3QgdGFyZ2V0Q2VsbCA9ICh0YXJnZXQsIGdyaWRFbGVtZW50KSA9PiB7XG4gICAgY29uc3QgY2VsbCA9IGdyaWRDZWxsKHRhcmdldCwgZ3JpZEVsZW1lbnQpO1xuICAgIGNvbnN0IHJvdyA9IGNsb3Nlc3QoY2VsbCwgbWF0Y2hlc05vZGVOYW1lKCd0cicpKTtcbiAgICBpZiAoY2VsbCAmJiByb3cpIHtcbiAgICAgICAgbGV0IHJvd0luZGV4ID0gcm93LmdldEF0dHJpYnV0ZSgnYXJpYS1yb3dpbmRleCcpO1xuICAgICAgICByb3dJbmRleCA9IHJvd0luZGV4ID8gcGFyc2VJbnQocm93SW5kZXgsIDEwKSAtIDEgOiBudWxsO1xuICAgICAgICBsZXQgY29sSW5kZXggPSBjZWxsLmdldEF0dHJpYnV0ZSgnYXJpYS1jb2xpbmRleCcpO1xuICAgICAgICBjb2xJbmRleCA9IGNvbEluZGV4ID8gcGFyc2VJbnQoY29sSW5kZXgsIDEwKSAtIDEgOiBudWxsO1xuICAgICAgICBpZiAocm93SW5kZXggIT09IG51bGwgJiYgY29sSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbEluZGV4LCByb3dJbmRleCwgZWxlbWVudDogY2VsbCB9O1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGlzQXJyb3dLZXkgPSBrZXlDb2RlID0+IGtleUNvZGUgPT09IEtleXMuQXJyb3dMZWZ0IHx8IGtleUNvZGUgPT09IEtleXMuQXJyb3dSaWdodCB8fFxuICAgIGtleUNvZGUgPT09IEtleXMuQXJyb3dVcCB8fCBrZXlDb2RlID09PSBLZXlzLkFycm93RG93bjtcbmNvbnN0IGlzTmF2aWdhdGlvbktleSA9IGtleUNvZGUgPT4gaXNBcnJvd0tleShrZXlDb2RlKSB8fFxuICAgIGtleUNvZGUgPT09IEtleXMuUGFnZVVwIHx8IGtleUNvZGUgPT09IEtleXMuUGFnZURvd24gfHxcbiAgICBrZXlDb2RlID09PSBLZXlzLkhvbWUgfHwga2V5Q29kZSA9PT0gS2V5cy5FbmQ7XG5jb25zdCBpc0lucHV0ID0gbWF0Y2hlc05vZGVOYW1lKCdpbnB1dCcpO1xuY29uc3QgaXNUZXh0SW5wdXQgPSBlbGVtZW50ID0+IGVsZW1lbnQgJiYgaXNJbnB1dChlbGVtZW50KSAmJiBlbGVtZW50LnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQnO1xuY29uc3QgaXNQcmludGFibGVDaGFyYWN0ZXIgPSAoc3RyKSA9PiBzdHIubGVuZ3RoID09PSAxICYmIHN0ci5tYXRjaCgvXFxTLyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvblZpZXdwb3J0IHtcbiAgICBjb25zdHJ1Y3RvcihmaXJzdEl0ZW1JbmRleCwgbGFzdEl0ZW1JbmRleCkge1xuICAgICAgICB0aGlzLmZpcnN0SXRlbUluZGV4ID0gZmlyc3RJdGVtSW5kZXg7XG4gICAgICAgIHRoaXMubGFzdEl0ZW1JbmRleCA9IGxhc3RJdGVtSW5kZXg7XG4gICAgfVxuICAgIGNvbnRhaW5zUm93KGRhdGFSb3dJbmRleCkge1xuICAgICAgICBjb25zdCBoZWFkZXJSb3cgPSBkYXRhUm93SW5kZXggPCAwO1xuICAgICAgICByZXR1cm4gaGVhZGVyUm93IHx8IChkYXRhUm93SW5kZXggPj0gdGhpcy5maXJzdEl0ZW1JbmRleCAmJiBkYXRhUm93SW5kZXggPD0gdGhpcy5sYXN0SXRlbUluZGV4KTtcbiAgICB9XG4gICAgaW50ZXJzZWN0cyhzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiAoc3RhcnQgPD0gdGhpcy5maXJzdEl0ZW1JbmRleCAmJiB0aGlzLmxhc3RJdGVtSW5kZXggPD0gZW5kKSB8fFxuICAgICAgICAgICAgKHRoaXMuZmlyc3RJdGVtSW5kZXggPD0gc3RhcnQgJiYgc3RhcnQgPD0gdGhpcy5sYXN0SXRlbUluZGV4KSB8fFxuICAgICAgICAgICAgKHRoaXMuZmlyc3RJdGVtSW5kZXggPD0gZW5kICYmIGVuZCA8PSB0aGlzLmxhc3RJdGVtSW5kZXgpO1xuICAgIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTmF2aWdhdGlvblNlcnZpY2UgPSBjbGFzcyBOYXZpZ2F0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Ioem9uZSwgZG9tRXZlbnRzLCBwYWdlckNvbnRleHRTZXJ2aWNlLCBzY3JvbGxSZXF1ZXN0U2VydmljZSwgZ3JvdXBzU2VydmljZSwgZGV0YWlsc1NlcnZpY2UsIGZvY3VzUm9vdCwgZWRpdFNlcnZpY2UsIGNkLCBsb2NhbGl6YXRpb24sIGZvY3VzYWJsZVBhcmVudCkge1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IGRvbUV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlckNvbnRleHRTZXJ2aWNlID0gcGFnZXJDb250ZXh0U2VydmljZTtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXF1ZXN0U2VydmljZSA9IHNjcm9sbFJlcXVlc3RTZXJ2aWNlO1xuICAgICAgICB0aGlzLmdyb3Vwc1NlcnZpY2UgPSBncm91cHNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRldGFpbHNTZXJ2aWNlID0gZGV0YWlsc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuZm9jdXNSb290ID0gZm9jdXNSb290O1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlID0gZWRpdFNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuZm9jdXNhYmxlUGFyZW50ID0gZm9jdXNhYmxlUGFyZW50O1xuICAgICAgICB0aGlzLmNlbGxLZXlkb3duID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubW9kZSA9IDAgLyogU3RhbmRieSAqLztcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyBOYXZpZ2F0aW9uTW9kZWwoKTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBuZXcgTmF2aWdhdGlvbkN1cnNvcih0aGlzLm1vZGVsKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gdGhpcy5jdXJzb3IuY2hhbmdlcztcbiAgICB9XG4gICAgc2V0IG1ldGFkYXRhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWV0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmN1cnNvci5tZXRhZGF0YSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGE7XG4gICAgfVxuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGl2ZTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZUNlbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgIT09IDAgLyogU3RhbmRieSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLmNlbGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZVJvdygpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gMCAvKiBTdGFuZGJ5ICovKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jdXJzb3Iucm93LCB7XG4gICAgICAgICAgICAgICAgY2VsbHM6IHRoaXMuY3Vyc29yLnJvdy5jZWxscy50b0FycmF5KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmVEYXRhUm93KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5hY3RpdmVSb3dJbmRleCAtIHRoaXMubWV0YS5oZWFkZXJSb3dzKTtcbiAgICB9XG4gICAgaW5pdChtZXRhKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvY3VzUm9vdC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YTtcbiAgICAgICAgY29uc3Qgb25TdGFibGVTdWJzY3JpYmVyID0gKC4uLm9wZXJhdG9ycykgPT4gKGFyZ3MpID0+IHRoaXMuem9uZS5pc1N0YWJsZSA/XG4gICAgICAgICAgICBmcm9tKFt0cnVlXSkucGlwZShtYXAoKCkgPT4gYXJncykpIDpcbiAgICAgICAgICAgIHRoaXMuem9uZS5vblN0YWJsZS5waXBlKHRha2UoMSksIG1hcCgoKSA9PiBhcmdzKSwgLi4ub3BlcmF0b3JzKTtcbiAgICAgICAgY29uc3Qgb25TdGFibGUgPSBvblN0YWJsZVN1YnNjcmliZXIoKTtcbiAgICAgICAgdGhpcy5zdWJzID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMuY3Vyc29yLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoYXJncyA9PiB0aGlzLm9uQ3Vyc29yQ2hhbmdlcyhhcmdzKSkpO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMuZG9tRXZlbnRzLmZvY3VzLnBpcGUoc3dpdGNoTWFwKG9uU3RhYmxlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGFyZ3MpID0+IHRoaXMubmF2aWdhdGVUbyhhcmdzLnRhcmdldCkpKTtcbiAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLmRvbUV2ZW50cy5mb2N1c091dC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLm1vZGUgIT09IDAgLyogU3RhbmRieSAqLyksIHN3aXRjaE1hcChvblN0YWJsZVN1YnNjcmliZXIodGFrZVVudGlsKHRoaXMuZG9tRXZlbnRzLmZvY3VzKSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShhcmdzID0+IHRoaXMub25Gb2N1c091dChhcmdzKSkpO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMuZG9tRXZlbnRzLndpbmRvd0JsdXIucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5tb2RlICE9PSAwIC8qIFN0YW5kYnkgKi8pKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uV2luZG93Qmx1cigpKSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQoXG4gICAgICAgIC8vIENsb3NpbmcgdGhlIGVkaXRvciB3aWxsIG5vdCBhbHdheXMgdHJpZ2dlciBmb2N1c291dCBpbiBGaXJlZm94LlxuICAgICAgICAvLyBUbyBnZXQgYXJvdW5kIHRoaXMsIHdlIGVuc3VyZSB0aGF0IHRoZSBjZWxsIGlzIGNsb3NlZCBhZnRlciBlZGl0aW5nLlxuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmNoYW5nZXMucGlwZShmaWx0ZXIoZSA9PiBlLmFjdGlvbiAhPT0gJ2VkaXQnICYmIHRoaXMubW9kZSA9PT0gMiAvKiBDb250ZW50ICovKSwgZmlsdGVyKChlKSA9PiBlLmFjdGlvbiA9PT0gJ2NlbGxDbG9zZScgJiYgIWUucHJldmVudGVkKSwgc3dpdGNoTWFwKG9uU3RhYmxlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5sZWF2ZUNlbGwoKSkpO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMucGFnZXJDb250ZXh0U2VydmljZS5wYWdlQ2hhbmdlXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY3Vyc29yLnJlc2V0KDAsIDApKSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5kb21FdmVudHMua2V5ZG93blxuICAgICAgICAgICAgLnN1YnNjcmliZShhcmdzID0+IHRoaXMub25LZXlkb3duKGFyZ3MpKSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5kb21FdmVudHMua2V5ZG93bi5waXBlKGZpbHRlcihhcmdzID0+IGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5UYWIgJiYgdGhpcy5tb2RlID09PSAyIC8qIENvbnRlbnQgKi8pLCBzd2l0Y2hNYXBUbyh0aGlzLmRvbUV2ZW50cy5mb2N1c091dC5waXBlKHRha2VVbnRpbChcbiAgICAgICAgLy8gVGltZW91dCBpZiBmb2N1c091dCBkb2Vzbid0IGZpcmUgdmVyeSBzb29uXG4gICAgICAgIGludGVydmFsKDApLnBpcGUodGFrZSgxKSkpKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMub25UYWJvdXQoKSkpO1xuICAgICAgICBpZiAodGhpcy5mb2N1c2FibGVQYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXcgR3JpZEZvY3VzYWJsZUVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzYWJsZVBhcmVudC5yZWdpc3RlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlRWxlbWVudHMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vicy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDZWxsKGNlbGwpIHtcbiAgICAgICAgaWYgKGNlbGwubG9naWNhbFJvd0luZGV4ICE9PSB0aGlzLnBlbmRpbmdSb3dJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxDZWxsID0gdGhpcy5tb2RlbC5yZWdpc3RlckNlbGwoY2VsbCk7XG4gICAgICAgICAgICBpZiAodGhpcy52aXJ0dWFsQ2VsbCAmJiB0aGlzLmN1cnNvci5hY3RpdmF0ZVZpcnR1YWxDZWxsKG1vZGVsQ2VsbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxDZWxsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJDZWxsT25DdXJyZW50Um93KGNlbGwpIHtcbiAgICAgICAgaWYgKGNlbGwubG9naWNhbFJvd0luZGV4ID09PSB0aGlzLnBlbmRpbmdSb3dJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5yZWdpc3RlckNlbGwoY2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5yZWdpc3RlckNlbGwoaW5kZXgsIHJvd0luZGV4LCBjZWxsKSB7XG4gICAgICAgIHRoaXMubW9kZWwudW5yZWdpc3RlckNlbGwoaW5kZXgsIHJvd0luZGV4LCBjZWxsKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSb3cocm93KSB7XG4gICAgICAgIHRoaXMubW9kZWwucmVnaXN0ZXJSb3cocm93KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUm93SW5kZXggPSByb3cubG9naWNhbFJvd0luZGV4O1xuICAgIH1cbiAgICB1cGRhdGVSb3cocm93KSB7XG4gICAgICAgIHRoaXMubW9kZWwudXBkYXRlUm93KHJvdyk7XG4gICAgfVxuICAgIHVucmVnaXN0ZXJSb3coaW5kZXgsIHJvdykge1xuICAgICAgICB0aGlzLm1vZGVsLnVucmVnaXN0ZXJSb3coaW5kZXgsIHJvdyk7XG4gICAgICAgIGNvbnN0IGxhc3RSb3cgPSB0aGlzLm1vZGVsLmxhc3RSb3c7XG4gICAgICAgIGlmIChsYXN0Um93ICYmIHRoaXMubW9kZSA9PT0gMCAvKiBTdGFuZGJ5ICovKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhJbmRleCA9ICh0aGlzLm5lZWRzVmlld3BvcnQoKSAmJiB0aGlzLnZpZXdwb3J0KSA/IHRoaXMudmlld3BvcnQubGFzdEl0ZW1JbmRleCA6IGxhc3RSb3cuaW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVSb3dJbmRleCA+IG1heEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQoMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNDZWxsRm9jdXNhYmxlKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpdmUgJiZcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlICYmXG4gICAgICAgICAgICB0aGlzLm1vZGUgIT09IDIgLyogQ29udGVudCAqLyAmJlxuICAgICAgICAgICAgdGhpcy5jdXJzb3IuaXNBY3RpdmUoY2VsbC5sb2dpY2FsUm93SW5kZXgsIGNlbGwubG9naWNhbENvbEluZGV4KTtcbiAgICB9XG4gICAgaXNDZWxsRm9jdXNlZChjZWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IDEgLyogQ3Vyc29yICovICYmIHRoaXMuaXNDZWxsRm9jdXNhYmxlKGNlbGwpO1xuICAgIH1cbiAgICBuYXZpZ2F0ZVRvKGVsKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0YXJnZXRDZWxsKGVsLCB0aGlzLm1ldGEuZ3JpZEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZE1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgIGNvbnN0IGZvY3VzSW5DZWxsID0gY29udGFpbnMoY2VsbC5lbGVtZW50LCBkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZm9jdXNJbkFjdGl2ZVJvd0NvbnRlbnQgPSB0aGlzLm1vZGUgPT09IDIgLyogQ29udGVudCAqLyAmJlxuICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9PT0gY2VsbC5yb3dJbmRleCAmJlxuICAgICAgICAgICAgZWwgIT09IGNlbGwuZWxlbWVudDtcbiAgICAgICAgaWYgKGZvY3VzSW5DZWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSAyIC8qIENvbnRlbnQgKi87XG4gICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldChjZWxsLnJvd0luZGV4LCBjZWxsLmNvbEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVSb3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZm9jdXNJbkFjdGl2ZVJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IDEgLyogQ3Vyc29yICovO1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlRWxlbWVudHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlBY3RpdmUgPSB0aGlzLmN1cnNvci5pc0FjdGl2ZShjZWxsLnJvd0luZGV4LCBjZWxsLmNvbEluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGlzQ3Vyc29yID0gb2xkTW9kZSA9PT0gMSAvKiBDdXJzb3IgKi8gJiYgYWxyZWFkeUFjdGl2ZTtcbiAgICAgICAgICAgIGlmICghaXNDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldChjZWxsLnJvd0luZGV4LCBjZWxsLmNvbEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnlGb2N1cyhlbCkge1xuICAgICAgICB0aGlzLmFjdGl2YXRlRWxlbWVudHMoKTtcbiAgICAgICAgY29uc3QgZm9jdXNhYmxlID0gZmluZEZvY3VzYWJsZUNoaWxkKGVsKTtcbiAgICAgICAgaWYgKGZvY3VzYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRhcmdldENlbGwoZm9jdXNhYmxlLCB0aGlzLm1ldGEuZ3JpZEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KGNlbGwucm93SW5kZXgsIGNlbGwuY29sSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZUVsZW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlckNlbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvY3VzYWJsZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFmb2N1c2FibGU7XG4gICAgfVxuICAgIG5lZWRzVmlld3BvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGEgJiYgdGhpcy5tZXRhLmlzVmlydHVhbDtcbiAgICB9XG4gICAgc2V0Vmlld3BvcnQoZmlyc3RJdGVtSW5kZXgsIGxhc3RJdGVtSW5kZXgpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBOYXZpZ2F0aW9uVmlld3BvcnQoZmlyc3RJdGVtSW5kZXgsIGxhc3RJdGVtSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5tZXRhICYmIHRoaXMubWV0YS5pc1ZpcnR1YWwgJiYgdGhpcy5hY3RpdmVEYXRhUm93ID4gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFSb3dJbmRleCA9IHRoaXMuYWN0aXZlRGF0YVJvdztcbiAgICAgICAgICAgIGNvbnN0IGFoZWFkID0gZmlyc3RJdGVtSW5kZXggLSBkYXRhUm93SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBiZWhpbmQgPSBkYXRhUm93SW5kZXggLSBsYXN0SXRlbUluZGV4O1xuICAgICAgICAgICAgaWYgKGFoZWFkID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KGZpcnN0SXRlbUluZGV4ICsgdGhpcy5tZXRhLmhlYWRlclJvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVoaW5kID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KGxhc3RJdGVtSW5kZXggLSB0aGlzLm1ldGEuaGVhZGVyUm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q29sdW1uVmlld3BvcnQoZmlyc3RJdGVtSW5kZXgsIGxhc3RJdGVtSW5kZXgpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5WaWV3cG9ydCA9IG5ldyBOYXZpZ2F0aW9uVmlld3BvcnQoZmlyc3RJdGVtSW5kZXgsIGxhc3RJdGVtSW5kZXgpO1xuICAgIH1cbiAgICBmb2N1c0NlbGwocm93SW5kZXggPSB1bmRlZmluZWQsIGNvbEluZGV4ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IDEgLyogQ3Vyc29yICovO1xuICAgICAgICB0aGlzLmN1cnNvci5yZXNldChyb3dJbmRleCwgY29sSW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVDZWxsO1xuICAgIH1cbiAgICBmb2N1c0NlbGxCeUVsZW1lbnQoZWwpIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRhcmdldENlbGwoZWwsIHRoaXMubWV0YS5ncmlkRWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvY3VzQ2VsbChjZWxsLnJvd0luZGV4LCBjZWxsLmNvbEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c05leHRDZWxsKHdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzQWRqYWNlbnRDZWxsKHRydWUsIHdyYXApO1xuICAgIH1cbiAgICBmb2N1c1ByZXZDZWxsKHdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzQWRqYWNlbnRDZWxsKGZhbHNlLCB3cmFwKTtcbiAgICB9XG4gICAgdG9nZ2xlKGFjdGl2ZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5jdXJzb3IuYW5ub3VuY2UoKTtcbiAgICB9XG4gICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IDEgLyogQ3Vyc29yICovIHx8IHRoaXMubW9kZSA9PT0gMiAvKiBDb250ZW50ICovO1xuICAgIH1cbiAgICBhdXRvRm9jdXNDZWxsKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLm1ldGEudmlydHVhbENvbHVtbnMgfHwgZW5kIDwgdGhpcy5tZXRhLmNvbHVtbnMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoIHx8IHRoaXMuY29sdW1uVmlld3BvcnQuaW50ZXJzZWN0cyhzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZm9jdXNBZGphY2VudENlbGwoZndkLCB3cmFwKSB7XG4gICAgICAgIHRoaXMuZm9jdXNDZWxsKCk7XG4gICAgICAgIGxldCBzdWNjZXNzID0gZndkID8gdGhpcy5tb3ZlQ3Vyc29yRndkKCkgOiB0aGlzLm1vdmVDdXJzb3JCd2QoKTtcbiAgICAgICAgaWYgKHdyYXAgJiYgIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBmd2QgPyB0aGlzLmN1cnNvci5tb3ZlRG93bigxKSA6IHRoaXMuY3Vyc29yLm1vdmVVcCgxKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5jdXJzb3Iucm93O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbElkeCA9IGZ3ZCA/IDAgOiB0aGlzLmN1cnNvci5sYXN0Q2VsbEluZGV4KHJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQocm93LmluZGV4LCBjb2xJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVDZWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gMCAvKiBTdGFuZGJ5ICovO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IuYW5ub3VuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZW50ZXJDZWxsKCkge1xuICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5jdXJzb3IuY2VsbDtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JvdXAgPSBjZWxsLmZvY3VzR3JvdXA7XG4gICAgICAgIGNvbnN0IGZvY3VzYWJsZSA9IGdyb3VwICYmIGdyb3VwLmNhbkZvY3VzKCk7XG4gICAgICAgIHRoaXMubW9kZSA9IGZvY3VzYWJsZSA/IDIgLyogQ29udGVudCAqLyA6IDEgLyogQ3Vyc29yICovO1xuICAgICAgICB0aGlzLmN1cnNvci5hbm5vdW5jZSgpO1xuICAgICAgICBpZiAoZm9jdXNhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlUm93KCk7XG4gICAgICAgICAgICBncm91cC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxlYXZlQ2VsbCgpIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY3Vyc29yLmNlbGw7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwID0gY2VsbC5mb2N1c0dyb3VwO1xuICAgICAgICBjb25zdCBmb2N1c2FibGUgPSBncm91cCAmJiBncm91cC5jYW5Gb2N1cygpO1xuICAgICAgICBpZiAoIWZvY3VzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGUgPSAxIC8qIEN1cnNvciAqLztcbiAgICAgICAgdGhpcy5jdXJzb3IuYW5ub3VuY2UoKTtcbiAgICB9XG4gICAgYWN0aXZhdGVFbGVtZW50cygpIHtcbiAgICAgICAgdGhpcy5mb2N1c1Jvb3QuYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgZGVhY3RpdmF0ZUVsZW1lbnRzKCkge1xuICAgICAgICB0aGlzLmZvY3VzUm9vdC5kZWFjdGl2YXRlKCk7XG4gICAgfVxuICAgIGFjdGl2YXRlUm93KCkge1xuICAgICAgICB0aGlzLmN1cnNvci5yb3cuY2VsbHNcbiAgICAgICAgICAgIC5mb3JFYWNoKGNlbGwgPT4gY2VsbC5mb2N1c0dyb3VwICYmIGNlbGwuZm9jdXNHcm91cC5hY3RpdmF0ZSgpKTtcbiAgICB9XG4gICAgbW92ZUN1cnNvckZ3ZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/IHRoaXMuY3Vyc29yLm1vdmVMZWZ0KCkgOiB0aGlzLmN1cnNvci5tb3ZlUmlnaHQoKTtcbiAgICB9XG4gICAgbW92ZUN1cnNvckJ3ZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/IHRoaXMuY3Vyc29yLm1vdmVSaWdodCgpIDogdGhpcy5jdXJzb3IubW92ZUxlZnQoKTtcbiAgICB9XG4gICAgb25DdXJzb3JLZXlkb3duKGFyZ3MpIHtcbiAgICAgICAgbGV0IHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gYXJncy5jdHJsS2V5IHx8IGFyZ3MubWV0YUtleTtcbiAgICAgICAgY29uc3Qgc3RlcCA9IG1vZGlmaWVyID8gNSA6IDE7XG4gICAgICAgIGlmICghdGhpcy5vbkNlbGxLZXlkb3duKGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5jdXJzb3Iucm93O1xuICAgICAgICBzd2l0Y2ggKGFyZ3Mua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93RG93bjpcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRoaXMuY3Vyc29yLm1vdmVEb3duKHN0ZXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93VXA6XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0aGlzLmN1cnNvci5tb3ZlVXAoc3RlcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuQXJyb3dSaWdodDpcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRoaXMubW92ZUN1cnNvckZ3ZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93TGVmdDpcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRoaXMubW92ZUN1cnNvckJ3ZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLlBhZ2VEb3duOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmlzVmlydHVhbCAmJiB0aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0SXRlbUluZGV4ID0gdGhpcy5tZXRhLmhlYWRlclJvd3MgKyB0aGlzLnZpZXdwb3J0Lmxhc3RJdGVtSW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5oYXNEZXRhaWxUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEl0ZW1JbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHRJdGVtSW5kZXggPSBNYXRoLm1pbih0aGlzLm1ldGEubWF4TG9naWNhbFJvd0luZGV4LCBuZXh0SXRlbUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQobmV4dEl0ZW1JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tZXRhZGF0YS5oYXNQYWdlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMucGFnZXJDb250ZXh0U2VydmljZS5uZXh0UGFnZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5cy5QYWdlVXA6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuaXNWaXJ0dWFsICYmIHRoaXMudmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZpZXdwb3J0U2l6ZSA9IHRoaXMudmlld3BvcnQubGFzdEl0ZW1JbmRleCAtIHRoaXMudmlld3BvcnQuZmlyc3RJdGVtSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMudmlld3BvcnQuZmlyc3RJdGVtSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0SXRlbUluZGV4ID0gTWF0aC5tYXgodGhpcy5tZXRhLmhlYWRlclJvd3MsIGZpcnN0SXRlbUluZGV4IC0gdmlld3BvcnRTaXplIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KG5leHRJdGVtSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWV0YWRhdGEuaGFzUGFnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLnBhZ2VyQ29udGV4dFNlcnZpY2UucHJldlBhZ2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuSG9tZTpcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWV0YS5pc1ZpcnR1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KHRoaXMubWV0YS5oZWFkZXJSb3dzLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldCh0aGlzLm1vZGVsLmZpcnN0Um93LmluZGV4LCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KHJvdy5pbmRleCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuRW5kOlxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXRhLmlzVmlydHVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RSb3dJbmRleCA9IHRoaXMubWV0YS5tYXhMb2dpY2FsUm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXRhLmhhc0RldGFpbFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJvd0luZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldChsYXN0Um93SW5kZXgsIHRoaXMuY3Vyc29yLmxhc3RDZWxsSW5kZXgoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQodGhpcy5tb2RlbC5sYXN0Um93LmluZGV4LCB0aGlzLmN1cnNvci5sYXN0Q2VsbEluZGV4KHRoaXMubW9kZWwubGFzdFJvdyksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5jdXJzb3IubGFzdENlbGxJbmRleChyb3cpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5tb2RlbC5maW5kQ2VsbChsYXN0SW5kZXgsIHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldChjZWxsLnJvd0luZGV4LCBjZWxsLmNvbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KHJvdy5pbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuRW50ZXI6XG4gICAgICAgICAgICBjYXNlIEtleXMuRjI6XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBJdGVtID0gcm93Lmdyb3VwSXRlbTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5ncm91cHNTZXJ2aWNlLnRvZ2dsZVJvdyhncm91cEl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IuY2VsbC5kZXRhaWxFeHBhbmRDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5kZXRhaWxzU2VydmljZS50b2dnbGVSb3cocm93LmRhdGFSb3dJbmRleCwgcm93LmRhdGFJdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVudGVyQ2VsbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY3Vyc29yLmNlbGwuZm9jdXNHcm91cC5pc05hdmlnYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICghYXJncy5jdHJsS2V5ICYmICFhcmdzLmFsdEtleSAmJiBpc1ByaW50YWJsZUNoYXJhY3RlcihhcmdzLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRlckNlbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Db250ZW50S2V5ZG93bihhcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5vbkNlbGxLZXlkb3duKGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlybSA9ICFhcmdzLmRlZmF1bHRQcmV2ZW50ZWQgJiYgYXJncy5rZXlDb2RlID09PSBLZXlzLkVudGVyICYmIGlzVGV4dElucHV0KGFyZ3Muc3JjRWxlbWVudCk7XG4gICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuRXNjYXBlIHx8IGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5GMiB8fCBjb25maXJtKSB7XG4gICAgICAgICAgICB0aGlzLmxlYXZlQ2VsbCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQoKTtcbiAgICAgICAgICAgIGFyZ3Muc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOYXZpZ2F0aW9uS2V5KGFyZ3Mua2V5Q29kZSkgJiYgdGhpcy5jdXJzb3IuY2VsbC5mb2N1c0dyb3VwLmlzTmF2aWdhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMub25DdXJzb3JLZXlkb3duKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGFyZ3MuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVDZWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DZWxsS2V5ZG93bihhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGluZ0NlbGwoKSkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlybSA9IGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5FbnRlcjtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9IGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5Fc2NhcGU7XG4gICAgICAgICAgICBjb25zdCBuYXZpZ2F0ZSA9IGlzTmF2aWdhdGlvbktleShhcmdzLmtleUNvZGUpO1xuICAgICAgICAgICAgaWYgKGNvbmZpcm0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmNsb3NlQ2VsbChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhbmNlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuY2xvc2VDZWxsKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZWxsS2V5ZG93bi5lbWl0KGFyZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb25DdXJzb3JDaGFuZ2VzKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IGFyZ3Mucm93SW5kZXg7XG4gICAgICAgIGNvbnN0IGRhdGFSb3dJbmRleCA9IHRoaXMuYWN0aXZlRGF0YVJvdztcbiAgICAgICAgaWYgKHRoaXMubWV0YSAmJiAodGhpcy5tZXRhLmlzVmlydHVhbCAmJlxuICAgICAgICAgICAgYXJncy5yb3dJbmRleCA+PSB0aGlzLm1ldGEuaGVhZGVyUm93cyAmJlxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCAmJlxuICAgICAgICAgICAgIXRoaXMudmlld3BvcnQuY29udGFpbnNSb3coZGF0YVJvd0luZGV4KSAmJiBkYXRhUm93SW5kZXggPiAtMSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUmVxdWVzdFNlcnZpY2Uuc2Nyb2xsVG8oeyByb3c6IGRhdGFSb3dJbmRleCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhLnZpcnR1YWxDb2x1bW5zICYmIGFyZ3MuY29sSW5kZXggPj0gdGhpcy5tZXRhLmNvbHVtbnMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLm1vZGVsLmNlbGxSYW5nZShjZWxsKTtcbiAgICAgICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbENlbGwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghY2VsbCAmJiB0aGlzLm1vZGUgIT09IDAgLyogU3RhbmRieSAqLykgfHwgKGNlbGwgJiYgIXRoaXMuY29sdW1uVmlld3BvcnQuaW50ZXJzZWN0cyhzdGFydCwgZW5kKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFJlcXVlc3RTZXJ2aWNlLnNjcm9sbFRvKHsgY29sdW1uOiBhcmdzLmNvbEluZGV4IC0gKHRoaXMubWV0YWRhdGEuaGFzRGV0YWlsVGVtcGxhdGUgPyAxIDogMCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Gb2N1c091dChhcmdzKSB7XG4gICAgICAgIGlmIChpc1Zpc2libGUoYXJncy50YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSAwIC8qIFN0YW5kYnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb2N1c2VkIHRhcmdldCBpcyBubyBsb25nZXIgdmlzaWJsZSxcbiAgICAgICAgICAgIC8vIHJlc2V0IHRvIGN1cnNvciBtb2RlIGFuZCByZWNhcHR1cmUgZm9jdXMuXG4gICAgICAgICAgICB0aGlzLm1vZGUgPSAxIC8qIEN1cnNvciAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYWN0aXZhdGVFbGVtZW50cygpO1xuICAgICAgICB0aGlzLmN1cnNvci5hbm5vdW5jZSgpO1xuICAgIH1cbiAgICBvbldpbmRvd0JsdXIoKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IDAgLyogU3RhbmRieSAqLztcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlRWxlbWVudHMoKTtcbiAgICAgICAgdGhpcy5jdXJzb3IuYW5ub3VuY2UoKTtcbiAgICB9XG4gICAgb25LZXlkb3duKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gMSAvKiBDdXJzb3IgKi8pIHtcbiAgICAgICAgICAgIHRoaXMub25DdXJzb3JLZXlkb3duKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gMiAvKiBDb250ZW50ICovKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29udGVudEtleWRvd24oYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25UYWJvdXQoKSB7XG4gICAgICAgIC8vIFRhYmJlZCBvdXQgb2YgdGhlIGxhc3QgZm9jdXNhYmxlIGNvbnRlbnQgZWxlbWVudFxuICAgICAgICAvLyByZXNldCB0byBjdXJzb3IgbW9kZSBhbmQgcmVjYXB0dXJlIGZvY3VzLlxuICAgICAgICBpZiAodGhpcy5jdXJzb3IuY2VsbC5mb2N1c0dyb3VwLmlzTmF2aWdhYmxlKCkpIHtcbiAgICAgICAgICAgIC8vIFVubGVzcyB0aGUgY2VsbCBoYXMgYSBzaW5nbGUgZm9jdXNhYmxlIGVsZW1lbnQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UnZCByZXR1cm4gdG8gQ29udGVudCBtb2RlIGFuZCBlbnRlciBhbiBlbmRsZXNzIGxvb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlYXZlQ2VsbCgpO1xuICAgICAgICB0aGlzLmN1cnNvci5yZXNldCgpO1xuICAgIH1cbn07XG5OYXZpZ2F0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtKDEwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZSxcbiAgICAgICAgRG9tRXZlbnRzU2VydmljZSxcbiAgICAgICAgUGFnZXJDb250ZXh0U2VydmljZSxcbiAgICAgICAgU2Nyb2xsUmVxdWVzdFNlcnZpY2UsXG4gICAgICAgIEdyb3Vwc1NlcnZpY2UsXG4gICAgICAgIERldGFpbHNTZXJ2aWNlLFxuICAgICAgICBGb2N1c1Jvb3QsXG4gICAgICAgIEVkaXRTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgRm9jdXNhYmxlRGlyZWN0aXZlXSlcbl0sIE5hdmlnYXRpb25TZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTZWxlY3Rpb25TZXJ2aWNlID0gY2xhc3MgU2VsZWN0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZG9tRXZlbnRzLCBsb2NhbERhdGFDaGFuZ2VzU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kb21FdmVudHMgPSBkb21FdmVudHM7XG4gICAgICAgIHRoaXMubG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UgPSBsb2NhbERhdGFDaGFuZ2VzU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblN0YXJ0SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGxDaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb25zKCk7XG4gICAgfVxuICAgIGdldCBlbmFibGVNYXJxdWVlKCkge1xuICAgICAgICBjb25zdCBjaGVja2JveE9ubHkgPSB0aGlzLnNldHRpbmdzICYmIHR5cGVvZiB0aGlzLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJiB0aGlzLnNldHRpbmdzLmNoZWNrYm94T25seTtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzIHx8IGNoZWNrYm94T25seSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGVTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3Muc2VsZWN0YWJsZTtcbiAgICAgICAgY29uc3QgZHJhZ0FuZE11bHRpcGxlID0gdHlwZW9mIChzZWxlY3RhYmxlU2V0dGluZ3MpID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgaXNQcmVzZW50KHNlbGVjdGFibGVTZXR0aW5ncykgJiZcbiAgICAgICAgICAgIHNlbGVjdGFibGVTZXR0aW5ncy5tb2RlID09PSAnbXVsdGlwbGUnICYmXG4gICAgICAgICAgICBzZWxlY3RhYmxlU2V0dGluZ3MuZW5hYmxlZCAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICFzZWxlY3RhYmxlU2V0dGluZ3MuY2hlY2tib3hPbmx5ICYmXG4gICAgICAgICAgICBzZWxlY3RhYmxlU2V0dGluZ3MuZHJhZztcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlICYmIGRyYWdBbmRNdWx0aXBsZTtcbiAgICB9XG4gICAgaW5pdChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IFtdO1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2VsZWN0YWJsZSAmJiBzZXR0aW5ncy5zZWxlY3RhYmxlLmVuYWJsZWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciQkMSA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdEFsbFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFpdGVtLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS52YWx1ZSAmJiBpdGVtLnZhbHVlLnR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0FyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbTogaXRlbS52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGl0ZW0udmFsdWUuaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJvd1NlbGVjdGVkKHJvd0FyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb25baXRlbS52YWx1ZS5pbmRleF0gPSByb3dBcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0QWxsU3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZXJhdG9yJCQxLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZWxlY3Rpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0QWxsU3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1NlbGVjdGVkKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzICYmIHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmVuYWJsZWQgJiYgaXNQcmVzZW50KHRoaXMuY3VycmVudFNlbGVjdGlvbltpbmRleF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNsaWNrKGl0ZW0sIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2O1xuICAgICAgICBjb25zdCBjdHJsS2V5ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vZGUgPT09IFwic2luZ2xlXCIgJiYgY3RybEtleSAmJiB0aGlzLmlzU2VsZWN0ZWQoaXRlbS5pbmRleCkpIHtcbiAgICAgICAgICAgIGV2ID0gdGhpcy50b2dnbGUoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLm1vZGUgPT09IFwibXVsdGlwbGVcIikge1xuICAgICAgICAgICAgaWYgKGN0cmxLZXkgJiYgIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgZXYgPSB0aGlzLnRvZ2dsZShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgZXYgPSB0aGlzLmFkZEFsbFRvKGl0ZW0sIGN0cmxLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQcmVzZW50KGV2KSkge1xuICAgICAgICAgICAgZXYgPSB0aGlzLnNlbGVjdChpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbltpdGVtLmluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhSXRlbTogaXRlbS5kYXRhLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpdGVtLmluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXYuc2VsZWN0ZWRSb3dzLmxlbmd0aCAmJiAhZXYuZGVzZWxlY3RlZFJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXYuY3RybEtleSA9IGN0cmxLZXk7XG4gICAgICAgIGV2LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KGV2KTtcbiAgICB9XG4gICAgdG9nZ2xlKGl0ZW0pIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkUm93cyA9IFtdO1xuICAgICAgICBsZXQgZGVzZWxlY3RlZFJvd3MgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uU3RhcnRJbmRleCA9IGl0ZW0uaW5kZXg7XG4gICAgICAgIGNvbnN0IHJvd0FyZ3MgPSB7IGRhdGFJdGVtOiBpdGVtLmRhdGEsIGluZGV4OiBpdGVtLmluZGV4IH07XG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQoaXRlbS5pbmRleCkpIHtcbiAgICAgICAgICAgIGRlc2VsZWN0ZWRSb3dzLnB1c2gocm93QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChyb3dBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVzZWxlY3RlZFJvd3M6IGRlc2VsZWN0ZWRSb3dzLFxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dzOiBzZWxlY3RlZFJvd3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9nZ2xlQnlJbmRleChpbmRleCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciQkMSA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0QWxsQ2hlY2tlZCAmJiB0aGlzLmlzU2VsZWN0ZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEFsbENoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXRlbSA9IGl0ZXJhdG9yJCQxLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFpdGVtLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnZhbHVlICYmIGl0ZW0udmFsdWUudHlwZSA9PT0gXCJkYXRhXCIgJiYgaXRlbS52YWx1ZS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtVG9Ub2dnbGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGl0ZW0udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGl0ZW0udmFsdWUuaW5kZXhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQoaW5kZXgpIHx8IHRoaXMub3B0aW9ucy5tb2RlID09PSBcIm11bHRpcGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGl0ZW1Ub1RvZ2dsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3QoaXRlbVRvVG9nZ2xlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdChpdGVtKSB7XG4gICAgICAgIGxldCBkZXNlbGVjdGVkUm93cyA9IFtdO1xuICAgICAgICBsZXQgc2VsZWN0ZWRSb3dzID0gW107XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblN0YXJ0SW5kZXggPSBpdGVtLmluZGV4O1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChpdGVtLmluZGV4KSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRSb3dzLnB1c2goeyBkYXRhSXRlbTogaXRlbS5kYXRhLCBpbmRleDogaXRlbS5pbmRleCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgICAgICBpZiAocm93LmluZGV4ICE9PSBpdGVtLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgZGVzZWxlY3RlZFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlc2VsZWN0ZWRSb3dzOiBkZXNlbGVjdGVkUm93cyxcbiAgICAgICAgICAgIHNlbGVjdGVkUm93czogc2VsZWN0ZWRSb3dzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vVXNlZCB0byBtYW51YWxseSBkZXNlbGVjdCByZW1vdmVkIGl0ZW1zXG4gICAgZGVzZWxlY3QocmVtb3ZlZEl0ZW0pIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IkJDEgPSB0aGlzLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBpdGVtID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIWl0ZW0uZG9uZSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUgJiYgaXRlbS52YWx1ZS50eXBlID09PSBcImRhdGFcIiAmJiBpdGVtLnZhbHVlLmRhdGEgPT09IHJlbW92ZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93QXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW06IGl0ZW0udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGl0ZW0udmFsdWUuaW5kZXhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQocm93QXJncy5pbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNlbGVjdGVkUm93czogW3Jvd0FyZ3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdChldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbSA9IGl0ZXJhdG9yJCQxLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRBbGxUbyhpdGVtLCBjdHJsS2V5KSB7XG4gICAgICAgIGxldCBzZWxlY3RlZFJvd3MgPSBbXTtcbiAgICAgICAgbGV0IGRlc2VsZWN0ZWRSb3dzID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4odGhpcy5sYXN0U2VsZWN0aW9uU3RhcnRJbmRleCwgaXRlbS5pbmRleCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWF4KHRoaXMubGFzdFNlbGVjdGlvblN0YXJ0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgICBjb25zdCBpdGVyYXRvciQkMSA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvciQkMS5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dC52YWx1ZSAmJiBuZXh0LnZhbHVlLnR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gbmV4dC52YWx1ZS5pbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dBcmdzID0geyBkYXRhSXRlbTogbmV4dC52YWx1ZS5kYXRhLCBpbmRleDogaWR4IH07XG4gICAgICAgICAgICAgICAgaWYgKChpZHggPCBzdGFydCB8fCBpZHggPiBlbmQpICYmIHRoaXMuaXNTZWxlY3RlZChpZHgpICYmICFjdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VsZWN0ZWRSb3dzLnB1c2gocm93QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoaWR4ID49IHN0YXJ0ICYmIGlkeCA8PSBlbmQpICYmICF0aGlzLmlzU2VsZWN0ZWQoaWR4KSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChyb3dBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZXNlbGVjdGVkUm93czogZGVzZWxlY3RlZFJvd3MsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd3M6IHNlbGVjdGVkUm93c1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGVBbGwoc2VsZWN0QWxsQ2hlY2tlZCkge1xuICAgICAgICB0aGlzLnNlbGVjdEFsbENoZWNrZWQgPSBzZWxlY3RBbGxDaGVja2VkO1xuICAgICAgICBsZXQgc2VsZWN0ZWRSb3dzID0gW107XG4gICAgICAgIGxldCBkZXNlbGVjdGVkUm93cyA9IFtdO1xuICAgICAgICBjb25zdCBpdGVyYXRvciQkMSA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvciQkMS5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dC52YWx1ZSAmJiBuZXh0LnZhbHVlLnR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gbmV4dC52YWx1ZS5pbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dBcmdzID0geyBkYXRhSXRlbTogbmV4dC52YWx1ZS5kYXRhLCBpbmRleDogaWR4IH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZChpZHgpICYmICFzZWxlY3RBbGxDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VsZWN0ZWRSb3dzLnB1c2gocm93QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKGlkeCkgJiYgc2VsZWN0QWxsQ2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChyb3dBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZWN0ZWRSb3dzLmxlbmd0aCAmJiAhZGVzZWxlY3RlZFJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ID0ge1xuICAgICAgICAgICAgY3RybEtleTogdHJ1ZSxcbiAgICAgICAgICAgIGRlc2VsZWN0ZWRSb3dzOiBkZXNlbGVjdGVkUm93cyxcbiAgICAgICAgICAgIHNlbGVjdGVkUm93czogc2VsZWN0ZWRSb3dzLFxuICAgICAgICAgICAgc2hpZnRLZXk6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoZXYpO1xuICAgIH1cbiAgICBzZWxlY3RSYW5nZShzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICBsZXQgc2VsZWN0ZWRSb3dzID0gW107XG4gICAgICAgIGxldCBkZXNlbGVjdGVkUm93cyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICBjb25zdCBpdGVyYXRvciQkMSA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvciQkMS5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dC52YWx1ZSAmJiBuZXh0LnZhbHVlLnR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gbmV4dC52YWx1ZS5pbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dBcmdzID0geyBkYXRhSXRlbTogbmV4dC52YWx1ZS5kYXRhLCBpbmRleDogaWR4IH07XG4gICAgICAgICAgICAgICAgaWYgKChpZHggPCBzdGFydCB8fCBpZHggPiBlbmQpICYmIHRoaXMuaXNTZWxlY3RlZChpZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VsZWN0ZWRSb3dzLnB1c2gocm93QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoaWR4ID49IHN0YXJ0ICYmIGlkeCA8PSBlbmQpICYmICF0aGlzLmlzU2VsZWN0ZWQoaWR4KSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChyb3dBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZXNlbGVjdGVkUm93czogZGVzZWxlY3RlZFJvd3MsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd3M6IHNlbGVjdGVkUm93c1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgc2VsZWN0QWxsU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RBbGxTdGF0ZTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2VsZWN0aW9uLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW5kZXg7XG4gICAgICAgIH0pLmZpbHRlcigobikgPT4gdHlwZW9mIG4gPT09IFwibnVtYmVyXCIpO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjaGVja2JveE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIG1vZGU6IFwibXVsdGlwbGVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnNldHRpbmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXR0aW5ncy5zZWxlY3RhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hlY2tib3hPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0aGlzLnNldHRpbmdzLnNlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJtdWx0aXBsZVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIHRoaXMuc2V0dGluZ3Muc2VsZWN0YWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU3Vic2NyaXB0aW9ucygpO1xuICAgIH1cbiAgICB0YXJnZXRBcmdzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IHRoaXMubW91c2VEb3duRXZlbnRBcmdzLnJvd0luZGV4LFxuICAgICAgICAgICAgZGF0YUl0ZW06IHRoaXMubW91c2VEb3duRXZlbnRBcmdzLmRhdGFJdGVtXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jZWxsQ2xpY2tTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbENsaWNrU3Vic2NyaXB0aW9uID0gdGhpcy5kb21FdmVudHMuY2VsbENsaWNrLnN1YnNjcmliZSgoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCAmJiAhdGhpcy5vcHRpb25zLmNoZWNrYm94T25seSAmJiBhcmdzLnR5cGUgIT09ICdjb250ZXh0bWVudScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKHsgaW5kZXg6IGFyZ3Mucm93SW5kZXgsIGRhdGE6IGFyZ3MuZGF0YUl0ZW0gfSwgYXJncy5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tb3VzZWRvd25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubW91c2Vkb3duU3Vic2NyaXB0aW9uID0gdGhpcy5kb21FdmVudHMuY2VsbE1vdXNlZG93bi5zdWJzY3JpYmUoKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlRG93bkV2ZW50QXJncyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMuZW5hYmxlZCAmJiAoIXRoaXMub3B0aW9ucy5tb2RlIHx8IHRoaXMub3B0aW9ucy5tb2RlID09PSBcIm11bHRpcGxlXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLm9wdGlvbnMuY2hlY2tib3hPbmx5ICYmIGFyZ3Mub3JpZ2luYWxFdmVudC5zaGlmdEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZm9jdXNDZWxsQnlFbGVtZW50KGFyZ3Mub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UgJiYgIXRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXJncy5hY3Rpb24pICYmIGFyZ3MuYWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdChhcmdzLml0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SXRlcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc29yID0gdGhpcy5zZXR0aW5ncy52aWV3LmFjY2Vzc29yKCk7XG4gICAgICAgIGlmICghYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjZXNzb3JbaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIHJlbW92ZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxDbGlja1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jZWxsQ2xpY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2VsbENsaWNrU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb3VzZWRvd25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubW91c2Vkb3duU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLm1vdXNlZG93blN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcblNlbGVjdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEb21FdmVudHNTZXJ2aWNlLFxuICAgICAgICBMb2NhbERhdGFDaGFuZ2VzU2VydmljZSxcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2VdKVxuXSwgU2VsZWN0aW9uU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ2VsbFNlbGVjdGlvblNlcnZpY2UgPSBjbGFzcyBDZWxsU2VsZWN0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZG9tRXZlbnRzLCBsb2NhbERhdGFDaGFuZ2VzU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kb21FdmVudHMgPSBkb21FdmVudHM7XG4gICAgICAgIHRoaXMubG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UgPSBsb2NhbERhdGFDaGFuZ2VzU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubW91c2VVcEV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYWdTZWxlY3REZXNlbGVjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25JdGVtID0geyBpdGVtS2V5OiAwLCBjb2x1bW5LZXk6IDAgfTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uSXRlbVJvd0luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uSXRlbUNvbEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb25zKCk7XG4gICAgfVxuICAgIGdldCBlbmFibGVNYXJxdWVlKCkge1xuICAgICAgICBjb25zdCBjaGVja2JveE9ubHkgPSB0aGlzLnNldHRpbmdzICYmIHR5cGVvZiB0aGlzLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJiB0aGlzLnNldHRpbmdzLmNoZWNrYm94T25seTtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzIHx8IGNoZWNrYm94T25seSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGVTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3Muc2VsZWN0YWJsZTtcbiAgICAgICAgY29uc3QgZHJhZ0FuZE11bHRpcGxlID0gdHlwZW9mIChzZWxlY3RhYmxlU2V0dGluZ3MpID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgaXNQcmVzZW50KHNlbGVjdGFibGVTZXR0aW5ncykgJiZcbiAgICAgICAgICAgIHNlbGVjdGFibGVTZXR0aW5ncy5tb2RlID09PSAnbXVsdGlwbGUnICYmXG4gICAgICAgICAgICBzZWxlY3RhYmxlU2V0dGluZ3MuY2VsbCAmJlxuICAgICAgICAgICAgc2VsZWN0YWJsZVNldHRpbmdzLmVuYWJsZWQgIT09IGZhbHNlICYmXG4gICAgICAgICAgICBzZWxlY3RhYmxlU2V0dGluZ3MuZHJhZztcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlICYmIGRyYWdBbmRNdWx0aXBsZTtcbiAgICB9XG4gICAgaW5pdChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IFtdO1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2VsZWN0YWJsZSAmJiBzZXR0aW5ncy5zZWxlY3RhYmxlLmVuYWJsZWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciQkMSA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFpdGVtLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS52YWx1ZSAmJiBpdGVtLnZhbHVlLnR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0FyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbTogaXRlbS52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGl0ZW0udmFsdWUuaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY29sdW1ucy5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZENlbGxBcmdzID0gc2V0dGluZ3MuY2VsbFNlbGVjdGVkKHJvd0FyZ3MsIGNvbCwgY29sLmxlYWZJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRDZWxsQXJncy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5wdXNoKHNlbGVjdGVkQ2VsbEFyZ3MuaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlzQ2VsbFNlbGVjdGVkKGl0ZW0sIGNvbCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncyAmJiB0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRDZWxsQXJncyA9IHRoaXMuc2V0dGluZ3MuY2VsbFNlbGVjdGVkKHsgZGF0YUl0ZW06IGl0ZW0uZGF0YSwgaW5kZXg6IGl0ZW0uaW5kZXggfSwgY29sLCBjb2wubGVhZkluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZW5hYmxlZCAmJiBzZWxlY3RlZENlbGxBcmdzLnNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlQ2xpY2soaXRlbSwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXY7XG4gICAgICAgIGNvbnN0IGN0cmxLZXkgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJzaW5nbGVcIiAmJiBjdHJsS2V5ICYmIHRoaXMuaXNDZWxsU2VsZWN0ZWQoaXRlbSwgaXRlbS5jb2x1bW4pKSB7XG4gICAgICAgICAgICBldiA9IHRoaXMudG9nZ2xlKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tb2RlID09PSBcIm11bHRpcGxlXCIpIHtcbiAgICAgICAgICAgIGlmIChjdHJsS2V5ICYmICFldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGV2ID0gdGhpcy50b2dnbGUoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0Um93SW5kZXggPSBNYXRoLm1pbih0aGlzLmxhc3RTZWxlY3Rpb25JdGVtUm93SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29sSW5kZXggPSBNYXRoLm1pbih0aGlzLmxhc3RTZWxlY3Rpb25JdGVtQ29sSW5kZXgsIGl0ZW0uY29sdW1uLmxlYWZJbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kUm93SW5kZXggPSBNYXRoLm1heCh0aGlzLmxhc3RTZWxlY3Rpb25JdGVtUm93SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZENvbEluZGV4ID0gTWF0aC5tYXgodGhpcy5sYXN0U2VsZWN0aW9uSXRlbUNvbEluZGV4LCBpdGVtLmNvbHVtbi5sZWFmSW5kZXgpO1xuICAgICAgICAgICAgICAgIGV2ID0gdGhpcy5zZWxlY3RSYW5nZShzdGFydFJvd0luZGV4LCBzdGFydENvbEluZGV4LCBlbmRSb3dJbmRleCwgZW5kQ29sSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQcmVzZW50KGV2KSkge1xuICAgICAgICAgICAgZXYgPSB0aGlzLnNlbGVjdChpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IFt0aGlzLmxhc3RTZWxlY3Rpb25JdGVtXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2LnNlbGVjdGVkQ2VsbHMubGVuZ3RoICYmICFldi5kZXNlbGVjdGVkQ2VsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXYuY3RybEtleSA9IGN0cmxLZXk7XG4gICAgICAgIGV2LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KGV2KTtcbiAgICB9XG4gICAgdG9nZ2xlKGl0ZW0pIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkQ2VsbHMgPSBbXTtcbiAgICAgICAgbGV0IGRlc2VsZWN0ZWRDZWxscyA9IFtdO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25JdGVtID1cbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY2VsbFNlbGVjdGVkKHsgZGF0YUl0ZW06IGl0ZW0uZGF0YSwgaW5kZXg6IGl0ZW0uaW5kZXggfSwgaXRlbS5jb2x1bW4sIGl0ZW0uY29sdW1uLmxlYWZJbmRleCkuaXRlbTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uSXRlbVJvd0luZGV4ID0gaXRlbS5pbmRleDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uSXRlbUNvbEluZGV4ID0gaXRlbS5jb2x1bW4ubGVhZkluZGV4O1xuICAgICAgICBpZiAodGhpcy5pc0NlbGxTZWxlY3RlZChpdGVtLCBpdGVtLmNvbHVtbikpIHtcbiAgICAgICAgICAgIGRlc2VsZWN0ZWRDZWxscy5wdXNoKHRoaXMubGFzdFNlbGVjdGlvbkl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0ZWRDZWxscy5wdXNoKHRoaXMubGFzdFNlbGVjdGlvbkl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZXNlbGVjdGVkQ2VsbHMsXG4gICAgICAgICAgICBzZWxlY3RlZENlbGxzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNlbGVjdChpdGVtKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBbXTtcbiAgICAgICAgY29uc3QgZGVzZWxlY3RlZENlbGxzID0gW107XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbkl0ZW0gPVxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5jZWxsU2VsZWN0ZWQoeyBkYXRhSXRlbTogaXRlbS5kYXRhLCBpbmRleDogaXRlbS5pbmRleCB9LCBpdGVtLmNvbHVtbiwgaXRlbS5jb2x1bW4ubGVhZkluZGV4KS5pdGVtO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25JdGVtUm93SW5kZXggPSBpdGVtLmluZGV4O1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25JdGVtQ29sSW5kZXggPSBpdGVtLmNvbHVtbi5sZWFmSW5kZXg7XG4gICAgICAgIGlmICghdGhpcy5pc0NlbGxTZWxlY3RlZChpdGVtLCBpdGVtLmNvbHVtbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkQ2VsbHMucHVzaCh0aGlzLmxhc3RTZWxlY3Rpb25JdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZm9yRWFjaCgoc2VsZWN0ZWRJdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtLml0ZW1LZXkgIT09IHRoaXMubGFzdFNlbGVjdGlvbkl0ZW0uaXRlbUtleSB8fCBzZWxlY3RlZEl0ZW0uY29sdW1uS2V5ICE9PSB0aGlzLmxhc3RTZWxlY3Rpb25JdGVtLmNvbHVtbktleSkge1xuICAgICAgICAgICAgICAgIGRlc2VsZWN0ZWRDZWxscy5wdXNoKHNlbGVjdGVkSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVzZWxlY3RlZENlbGxzLFxuICAgICAgICAgICAgc2VsZWN0ZWRDZWxsc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvL1VzZWQgdG8gbWFudWFsbHkgZGVzZWxlY3QgcmVtb3ZlZCBpdGVtc1xuICAgIGRlc2VsZWN0KHJlbW92ZWRJdGVtKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yJCQxID0gdGhpcy5nZXRJdGVyYXRvcigpO1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZXJhdG9yJCQxLm5leHQoKTtcbiAgICAgICAgbGV0IHJvd0FyZ3M7XG4gICAgICAgIHdoaWxlICghaXRlbS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS52YWx1ZSAmJiBpdGVtLnZhbHVlLnR5cGUgPT09IFwiZGF0YVwiICYmIGl0ZW0udmFsdWUuZGF0YSA9PT0gcmVtb3ZlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICByb3dBcmdzID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbTogaXRlbS52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaXRlbS52YWx1ZS5pbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3dBcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsc1RvUmVtb3ZlID0gdGhpcy5jdXJyZW50U2VsZWN0aW9uLmZpbHRlcihzZWxlY3RlZEl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbmRlciA9IHRoaXMuc2V0dGluZ3MuY2VsbFNlbGVjdGVkKHJvd0FyZ3MsIG51bGwsIG51bGwpLml0ZW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkSXRlbS5pdGVtS2V5ID09PSBjb250ZW5kZXIuaXRlbUtleTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNlbGxzVG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ID0ge1xuICAgICAgICAgICAgICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzZWxlY3RlZENlbGxzOiBjZWxsc1RvUmVtb3ZlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZENlbGxzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdFJhbmdlKHN0YXJ0Um93SW5kZXgsIHN0YXJ0Q29sSW5kZXgsIGVuZFJvd0luZGV4LCBlbmRDb2xJbmRleCkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZENlbGxzID0gW107XG4gICAgICAgIGNvbnN0IGRlc2VsZWN0ZWRDZWxscyA9IFtdO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydFJvdyA9IE1hdGgubWluKHN0YXJ0Um93SW5kZXgsIGVuZFJvd0luZGV4KTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRDb2wgPSBNYXRoLm1pbihzdGFydENvbEluZGV4LCBlbmRDb2xJbmRleCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZFJvdyA9IE1hdGgubWF4KHN0YXJ0Um93SW5kZXgsIGVuZFJvd0luZGV4KTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kQ29sID0gTWF0aC5tYXgoc3RhcnRDb2xJbmRleCwgZW5kQ29sSW5kZXgpO1xuICAgICAgICBjb25zdCBpdGVyYXRvciQkMSA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvciQkMS5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dC52YWx1ZSAmJiBuZXh0LnZhbHVlLnR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gbmV4dC52YWx1ZS5pbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbmV4dC52YWx1ZS5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0FyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaWR4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNvbHVtbnMuZm9yRWFjaChjb2wgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGl0ZW0gfSA9IHRoaXMuc2V0dGluZ3MuY2VsbFNlbGVjdGVkKHJvd0FyZ3MsIGNvbCwgY29sLmxlYWZJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5pc0NlbGxTZWxlY3RlZChuZXh0LnZhbHVlLCBjb2wpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0luUm93UmFuZ2UgPSBzZWxlY3Rpb25TdGFydFJvdyA8PSBpZHggJiYgaWR4IDw9IHNlbGVjdGlvbkVuZFJvdztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNJbkNvbFJhbmdlID0gc2VsZWN0aW9uU3RhcnRDb2wgPD0gY29sLmxlYWZJbmRleCAmJiBjb2wubGVhZkluZGV4IDw9IHNlbGVjdGlvbkVuZENvbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNJblNlbGVjdGlvblJlY3QgPSBpc0luUm93UmFuZ2UgJiYgaXNJbkNvbFJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW5TZWxlY3Rpb25SZWN0ICYmIHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNlbGVjdGVkQ2VsbHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJblNlbGVjdGlvblJlY3QgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZENlbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvciQkMS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlc2VsZWN0ZWRDZWxscyxcbiAgICAgICAgICAgIHNlbGVjdGVkQ2VsbHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgY2hlY2tib3hPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBtb2RlOiBcIm11bHRpcGxlXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5zZXR0aW5ncykpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2V0dGluZ3Muc2VsZWN0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoZWNrYm94T25seTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdGhpcy5zZXR0aW5ncy5zZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIG1vZGU6IFwibXVsdGlwbGVcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCB0aGlzLnNldHRpbmdzLnNlbGVjdGFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9XG4gICAgYWRkU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNlbGxDbGlja1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jZWxsQ2xpY2tTdWJzY3JpcHRpb24gPSB0aGlzLmRvbUV2ZW50cy5jZWxsQ2xpY2suc3Vic2NyaWJlKChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkICYmICF0aGlzLm9wdGlvbnMuY2hlY2tib3hPbmx5ICYmIGFyZ3MudHlwZSAhPT0gJ2NvbnRleHRtZW51Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpY2soeyBpbmRleDogYXJncy5yb3dJbmRleCwgZGF0YTogYXJncy5kYXRhSXRlbSwgY29sdW1uOiBhcmdzLmNvbHVtbiB9LCBhcmdzLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlZG93blN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tb3VzZWRvd25TdWJzY3JpcHRpb24gPSB0aGlzLmRvbUV2ZW50cy5jZWxsTW91c2Vkb3duLnN1YnNjcmliZSgoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2VEb3duRXZlbnRBcmdzID0gYXJncztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgJiYgKCF0aGlzLm9wdGlvbnMubW9kZSB8fCB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJtdWx0aXBsZVwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5vcHRpb25zLmNoZWNrYm94T25seSAmJiBhcmdzLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZm9jdXNDZWxsQnlFbGVtZW50KGFyZ3Mub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UgJiYgIXRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXJncy5hY3Rpb24pICYmIGFyZ3MuYWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdChhcmdzLml0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SXRlcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc29yID0gdGhpcy5zZXR0aW5ncy52aWV3LmFjY2Vzc29yKCk7XG4gICAgICAgIGlmICghYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjZXNzb3JbaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIHJlbW92ZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxDbGlja1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jZWxsQ2xpY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2VsbENsaWNrU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb3VzZWRvd25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubW91c2Vkb3duU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLm1vdXNlZG93blN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbkNlbGxTZWxlY3Rpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRG9tRXZlbnRzU2VydmljZSxcbiAgICAgICAgTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlXSlcbl0sIENlbGxTZWxlY3Rpb25TZXJ2aWNlKTtcblxuY29uc3QgY3JlYXRlRWxlbWVudCA9ICgpID0+IHtcbiAgICBjb25zdCBtYXJxdWVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBtYXJxdWVlLmNsYXNzTmFtZSA9IFwiay1tYXJxdWVlXCI7XG4gICAgY29uc3QgbWFycXVlZUNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBtYXJxdWVlQ29sb3IuY2xhc3NOYW1lID0gXCJrLW1hcnF1ZWUtY29sb3JcIjtcbiAgICBtYXJxdWVlLmFwcGVuZENoaWxkKG1hcnF1ZWVDb2xvcik7XG4gICAgcmV0dXJuIG1hcnF1ZWU7XG59O1xuY29uc3QgUE9JTlRFUl9PRkZTRVQgPSAyO1xuY29uc3QgTUlOSU1BTF9EUkFHX0RJU1RBTkNFID0gNTtcbmNvbnN0IG9mZnNldHMgPSB7XG4gICAgdG9wTGVmdDogeyB4OiBQT0lOVEVSX09GRlNFVCwgeTogUE9JTlRFUl9PRkZTRVQgfSxcbiAgICB0b3BSaWdodDogeyB4OiAtUE9JTlRFUl9PRkZTRVQsIHk6IFBPSU5URVJfT0ZGU0VUIH0sXG4gICAgYm90dG9tTGVmdDogeyB4OiBQT0lOVEVSX09GRlNFVCwgeTogLVBPSU5URVJfT0ZGU0VUIH0sXG4gICAgYm90dG9tUmlnaHQ6IHsgeDogLVBPSU5URVJfT0ZGU0VULCB5OiAtUE9JTlRFUl9PRkZTRVQgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgR3JpZE1hcnF1ZWVEaXJlY3RpdmUgPSBjbGFzcyBHcmlkTWFycXVlZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZHJhZ2dhYmxlLCBzZWxlY3Rpb24sIGNlbGxTZWxlY3Rpb24sIGRvbUV2ZW50cykge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuY2VsbFNlbGVjdGlvbiA9IGNlbGxTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzID0gZG9tRXZlbnRzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHdlYmtpdFVzZXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jZWxsU2VsZWN0aW9uLmVuYWJsZU1hcnF1ZWUgfHwgdGhpcy5zZWxlY3Rpb24uZW5hYmxlTWFycXVlZSkgPyAnbm9uZScgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgdXNlclNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNlbGxTZWxlY3Rpb24uZW5hYmxlTWFycXVlZSB8fCB0aGlzLnNlbGVjdGlvbi5lbmFibGVNYXJxdWVlKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9ICh0aGlzLmRyYWdnYWJsZS5rZW5kb1ByZXNzLnN1YnNjcmliZSh0aGlzLnN0YXJ0LmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmRyYWdnYWJsZS5rZW5kb0RyYWcuc3Vic2NyaWJlKHRoaXMubW92ZU1hcnF1ZWUuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYW4oKTtcbiAgICB9XG4gICAgc3RhcnQoYXJncykge1xuICAgICAgICBpZiAoYXJncy5vcmlnaW5hbEV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2stY2hlY2tib3gnKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc0FyZ3MgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlc3NBcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5wcmVzc1RhcmdldCA9IG51bGw7XG4gICAgfVxuICAgIG1vdmVNYXJxdWVlKGFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByZXNzVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzVGFyZ2V0ID0gdGhpcy5jZWxsU2VsZWN0aW9uLmFjdGl2ZSA/IHRoaXMuY2VsbFNlbGVjdGlvbi5tb3VzZURvd25FdmVudEFyZ3MgOiB0aGlzLnNlbGVjdGlvbi5tb3VzZURvd25FdmVudEFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlc3MgPSB0aGlzLnByZXNzQXJncztcbiAgICAgICAgaWYgKCFwcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25TdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdygoYXJncy5wYWdlWCAtIHByZXNzLnBhZ2VYKSwgMikgKyBNYXRoLnBvdygoYXJncy5wYWdlWSAtIHByZXNzLnBhZ2VZKSwgMikpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gTUlOSU1BTF9EUkFHX0RJU1RBTkNFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdFbmRTdWJzY3JpcHRpb24gPSBtZXJnZSh0aGlzLmRvbUV2ZW50cy5jZWxsTW91c2V1cC5waXBlKHRha2UoMSkpLCB0aGlzLmRyYWdnYWJsZS5rZW5kb1JlbGVhc2UucGlwZShkZWxheSgxKSwgdGFrZSgxKSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5lbmRTZWxlY3Rpb24uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0TWFycXVlZSgpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5tYXJxdWVlRWxlbWVudDtcbiAgICAgICAgY29uc3QgbWFycXVlZVF1YWRyYW50ID0gdGhpcy5nZXRNYXJxdWVlUXVhZHJhbnQoYXJncy5wYWdlWCwgYXJncy5wYWdlWSwgcHJlc3MucGFnZVgsIHByZXNzLnBhZ2VZKTtcbiAgICAgICAgbGV0IGxlZnQgPSBNYXRoLm1pbihhcmdzLnBhZ2VYLCBwcmVzcy5wYWdlWCk7XG4gICAgICAgIGxldCB0b3AgPSBNYXRoLm1pbihhcmdzLnBhZ2VZLCBwcmVzcy5wYWdlWSk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5hYnMoYXJncy5wYWdlWCAtIHByZXNzLnBhZ2VYKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMoYXJncy5wYWdlWSAtIHByZXNzLnBhZ2VZKTtcbiAgICAgICAgaWYgKG1hcnF1ZWVRdWFkcmFudCkge1xuICAgICAgICAgICAgbGVmdCArPSBvZmZzZXRzW21hcnF1ZWVRdWFkcmFudF0ueDtcbiAgICAgICAgICAgIHRvcCArPSBvZmZzZXRzW21hcnF1ZWVRdWFkcmFudF0ueTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgfVxuICAgIGVuZFNlbGVjdGlvbihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBhcmdzLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbGxTZWxlY3Rpb24uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsU2VsZWN0aW9uLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxTZWxlY3Rpb24uY2hhbmdlcy5lbWl0KHRoaXMuY2VsbFNlbGVjdGlvbi5zZWxlY3RSYW5nZSh0aGlzLnByZXNzVGFyZ2V0LnJvd0luZGV4LCB0aGlzLnByZXNzVGFyZ2V0LmNvbHVtbi5sZWFmSW5kZXgsIGFyZ3Mucm93SW5kZXgsIGFyZ3MuY29sdW1uLmxlYWZJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmNoYW5nZXMuZW1pdCh0aGlzLnNlbGVjdGlvbi5zZWxlY3RSYW5nZSh0aGlzLnByZXNzVGFyZ2V0LnJvd0luZGV4LCBhcmdzLnJvd0luZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhbigpO1xuICAgIH1cbiAgICBjbGVhbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWFycXVlZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5tYXJxdWVlRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLm1hcnF1ZWVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcmFnRW5kU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbmRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdFbmRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnByZXNzVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmVzc0FyZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZWxsU2VsZWN0aW9uLmFjdGl2ZSA/IHRoaXMuY2VsbFNlbGVjdGlvbi5kcmFnZ2luZyA9IGZhbHNlIDogdGhpcy5zZWxlY3Rpb24uZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgaW5pdE1hcnF1ZWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXJxdWVlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5tYXJxdWVlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5tYXJxdWVlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWFycXVlZVF1YWRyYW50KHBvaW50ZXJYLCBwb2ludGVyWSwgc3RhcnRYLCBzdGFydFkpIHtcbiAgICAgICAgY29uc3QgbGVmdEhhbGYgPSBwb2ludGVyWCA8IHN0YXJ0WDtcbiAgICAgICAgY29uc3QgcmlnaHRIYWxmID0gcG9pbnRlclggPiBzdGFydFg7XG4gICAgICAgIGNvbnN0IHRvcEhhbGYgPSBwb2ludGVyWSA8IHN0YXJ0WTtcbiAgICAgICAgY29uc3QgYm90dG9tSGFsZiA9IHBvaW50ZXJZID4gc3RhcnRZO1xuICAgICAgICBpZiAobGVmdEhhbGYgJiYgdG9wSGFsZikge1xuICAgICAgICAgICAgcmV0dXJuICd0b3BMZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdEhhbGYgJiYgYm90dG9tSGFsZikge1xuICAgICAgICAgICAgcmV0dXJuICdib3R0b21MZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHRIYWxmICYmIHRvcEhhbGYpIHtcbiAgICAgICAgICAgIHJldHVybiAndG9wUmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodEhhbGYgJiYgYm90dG9tSGFsZikge1xuICAgICAgICAgICAgcmV0dXJuICdib3R0b21SaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS4td2Via2l0LXVzZXItc2VsZWN0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgR3JpZE1hcnF1ZWVEaXJlY3RpdmUucHJvdG90eXBlLCBcIndlYmtpdFVzZXJTZWxlY3Rpb25cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MudXNlci1zZWxlY3Qtbm9uZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBHcmlkTWFycXVlZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwidXNlclNlbGVjdGlvblwiLCBudWxsKTtcbkdyaWRNYXJxdWVlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkU2VsZWN0aW9uTWFycXVlZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEcmFnZ2FibGVEaXJlY3RpdmUsXG4gICAgICAgIFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIENlbGxTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBEb21FdmVudHNTZXJ2aWNlXSlcbl0sIEdyaWRNYXJxdWVlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFpvbmVBd2FyZUV2ZW50RW1pdHRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iobmdab25lLCBpc0FzeW5jID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoaXNBc3luYyk7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoZ2VuZXJhdG9yT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgbGV0IHNjaGVkdWxlckZuO1xuICAgICAgICBsZXQgZXJyb3JGbiA9IChfKSA9PiBudWxsO1xuICAgICAgICBsZXQgY29tcGxldGVGbiA9ICgpID0+IG51bGw7XG4gICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQgJiYgdHlwZW9mIGdlbmVyYXRvck9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlckZuID0gKHZhbHVlKSA9PiB7IHRoaXMubmdab25lLnJ1bigoKSA9PiBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSkpOyB9O1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yRm4gPSAoZXJyKSA9PiB7IHRoaXMubmdab25lLnJ1bigoKSA9PiBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKSk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVGbiA9ICgpID0+IHsgdGhpcy5uZ1pvbmUucnVuKCgpID0+IGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlckZuID0gKHZhbHVlKSA9PiB7IHRoaXMubmdab25lLnJ1bigoKSA9PiBnZW5lcmF0b3JPck5leHQodmFsdWUpKTsgfTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yRm4gPSAoZXJyKSA9PiB7IHRoaXMubmdab25lLnJ1bigoKSA9PiBlcnJvcihlcnIpKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4gPSAoKSA9PiB7IHRoaXMubmdab25lLnJ1bigoKSA9PiBjb21wbGV0ZSgpKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuc3Vic2NyaWJlKHNjaGVkdWxlckZuLCBlcnJvckZuLCBjb21wbGV0ZUZuKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYWNrYWdlTWV0YWRhdGEgPSB7XG4gICAgbmFtZTogJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWdyaWQnLFxuICAgIHByb2R1Y3ROYW1lOiAnS2VuZG8gVUkgZm9yIEFuZ3VsYXInLFxuICAgIHByb2R1Y3RDb2RlczogWydLRU5ET1VJQU5HVUxBUicsICdLRU5ET1VJQ09NUExFVEUnXSxcbiAgICBwdWJsaXNoRGF0ZTogMTY0ODcwOTU3OCxcbiAgICB2ZXJzaW9uOiAnJyxcbiAgICBsaWNlbnNpbmdEb2NzVXJsOiAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9teS1saWNlbnNlLz91dG1fbWVkaXVtPXByb2R1Y3QmdXRtX3NvdXJjZT1rZW5kb2FuZ3VsYXImdXRtX2NhbXBhaWduPWtlbmRvLXVpLWFuZ3VsYXItcHVyY2hhc2UtbGljZW5zZS1rZXlzLXdhcm5pbmcnXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbHVtbiBjZWxsIHRlbXBsYXRlIG9mIHRoZSBHcmlkIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyB0ZW1wbGF0ZXNfY29sdW1uc19ncmlkICV9I3RvYy1jZWxsLXRlbXBsYXRlKSkuXG4gKiBIZWxwcyB0byBjdXN0b21pemUgdGhlIGNvbnRlbnQgb2YgdGhlIGNlbGxzLiBUbyBkZWZpbmUgdGhlIGNlbGwgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZ1xuICogd2l0aCB0aGUgYGtlbmRvR3JpZENlbGxUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBhIGA8a2VuZG8tZ3JpZC1jb2x1bW4+YCB0YWcuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGRhdGEgaXRlbSBhbmQgdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgcGFzc2VkOlxuICogLSBgY29sdW1uSW5kZXhgJm1kYXNoO1RoZSBjdXJyZW50IGNvbHVtbiBpbmRleC4gVXNlIGl0IGFzIGFuIGFsaWFzIGZvciBhIHRlbXBsYXRlIHZhcmlhYmxlIGJ5IHV0aWxpemluZyB0aGUgYGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCJgIHN5bnRheC5cbiAqIC0gYHJvd0luZGV4YCZtZGFzaDtUaGUgY3VycmVudCBkYXRhIHJvdyBpbmRleC4gVXNlIGl0IGFzIGFuIGFsaWFzIGZvciBhIHRlbXBsYXRlIHZhcmlhYmxlIGJ5IHV0aWxpemluZyB0aGUgYGxldC1yb3dJbmRleD1cInJvd0luZGV4XCJgIHN5bnRheC5cbiAqIC0gYGRhdGFJdGVtYCZtZGFzaDtUaGUgY3VycmVudCBkYXRhIGl0ZW0uIFJlcHJlc2VudHMgdGhlIGRlZmF1bHQgY29udGV4dCB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gYW55IHRlbXBsYXRlIHZhcmlhYmxlIHdoaWNoIHV0aWxpemVzIHRoZSBgbGV0LXhgIHN5bnRheCZtZGFzaDtmb3IgZXhhbXBsZSwgYGxldC1kYXRhSXRlbWAuXG4gKiAtIGBjb2x1bW5gJm1kYXNoO1RoZSBjdXJyZW50IGNvbHVtbiBpbnN0YW5jZS4gVXNlIGl0IGFzIGFuIGFsaWFzIGZvciBhIHRlbXBsYXRlIHZhcmlhYmxlIGJ5IHV0aWxpemluZyB0aGUgYGxldC1jb2x1bW49XCJjb2x1bW5cImAgc3ludGF4LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJncmlkRGF0YVwiPlxuICogICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiUHJvZHVjdE5hbWVcIj5cbiAqICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkQ2VsbFRlbXBsYXRlIGxldC1kYXRhSXRlbSBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuICogICAgICAgICAgICAgICAgICAgICBEYXRhIFJvdyAjOiB7e3Jvd0luZGV4fX0gL1xuICogICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPnt7ZGF0YUl0ZW0uUHJvZHVjdE5hbWV9fTwvc3Ryb25nPlxuICogICAgICAgICAgICAgICAgICAgICAoe3tkYXRhSXRlbS5EaXNjb250aW51ZWQgPyBcImRpc2NvbnRpbnVlZFwiIDogXCJhY3RpdmVcIn19KVxuICogICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgIHB1YmxpYyBncmlkRGF0YSA9IFt7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gKiAgICAgICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gKiAgICAgICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gKiAgICAgICB9LCB7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICogICAgICAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgXTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IENlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5DZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRDZWxsVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBDZWxsVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGdyb3VwLWhlYWRlciBjZWxsIHRlbXBsYXRlIG9mIHRoZSBHcmlkIHdoaWNoIGhlbHBzIHRvIGN1c3RvbWl6ZSB0aGUgY29udGVudCBvZiB0aGUgZ3JvdXAgaGVhZGVyIGl0ZW0uXG4gKiBUbyBkZWZpbmUgdGhlIGdyb3VwIGhlYWRlciB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb0dyaWRHcm91cEhlYWRlclRlbXBsYXRlYFxuICogZGlyZWN0aXZlIGluc2lkZSBgPGtlbmRvLWdyaWQtY29sdW1uPmAuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGRhdGEgaXRlbSBhbmQgdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgcGFzc2VkOlxuICogLSBgZ3JvdXBgJm1kYXNoO1RoZSBjdXJyZW50IGdyb3VwIGl0ZW0uXG4gKiAtIGBmaWVsZGAmbWRhc2g7VGhlIG5hbWUgb2YgdGhlIGZpZWxkIGJ5IHdoaWNoIGRhdGEgaXMgZ3JvdXBlZC5cbiAqIC0gYHZhbHVlYCZtZGFzaDtUaGUgY3VycmVudCBncm91cCB2YWx1ZS5cbiAqIC0gYGFnZ3JlZ2F0ZXNgJm1kYXNoO0FsbCBhZ2dyZWdhdGUgdmFsdWVzIGZvciB0aGUgY3VycmVudCBncm91cC5cbiAqIC0gYGluZGV4YCZtZGFzaDtUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgZ3JvdXAuXG4gKiAtIGBleHBhbmRlZGAmbWRhc2g7QSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGdyb3VwIGlzIGN1cnJlbnRseSBleHBhbmRlZC5cbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZ3JvdXBhYmxlX2dyaWRfd2l0aF9hZ2dyZWdhdGVzICV9KSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWRhdGEtcXVlcnknO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGtlbmRvLWdyaWQgW2RhdGFdPVwiZ3JpZERhdGFcIiBbZ3JvdXBdPVwiZ3JvdXBzXCI+XG4gKiAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiPlxuICogICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRHcm91cEhlYWRlclRlbXBsYXRlIGxldC1ncm91cCBsZXQtZmllbGQ9XCJmaWVsZFwiIGxldC12YWx1ZT1cInZhbHVlXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgPHN0cm9uZz57e2ZpZWxkfX08L3N0cm9uZz46IHt7dmFsdWV9fVxuICogICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgIHB1YmxpYyBncm91cHMgPSBbeyBmaWVsZDogXCJQcm9kdWN0TmFtZVwiIH1dO1xuICpcbiAqICAgICBwdWJsaWMgZ3JpZERhdGEgPSBwcm9jZXNzKFt7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gKiAgICAgICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gKiAgICAgICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gKiAgICAgICB9LCB7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICogICAgICAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgXSwge1xuICogICAgICBncm91cDogdGhpcy5ncm91cHNcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRHcm91cEhlYWRlclRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZ3JvdXAtaGVhZGVyIGNvbHVtbiB0ZW1wbGF0ZSBvZiB0aGUgR3JpZCB3aGljaCBoZWxwcyB0byBjdXN0b21pemUgdGhlIGNvbnRlbnQgb2YgdGhlIGdyb3VwIGhlYWRlcnMuXG4gKiBUbyBkZWZpbmUgdGhlIGdyb3VwIGhlYWRlciB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb0dyaWRHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlYFxuICogZGlyZWN0aXZlIGluc2lkZSBgPGtlbmRvLWdyaWQtY29sdW1uPmAuIChbU2VlIGV4YW1wbGVdKHslIHNsdWcgZ3JvdXBhYmxlX2dyaWRfd2l0aF9hZ2dyZWdhdGVzICV9KSkuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGRhdGEgaXRlbSBhbmQgdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgcGFzc2VkOlxuICogLSBgZ3JvdXBgJm1kYXNoO1RoZSBjdXJyZW50IGdyb3VwIGl0ZW0uXG4gKiAtIGBmaWVsZGAmbWRhc2g7VGhlIG5hbWUgb2YgdGhlIGZpZWxkIGJ5IHdoaWNoIGRhdGEgaXMgZ3JvdXBlZC5cbiAqIC0gYHZhbHVlYCZtZGFzaDtUaGUgY3VycmVudCBncm91cCB2YWx1ZS5cbiAqIC0gYGFnZ3JlZ2F0ZXNgJm1kYXNoO0FsbCBhZ2dyZWdhdGUgdmFsdWVzIGZvciB0aGUgY3VycmVudCBncm91cC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAqICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZSBsZXQtZ3JvdXA9XCJncm91cFwiIGxldC1hZ2dyZWdhdGVzPVwiYWdncmVnYXRlc1wiPlxuICogICAgICAgICA8c3BhbiB0aXRsZT1cIkdyb3VwIEhlYWRlciBDb2x1bW4gVGVtcGxhdGUgZm9yIFByb2R1Y3ROYW1lXCI+XG4gKiAgICAgICAgICAgICBDb3VudDoge3sgYWdncmVnYXRlcy5EaXNjb250aW51ZWQuY291bnQgfX1cbiAqICAgICAgICAgPC9zcGFuPlxuICogICAgIDwvbmctdGVtcGxhdGU+XG4gKiA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogYGBgXG4gKi9cbmxldCBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5Hcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbHVtbiBlZGl0LWNlbGwgdGVtcGxhdGUgb2YgdGhlIEdyaWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RlbXBsYXRlX2Zvcm1zX2dyaWQgJX0pKS5cbiAqIEhlbHBzIHRvIGN1c3RvbWl6ZSB0aGUgY29udGVudCBvZiB0aGUgZWRpdGVkIGNlbGxzLiBUbyBkZWZpbmUgdGhlIGNlbGwgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gXG4gKiB0YWcgd2l0aCB0aGUgYGtlbmRvR3JpZEVkaXRUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBhIGA8a2VuZG8tZ3JpZC1jb2x1bW4+YCB0YWcuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGZvcm0gZ3JvdXAgYW5kIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbCBmaWVsZHMgYXJlIHBhc3NlZDpcbiAqIC0gYGZvcm1Hcm91cGAmbWRhc2g7VGhlIGN1cnJlbnQgW0Zvcm1Hcm91cF0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnZm9ybWdyb3VwYXBpJ10gfX0pLlxuICogUmVwcmVzZW50cyB0aGUgZGVmYXVsdCBjb250ZXh0IHRoYXQgd2lsbCBiZSBhc3NpZ25lZCB0byBhbnkgdGVtcGxhdGUgdmFyaWFibGUgd2hpY2ggdXRpbGl6ZXMgdGhlIGBsZXQteGAgc3ludGF4Jm1kYXNoO2ZvciBleGFtcGxlLCBgbGV0LWZvcm1Hcm91cGAuXG4gKiBJZiB5b3UgdXNlIHRoZSBHcmlkIGluc2lkZSBbVGVtcGxhdGUtRHJpdmVuIEZvcm1zXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWydmb3JtcyddIH19KSwgaXQgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAqIC0gYHJvd0luZGV4YCZtZGFzaDtUaGUgY3VycmVudCBkYXRhIHJvdyBpbmRleC4gSWYgaW5zaWRlIGEgbmV3IGl0ZW0gcm93LCBgcm93SW5kZXhgIGlzIGAtMWAuIFVzZSBpdCBhcyBhbiBhbGlhcyBmb3IgYSB0ZW1wbGF0ZSB2YXJpYWJsZSBieSB1dGlsaXppbmcgdGhlIGBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiYCBzeW50YXguXG4gKiAtIGBkYXRhSXRlbWAmbWRhc2g7VGhlIGN1cnJlbnQgZGF0YSBpdGVtLiBVc2UgaXQgYXMgYW4gYWxpYXMgZm9yIGEgdGVtcGxhdGUgdmFyaWFibGUgYnkgdXRpbGl6aW5nIHRoZSBgbGV0LWRhdGFJdGVtPVwiZGF0YUl0ZW1cImAgc3ludGF4LlxuICogLSBgY29sdW1uYCZtZGFzaDtUaGUgY3VycmVudCBjb2x1bW4gaW5zdGFuY2UuIFVzZSBpdCBhcyBhbiBhbGlhcyBmb3IgYSB0ZW1wbGF0ZSB2YXJpYWJsZSBieSB1dGlsaXppbmcgdGhlIGBsZXQtY29sdW1uPVwiY29sdW1uXCJgIHN5bnRheC5cbiAqIC0gYGlzTmV3YCZtZGFzaDtUaGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgaXRlbS4gVXNlIGl0IGFzIGFuIGFsaWFzIGZvciBhIHRlbXBsYXRlIHZhcmlhYmxlIGJ5IHV0aWxpemluZyB0aGUgYGxldC1pc05ldz1cImlzTmV3XCJgIHN5bnRheC5cbiAqL1xubGV0IEVkaXRUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIEVkaXRUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5FZGl0VGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRFZGl0VGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBFZGl0VGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbHVtbiBncm91cCBmb290ZXIgY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgR3JpZCB3aGljaCBoZWxwcyB0byBjdXN0b21pemUgdGhlIGdyb3VwIGZvb3RlciBjZWxsIGZvciB0aGUgY29sdW1uLlxuICogVG8gZGVmaW5lIHRoZSBncm91cCBmb290ZXIgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9HcmlkR3JvdXBGb290ZXJUZW1wbGF0ZWAgZGlyZWN0aXZlXG4gKiBpbnNpZGUgYDxrZW5kby1ncmlkLWNvbHVtbj5gLlxuICpcbiAqIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGlzIHNldCB0byB0aGUgY3VycmVudCBhZ2dyZWdhdGVzIGFuZCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBwYXNzZWQ6XG4gKiAtIGBjb2x1bW5gJm1kYXNoO0RlZmluZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGBDb2x1bW5Db21wb25lbnRgIG9wdGlvbi5cbiAqIC0gYGZpZWxkYCZtZGFzaDtUaGUgY3VycmVudCBjb2x1bW4gZmllbGQgbmFtZS5cbiAqIC0gYGdyb3VwYCZtZGFzaDtUaGUgY3VycmVudCBncm91cCBkYXRhIGl0ZW0uXG4gKiAtIGBhZ2dyZWdhdGVzYCZtZGFzaDtBbGwgYWdncmVnYXRlIHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgZ3JvdXAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqIGltcG9ydCB7IHByb2Nlc3MgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tZGF0YS1xdWVyeSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJncmlkRGF0YVwiIFtncm91cF09XCJncm91cHNcIj5cbiAqICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCI+XG4gKiAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZEdyb3VwRm9vdGVyVGVtcGxhdGUgbGV0LWFnZ3JlZ2F0ZXMgbGV0LWZpZWxkPVwiZmllbGRcIj5cbiAqICAgICAgICAgICAgICAgICAgICBDb3VudDoge3thZ2dyZWdhdGVzW2ZpZWxkXS5jb3VudH19XG4gKiAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgcHVibGljIGdyb3VwcyA9IFt7IGZpZWxkOiBcIlByb2R1Y3ROYW1lXCIsIGFnZ3JlZ2F0ZXM6IFt7IGZpZWxkOiBcIlByb2R1Y3ROYW1lXCIsIGFnZ3JlZ2F0ZTogXCJjb3VudFwiIH1dIH1dO1xuICpcbiAqICAgICBwdWJsaWMgZ3JpZERhdGEgPSBwcm9jZXNzKFt7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gKiAgICAgICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gKiAgICAgICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gKiAgICAgICB9LCB7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICogICAgICAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgXSwge1xuICogICAgICBncm91cDogdGhpcy5ncm91cHNcbiAqICAgICB9KTtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIEdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZEdyb3VwRm9vdGVyVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBHcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb2x1bW4gaGVhZGVyIGNlbGwgdGVtcGxhdGUgb2YgdGhlIEdyaWRcbiAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyB0ZW1wbGF0ZXNfY29sdW1uc19ncmlkICV9I3RvYy1oZWFkZXItdGVtcGxhdGUpKS5cbiAqIEhlbHBzIHRvIGN1c3RvbWl6ZSB0aGUgdGFibGUgaGVhZGVyIGNlbGwgZm9yIHRoZSBjb2x1bW4uXG4gKiBUbyBkZWZpbmUgYSBoZWFkZXIgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZVxuICogW2tlbmRvR3JpZEhlYWRlclRlbXBsYXRlXSh7JSBzbHVnIGFwaV9ncmlkX2hlYWRlcnRlbXBsYXRlZGlyZWN0aXZlICV9KSBkaXJlY3RpdmUgaW5zaWRlIHRoZSBgPGtlbmRvLWdyaWQtY29sdW1uPmAgdGFnLlxuICpcbiAqICBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgY29sdW1uIGFuZCB0aGVuIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbCBmaWVsZHMgYXJlIHBhc3NlZDpcbiAqICogYGNvbHVtbmAmbWRhc2g7RGVmaW5lcyBhbiBpbnN0YW5jZSBvZiB0aGUgW0NvbHVtbkNvbXBvbmVudF0oeyUgc2x1ZyBhcGlfZ3JpZF9jb2x1bW5jb21wb25lbnQgJX0pIG9wdGlvbi5cbiAqICogYGNvbHVtbkluZGV4YCZtZGFzaDtEZWZpbmVzIHRoZSBjdXJyZW50IGNvbHVtbiBpbmRleC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGtlbmRvLWdyaWQgW2RhdGFdPVwiZ3JpZERhdGFcIj5cbiAqICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCI+XG4gKiAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZEhlYWRlclRlbXBsYXRlIGxldC1jb2x1bW4gbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgIHt7Y29sdW1uLmZpZWxkfX0oe3tjb2x1bW5JbmRleH19KVxuICogICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiPlxuICogICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRIZWFkZXJUZW1wbGF0ZSBsZXQtY29sdW1uIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCI+XG4gKiAgICAgICAgICAgICAgICAgICB7e2NvbHVtbi5maWVsZH19KHt7Y29sdW1uSW5kZXh9fSlcbiAqICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgPC9rZW5kby1ncmlkPlxuICogICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgZ3JpZERhdGEgPSBbe1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAxLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICogICAgICAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICogICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICogICAgICAgfSwge1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAqICAgICAgICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAqICAgICAgICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICogICAgICAgfVxuICogICAgIF07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkhlYWRlclRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkSGVhZGVyVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29sdW1uIGZvb3RlciBjZWxsIHRlbXBsYXRlIG9mIHRoZSBHcmlkXG4gKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgdGVtcGxhdGVzX2NvbHVtbnNfZ3JpZCAlfSN0b2MtZm9vdGVyLXRlbXBsYXRlKSkuXG4gKiBIZWxwcyB0byBjdXN0b21pemUgdGhlIHRhYmxlIGZvb3RlciBjZWxsIGZvciB0aGUgY29sdW1uLlxuICogVG8gZGVmaW5lIGEgZm9vdGVyIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGVcbiAqIFtrZW5kb0dyaWRGb290ZXJUZW1wbGF0ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9mb290ZXJ0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlIGluc2lkZSB0aGUgYDxrZW5kby1ncmlkLWNvbHVtbj5gIHRhZy5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgY29sdW1uIGFuZCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBwYXNzZWQ6XG4gKiAqIGBjb2x1bW5gJm1kYXNoO0RlZmluZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFtDb2x1bW5Db21wb25lbnRdKHslIHNsdWcgYXBpX2dyaWRfY29sdW1uY29tcG9uZW50ICV9KSBvcHRpb24uXG4gKiAqIGBjb2x1bW5JbmRleGAmbWRhc2g7RGVmaW5lcyB0aGUgY3VycmVudCBjb2x1bW4gaW5kZXguXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIGRpc3BsYXkgYWdncmVnYXRlcyBpbiB0aGUgZm9vdGVyIG9mIHRoZSBHcmlkLFxuICogcmVmZXIgdG8gdGhlIGFydGljbGUgb24gW2FnZ3JlZ2F0ZXNdKHslIHNsdWcgZ3JvdXBhYmxlX2dyaWRfd2l0aF9hZ2dyZWdhdGVzICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGtlbmRvLWdyaWQgW2RhdGFdPVwiZ3JpZERhdGFcIiBzY3JvbGxhYmxlPVwibm9uZVwiPlxuICogICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiUHJvZHVjdE5hbWVcIj5cbiAqICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkRm9vdGVyVGVtcGxhdGUgbGV0LWNvbHVtbiBsZXQtY29sdW1uSW5kZXg9XCJjb2x1bW5JbmRleFwiPlxuICogICAgICAgICAgICAgICAgICAge3tjb2x1bW4uZmllbGR9fSh7e2NvbHVtbkluZGV4fX0pXG4gKiAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiVW5pdFByaWNlXCI+XG4gKiAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZEZvb3RlclRlbXBsYXRlIGxldC1jb2x1bW4gbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgIHt7Y29sdW1uLmZpZWxkfX0oe3tjb2x1bW5JbmRleH19KVxuICogICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgIHB1YmxpYyBncmlkRGF0YSA9IFt7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gKiAgICAgICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gKiAgICAgICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gKiAgICAgICB9LCB7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICogICAgICAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgXTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRGb290ZXJUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRlbXBsYXRlIGZvciB0aGUgY29sdW1uIG1lbnUgaW4gdGhlIEdyaWQuIFByb3ZpZGVzIGFuIG9wdGlvbiBmb3JcbiAqIGN1c3RvbWl6aW5nIHRoZSBjb250ZW50IG9mIHRoZSBjb2x1bW4gbWVudSBmb3IgYWxsIG9yIGZvciBzcGVjaWZpYyBjb2x1bW5zLlxuICogVG8gZGVmaW5lIHRoZSBjb250ZW50IHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGVcbiAqIGBrZW5kb0dyaWRDb2x1bW5NZW51VGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGBrZW5kby1ncmlkYCBvciB0aGUgYDxrZW5kby1ncmlkLWNvbHVtbj5gIGNvbXBvbmVudC5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBwYXNzZXMgdGhyb3VnaCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAqIC0gYHNlcnZpY2VgJm1kYXNoO1JlcHJlc2VudHMgdGhlIFtDb2x1bW5NZW51U2VydmljZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jb2x1bW5tZW51c2VydmljZSAlfSkuXG4gKiAtIGBjb2x1bW5gJm1kYXNoO1JlcHJlc2VudHMgdGhlIEdyaWQgY29sdW1uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgPGtlbmRvLWdyaWQgW2tlbmRvR3JpZEJpbmRpbmddPVwiZGF0YVwiIFtzb3J0YWJsZV09XCJ0cnVlXCIgW2NvbHVtbk1lbnVdPVwidHJ1ZVwiPlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENvbHVtbk1lbnVUZW1wbGF0ZSBsZXQtc2VydmljZT1cInNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LXNvcnQgW3NlcnZpY2VdPVwic2VydmljZVwiPlxuICogICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LXNvcnQ+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiRmllbGQxXCIgW3dpZHRoXT1cIjEwMFwiPlxuICogICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDb2x1bW5NZW51VGVtcGxhdGUgbGV0LXNlcnZpY2U9XCJzZXJ2aWNlXCI+XG4gKiAgICAgICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbm1lbnUtbG9jayBbc2VydmljZV09XCJzZXJ2aWNlXCI+XG4gKiAgICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LWxvY2s+XG4gKiAgICAgICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbm1lbnUtc29ydCBbc2VydmljZV09XCJzZXJ2aWNlXCI+XG4gKiAgICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LXNvcnQ+XG4gKiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJGaWVsZDJcIiBbd2lkdGhdPVwiMTAwXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFt7IEZpZWxkMTogJ0ZvbycsIEZpZWxkMjogJ0JhcicgfSwgeyBGaWVsZDE6ICdGb28xJywgRmllbGQyOiAnQmFyMScgfV07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBDb2x1bW5NZW51VGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBDb2x1bW5NZW51VGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuQ29sdW1uTWVudVRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkQ29sdW1uTWVudVRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgQ29sdW1uTWVudVRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzU3BhbkNvbHVtbiA9IGNvbHVtbiA9PiBjb2x1bW4uaXNTcGFuQ29sdW1uO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQ2hlY2tib3hDb2x1bW4gPSBjb2x1bW4gPT4gY29sdW1uLmlzQ2hlY2tib3hDb2x1bW47XG5jb25zdCBpc0NvbHVtbkNvbnRhaW5lciA9IGNvbHVtbiA9PiBjb2x1bW4uaXNDb2x1bW5Hcm91cCB8fCBpc1NwYW5Db2x1bW4oY29sdW1uKTtcbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIHRoZSBjb2x1bW4gY29tcG9uZW50cyBvZiB0aGUgR3JpZC5cbiAqL1xuY2xhc3MgQ29sdW1uQmFzZSQxIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50LCBpZFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hdGNoZXNNZWRpYSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29sdW1uIGluZGV4IGFmdGVyIHJlb3JkZXJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gYG9yZGVySW5kZXhgIGlzIGEgcmVhZC1vbmx5IHByb3BlcnR5LiBTZXR0aW5nIHRoaXMgZmllbGQgZG9lcyBub3QgYWZmZWN0IGNvbHVtbiBvcmRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JkZXJJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ29sdW1uR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNTcGFuQ29sdW1uID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29sdW1uIGlzIHJlc2l6YWJsZS5cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemFibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyByZW9yZGVyYWJsZS5cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW9yZGVyYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggKGluIHBpeGVscykgYmVsb3cgd2hpY2ggdGhlIHVzZXIgaXMgbm90IGFibGUgdG8gcmVzaXplIHRoZSBjb2x1bW4gYnkgdXNpbmcgdGhlIFVJLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5SZXNpemFibGVXaWR0aCA9IDEwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVG9nZ2xlcyB0aGUgbG9ja2VkIChmcm96ZW4pIHN0YXRlIG9mIHRoZSBjb2x1bW5zIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBsb2NrZWRfY29sdW1uc19ncmlkICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgICAgICAgPGtlbmRvLWdyaWQgW2RhdGFdPVwiZ3JpZERhdGFcIiBbc2Nyb2xsYWJsZV09XCJzY3JvbGxhYmxlXCIgc3R5bGU9XCJoZWlnaHQ6IDIwMHB4XCI+XG4gICAgICAgICAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3RJRFwiIHRpdGxlPVwiUHJvZHVjdCBJRFwiIHdpZHRoPVwiMTIwXCIgW2xvY2tlZF09XCJ0cnVlXCI+XG4gICAgICAgICAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gICAgICAgICAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIiB3aWR0aD1cIjIwMFwiPlxuICAgICAgICAgKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICAgICAgICAgKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJVbml0UHJpY2VcIiB0aXRsZT1cIlVuaXQgUHJpY2VcIiB3aWR0aD1cIjIzMFwiPlxuICAgICAgICAgKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICAgICAgICAgKiAgICAgICAgPC9rZW5kby1ncmlkPlxuICAgICAgICAgKiAgICBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgIHB1YmxpYyBncmlkRGF0YTogYW55W107XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgKiAgICAgICAgdGhpcy5ncmlkRGF0YSA9IHByb2R1Y3RzO1xuICAgICAgICAgKiAgICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAgICAgKiAgICBcIlByb2R1Y3RJRFwiOiAxLFxuICAgICAgICAgKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICAgICAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gICAgICAgICAqICB9LCB7XG4gICAgICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICAgICAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICAgICAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICAgICAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAgICAgKiAgfVxuICAgICAgICAgKiBdO1xuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbHVtbiB3aWxsIGJlIGFsd2F5cyB2aXNpYmxlIHdoZW4gc2Nyb2xsaW5nIHRoZSBHcmlkIGhvcml6b250YWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RpY2t5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGNvbHVtbiBjYW4gYmUgbG9ja2VkIG9yIHVubG9ja2VkIGZyb20gdGhlIGNvbHVtbiBtZW51IG9yIGJ5IHJlb3JkZXJpbmcgdGhlIGNvbHVtbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvY2thYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgY29sdW1uIGNhbiBiZSBzdHVjayBvciB1bnN0dWNrIGZyb20gdGhlIGNvbHVtbiBtZW51LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGlja2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBjb2x1bW4gbWVudSB3aWxsIGJlIHNob3duIGZvciB0aGUgY29sdW1uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5NZW51ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgY29sdW1uIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGNvbHVtbi1jaG9vc2VyIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluY2x1ZGVJbkNob29zZXIgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWFkZXJUZW1wbGF0ZXMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbk1lbnVUZW1wbGF0ZXMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMuaWRTZXJ2aWNlID0gaWRTZXJ2aWNlO1xuICAgICAgICBpZiAocGFyZW50ICYmIGlkU2VydmljZSAmJiBwYXJlbnQuaWRTZXJ2aWNlLmdyaWRJZCgpID09PSBpZFNlcnZpY2UuZ3JpZElkKCkgJiYgIWlzQ29sdW1uQ29udGFpbmVyKHBhcmVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sdW1ucyBjYW4gYmUgbmVzdGVkIG9ubHkgaW5zaWRlIENvbHVtbkdyb3VwQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gKGluIHBpeGVscykuXG4gICAgICovXG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHRoaXMuX3dpZHRoID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXhwZWN0ZWQgbnVtZXJpYyB2YWx1ZSBmb3IgY29sdW1uIHdpZHRoLCBidXQgZ290IGEgc3RyaW5nIFwiJHt2YWx1ZX1cIi4gVHJlYXRpbmcgYXMgJHtwYXJzZWRWYWx1ZX1weC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fd2lkdGg7IH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgaXNTcGFuQ29sdW1uKHRoaXMucGFyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmxldmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmxldmVsICsgMSA6IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmlzTG9ja2VkIDogdGhpcy5sb2NrZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY29sc3BhbigpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByb3dzcGFuKHRvdGFsQ29sdW1uTGV2ZWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxldmVsIDwgdG90YWxDb2x1bW5MZXZlbHMgPyAodG90YWxDb2x1bW5MZXZlbHMgLSB0aGlzLmxldmVsKSArIDEgOiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhlYWRlclRlbXBsYXRlUmVmKCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuaGVhZGVyVGVtcGxhdGVzLmZpcnN0O1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUgPyB0ZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBmb290ZXJUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9vdGVyVGVtcGxhdGUgPyB0aGlzLmZvb3RlclRlbXBsYXRlLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbk1lbnVUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLmNvbHVtbk1lbnVUZW1wbGF0ZXMuZmlyc3Q7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSA/IHRlbXBsYXRlLnRlbXBsYXRlUmVmIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkaXNwbGF5VGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmhpZGRlbiAmJiB0aGlzLm1hdGNoZXNNZWRpYTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uQmFzZSQxLnByb3RvdHlwZSwgXCJyZXNpemFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5CYXNlJDEucHJvdG90eXBlLCBcInJlb3JkZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDb2x1bW5CYXNlJDEucHJvdG90eXBlLCBcIm1pblJlc2l6YWJsZVdpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2x1bW5CYXNlJDEucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwid2lkdGhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uQmFzZSQxLnByb3RvdHlwZSwgXCJhdXRvU2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwibG9ja2VkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uQmFzZSQxLnByb3RvdHlwZSwgXCJzdGlja3lcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5CYXNlJDEucHJvdG90eXBlLCBcImhpZGRlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sdW1uQmFzZSQxLnByb3RvdHlwZSwgXCJtZWRpYVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwibG9ja2FibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5CYXNlJDEucHJvdG90eXBlLCBcInN0aWNrYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwiY29sdW1uTWVudVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwiaW5jbHVkZUluQ2hvb3NlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uQmFzZSQxLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uQmFzZSQxLnByb3RvdHlwZSwgXCJoZWFkZXJTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uQmFzZSQxLnByb3RvdHlwZSwgXCJmaWx0ZXJTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uQmFzZSQxLnByb3RvdHlwZSwgXCJmb290ZXJTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2NsYXNzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwiY3NzQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwiaGVhZGVyQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwiZmlsdGVyQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwiZm9vdGVyQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIENvbHVtbkJhc2UkMS5wcm90b3R5cGUsIFwiaGVhZGVyVGVtcGxhdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDb2x1bW5CYXNlJDEucHJvdG90eXBlLCBcImZvb3RlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oQ29sdW1uTWVudVRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgQ29sdW1uQmFzZSQxLnByb3RvdHlwZSwgXCJjb2x1bW5NZW51VGVtcGxhdGVzXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZmlsdGVyLWNlbGwgdGVtcGxhdGUgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2MtY3VzdG9taXppbmctZmlsdGVyLXJvd3MpKS5cbiAqL1xubGV0IEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5GaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRGaWx0ZXJDZWxsVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGZpbHRlci1tZW51IHRlbXBsYXRlXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1jdXN0b21pemluZy1maWx0ZXItbWVudXMpKS5cbiAqL1xubGV0IEZpbHRlck1lbnVUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIEZpbHRlck1lbnVUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5GaWx0ZXJNZW51VGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRGaWx0ZXJNZW51VGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBGaWx0ZXJNZW51VGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vLyBJbmNyZW1lbnRlZCBlYWNoIHRpbWUgdGhlIHNlcnZpY2UgaXMgaW5zdGFudGlhdGVkLlxubGV0IHNlcXVlbmNlID0gMDtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgSWRTZXJ2aWNlID0gY2xhc3MgSWRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBgay1ncmlkJHtzZXF1ZW5jZSsrfWA7XG4gICAgfVxuICAgIGdyaWRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4O1xuICAgIH1cbiAgICBjZWxsSWQocm93SW5kZXgsIGNvbEluZGV4KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnByZWZpeH0tciR7cm93SW5kZXh9YyR7Y29sSW5kZXh9YDtcbiAgICB9XG4gICAgc2VsZWN0aW9uQ2hlY2tib3hJZChpdGVtSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fS1jaGVja2JveCR7aXRlbUluZGV4fWA7XG4gICAgfVxuICAgIHNlbGVjdEFsbENoZWNrYm94SWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnByZWZpeH0tc2VsZWN0LWFsbGA7XG4gICAgfVxufTtcbklkU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBJZFNlcnZpY2UpO1xuXG52YXIgQ29sdW1uQ29tcG9uZW50XzE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gaXNDb2x1bW5Db21wb25lbnQoY29sdW1uKSB7XG4gICAgcmV0dXJuIGlzUHJlc2VudChjb2x1bW4uZmllbGQpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb2x1bW5zIG9mIHRoZSBbQW5ndWxhciBEYXRhIEdyaWRdKHslIHNsdWcgb3ZlcnZpZXdfZ3JpZCAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1ncmlkIFtkYXRhXT1cImdyaWREYXRhXCI+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0SURcIiB0aXRsZT1cIlByb2R1Y3QgSURcIiB3aWR0aD1cIjEyMFwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJVbml0UHJpY2VcIiB0aXRsZT1cIlVuaXQgUHJpY2VcIiB3aWR0aD1cIjIzMFwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkRpc2NvbnRpbnVlZFwiIHdpZHRoPVwiMTIwXCI+XG4gKiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENlbGxUZW1wbGF0ZSBsZXQtZGF0YUl0ZW0+XG4gKiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBbY2hlY2tlZF09XCJkYXRhSXRlbS5EaXNjb250aW51ZWRcIiBkaXNhYmxlZC8+XG4gKiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgPC9rZW5kby1ncmlkPlxuICogICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgcHVibGljIGdyaWREYXRhOiBhbnlbXTtcbiAqXG4gKiAgICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICAgICB0aGlzLmdyaWREYXRhID0gcHJvZHVjdHM7XG4gKiAgICB9XG4gKiB9XG4gKlxuICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICogICAgXCJQcm9kdWN0SURcIjogMSxcbiAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICogICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICogIH0sIHtcbiAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAqICAgIFwiVW5pdFByaWNlXCI6IDE5LjAwMDAsXG4gKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICogIH1cbiAqIF07XG4gKlxuICogYGBgXG4gKi9cbmxldCBDb2x1bW5Db21wb25lbnQgPSBDb2x1bW5Db21wb25lbnRfMSA9IGNsYXNzIENvbHVtbkNvbXBvbmVudCBleHRlbmRzIENvbHVtbkJhc2UkMSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBpZFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBpZFNlcnZpY2UpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHRoZSBjb2x1bW4gaGVhZGVycyB0byBiZSBjbGlja2VkIGFuZCB0aGUgYHNvcnRDaGFuZ2VgIGV2ZW50IGVtaXR0ZWQuXG4gICAgICAgICAqIFlvdSBoYXZlIHRvIGhhbmRsZSB0aGUgYHNvcnRDaGFuZ2VgIGV2ZW50IHlvdXJzZWxmIGFuZCBzb3J0IHRoZSBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3J0YWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBjb2x1bW4gY2FuIGJlIGRyYWdnZWQgdG8gdGhlIGdyb3VwIHBhbmVsLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICAgICAqIElmIHNldCB0byBgZmFsc2VgLCB5b3UgY2FuIGdyb3VwIHRoZSBjb2x1bW5zIGJ5IHRoZSBjb2x1bW4gZmllbGQgYnkgdXNpbmcgdGhlIEFQSSBvZiB0aGUgR3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXBhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGVkaXRvciB0eXBlIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ19yZWFjdGl2ZV9mb3Jtc19ncmlkICV9I3RvYy1zZXR1cCkpLlxuICAgICAgICAgKiBVc2VkIHdoZW4gdGhlIGNvbHVtbiBlbnRlcnMgdGhlIGVkaXQgbW9kZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRleHRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBodG1sLW5vLXJ1blxuICAgICAgICAgKiA8a2VuZG8tZ3JpZD5cbiAgICAgICAgICogICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiVW5pdFByaWNlXCIgZWRpdG9yPVwibnVtZXJpY1wiPlxuICAgICAgICAgKiAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICAgICAgICAgKiA8L2tlbmRvLWdyaWQ+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0b3IgPSAndGV4dCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBmaWx0ZXIgdHlwZSB0aGF0IGlzIGRpc3BsYXllZCBpbnNpZGUgdGhlIGZpbHRlciByb3cuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0ZXh0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgaHRtbC1uby1ydW5cbiAgICAgICAgICogPGtlbmRvLWdyaWQ+XG4gICAgICAgICAqICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiIGZpbHRlcj1cIm51bWVyaWNcIj5cbiAgICAgICAgICogICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAgICAgICAgICogPC9rZW5kby1ncmlkPlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyID0gJ3RleHQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBpZiBhIGZpbHRlciBVSSB3aWxsIGJlIGRpc3BsYXllZCBmb3IgdGhpcyBjb2x1bW4uIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgaHRtbC1uby1ydW5cbiAgICAgICAgICogPGtlbmRvLWdyaWQ+XG4gICAgICAgICAqICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiIFtmaWx0ZXJhYmxlXT1cImZhbHNlXCI+XG4gICAgICAgICAqICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gICAgICAgICAqIDwva2VuZG8tZ3JpZD5cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlcmFibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgZWRpdGFibGUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgaHRtbC1uby1ydW5cbiAgICAgICAgICogPGtlbmRvLWdyaWQ+XG4gICAgICAgICAqICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiIFtlZGl0YWJsZV09XCJmYWxzZVwiPlxuICAgICAgICAgKiAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICAgICAgICAgKiA8L2tlbmRvLWdyaWQ+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGdldCB0ZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGUgPyB0aGlzLnRlbXBsYXRlLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgZ3JvdXBIZWFkZXJUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBIZWFkZXJUZW1wbGF0ZSA/IHRoaXMuZ3JvdXBIZWFkZXJUZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUgPyB0aGlzLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBncm91cEZvb3RlclRlbXBsYXRlUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cEZvb3RlclRlbXBsYXRlID8gdGhpcy5ncm91cEZvb3RlclRlbXBsYXRlLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgZWRpdFRlbXBsYXRlUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0VGVtcGxhdGUgPyB0aGlzLmVkaXRUZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGZpbHRlckNlbGxUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ2VsbFRlbXBsYXRlID8gdGhpcy5maWx0ZXJDZWxsVGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBmaWx0ZXJNZW51VGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlck1lbnVUZW1wbGF0ZSA/IHRoaXMuZmlsdGVyTWVudVRlbXBsYXRlLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgZGlzcGxheVRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aXRsZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5maWVsZCA6IHRoaXMudGl0bGU7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcInNvcnRhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZWRpdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZWRpdGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBIZWFkZXJUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBGb290ZXJUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEVkaXRUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFZGl0VGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcImVkaXRUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlckNlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEZpbHRlck1lbnVUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGaWx0ZXJNZW51VGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlck1lbnVUZW1wbGF0ZVwiLCB2b2lkIDApO1xuQ29sdW1uQ29tcG9uZW50ID0gQ29sdW1uQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBDb2x1bW5CYXNlJDEsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sdW1uQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1jb2x1bW4nLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIFNraXBTZWxmKCkpLCBfX3BhcmFtKDAsIEhvc3QoKSksIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb2x1bW5CYXNlJDEsIElkU2VydmljZV0pXG5dLCBDb2x1bW5Db21wb25lbnQpO1xuXG52YXIgU3BhbkNvbHVtbkNvbXBvbmVudF8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGlzU3BhbkNvbHVtbkNvbXBvbmVudChjb2x1bW4pIHtcbiAgICByZXR1cm4gY29sdW1uLmlzU3BhbkNvbHVtbjtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbHVtbiB3aGljaCBjYW4gYmUgc3Bhbm5lZCBvdmVyIG11bHRpcGxlIGRhdGEgY2VsbHMgd2hpbGUgdGhlIGluZGl2aWR1YWxcbiAqIGhlYWRlciBhbmQgZm9vdGVyIGNlbGxzIGFyZSByZXRhaW5lZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNwYW5uZWRfY29sdW1uc19ncmlkICV9KSkuXG4gKiBFbmFibGVzIHlvdSB0byBhY2hpZXZlIG1vcmUgZmxleGlibGUgbGF5b3V0IHdoaWxlIGtlZXBpbmcgdGhlIGJ1aWx0LWluIFVJIGVsZW1lbnQgZm9yXG4gKiBbc29ydGluZ10oeyUgc2x1ZyBzb3J0aW5nX2dyaWQgJX0pLCBbZmlsdGVyaW5nXSh7JSBzbHVnIGZpbHRlcmluZ19ncmlkICV9KSwgYW5kXG4gKiBbZ3JvdXBpbmddKHslIHNsdWcgZ3JvdXBpbmdiYXNpY3NfZ3JpZCAlfSkuIFdyYXAgdGhlIGNvbHVtbnMgdGhhdCB3aWxsIGJlXG4gKiBtZXJnZWQgaW5zaWRlIHRoZSBgPGtlbmRvLWdyaWQtc3Bhbi1jb2x1bW4+YCB0YWcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1ncmlkXG4gKiAgICAgICAgICAgICAgW3NvcnRhYmxlXT1cInRydWVcIlxuICogICAgICAgICAgICAgIFtmaWx0ZXJhYmxlXT1cInRydWVcIlxuICogICAgICAgICAgICAgIFtrZW5kb0dyaWRCaW5kaW5nXT1cInByb2R1Y3RzXCI+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0SURcIiB0aXRsZT1cIlByb2R1Y3QgSURcIiB3aWR0aD1cIjEyMFwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLXNwYW4tY29sdW1uPlxuICogICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAqICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiIHRpdGxlPVwiVW5pdCBQcmljZVwiIGZpbHRlcj1cIm51bWVyaWNcIiB3aWR0aD1cIjE4MFwiIGZvcm1hdD1cInswOmN9XCI+XG4gKiAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1zcGFuLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkRpc2NvbnRpbnVlZFwiIHdpZHRoPVwiMTIwXCIgZmlsdGVyPVwiYm9vbGVhblwiPlxuICogICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDZWxsVGVtcGxhdGUgbGV0LWRhdGFJdGVtPlxuICogICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgW2NoZWNrZWRdPVwiZGF0YUl0ZW0uRGlzY29udGludWVkXCIgZGlzYWJsZWQvPlxuICogICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIHByb2R1Y3RzID0gW3tcbiAqICAgICAgXCJQcm9kdWN0SURcIjogMSxcbiAqICAgICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAqICAgICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAqICAgICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICogICAgfSwge1xuICogICAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAqICAgICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAqICAgICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAqICAgIH1cbiAqICAgXTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgZGF0YSBjZWxsIGRpc3BsYXlzIHRoZSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGZpZWxkcy4gVG8gZnVydGhlciBjdXN0b21pemVcbiAqIHRoZSBzcGFuLWNvbHVtbiBmdW5jdGlvbmFsaXR5LCB1c2UgYSBbY2VsbCB0ZW1wbGF0ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jZWxsdGVtcGxhdGVkaXJlY3RpdmUgJX0pLlxuICpcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tZ3JpZC1zcGFuLWNvbHVtbj5cbiAqICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJmaWVsZDFcIiB0aXRsZT1cIkZpZWxkIDFcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cImZpZWxkMlwiIHRpdGxlPVwiRmllbGQgMlwiPjwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkQ2VsbFRlbXBsYXRlIGxldC1kYXRhSXRlbT5cbiAqICAgICAgICA8aDU+e3sgZGF0YUl0ZW0uZmllbGQxIH19PC9oNT5cbiAqICAgICAgICA8cD57eyBkYXRhSXRlbS5maWVsZDIgfX08L3A+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tZ3JpZC1zcGFuLWNvbHVtbj5cbiAqIGBgYFxuICovXG5sZXQgU3BhbkNvbHVtbkNvbXBvbmVudCA9IFNwYW5Db2x1bW5Db21wb25lbnRfMSA9IGNsYXNzIFNwYW5Db2x1bW5Db21wb25lbnQgZXh0ZW5kcyBDb2x1bW5CYXNlJDEge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgaWRTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgaWRTZXJ2aWNlKTtcbiAgICAgICAgLypcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1NwYW5Db2x1bW4gPSB0cnVlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLmVkaXRUZW1wbGF0ZSA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRDb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmNsdWRlSW5DaG9vc2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmlzU3BhbkNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGFuQ29sdW1uIGNhbm5vdCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgU3BhbkNvbHVtbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGUgZWRpdCB0ZW1wbGF0ZSBvZiB0aGUgY29sdW1uIHdpbGwgYmUgcmVuZGVyZWQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiA+IFRvIGVuYWJsZSB0aGUgZWRpdGluZyBmdW5jdGlvbmFsaXR5IGZvciBhIHNwYW5uZWQgY29sdW1uLCBzZXQgYW4gZWRpdCB0ZW1wbGF0ZSBmb3IgaXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWwtbm8tcnVuXG4gICAgICogPGtlbmRvLWdyaWQ+XG4gICAgICogICAgPGtlbmRvLWdyaWQtc3Bhbi1jb2x1bW4gW2VkaXRhYmxlXT1cImZhbHNlXCI+XG4gICAgICogICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJVbml0UHJpY2VcIj5cbiAgICAgKiAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gICAgICogICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiPlxuICAgICAqICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAgICAgKiAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRFZGl0VGVtcGxhdGU+XG4gICAgICogICAgICAgICAuLi4uLlxuICAgICAqICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICA8L2tlbmRvLWdyaWQtc3Bhbi1jb2x1bW4+XG4gICAgICogPC9rZW5kby1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBlZGl0YWJsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9lZGl0YWJsZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZWRpdGFibGUoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5lZGl0VGVtcGxhdGVSZWYpICYmIHRoaXMuX2VkaXRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogYWRkZWQgZm9yIGJhY2t3YXJkcyBjb21waXRhYmlsaXR5XG4gICAgICovXG4gICAgc2V0IHdpZHRoKF92YWx1ZSkge1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ29sdW1ucy5yZWR1Y2UoKHRvdGFsLCBjb2x1bW4pID0+IHRvdGFsICsgY29sdW1uLndpZHRoLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBsZWFmSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ29sdW1ucy5maXJzdC5sZWFmSW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5maXJzdDtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlID8gdGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZWRpdFRlbXBsYXRlUmVmKCkge1xuICAgICAgICBjb25zdCBlZGl0VGVtcGxhdGUgPSB0aGlzLmVkaXRUZW1wbGF0ZS5maXJzdDtcbiAgICAgICAgcmV0dXJuIGVkaXRUZW1wbGF0ZSA/IGVkaXRUZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb2xzcGFuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZENvbHVtbnMuZmlsdGVyKGMgPT4gYy5pc1Zpc2libGUpLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgbG9ja2VkIChmcm96ZW4pIHN0YXRlIG9mIHRoZSBjb2x1bW5zLiBMb2NrZWQgY29sdW1ucyBhcmUgdmlzaWJsZVxuICAgICAqIGF0IGFsbCB0aW1lcyBkdXJpbmcgdGhlIGhvcml6b250YWwgc2Nyb2xsaW5nIG9mIHRoZSBHcmlkLlxuICAgICAqXG4gICAgICogRm9yIHRoZSBvcHRpb24gdG8gd29yayBwcm9wZXJseSwgbWFrZSBzdXJlIHRoYXQ6XG4gICAgICogLSBTY3JvbGxpbmcgaXMgZW5hYmxlZC5cbiAgICAgKiAtIFRoZSBgaGVpZ2h0YCBvcHRpb24gb2YgdGhlIEdyaWQgaXMgc2V0LlxuICAgICAqIC0gVGhlIHdpZHRocyBvZiBhbGwgR3JpZCBjb2x1bW5zIGFyZSBleHBsaWNpdGx5IHNldCBpbiBwaXhlbHMuIEluIHRoaXMgd2F5LFxuICAgICAqIHRoZSBHcmlkIGFkanVzdHMgdGhlIGxheW91dCBvZiB0aGUgbG9ja2VkIGFuZCB1bmxvY2tlZCBjb2x1bW5zLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqICAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgICAgIDxrZW5kby1ncmlkIFtkYXRhXT1cImdyaWREYXRhXCIgW3Njcm9sbGFibGVdPVwic2Nyb2xsYWJsZVwiIHN0eWxlPVwiaGVpZ2h0OiAyMDBweFwiPlxuICAgICAqICAgICAgICAgIDxrZW5kby1ncmlkLXNwYW4tY29sdW1uIFtsb2NrZWRdPVwidHJ1ZVwiPlxuICAgICAqICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3RJRFwiIHRpdGxlPVwiUHJvZHVjdCBJRFwiIHdpZHRoPVwiMTIwXCI+XG4gICAgICogICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAgICAgKiAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCIgd2lkdGg9XCIyMDBcIj5cbiAgICAgKiAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICAgICAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1zcGFuLWNvbHVtbj5cbiAgICAgKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJVbml0UHJpY2VcIiB0aXRsZT1cIlVuaXQgUHJpY2VcIiB3aWR0aD1cIjIzMFwiPlxuICAgICAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gICAgICogICAgICAgIDwva2VuZG8tZ3JpZD5cbiAgICAgKiAgICBgXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICAgcHVibGljIGdyaWREYXRhOiBhbnlbXTtcbiAgICAgKlxuICAgICAqICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAqICAgICAgICB0aGlzLmdyaWREYXRhID0gcHJvZHVjdHM7XG4gICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IHByb2R1Y3RzID0gW3tcbiAgICAgKiAgICBcIlByb2R1Y3RJRFwiOiAxLFxuICAgICAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gICAgICogIH0sIHtcbiAgICAgKiAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICAgICAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICAgICAqICAgIFwiVW5pdFByaWNlXCI6IDE5LjAwMDAsXG4gICAgICogICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAgICAgKiAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgbG9ja2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xvY2tlZCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9ja2VkIHx8IHRoaXMuY2hpbGRDb2x1bW5zLnNvbWUoYyA9PiBjLmxvY2tlZCk7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbkFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZENvbHVtbnMudG9BcnJheSgpO1xuICAgIH1cbiAgICBnZXQgaGFzQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ29sdW1ucy5sZW5ndGggPiAwO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgU3BhbkNvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihFZGl0VGVtcGxhdGVEaXJlY3RpdmUsIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBTcGFuQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlZGl0VGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihDb2x1bW5Db21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBTcGFuQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGlsZENvbHVtbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBTcGFuQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlZGl0YWJsZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBTcGFuQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsb2NrZWRcIiwgbnVsbCk7XG5TcGFuQ29sdW1uQ29tcG9uZW50ID0gU3BhbkNvbHVtbkNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogQ29sdW1uQmFzZSQxLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNwYW5Db2x1bW5Db21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLXNwYW4tY29sdW1uJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBTa2lwU2VsZigpKSwgX19wYXJhbSgwLCBIb3N0KCkpLCBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29sdW1uQmFzZSQxLCBJZFNlcnZpY2VdKVxuXSwgU3BhbkNvbHVtbkNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBleHBhbmRDb2x1bW5zID0gKGNvbHVtbnMpID0+IChjb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2x1bW4pID0+IGFjYy5jb25jYXQoaXNTcGFuQ29sdW1uQ29tcG9uZW50KGNvbHVtbikgPyBjb2x1bW4uY2hpbGRyZW5BcnJheSA6IFtjb2x1bW5dKSwgW10pIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZXhwYW5kQ29sdW1uc1dpdGhTcGFuID0gKGNvbHVtbnMpID0+IChjb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2x1bW4pID0+IGFjYy5jb25jYXQoaXNTcGFuQ29sdW1uQ29tcG9uZW50KGNvbHVtbikgP1xuICAgIFtjb2x1bW5dLmNvbmNhdChjb2x1bW4uY2hpbGRyZW5BcnJheSkgOlxuICAgIFtjb2x1bW5dKSwgW10pIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY29sdW1uc1RvUmVuZGVyID0gKGNvbHVtbnMpID0+IChleHBhbmRDb2x1bW5zKGNvbHVtbnMpLmZpbHRlcih4ID0+IHguaXNWaXNpYmxlKSk7XG5jb25zdCBzdW1Qcm9wID0gKHByb3ApID0+IChhcnJheSkgPT4gKGFycmF5IHx8IFtdKS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHByZXYgKyAoY3Vycltwcm9wXSB8fCAwKSwgMCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc3VtQ29sdW1uV2lkdGhzID0gc3VtUHJvcCgnd2lkdGgnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjb2x1bW5zU3BhbiA9IHN1bVByb3AoJ2NvbHNwYW4nKTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbmNvbnN0IHZhbGlkRmllbGQgPSBuZXcgUmVnRXhwKGBeWyRBLVpcXF9hLXpdWyRBLVpcXF9hLXowLTlcXFxcLl0qJGApO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzVmFsaWRGaWVsZE5hbWUgPSAoZmllbGROYW1lKSA9PiAhaXNOdWxsT3JFbXB0eVN0cmluZyhmaWVsZE5hbWUpICYmIHZhbGlkRmllbGQudGVzdChmaWVsZE5hbWUpICYmXG4gICAgZmllbGROYW1lWzBdICE9PSBcIi5cIiAmJiBmaWVsZE5hbWVbZmllbGROYW1lLmxlbmd0aCAtIDFdICE9PSBcIi5cIjtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjaGlsZHJlbiA9IGNvbHVtbiA9PiBjb2x1bW4uY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkICE9PSBjb2x1bW4pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxlYWZDb2x1bW5zID0gY29sdW1ucyA9PiB7XG4gICAgcmV0dXJuIGNvbHVtbnMucmVkdWNlKChhY2MsIGNvbHVtbikgPT4ge1xuICAgICAgICBpZiAoY29sdW1uLmlzQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIGFjYyA9IGFjYy5jb25jYXQobGVhZkNvbHVtbnMoY2hpbGRyZW4oY29sdW1uKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbHVtbi5pc1NwYW5Db2x1bW4pIHtcbiAgICAgICAgICAgIGFjYyA9IGFjYy5jb25jYXQoY29sdW1uLmNoaWxkcmVuQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWNjLnB1c2goY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKS5maWx0ZXIoeCA9PiB4LmlzVmlzaWJsZSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc29tZUxlYWZDb2x1bW4gPSAoY2FsbGJhY2ssIC4uLmNvbHVtbnMpID0+IGxlYWZDb2x1bW5zKGNvbHVtbnMpLnNvbWUoY2FsbGJhY2spO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJlc2l6YWJsZUNvbHVtbnMgPSBjb2x1bW5zID0+IGNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiBpc1RydXRoeShjb2x1bW4ucmVzaXphYmxlKSAmJiBjb2x1bW4uaXNWaXNpYmxlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzb3J0Q29sdW1ucyA9IChjb2x1bW5zKSA9PiBvcmRlckJ5KGNvbHVtbnMsIFt7IGZpZWxkOiAnb3JkZXJJbmRleCcsIGRpcjogJ2FzYycgfV0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzSW5TcGFuQ29sdW1uID0gKGNvbHVtbikgPT4gaXNUcnV0aHkoY29sdW1uLnBhcmVudCkgJiYgaXNTcGFuQ29sdW1uQ29tcG9uZW50KGNvbHVtbi5wYXJlbnQpO1xuXG52YXIgQ29sdW1uR3JvdXBDb21wb25lbnRfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBpc0NvbHVtbkdyb3VwQ29tcG9uZW50KGNvbHVtbikge1xuICAgIHJldHVybiBjb2x1bW4uaXNDb2x1bW5Hcm91cDtcbn1cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29sdW1uIGdyb3VwIGhlYWRlciBvZiB0aGUgR3JpZFxuICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlc10oeyUgc2x1ZyBtdWx0aWNvbHVtbmhlYWRlcnNfY29sdW1uc19ncmlkICV9KSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgIDxrZW5kby1ncmlkIFtkYXRhXT1cImdyaWREYXRhXCI+XG4gKiAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4tZ3JvdXAgdGl0bGU9XCJQcm9kdWN0IEluZm9cIj5cbiAqICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZEhlYWRlclRlbXBsYXRlIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCIgbGV0LWNvbHVtbj1cImNvbHVtblwiPlxuICogICAgICAgICAgICAgICBDb2x1bW4gaW5kZXg6IHt7Y29sdW1uSW5kZXh9fSAvIGNvbHVtbiB0aXRsZToge3tjb2x1bW4udGl0bGV9fVxuICogICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0SURcIiB0aXRsZT1cIlByb2R1Y3QgSURcIiB3aWR0aD1cIjEyMFwiPlxuICogICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCI+XG4gKiAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uLWdyb3VwPlxuICogICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiVW5pdFByaWNlXCIgdGl0bGU9XCJVbml0IFByaWNlXCIgd2lkdGg9XCIyMzBcIj5cbiAqICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJEaXNjb250aW51ZWRcIiB3aWR0aD1cIjEyMFwiPlxuICogICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDZWxsVGVtcGxhdGUgbGV0LWRhdGFJdGVtPlxuICogICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgW2NoZWNrZWRdPVwiZGF0YUl0ZW0uRGlzY29udGludWVkXCIgZGlzYWJsZWQvPlxuICogICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgIHB1YmxpYyBncmlkRGF0YTogYW55W107XG4gKlxuICogICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgICAgdGhpcy5ncmlkRGF0YSA9IHByb2R1Y3RzO1xuICogICAgfVxuICogfVxuICpcbiAqIGNvbnN0IHByb2R1Y3RzID0gW3tcbiAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICogICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAqICB9LCB7XG4gKiAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gKiAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAqICB9XG4gKiBdO1xuICpcbiAqIGBgYFxuICovXG5sZXQgQ29sdW1uR3JvdXBDb21wb25lbnQgPSBDb2x1bW5Hcm91cENvbXBvbmVudF8xID0gY2xhc3MgQ29sdW1uR3JvdXBDb21wb25lbnQgZXh0ZW5kcyBDb2x1bW5CYXNlJDEge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgaWRTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgaWRTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluY2x1ZGVJbkNob29zZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNDb2x1bW5Hcm91cCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pblJlc2l6YWJsZVdpZHRoID0gMTA7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmlzU3BhbkNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2x1bW5Hcm91cENvbXBvbmVudCBjYW5ub3QgYmUgbmVzdGVkIGluc2lkZSBTcGFuQ29sdW1uQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJvd3NwYW4oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbHNwYW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbnNTcGFuKHRoaXMuY2hpbGRyZW5cbiAgICAgICAgICAgIC5maWx0ZXIoY2hpbGQgPT4gY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQuaXNWaXNpYmxlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgbGVhZkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbiA/ICh0aGlzLmZpcnN0Q2hpbGQgfHwge30pLmxlYWZJbmRleCA6IC0xO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW5BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZmlsdGVyKGMgPT4gYyAhPT0gdGhpcyk7XG4gICAgfVxuICAgIGdldCBoYXNDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmZpbmQoY29sdW1uID0+IGNvbHVtbiAhPT0gdGhpcyk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihDb2x1bW5CYXNlJDEpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBDb2x1bW5Hcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcbkNvbHVtbkdyb3VwQ29tcG9uZW50ID0gQ29sdW1uR3JvdXBDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbHVtbkJhc2UkMSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb2x1bW5Hcm91cENvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWdyaWQtY29sdW1uLWdyb3VwJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBTa2lwU2VsZigpKSwgX19wYXJhbSgwLCBIb3N0KCkpLCBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29sdW1uQmFzZSQxLCBJZFNlcnZpY2VdKVxuXSwgQ29sdW1uR3JvdXBDb21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRldGFpbCB0ZW1wbGF0ZSBvZiB0aGUgR3JpZCAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzXSh7JSBzbHVnIGRldGFpbHJvd3RlbXBsYXRlX2dyaWQgJX0pKS5cbiAqIFRvIGRlZmluZSB0aGUgZGV0YWlsIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvR3JpZERldGFpbFRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIGEgYDxrZW5kby1ncmlkPmAgdGFnLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tZ3JpZFxuICogICAgICAgICBbZGF0YV09XCJkYXRhXCJcbiAqICAgICAgICAgc2VsZWN0YWJsZT1cInRydWVcIlxuICogICAgICAgICBzdHlsZT1cImhlaWdodDogMTYwcHhcIlxuICogICAgICAgICA+XG4gKiAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3RJRFwiPjwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiVW5pdFByaWNlXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZERldGFpbFRlbXBsYXRlIGxldC1kYXRhSXRlbT5cbiAqICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiZGF0YUl0ZW0uQ2F0ZWdvcnlcIj5cbiAqICAgICAgICAgICAgIDxoZWFkZXI+e3tkYXRhSXRlbS5DYXRlZ29yeT8uQ2F0ZWdvcnlOYW1lfX08L2hlYWRlcj5cbiAqICAgICAgICAgICAgIDxzcGFuPnt7ZGF0YUl0ZW0uQ2F0ZWdvcnk/LkRlc2NyaXB0aW9ufX08L3NwYW4+XG4gKiAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgZGF0YSA9IFt7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gKiAgICAgICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gKiAgICAgICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlLFxuICogICAgICAgICBcIkNhdGVnb3J5XCI6IHtcbiAqICAgICAgICAgICAgIFwiQ2F0ZWdvcnlJRFwiOiAxLFxuICogICAgICAgICAgICAgXCJDYXRlZ29yeU5hbWVcIjogXCJCZXZlcmFnZXNcIixcbiAqICAgICAgICAgICAgIFwiRGVzY3JpcHRpb25cIjogXCJTb2Z0IGRyaW5rcywgY29mZmVlcywgdGVhcywgYmVlcnMsIGFuZCBhbGVzXCJcbiAqICAgICAgICAgfVxuICogICAgICAgfSwge1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAqICAgICAgICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAqICAgICAgICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2UsXG4gKiAgICAgICAgIFwiQ2F0ZWdvcnlcIjoge1xuICogICAgICAgICAgICAgXCJDYXRlZ29yeUlEXCI6IDEsXG4gKiAgICAgICAgICAgICBcIkNhdGVnb3J5TmFtZVwiOiBcIkJldmVyYWdlc1wiLFxuICogICAgICAgICAgICAgXCJEZXNjcmlwdGlvblwiOiBcIlNvZnQgZHJpbmtzLCBjb2ZmZWVzLCB0ZWFzLCBiZWVycywgYW5kIGFsZXNcIlxuICogICAgICAgICB9XG4gKiAgICAgICB9LCB7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDMsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJBbmlzZWVkIFN5cnVwXCIsXG4gKiAgICAgICAgIFwiVW5pdFByaWNlXCI6IDEwLjAwMDAsXG4gKiAgICAgICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlLFxuICogICAgICAgICBcIkNhdGVnb3J5XCI6IHtcbiAqICAgICAgICAgICAgIFwiQ2F0ZWdvcnlJRFwiOiAyLFxuICogICAgICAgICAgICAgXCJDYXRlZ29yeU5hbWVcIjogXCJDb25kaW1lbnRzXCIsXG4gKiAgICAgICAgICAgICBcIkRlc2NyaXB0aW9uXCI6IFwiU3dlZXQgYW5kIHNhdm9yeSBzYXVjZXMsIHJlbGlzaGVzLCBzcHJlYWRzLCBhbmQgc2Vhc29uaW5nc1wiXG4gKiAgICAgICAgIH1cbiAqICAgICB9XTtcbiAqXG4gKiB9XG4gKlxuICogYGBgXG4gKlxuICovXG5sZXQgRGV0YWlsVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBEZXRhaWxUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgICAgICB0aGlzLl9jb25kaXRpb24gPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBmdW5jdGlvbiB0aGF0IGluZGljYXRlcyBpZiBhIGdpdmVuIGRldGFpbCByb3cgYW5kIHRoZSBhc3NvY2lhdGVkICoqRXhwYW5kKiogb3IgKipDb2xsYXBzZSoqIGJ1dHRvbiB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgICBzZXQgc2hvd0lmKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2hvd0lmIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoZm4pfS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25kaXRpb24gPSBmbjtcbiAgICB9XG4gICAgZ2V0IHNob3dJZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmRpdGlvbjtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoXCJrZW5kb0dyaWREZXRhaWxUZW1wbGF0ZVNob3dJZlwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRnVuY3Rpb25dKVxuXSwgRGV0YWlsVGVtcGxhdGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInNob3dJZlwiLCBudWxsKTtcbkRldGFpbFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkRGV0YWlsVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBEZXRhaWxUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbmNvbnN0IGNhbkNyZWF0ZUVsZW1lbnQgPSAoKSA9PiBpc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudDtcbmxldCBjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IG51bGw7XG5sZXQgY2FjaGVkUGl4ZWxSYXRpbztcbmxldCBjYWNoZWRSdGxTY3JvbGxMZWZ0ID0gbnVsbDtcbmZ1bmN0aW9uIHNjcm9sbGJhcldpZHRoKCkge1xuICAgIGlmIChjYWNoZWRTY3JvbGxiYXJXaWR0aCA9PT0gbnVsbCAmJiBjYW5DcmVhdGVFbGVtZW50KCkpIHtcbiAgICAgICAgY2FjaGVkUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gXCJvdmVyZmxvdzpzY3JvbGw7b3ZlcmZsb3cteDpoaWRkZW47em9vbToxO2NsZWFyOmJvdGg7ZGlzcGxheTpibG9ja1wiO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCImbmJzcDtcIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IGRpdi5vZmZzZXRXaWR0aCAtIGRpdi5zY3JvbGxXaWR0aDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkU2Nyb2xsYmFyV2lkdGg7XG59XG5mdW5jdGlvbiBydGxTY3JvbGxMZWZ0KCkge1xuICAgIGlmIChjYWNoZWRSdGxTY3JvbGxMZWZ0ID09PSBudWxsICYmIGNhbkNyZWF0ZUVsZW1lbnQoKSkge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IFwib3ZlcmZsb3c6c2Nyb2xsO3pvb206MTtjbGVhcjpib3RoO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwcHg7dmlzaWJpbGl0eTpoaWRkZW47cG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTAwMDBweDtkaXJlY3Rpb246cnRsO1wiO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IHN0eWxlPSd3aWR0aDoyMDBweDtoZWlnaHQ6MXB4Oyc8L2Rpdj5cIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBjb25zdCBpbml0aWFsID0gZGl2LnNjcm9sbExlZnQ7XG4gICAgICAgIGRpdi5zY3JvbGxMZWZ0ID0gLTE7XG4gICAgICAgIGNhY2hlZFJ0bFNjcm9sbExlZnQgPSBkaXYuc2Nyb2xsTGVmdCA8IDAgPyBkaXYuc2Nyb2xsTGVmdCA6IGluaXRpYWw7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFJ0bFNjcm9sbExlZnQ7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqIG1vdmUgdG8ga2VuZG8tY29tbW9uXG4gKi9cbmxldCBCcm93c2VyU3VwcG9ydFNlcnZpY2UgPSBjbGFzcyBCcm93c2VyU3VwcG9ydFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHpvbmUsIGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLnBpcGUoYXVkaXRUaW1lKDEwMCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFBpeGVsUmF0aW8gIT09IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGgoKTtcbiAgICB9XG4gICAgZ2V0IHJ0bFNjcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiBydGxTY3JvbGxMZWZ0KCk7XG4gICAgfVxufTtcbkJyb3dzZXJTdXBwb3J0U2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZSwgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgQnJvd3NlclN1cHBvcnRTZXJ2aWNlKTtcblxuLyogdHNsaW50OmRpc2FibGU6dXNlLWxpZmUtY3ljbGUtaW50ZXJmYWNlICovXG5jb25zdCBpc0dyb3VwSXRlbSA9IChzb3VyY2UpID0+IHtcbiAgICByZXR1cm4gc291cmNlLml0ZW1zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgc291cmNlLmZpZWxkICE9PSB1bmRlZmluZWQ7XG59O1xuY29uc3QgaXNWaXJ0dWFsR3JvdXBJdGVtID0gKHNvdXJjZSkgPT4ge1xuICAgIHJldHVybiBzb3VyY2Uub2Zmc2V0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgc291cmNlLnNraXBIZWFkZXIgIT09IHVuZGVmaW5lZDtcbn07XG5jb25zdCBmbGF0dGVuR3JvdXBzID0gKGdyb3VwcykgPT4gKGdyb3Vwcy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgIGlmIChpc0dyb3VwSXRlbShjdXJyKSkge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChmbGF0dGVuR3JvdXBzKGN1cnIuaXRlbXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoW2N1cnJdKTtcbn0sIFtdKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmFsaWduXG4pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGl0ZW1BdCA9IChkYXRhLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gZGF0YVswXTtcbiAgICBpZiAoaXNQcmVzZW50KGZpcnN0KSAmJiBpc0dyb3VwSXRlbShmaXJzdCkpIHtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5Hcm91cHMoZGF0YSlbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVtpbmRleF07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldEl0ZXJhdG9yJDEgPSAoZGF0YSwgeyBmb290ZXJzLCBsZXZlbCwgZGF0YUluZGV4LCBwYXJlbnRHcm91cEluZGV4LCBncm91cEluZGV4LCBwYXJlbnRHcm91cCB9KSA9PiB7XG4gICAgY29uc3QgZmlyc3QgPSBkYXRhWzBdO1xuICAgIGlmIChpc1ByZXNlbnQoZmlyc3QpICYmIGlzR3JvdXBJdGVtKGZpcnN0KSkge1xuICAgICAgICBpZiAoaXNWaXJ0dWFsR3JvdXBJdGVtKGZpcnN0KSkge1xuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IGlzUHJlc2VudChmaXJzdC5vZmZzZXQpID8gZmlyc3Qub2Zmc2V0IDogZ3JvdXBJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvL3RzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11c2UtYmVmb3JlLWRlY2xhcmVcbiAgICAgICAgcmV0dXJuIG5ldyBHcm91cEl0ZXJhdG9yKGRhdGEsIGZvb3RlcnMsIGxldmVsLCBkYXRhSW5kZXgsIHBhcmVudEdyb3VwSW5kZXgsIGdyb3VwSW5kZXgsIHBhcmVudEdyb3VwKTtcbiAgICB9XG4gICAgLy90c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlXG4gICAgcmV0dXJuIG5ldyBJdGVtSXRlcmF0b3IoZGF0YSwgZGF0YUluZGV4LCBwYXJlbnRHcm91cEluZGV4LCBwYXJlbnRHcm91cCk7XG59O1xuY2xhc3MgQXJyYXlJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoYXJyLCBpZHggPSAwKSB7XG4gICAgICAgIHRoaXMuYXJyID0gYXJyO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5hcnIgPSBhcnIgfHwgW107XG4gICAgfVxuICAgIFtpdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmFyci5sZW5ndGggPyB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmFyclt0aGlzLmlkeCsrXVxuICAgICAgICB9IDogeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihhcnIsIGRhdGFJbmRleCA9IDAsIHJlc3VsdE1hcCA9ICh4KSA9PiB4KSB7XG4gICAgICAgIHRoaXMuZGF0YUluZGV4ID0gZGF0YUluZGV4O1xuICAgICAgICB0aGlzLnJlc3VsdE1hcCA9IHJlc3VsdE1hcDtcbiAgICAgICAgY29uc3QgaXRlciA9IGFycltpdGVyYXRvcl07XG4gICAgICAgIHRoaXMuX2lubmVySXRlcmF0b3IgPSBpdGVyID8gYXJyW2l0ZXJhdG9yXSgpIDogbmV3IEFycmF5SXRlcmF0b3IoYXJyKTtcbiAgICB9XG4gICAgW2l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdE1hcCh0aGlzLl9pbm5lckl0ZXJhdG9yLm5leHQoKSwgdGhpcy5kYXRhSW5kZXgrKyk7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEl0ZW1JdGVyYXRvciBleHRlbmRzIEl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihhcnIsIGRhdGFJbmRleCwgZ3JvdXBJbmRleCwgZ3JvdXApIHtcbiAgICAgICAgc3VwZXIoYXJyLCBkYXRhSW5kZXgsICh4LCBpZHgpID0+ICh7XG4gICAgICAgICAgICBkb25lOiB4LmRvbmUsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGRhdGE6IHgudmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogZ3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICBpbmRleDogaWR4LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgICBncm91cFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgbmV4dCByZWNvcmQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFJbmRleDtcbiAgICB9XG59XG5jb25zdCBwcmVmaXggPSAocywgbikgPT4ge1xuICAgIGNvbnN0IHAgPSBzID8gcyArIFwiX1wiIDogcztcbiAgICByZXR1cm4gYCR7cH0ke259YDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgR3JvdXBJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoYXJyLCBvdXRwdXRGb290ZXJzID0gZmFsc2UsIGxldmVsID0gMCwgZGF0YUluZGV4ID0gMCwgcGFyZW50SW5kZXggPSBcIlwiLCBncm91cEluZGV4ID0gMCwgcGFyZW50R3JvdXAgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5hcnIgPSBhcnI7XG4gICAgICAgIHRoaXMub3V0cHV0Rm9vdGVycyA9IG91dHB1dEZvb3RlcnM7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5kYXRhSW5kZXggPSBkYXRhSW5kZXg7XG4gICAgICAgIHRoaXMucGFyZW50SW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgdGhpcy5ncm91cEluZGV4ID0gZ3JvdXBJbmRleDtcbiAgICAgICAgdGhpcy5wYXJlbnRHcm91cCA9IHBhcmVudEdyb3VwO1xuICAgICAgICB0aGlzLmN1cnJlbnRHcm91cEluZGV4ID0gXCJcIjtcbiAgICAgICAgdGhpcy5hcnIgPSBhcnIgfHwgW107XG4gICAgICAgIHRoaXMuX2l0ZXJhdG9yID0gbmV3IEl0ZXJhdG9yKHRoaXMuYXJyLCB0aGlzLmRhdGFJbmRleCk7XG4gICAgfVxuICAgIFtpdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0R3JvdXBJdGVtKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLl9pdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgIHRoaXMuX2lubmVySXRlcmF0b3IgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRHcm91cEluZGV4ID0gcHJlZml4KHRoaXMucGFyZW50SW5kZXgsIHRoaXMuZ3JvdXBJbmRleCsrKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5jdXJyZW50R3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IHRoaXMubGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEdyb3VwOiB0aGlzLnBhcmVudEdyb3VwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9vdGVySXRlbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogdGhpcy5jdXJyZW50R3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IHRoaXMubGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgICAgICBncm91cDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5jdXJyZW50R3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiB0aGlzLmxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEdyb3VwOiB0aGlzLnBhcmVudEdyb3VwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbm5lckl0ZXJhdG9yKGdyb3VwKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5uZXJJdGVyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5faW5uZXJJdGVyYXRvciA9IGdldEl0ZXJhdG9yJDEoZ3JvdXAuaXRlbXMsIHtcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IHRoaXMuZGF0YUluZGV4LFxuICAgICAgICAgICAgICAgIGZvb3RlcnM6IHRoaXMub3V0cHV0Rm9vdGVycyxcbiAgICAgICAgICAgICAgICBsZXZlbDogdGhpcy5sZXZlbCArIDEsXG4gICAgICAgICAgICAgICAgcGFyZW50R3JvdXBJbmRleDogdGhpcy5jdXJyZW50R3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICBwYXJlbnRHcm91cDoge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmN1cnJlbnRHcm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBsZXZlbDogdGhpcy5sZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50R3JvdXA6IHRoaXMucGFyZW50R3JvdXBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJJdGVyYXRvcjtcbiAgICB9XG4gICAgbmV4dERhdGFJdGVtKGdyb3VwKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yJCQxID0gdGhpcy5pbm5lckl0ZXJhdG9yKGdyb3VwKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IkJDEubmV4dCgpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHJlc3VsdC52YWx1ZSkgJiYgIXJlc3VsdC5kb25lICYmIHJlc3VsdC52YWx1ZS50eXBlID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5kYXRhSW5kZXggPSByZXN1bHQudmFsdWUuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcmVzdWx0LmRvbmUgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuY3VycmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRHcm91cEl0ZW0oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5uZXh0RGF0YUl0ZW0odGhpcy5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtIDogKHRoaXMub3V0cHV0Rm9vdGVycyA/IHRoaXMuZm9vdGVySXRlbSgpIDogdGhpcy5uZXh0R3JvdXBJdGVtKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGxhc3QgaXRlcmF0ZWQgZGF0YSByZWNvcmQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFJbmRleCArIDE7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRGF0YVJlc3VsdEl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNraXAgPSAwLCBncm91cEZvb3RlcnMgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5ncm91cEZvb3RlcnMgPSBncm91cEZvb3RlcnM7XG4gICAgICAgIHRoaXMuc291cmNlID0gdGhpcy5zb3VyY2UgPyB0aGlzLnNvdXJjZSA6IFtdO1xuICAgICAgICB0aGlzLmlzT2JqZWN0ID0gdGhpcy5pc0dyaWREYXRhUmVzdWx0KHRoaXMuc291cmNlKTtcbiAgICB9XG4gICAgaXNHcmlkRGF0YVJlc3VsdChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS50b3RhbCAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZS5kYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCB0b3RhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3QgPyB0aGlzLnNvdXJjZS50b3RhbCA6IHRoaXMuc291cmNlLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT2JqZWN0ID8gdGhpcy5zb3VyY2UuZGF0YSA6IHRoaXMuc291cmNlO1xuICAgIH1cbiAgICBtYXAoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZm4pO1xuICAgIH1cbiAgICBmaWx0ZXIoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maWx0ZXIoZm4pO1xuICAgIH1cbiAgICByZWR1Y2UoZm4sIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5yZWR1Y2UoZm4sIGluaXQpO1xuICAgIH1cbiAgICBmb3JFYWNoKGZuKSB7XG4gICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGZuKTtcbiAgICB9XG4gICAgc29tZShmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNvbWUoZm4pO1xuICAgIH1cbiAgICBbaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gZ2V0SXRlcmF0b3IkMSh0aGlzLmRhdGEsIHtcbiAgICAgICAgICAgIGRhdGFJbmRleDogdGhpcy5za2lwLFxuICAgICAgICAgICAgZm9vdGVyczogdGhpcy5ncm91cEZvb3RlcnMsXG4gICAgICAgICAgICBncm91cEluZGV4OiB0aGlzLnNraXBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5kYXRhLnRvU3RyaW5nKCk7IH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEYXRhQ29sbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYWNjZXNzb3IpIHtcbiAgICAgICAgdGhpcy5hY2Nlc3NvciA9IGFjY2Vzc29yO1xuICAgIH1cbiAgICBnZXQgdG90YWwoKSB7IHJldHVybiB0aGlzLmFjY2Vzc29yKCkudG90YWw7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5hY2Nlc3NvcigpLmRhdGEubGVuZ3RoOyB9XG4gICAgZ2V0IGZpcnN0KCkgeyByZXR1cm4gdGhpcy5hY2Nlc3NvcigpLmRhdGFbMF07IH1cbiAgICBnZXQgbGFzdCgpIHsgcmV0dXJuIHRoaXMuYWNjZXNzb3IoKS5kYXRhW3RoaXMubGVuZ3RoIC0gMV07IH1cbiAgICBhdChpbmRleCkge1xuICAgICAgICByZXR1cm4gaXRlbUF0KHRoaXMuYWNjZXNzb3IoKS5kYXRhLCBpbmRleCk7XG4gICAgfVxuICAgIG1hcChmbikgeyByZXR1cm4gdGhpcy5hY2Nlc3NvcigpLm1hcChmbik7IH1cbiAgICBmaWx0ZXIoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXNzb3IoKS5maWx0ZXIoZm4pO1xuICAgIH1cbiAgICByZWR1Y2UoZm4sIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXNzb3IoKS5yZWR1Y2UoZm4sIGluaXQpO1xuICAgIH1cbiAgICBmb3JFYWNoKGZuKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzb3IoKS5mb3JFYWNoKGZuKTtcbiAgICB9XG4gICAgc29tZShmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NvcigpLnNvbWUoZm4pO1xuICAgIH1cbiAgICBbaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NvcigpW2l0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuYWNjZXNzb3IoKS50b1N0cmluZygpOyB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFF1aWNrIGxvb2stdXAgc3RydWN0dXJlIGZvciBjb21iaW5hdGlvbnMgb2Yga2V5cy5cbiAqIFNpbWlsYXIgdG8gdGhlIG5hdGl2ZSBKUyBTZXQsIGhvd2V2ZXIsIHdvcmtpbmcgd2l0aCBhIGNvdXBsZSBvZiBrZXlzIGluc3RlYWQgb2Ygd2l0aCBhIHNpbmdsZSBrZXkuXG4gKiBTdXBwb3J0cyBib3RoIHByaW1pdGl2ZSBrZXlzIGFuZCBvYmplY3Qga2V5cyAoY29tcGFyZWQgYnkgcmVmZXJlbmNlKS5cbiAqL1xuY2xhc3MgUGFpclNldCB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMsIGtleVhGaWVsZCwga2V5WUZpZWxkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyBhIHNldCBvZiBZIGtleXMgZm9yIGVhY2ggZGVmaW5lZCBYIGtleS5cbiAgICAgICAgICogRWFjaCBYIGtleSBjcmVhdGVzIGEgbWFwIHdoaWNoIGhvbGRzIGEgc2V0IG9mIFkga2V5cy5cbiAgICAgICAgICpcbiAgICAgICAgICogTWFwIHsgMSA9PiBTZXQgeyAxLCAyLCAzIH0gfSAvLyBwYWlyczogWzEsIDFdLCBbMSwgMl0sIFsxLCAzXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZXlzWCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50IHRoZSBlYWNoIGFkZGVkIG9yIGRlbGV0ZWQga2V5IG1hbnVhbGx5IHRvIGF2b2lkIGl0ZXJhdGluZyBvdmVyIGFsbCBpdGVtcyB3aGVuIGNhbGxpbmcgYHRoaXMuc2l6ZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvdGFsS2V5c0NvdW50ID0gMDtcbiAgICAgICAgaWYgKGl0ZW1zICYmIGtleVhGaWVsZCAmJiBrZXlZRmllbGQpIHtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB0aGlzLmFkZChpdGVtW2tleVhGaWVsZF0sIGl0ZW1ba2V5WUZpZWxkXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBYL1kga2V5IHBhaXJzLlxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbEtleXNDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvdXBsZSBvZiBpdGVtcyBpZGVudGlmaWVkIGFzIGEgY29tYmluYXRpb24uXG4gICAgICovXG4gICAgYWRkKGtleVgsIGtleVkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleXNYLmhhcyhrZXlYKSkge1xuICAgICAgICAgICAgdGhpcy5rZXlzWC5zZXQoa2V5WCwgbmV3IFNldCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFzKGtleVgsIGtleVkpKSB7XG4gICAgICAgICAgICB0aGlzLmtleXNYLmdldChrZXlYKS5hZGQoa2V5WSk7XG4gICAgICAgICAgICB0aGlzLnRvdGFsS2V5c0NvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbWJpbmF0aW9uIG9mIGEgY291cGxlIG9mIGl0ZW1zIGlkZW50aWZpZWQgdG9nZXRoZXIuXG4gICAgICovXG4gICAgZGVsZXRlKGtleVgsIGtleVkpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKGtleVgsIGtleVkpKSB7XG4gICAgICAgICAgICB0aGlzLmtleXNYLmdldChrZXlYKS5kZWxldGUoa2V5WSk7XG4gICAgICAgICAgICB0aGlzLnRvdGFsS2V5c0NvdW50IC09IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGRlZmluZWQgY29tYmluYXRpb24gaXMgc3RvcmVkLlxuICAgICAqL1xuICAgIGhhcyhrZXlYLCBrZXlZKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXNYLmhhcyhrZXlYKSAmJiB0aGlzLmtleXNYLmdldChrZXlYKS5oYXMoa2V5WSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwga2V5IGNvbWJpbmF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5rZXlzWC5jbGVhcigpO1xuICAgICAgICB0aGlzLnRvdGFsS2V5c0NvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIHBlcnNpc3RlZCBkYXRhIHN0cnVjdHVyZSB0byBhbiBhcnJheSBvZiBvYmplY3RzLFxuICAgICAqIHVzaW5nIHRoZSBwcm92aWRlZCBmaWVsZCBuYW1lcyBmb3IgdGhlIG9iamVjdCBwcm9wcy5cbiAgICAgKi9cbiAgICB0b0FycmF5KGtleVhGaWVsZCwga2V5WUZpZWxkKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5c1gpLnJlZHVjZSgocGFpcnMsIHBhaXIpID0+IHtcbiAgICAgICAgICAgIC8vIEFycmF5LmZyb20obWFwSW5zdGFuY2UpIHJldHVybnMgYW4gYXJyYXkgb2YgYXJyYXlzIFtbaXRlbUtleTEsIGNvbHVtbktleXNTZXQxXSwgW2l0ZW1LZXkyLCBjb2x1bW5LZXlzU2V0Ml1dXG4gICAgICAgICAgICBjb25zdCBba2V5WCwga2V5c1ldID0gcGFpcjtcbiAgICAgICAgICAgIEFycmF5LmZyb20oa2V5c1kpLmZvckVhY2goa2V5WSA9PiBwYWlycy5wdXNoKHsgW2tleVhGaWVsZF06IGtleVgsIFtrZXlZRmllbGRdOiBrZXlZIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBwYWlycztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZ3JpZCwgY2QpIHtcbiAgICAgICAgdGhpcy5ncmlkID0gZ3JpZDtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgY29sbGVjdGlvbiB0aGF0IHdpbGwgc3RvcmUgdGhlIHNlbGVjdGVkIGl0ZW0ga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBgc2VsZWN0ZWRLZXlzYCBjb2xsZWN0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkS2V5c0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jZWxsU2VsZWN0aW9uU3RhdGUgPSBuZXcgUGFpclNldCgpO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgZ2V0IGlzQ2VsbFNlbGVjdGlvbk1vZGUoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ncmlkLnNlbGVjdGFibGUpICYmIHRoaXMuZ3JpZC5zZWxlY3RhYmxlWydjZWxsJ107XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgLy8gc2tpcCByZWluaXRpYWxpemF0aW9uIGlmIHRoZSB1c2VyIGRhdGEgaXMgdGhlIHNhbWUgYXMgdGhlIGxhc3Qgc3RhdGUgY2hhbmdlXG4gICAgICAgIGlmIChpc1ByZXNlbnQoY2hhbmdlcy5zZWxlY3RlZEtleXMpICYmIHRoaXMubGFzdFNlbGVjdGlvblN0YXRlICE9PSB0aGlzLnNlbGVjdGVkS2V5cykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLnNlbGVjdGVkS2V5cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5ncmlkLnJvd1NlbGVjdGVkKSkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLnJvd1NlbGVjdGVkID0gKHJvdykgPT4gdGhpcy5yb3dTZWxlY3Rpb25TdGF0ZS5oYXModGhpcy5nZXRJdGVtS2V5KHJvdykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuZ3JpZC5jZWxsU2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuY2VsbFNlbGVjdGVkID0gKHJvdywgY29sdW1uLCBjb2xJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbmRlciA9IHRoaXMuZ2V0U2VsZWN0aW9uSXRlbShyb3csIGNvbHVtbiwgY29sSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0aGlzLmNlbGxTZWxlY3Rpb25TdGF0ZS5oYXMoY29udGVuZGVyLml0ZW1LZXksIGNvbnRlbmRlci5jb2x1bW5LZXkpLFxuICAgICAgICAgICAgICAgICAgICBpdGVtOiBjb250ZW5kZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMuZ3JpZFxuICAgICAgICAgICAgLnNlbGVjdGlvbkNoYW5nZVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvblN0YXRlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2VsbFNlbGVjdGlvblN0YXRlLmNsZWFyKCk7XG4gICAgfVxuICAgIGdldEl0ZW1LZXkocm93KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbktleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGlvbktleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3cuZGF0YUl0ZW1bdGhpcy5zZWxlY3Rpb25LZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGlvbktleSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uS2V5KHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdy5pbmRleDtcbiAgICB9XG4gICAgZ2V0U2VsZWN0aW9uSXRlbShyb3csIGNvbCwgY29sSW5kZXgpIHtcbiAgICAgICAgY29uc3QgaXRlbUlkZW50aWZpZXJzID0ge307XG4gICAgICAgIGl0ZW1JZGVudGlmaWVycy5pdGVtS2V5ID0gdGhpcy5nZXRJdGVtS2V5KHJvdyk7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGNvbCkgJiYgIWlzUHJlc2VudChjb2xJbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtSWRlbnRpZmllcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uS2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29sdW1uS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaXRlbUlkZW50aWZpZXJzLmNvbHVtbktleSA9IHJvdy5kYXRhSXRlbVt0aGlzLmNvbHVtbktleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29sdW1uS2V5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpdGVtSWRlbnRpZmllcnMuY29sdW1uS2V5ID0gdGhpcy5jb2x1bW5LZXkoY29sLCBjb2xJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGl0ZW1LZXk6IGl0ZW1JZGVudGlmaWVycy5pdGVtS2V5LFxuICAgICAgICAgICAgY29sdW1uS2V5OiBpdGVtSWRlbnRpZmllcnMuY29sdW1uS2V5ID8gaXRlbUlkZW50aWZpZXJzLmNvbHVtbktleSA6IGNvbEluZGV4XG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLnNlbGVjdGVkUm93cykge1xuICAgICAgICAgICAgc2VsZWN0aW9uLmRlc2VsZWN0ZWRSb3dzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtS2V5ID0gdGhpcy5nZXRJdGVtS2V5KGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMucm93U2VsZWN0aW9uU3RhdGUuZGVsZXRlKGl0ZW1LZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkLnNlbGVjdGFibGVTZXR0aW5ncy5tb2RlID09PSBcInNpbmdsZVwiICYmIHRoaXMucm93U2VsZWN0aW9uU3RhdGUuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0ZWRSb3dzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtS2V5ID0gdGhpcy5nZXRJdGVtS2V5KGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMucm93U2VsZWN0aW9uU3RhdGUuYWRkKGl0ZW1LZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZGVzZWxlY3RlZENlbGxzLmZvckVhY2goKHsgaXRlbUtleSwgY29sdW1uS2V5IH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxTZWxlY3Rpb25TdGF0ZS5kZWxldGUoaXRlbUtleSwgY29sdW1uS2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZC5zZWxlY3RhYmxlU2V0dGluZ3MubW9kZSA9PT0gXCJzaW5nbGVcIiAmJiB0aGlzLmNlbGxTZWxlY3Rpb25TdGF0ZS5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3RlZENlbGxzLmZvckVhY2goKHsgaXRlbUtleSwgY29sdW1uS2V5IH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxTZWxlY3Rpb25TdGF0ZS5hZGQoaXRlbUtleSwgY29sdW1uS2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlKCk7XG4gICAgfVxuICAgIG5vdGlmeUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uU3RhdGUgPSB0aGlzLnN0YXRlVG9BcnJheSgpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkS2V5c0NoYW5nZS5lbWl0KHRoaXMubGFzdFNlbGVjdGlvblN0YXRlKTtcbiAgICB9XG4gICAgc2V0U3RhdGUoc2VsZWN0ZWRLZXlzKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDZWxsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5jZWxsU2VsZWN0aW9uU3RhdGUgPSBuZXcgUGFpclNldChzZWxlY3RlZEtleXMsICdpdGVtS2V5JywgJ2NvbHVtbktleScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25TdGF0ZSA9IG5ldyBTZXQoc2VsZWN0ZWRLZXlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZVRvQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ2VsbFNlbGVjdGlvbk1vZGUgP1xuICAgICAgICAgICAgdGhpcy5jZWxsU2VsZWN0aW9uU3RhdGUudG9BcnJheSgnaXRlbUtleScsICdjb2x1bW5LZXknKSA6XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucm93U2VsZWN0aW9uU3RhdGUpO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgU2VsZWN0aW9uLnByb3RvdHlwZSwgXCJzZWxlY3RlZEtleXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KFwia2VuZG9HcmlkU2VsZWN0QnlcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlbGVjdGlvbi5wcm90b3R5cGUsIFwic2VsZWN0aW9uS2V5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZWxlY3Rpb24ucHJvdG90eXBlLCBcImNvbHVtbktleVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFNlbGVjdGlvbi5wcm90b3R5cGUsIFwic2VsZWN0ZWRLZXlzQ2hhbmdlXCIsIHZvaWQgMCk7XG5cbmNvbnN0IHJlc2V0ID0gKC4uLmxpc3RzKSA9PiB7XG4gICAgbGV0IGRpZmYgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBsaXN0cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGNvbnN0IFtsaXN0LCBjb2x1bW5zXSA9IGxpc3RzW2lkeF07XG4gICAgICAgIGRpZmYgPSBkaWZmIHx8IGxpc3QubGVuZ3RoICE9PSBjb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgbGlzdC5yZXNldChjb2x1bW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmY7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbHVtbnNDb250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLmxlYWZDb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLmxvY2tlZENvbHVtbnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMubm9uTG9ja2VkQ29sdW1ucyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5sb2NrZWRMZWFmQ29sdW1ucyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5ub25Mb2NrZWRMZWFmQ29sdW1ucyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy50b3RhbExldmVscyA9IDA7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5sZWFmQ29sdW1uc1RvUmVuZGVyID0gW107XG4gICAgICAgIHRoaXMubG9ja2VkQ29sdW1uc1RvUmVuZGVyID0gW107XG4gICAgICAgIHRoaXMubm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyID0gW107XG4gICAgICAgIHRoaXMuaGFzR3JvdXBIZWFkZXJDb2x1bW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNHcm91cEZvb3RlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Zvb3RlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVubG9ja2VkV2lkdGggPSAwO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50TGV2ZWxzID0gdGhpcy50b3RhbExldmVscztcbiAgICAgICAgY29uc3QgbGVhZkNvbHVtbnMkJDEgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3QgbG9ja2VkTGVhZkNvbHVtbnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgbm9uTG9ja2VkTGVhZkNvbHVtbnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3QgbG9ja2VkQ29sdW1ucyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb25zdCBub25Mb2NrZWRDb2x1bW5zID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGNvbnN0IGFsbENvbHVtbnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3QgbGVhZkNvbHVtbnNUb1JlbmRlciA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb25zdCBsb2NrZWRDb2x1bW5zVG9SZW5kZXIgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgbm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGxldCBoYXNHcm91cEhlYWRlckNvbHVtbiA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFzR3JvdXBGb290ZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IGhhc0Zvb3RlciA9IGZhbHNlO1xuICAgICAgICBsZXQgdW5sb2NrZWRXaWR0aCA9IDA7XG4gICAgICAgIGxldCBsZWFmSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRvdGFsTGV2ZWxzID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5zKCkuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyTGVhZkNvbHVtbnMgPSBjb2x1bW4uaXNMb2NrZWQgPT09IHRydWUgPyBsb2NrZWRMZWFmQ29sdW1ucyA6IG5vbkxvY2tlZExlYWZDb2x1bW5zO1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyQ29sdW1ucyA9IGNvbHVtbi5pc0xvY2tlZCA9PT0gdHJ1ZSA/IGxvY2tlZENvbHVtbnMgOiBub25Mb2NrZWRDb2x1bW5zO1xuICAgICAgICAgICAgY29uc3QgdG9SZW5kZXJDb250YWluZXIgPSBjb2x1bW4uaXNMb2NrZWQgPT09IHRydWUgPyBsb2NrZWRDb2x1bW5zVG9SZW5kZXIgOiBub25Mb2NrZWRDb2x1bW5zVG9SZW5kZXI7XG4gICAgICAgICAgICBpZiAoIWlzQ29sdW1uR3JvdXBDb21wb25lbnQoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckxlYWZDb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgICAgICBsZWFmQ29sdW1ucyQkMS5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgbGVhZkNvbHVtbnNUb1JlbmRlci5wdXNoLmFwcGx5KGxlYWZDb2x1bW5zVG9SZW5kZXIsIGNvbHVtbnNUb1JlbmRlcihbY29sdW1uXSkpO1xuICAgICAgICAgICAgICAgIHRvUmVuZGVyQ29udGFpbmVyLnB1c2guYXBwbHkodG9SZW5kZXJDb250YWluZXIsIGNvbHVtbnNUb1JlbmRlcihbY29sdW1uXSkpO1xuICAgICAgICAgICAgICAgIGhhc0dyb3VwSGVhZGVyQ29sdW1uID0gaGFzR3JvdXBIZWFkZXJDb2x1bW4gfHwgc29tZUxlYWZDb2x1bW4obGVhZiA9PiBCb29sZWFuKGxlYWYuZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZVJlZiksIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgaGFzR3JvdXBGb290ZXIgPSBoYXNHcm91cEZvb3RlciB8fCBzb21lTGVhZkNvbHVtbihsZWFmID0+IEJvb2xlYW4obGVhZi5ncm91cEZvb3RlclRlbXBsYXRlUmVmKSwgY29sdW1uKTtcbiAgICAgICAgICAgICAgICBoYXNGb290ZXIgPSBoYXNGb290ZXIgfHwgc29tZUxlYWZDb2x1bW4obGVhZiA9PiBCb29sZWFuKGxlYWYuZm9vdGVyVGVtcGxhdGVSZWYpLCBjb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmICghY29sdW1uLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVubG9ja2VkV2lkdGggKz0gY29sdW1uLndpZHRoIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uaXNTcGFuQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5jaGlsZENvbHVtbnMuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGVhZkluZGV4ID0gbGVhZkluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmxlYWZJbmRleCA9IGxlYWZJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lckNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgYWxsQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB0aGlzLnRvdGFsTGV2ZWxzID0gY29sdW1uLmxldmVsID4gdGhpcy50b3RhbExldmVscyA/IGNvbHVtbi5sZXZlbCA6IHRoaXMudG90YWxMZXZlbHM7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhc0dyb3VwSGVhZGVyQ29sdW1uID0gaGFzR3JvdXBIZWFkZXJDb2x1bW47XG4gICAgICAgIHRoaXMuaGFzR3JvdXBGb290ZXIgPSBoYXNHcm91cEZvb3RlcjtcbiAgICAgICAgdGhpcy5oYXNGb290ZXIgPSBoYXNGb290ZXI7XG4gICAgICAgIHRoaXMubGVhZkNvbHVtbnNUb1JlbmRlciA9IGxlYWZDb2x1bW5zVG9SZW5kZXI7XG4gICAgICAgIHRoaXMubG9ja2VkQ29sdW1uc1RvUmVuZGVyID0gbG9ja2VkQ29sdW1uc1RvUmVuZGVyO1xuICAgICAgICB0aGlzLm5vbkxvY2tlZENvbHVtbnNUb1JlbmRlciA9IG5vbkxvY2tlZENvbHVtbnNUb1JlbmRlcjtcbiAgICAgICAgdGhpcy51bmxvY2tlZFdpZHRoID0gdW5sb2NrZWRXaWR0aDtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHJlc2V0KFt0aGlzLmxlYWZDb2x1bW5zLCBsZWFmQ29sdW1ucyQkMV0sIFt0aGlzLmxvY2tlZExlYWZDb2x1bW5zLCBsb2NrZWRMZWFmQ29sdW1uc10sIFt0aGlzLm5vbkxvY2tlZExlYWZDb2x1bW5zLCBub25Mb2NrZWRMZWFmQ29sdW1uc10sIFt0aGlzLmxvY2tlZENvbHVtbnMsIGxvY2tlZENvbHVtbnNdLCBbdGhpcy5hbGxDb2x1bW5zLCBhbGxDb2x1bW5zXSwgW3RoaXMubm9uTG9ja2VkQ29sdW1ucywgbm9uTG9ja2VkQ29sdW1uc10pIHx8IGN1cnJlbnRMZXZlbHMgIT09IHRoaXMudG90YWxMZXZlbHM7XG4gICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH1cbn1cblxuY29uc3QgZm9yRWFjaENvbHVtbiA9IChsaXN0LCBjYWxsYmFjaykgPT4ge1xuICAgIGxpc3QuZm9yRWFjaCgoY29sdW1uKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGNvbHVtbik7XG4gICAgICAgIGlmIChjb2x1bW4uaXNDb2x1bW5Hcm91cCAmJiBjb2x1bW4uaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvckVhY2hDb2x1bW4oY29sdW1uLmNoaWxkcmVuQXJyYXksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IGZvckVhY2hMZXZlbCA9IChsaXN0LCBjYWxsYmFjaykgPT4ge1xuICAgIHNvcnRDb2x1bW5zKGxpc3QpXG4gICAgICAgIC5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgY2FsbGJhY2soY29sdW1uKTtcbiAgICAgICAgaWYgKGNvbHVtbi5pc0NvbHVtbkdyb3VwICYmIGNvbHVtbi5oYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yRWFjaExldmVsKGNvbHVtbi5jaGlsZHJlbkFycmF5LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5jb25zdCBmaWx0ZXJIaWVyYXJjaHkgPSAobGlzdCwgcHJlZGljYXRlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgc29ydENvbHVtbnMobGlzdClcbiAgICAgICAgLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlKGNvbHVtbikpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uaXNDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuJCQxID0gZmlsdGVySGllcmFyY2h5KGNvbHVtbi5jaGlsZHJlbkFycmF5LCBwcmVkaWNhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbiQkMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29sdW1uLCAuLi5jaGlsZHJlbiQkMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNvbHVtbi5pc1NwYW5Db2x1bW4gfHwgZmlsdGVySGllcmFyY2h5KGNvbHVtbi5jaGlsZHJlbkFycmF5LCBwcmVkaWNhdGUpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb2x1bW5MaXN0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2x1bW5MaXN0KG5ldyBRdWVyeUxpc3QoKSk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgZm9yRWFjaENvbHVtbih0aGlzLmNvbHVtbnMsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZmlsdGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3JFYWNoQ29sdW1uKHRoaXMuY29sdW1ucywgKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmlsdGVySGllcmFyY2h5KHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gZmlsdGVySGllcmFyY2h5KHRoaXMuY29sdW1ucy50b0FycmF5KCksIHByZWRpY2F0ZSk7XG4gICAgfVxuICAgIGZpbHRlclNvcnQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvckVhY2hMZXZlbCh0aGlzLmNvbHVtbnMudG9BcnJheSgpLCAoY29sdW1uKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yRWFjaENvbHVtbih0aGlzLmNvbHVtbnMsIChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbHVtbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByb290Q29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucy50b0FycmF5KCk7XG4gICAgfVxuICAgIHRvdGFsQ29sdW1uTGV2ZWxzKCkge1xuICAgICAgICBsZXQgdG90YWxMZXZlbHMgPSAwO1xuICAgICAgICB0aGlzLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIHRvdGFsTGV2ZWxzID0gTWF0aC5tYXgoY29sdW1uLmxldmVsLCB0b3RhbExldmVscyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG90YWxMZXZlbHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgR3JvdXBJbmZvU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NvbHVtbkxpc3QgPSBDb2x1bW5MaXN0LmVtcHR5O1xuICAgIH1cbiAgICBnZXQgY29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZENvbHVtbnModGhpcy5fY29sdW1uTGlzdCgpLnRvQXJyYXkoKSkuZmlsdGVyKGlzQ29sdW1uQ29tcG9uZW50KTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDb2x1bW5zQ29udGFpbmVyKGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5fY29sdW1uTGlzdCA9IGNvbHVtbnM7XG4gICAgfVxuICAgIGZvcm1hdEZvckdyb3VwKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5Gb3JHcm91cChpdGVtKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbiA/IGNvbHVtbi5mb3JtYXQgOiBcIlwiO1xuICAgIH1cbiAgICBpc0dyb3VwYWJsZShncm91cEZpZWxkKSB7XG4gICAgICAgIGNvbnN0IFtjb2x1bW5dID0gdGhpcy5jb2x1bW5zLmZpbHRlcih4ID0+IHguZmllbGQgPT09IGdyb3VwRmllbGQpO1xuICAgICAgICByZXR1cm4gY29sdW1uID8gY29sdW1uLmdyb3VwYWJsZSA6IHRydWU7XG4gICAgfVxuICAgIGdyb3VwVGl0bGUoaXRlbSkge1xuICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmNvbHVtbkZvckdyb3VwKGl0ZW0pO1xuICAgICAgICByZXR1cm4gY29sdW1uID8gKGNvbHVtbi50aXRsZSB8fCBjb2x1bW4uZmllbGQpIDogdGhpcy5ncm91cEZpZWxkKGl0ZW0pO1xuICAgIH1cbiAgICBncm91cEhlYWRlclRlbXBsYXRlKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5Gb3JHcm91cChpdGVtKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbiA/IGNvbHVtbi5ncm91cEhlYWRlclRlbXBsYXRlUmVmIHx8IGNvbHVtbi5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBncm91cEZpZWxkKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBncm91cC5kYXRhID8gZ3JvdXAuZGF0YS5maWVsZCA6IGdyb3VwLmZpZWxkO1xuICAgIH1cbiAgICBjb2x1bW5Gb3JHcm91cChncm91cCkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZ3JvdXBGaWVsZChncm91cCk7XG4gICAgICAgIGNvbnN0IFtjb2x1bW5dID0gdGhpcy5jb2x1bW5zLmZpbHRlcih4ID0+IHguZmllbGQgPT09IGZpZWxkKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSA9IGNsYXNzIENoYW5nZU5vdGlmaWNhdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKG5nWm9uZSkge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24gfHwgdGhpcy5zdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMubmdab25lLm9uU3RhYmxlXG4gICAgICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2hhbmdlcy5lbWl0KCkpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkNoYW5nZU5vdGlmaWNhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOZ1pvbmVdKVxuXSwgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbm8tcmVjb3JkcyB0ZW1wbGF0ZSBvZiB0aGUgR3JpZC4gUHJvdmlkZXMgYW4gb3B0aW9uIHRvIGN1c3RvbWl6ZSB0aGVcbiAqIGFwcGVhcmFuY2Ugb2YgdGhlIGl0ZW0gdGhhdCBpcyBkaXNwbGF5ZWQgd2hlbiBubyBkYXRhIGlzIHByZXNlbnQuIFRvIGRlZmluZSB0aGUgbm8tcmVjb3JkcyB0ZW1wbGF0ZSxcbiAqIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9HcmlkTm9SZWNvcmRzVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYDxrZW5kby1ncmlkPmAuXG4gKlxuICogPiBXaGVuIHRoZSBsb2NrZWQgY29sdW1ucyBvZiB0aGUgR3JpZCBhcmUgaW4gdXNlLCB0aGUgdGVtcGxhdGUgaXMgZGlzcGxheWVkIGluIHRoZSBub24tbG9ja2VkIHBhcnQgb2YgdGhlIGNvbnRlbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxrZW5kby1ncmlkIFtkYXRhXT1cImRhdGFcIj5cbiAqICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiUHJvZHVjdElEXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiUHJvZHVjdE5hbWVcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJVbml0UHJpY2VcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkTm9SZWNvcmRzVGVtcGxhdGU+XG4gKiAgICAgICAgICAgIFRoZXJlIGFyZSBub3QgcHJvZHVjdHMuIDxhIGhyZWY9XCIjXCIgKGNsaWNrKT1cInJlZnJlc2goKVwiPkNsaWNrIGhlcmUgdG8gcmVmcmVzaDwvYT4uXG4gKiAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgZGF0YSA9IFtdO1xuICogICAgIHB1YmxpYyByZWZyZXNoKCkge1xuICogICAgICAgdGhpcy5kYXRhID0gW3tcbiAqICAgICAgICAgICAgXCJQcm9kdWN0SURcIjogMSxcbiAqICAgICAgICAgICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAqICAgICAgICAgICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAqICAgICAgICAgICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2UsXG4gKiAgICAgICAgICAgIFwiQ2F0ZWdvcnlcIjoge1xuICogICAgICAgICAgICAgICAgXCJDYXRlZ29yeUlEXCI6IDEsXG4gKiAgICAgICAgICAgICAgICBcIkNhdGVnb3J5TmFtZVwiOiBcIkJldmVyYWdlc1wiLFxuICogICAgICAgICAgICAgICAgXCJEZXNjcmlwdGlvblwiOiBcIlNvZnQgZHJpbmtzLCBjb2ZmZWVzLCB0ZWFzLCBiZWVycywgYW5kIGFsZXNcIlxuICogICAgICAgICAgICB9XG4gKiAgICAgICAgICB9LCB7XG4gKiAgICAgICAgICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gKiAgICAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICogICAgICAgICAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZSxcbiAqICAgICAgICAgICAgXCJDYXRlZ29yeVwiOiB7XG4gKiAgICAgICAgICAgICAgICBcIkNhdGVnb3J5SURcIjogMSxcbiAqICAgICAgICAgICAgICAgIFwiQ2F0ZWdvcnlOYW1lXCI6IFwiQmV2ZXJhZ2VzXCIsXG4gKiAgICAgICAgICAgICAgICBcIkRlc2NyaXB0aW9uXCI6IFwiU29mdCBkcmlua3MsIGNvZmZlZXMsIHRlYXMsIGJlZXJzLCBhbmQgYWxlc1wiXG4gKiAgICAgICAgICAgIH1cbiAqICAgICAgICAgIH0sIHtcbiAqICAgICAgICAgICAgXCJQcm9kdWN0SURcIjogMyxcbiAqICAgICAgICAgICAgXCJQcm9kdWN0TmFtZVwiOiBcIkFuaXNlZWQgU3lydXBcIixcbiAqICAgICAgICAgICAgXCJVbml0UHJpY2VcIjogMTAuMDAwMCxcbiAqICAgICAgICAgICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2UsXG4gKiAgICAgICAgICAgIFwiQ2F0ZWdvcnlcIjoge1xuICogICAgICAgICAgICAgICAgXCJDYXRlZ29yeUlEXCI6IDIsXG4gKiAgICAgICAgICAgICAgICBcIkNhdGVnb3J5TmFtZVwiOiBcIkNvbmRpbWVudHNcIixcbiAqICAgICAgICAgICAgICAgIFwiRGVzY3JpcHRpb25cIjogXCJTd2VldCBhbmQgc2F2b3J5IHNhdWNlcywgcmVsaXNoZXMsIHNwcmVhZHMsIGFuZCBzZWFzb25pbmdzXCJcbiAqICAgICAgICAgICAgfVxuICogICAgICAgIH1dO1xuICpcbiAqICAgICB9XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBOb1JlY29yZHNUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIE5vUmVjb3Jkc1RlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbk5vUmVjb3Jkc1RlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkTm9SZWNvcmRzVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBOb1JlY29yZHNUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbmNvbnN0IHNldCA9IHZhbHVlID0+IHBhaXIgPT4gcGFpci5mb3JFYWNoKHggPT4geC5zdHlsZS5oZWlnaHQgPSB2YWx1ZSk7XG5jb25zdCBjbGVhckhlaWdodCA9IHBhaXJzID0+IHBhaXJzXG4gICAgLmZpbHRlcigoW2xlZnQsIHJpZ2h0XSkgPT4gbGVmdC5zdHlsZS5oZWlnaHQgfHwgcmlnaHQuc3R5bGUuaGVpZ2h0KVxuICAgIC5mb3JFYWNoKHNldChcIlwiKSk7XG5jb25zdCB6aXAkMSA9IChhcnIxLCBhcnIyKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaWR4ID0gMCwgbGVuID0gYXJyMS5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgICAgaWYgKCFhcnIyW2lkeF0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKFthcnIxW2lkeF0sIGFycjJbaWR4XV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IHNldEhlaWdodCA9IGhlaWdodHMgPT4gKHJvdywgaWR4KSA9PiBzZXQoYCR7aGVpZ2h0c1tpZHhdICsgMX1weGApKHJvdyk7XG5jb25zdCBnZXRIZWlnaHRzID0gcm93cyA9PiByb3dzLm1hcCgoW2xlZnQsIHJpZ2h0XSkgPT4ge1xuICAgIGNvbnN0IGhlaWdodCA9IGxlZnQub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldEhlaWdodDIgPSByaWdodC5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKGhlaWdodCA8IG9mZnNldEhlaWdodDIpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldEhlaWdodDI7XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQ7XG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzeW5jUm93c0hlaWdodCA9ICh0YWJsZTEsIHRhYmxlMikgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGNvbnN0IHJvd3MgPSB6aXAkMSh0YWJsZTEucm93cywgdGFibGUyLnJvd3MpO1xuICAgIGNsZWFySGVpZ2h0KHJvd3MpO1xuICAgIGNvbnN0IGhlaWdodHMgPSBnZXRIZWlnaHRzKHJvd3MpO1xuICAgIFt0YWJsZTEsIHRhYmxlMl0uZm9yRWFjaCh4ID0+IHguc3R5bGUuZGlzcGxheSA9ICdub25lJyk7XG4gICAgcm93cy5mb3JFYWNoKHNldEhlaWdodChoZWlnaHRzKSk7XG4gICAgW3RhYmxlMSwgdGFibGUyXS5mb3JFYWNoKHggPT4geC5zdHlsZS5kaXNwbGF5ID0gJycpO1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmVFbGVtZW50ICYmXG4gICAgICAgICh0YWJsZTEuY29udGFpbnMoYWN0aXZlRWxlbWVudCkgfHwgdGFibGUyLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSkge1xuICAgICAgICBhY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBNZW51VGFiYmluZ1NlcnZpY2UgPSBjbGFzcyBNZW51VGFiYmluZ1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc0NvbHVtbk1lbnUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1BvcHVwT3BlbiA9IGZhbHNlO1xuICAgIH1cbn07XG5NZW51VGFiYmluZ1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIE1lbnVUYWJiaW5nU2VydmljZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNlcnZpY2UgdG8gc2V0IHRoZSBmaWx0ZXIgZGVzY3JpcHRvclxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZXVzYWJsZWN1c3RvbWZpbHRlcnNfZ3JpZCAlfSkpLlxuICovXG5sZXQgRmlsdGVyU2VydmljZSA9IGNsYXNzIEZpbHRlclNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZW51VGFiYmluZ1NlcnZpY2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGZpbHRlciBkZXNjcmlwdG9ycyBpcyBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLm1lbnVUYWJiaW5nU2VydmljZSA9IG1lbnVUYWJiaW5nU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZmlsdGVyIGRlc2NyaXB0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3J9IHZhbHVlIC0gVGhlIGZpbHRlciBkZXNjcmlwdG9yIHRoYXQgd2lsbCBiZSBzZXQuXG4gICAgICovXG4gICAgZmlsdGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KHZhbHVlKTtcbiAgICB9XG59O1xuRmlsdGVyU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtNZW51VGFiYmluZ1NlcnZpY2VdKVxuXSwgRmlsdGVyU2VydmljZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcGFnZXIgdGVtcGxhdGUgd2hpY2ggaGVscHMgdG8gY3VzdG9taXplIHRoZSBwYWdlciBhcHBlYXJhbmNlIGluIHRoZSBHcmlkLiBUbyBkZWZpbmUgYSBwYWdlclxuICogdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9QYWdlclRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIGA8a2VuZG8tZ3JpZD5gLlxuICpcbiAqIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICogKiBgY3VycmVudFBhZ2VgJm1kYXNoO1RoZSBpbmRleCBvZiB0aGUgZGlzcGxheWVkIHBhZ2UuXG4gKiAqIGBwYWdlU2l6ZWAmbWRhc2g7VGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IGBwYWdlU2l6ZWAuXG4gKiAqIGBza2lwYCZtZGFzaDtUaGUgY3VycmVudCBza2lwIHZhbHVlLlxuICogKiBgdG90YWxgJm1kYXNoO1RoZSB0b3RhbCBudW1iZXIgb2YgcmVjb3Jkcy5cbiAqICogYHRvdGFsUGFnZXNgJm1kYXNoO1RoZSB0b3RhbCBudW1iZXIgb2YgYXZhaWxhYmxlIHBhZ2VzLlxuICogKiAgTmVlZHMgdG8gYmUgcHJvdmlkZWQgYXMgYW4gaW5wdXQgdG8gaW5uZXIgcGFnZXIgY29tcG9uZW50cyB1c2VkIHdpdGhpbiB0aGUgdGVtcGxhdGUgd2hlbiB0aGUgR3JpZCBpcyBuYXZpZ2FibGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgIDxrZW5kby1ncmlkXG4gKiAgICAgICAgW2tlbmRvR3JpZEJpbmRpbmddPVwiZ3JpZERhdGFcIlxuICogICAgICAgIFtwYWdlU2l6ZV09XCIxXCJcbiAqICAgICAgICBbcGFnZWFibGVdPVwidHJ1ZVwiXG4gKiAgICAgID5cbiAqICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3RJRFwiIHRpdGxlPVwiSURcIiB3aWR0aD1cIjQwXCI+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiUHJvZHVjdE5hbWVcIiB0aXRsZT1cIk5hbWVcIiB3aWR0aD1cIjI1MFwiPlxuICogICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiIHRpdGxlPVwiUHJpY2VcIiB3aWR0aD1cIjgwXCIgZm9ybWF0PVwiezA6Y31cIj5cbiAqICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKlxuICogICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvUGFnZXJUZW1wbGF0ZSBsZXQtdG90YWxQYWdlcz1cInRvdGFsUGFnZXNcIiBsZXQtY3VycmVudFBhZ2U9XCJjdXJyZW50UGFnZVwiPlxuICogICAgICAgICAgPGtlbmRvLXBhZ2VyLXByZXYtYnV0dG9ucz48L2tlbmRvLXBhZ2VyLXByZXYtYnV0dG9ucz5cbiAqICAgICAgICAgIDxrZW5kby1wYWdlci1udW1lcmljLWJ1dHRvbnMgW2J1dHRvbkNvdW50XT1cIjEwXCI+PC9rZW5kby1wYWdlci1udW1lcmljLWJ1dHRvbnM+XG4gKiAgICAgICAgICA8a2VuZG8tcGFnZXItbmV4dC1idXR0b25zPjwva2VuZG8tcGFnZXItbmV4dC1idXR0b25zPlxuICogICAgICAgICAgPGtlbmRvLXBhZ2VyLWluZm8+PC9rZW5kby1wYWdlci1pbmZvPlxuICogICAgICAgICAgQ3VycmVudCBwYWdlOiB7e2N1cnJlbnRQYWdlfX1cbiAqICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICogICAgPC9rZW5kby1ncmlkPlxuICogICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgZ3JpZERhdGEgPSBbe1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAxLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICogICAgICAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICogICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICogICAgICAgfSwge1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAqICAgICAgICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAqICAgICAgICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICogICAgICAgfVxuICogICAgIF07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBQYWdlclRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgUGFnZXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5QYWdlclRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9QYWdlclRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgUGFnZXJUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgUERGU2VydmljZSA9IGNsYXNzIFBERlNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zYXZlUERGID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRyYXdQREYgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZXhwb3J0Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIHNhdmUoY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHRoaXMuc2F2ZVBERiwgY29tcG9uZW50KTtcbiAgICB9XG4gICAgZHJhdyhjb21wb25lbnQsIHByb21pc2UpIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodGhpcy5kcmF3UERGLCB7IGNvbXBvbmVudCwgcHJvbWlzZSB9KTtcbiAgICB9XG4gICAgZW1pdEV2ZW50KGVtaXR0ZXIsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGVtaXR0ZXIub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDcmVhdGluZyBQREYgcmVxdWlyZXMgaW5jbHVkaW5nIHRoZSBQREZNb2R1bGUgYW5kIGFkZGluZyB0aGUgPGtlbmRvLWdyaWQtcGRmPiBjb21wb25lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuUERGU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgUERGU2VydmljZSk7XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHBkZkV4cG9ydGAgZXZlbnQuXG4gKi9cbmNsYXNzIFBERkV4cG9ydEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU3VzcGVuZFNlcnZpY2UgPSBjbGFzcyBTdXNwZW5kU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNjcm9sbCA9IGZhbHNlO1xuICAgIH1cbn07XG5TdXNwZW5kU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgU3VzcGVuZFNlcnZpY2UpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTogb2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzICovXG5jb25zdCBib290c3RyYXBUb01lZGlhID0gKG1lZGlhKSA9PiAoKHtcbiAgICBcInhzXCI6IFwiKG1heC13aWR0aDogNTc2cHgpXCIsXG4gICAgXCJzbVwiOiBcIihtaW4td2lkdGg6IDU3NnB4KVwiLFxuICAgIFwibWRcIjogXCIobWluLXdpZHRoOiA3NjhweClcIixcbiAgICBcImxnXCI6IFwiKG1pbi13aWR0aDogOTkycHgpXCIsXG4gICAgXCJ4bFwiOiBcIihtaW4td2lkdGg6IDEyMDBweClcIlxufSlbbWVkaWFdIHx8IG1lZGlhKTtcbi8qIHRzbGludDplbmFibGU6IG9iamVjdC1saXRlcmFsLXNvcnQta2V5cyAqL1xuY29uc3QgYnJvd3Nlck1hdGNoTWVkaWEgPSAobWVkaWEpID0+IHdpbmRvdy5tYXRjaE1lZGlhKG1lZGlhKS5tYXRjaGVzO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBSZXNwb25zaXZlU2VydmljZSA9IGNsYXNzIFJlc3BvbnNpdmVTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hdGNoTWVkaWEgPSBicm93c2VyTWF0Y2hNZWRpYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG1hdGNoZXNNZWRpYShtZWRpYSkge1xuICAgICAgICByZXR1cm4gIW1lZGlhIHx8IHRoaXMubWF0Y2hNZWRpYShib290c3RyYXBUb01lZGlhKG1lZGlhKSk7XG4gICAgfVxufTtcblJlc3BvbnNpdmVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBSZXNwb25zaXZlU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRXhjZWxTZXJ2aWNlID0gY2xhc3MgRXhjZWxTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2F2ZVRvRXhjZWwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZXhwb3J0Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIHNhdmUoY29tcG9uZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnNhdmVUb0V4Y2VsLm9ic2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2F2aW5nIGV4Y2VsIHJlcXVpcmVzIGluY2x1ZGluZyB0aGUgRXhjZWxNb2R1bGUgYW5kIGFkZGluZyB0aGUgPGtlbmRvLWdyaWQtZXhjZWw+IGNvbXBvbmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZVRvRXhjZWwuZW1pdChjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkV4Y2VsU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgRXhjZWxTZXJ2aWNlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0b29sYmFyIHRlbXBsYXRlIG9mIHRoZSBHcmlkLlxuICpcbiAqIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGhhcyB0aGUgZm9sbG93aW5nIGZpZWxkOlxuICogLSBgcG9zaXRpb25gJm1kYXNoO1RoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgdG9vbGJhciB0ZW1wbGF0ZSBpcyByZW5kZXJlZC4gVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmUgXCJ0b3BcIiBhbmQgXCJib3R0b21cIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxkaXYgY2xhc3M9XCJleGFtcGxlLWNvbmZpZ1wiPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgaWQ9XCJ0b3BcIiBuYW1lPVwicG9zaXRpb25cIiB2YWx1ZT1cInRvcFwiIGNoZWNrZWQgKGNsaWNrKT1cInBvc2l0aW9uQ2hhbmdlKCRldmVudClcIi8+XG4gKiAgICAgICAgIDxsYWJlbCBjbGFzcz1cImstcmFkaW8tbGFiZWxcIiBmb3I9XCJ0b3BcIj5Ub3A8L2xhYmVsPjxici8+XG4gKiAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBpZD1cImJvdHRvbVwiIG5hbWU9XCJwb3NpdGlvblwiIHZhbHVlPVwiYm90dG9tXCIgKGNsaWNrKT1cInBvc2l0aW9uQ2hhbmdlKCRldmVudClcIi8+XG4gKiAgICAgICAgIDxsYWJlbCBjbGFzcz1cImstcmFkaW8tbGFiZWxcIiBmb3I9XCJib3R0b21cIj5Cb3R0b208L2xhYmVsPjxici8+XG4gKiAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBpZD1cImJvdGhcIiBuYW1lPVwicG9zaXRpb25cIiB2YWx1ZT1cImJvdGhcIiAoY2xpY2spPVwicG9zaXRpb25DaGFuZ2UoJGV2ZW50KVwiLz5cbiAqICAgICAgICAgPGxhYmVsIGNsYXNzPVwiay1yYWRpby1sYWJlbFwiIGZvcj1cImJvdGhcIj5Cb3RoPC9sYWJlbD48YnIvPlxuICogICAgICAgPC9kaXY+XG4gKiAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJncmlkRGF0YVwiIHN0eWxlPVwiaGVpZ2h0OiAyMDBweFwiPlxuICogICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkVG9vbGJhclRlbXBsYXRlIFtwb3NpdGlvbl09XCJwb3NpdGlvblwiIGxldC1wb3NpdGlvbj1cInBvc2l0aW9uXCI+XG4gKiAgICAgICAgICAgICAgICA8YnV0dG9uIChjbGljayk9XCJvbkNsaWNrKClcIj5DdXN0b20gYWN0aW9uPC9idXR0b24+XG4gKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCI+XG4gKiAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiPlxuICogICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgcHVibGljIHBvc2l0aW9uOiAndG9wJyB8ICdib3R0b20nIHwgJ2JvdGgnID0gJ3RvcCc7XG4gKlxuICogICAgIHB1YmxpYyBncmlkRGF0YSA9IFt7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gKiAgICAgICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gKiAgICAgICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gKiAgICAgICB9LCB7XG4gKiAgICAgICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gKiAgICAgICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICogICAgICAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgXTtcbiAqXG4gKiAgICAgcHVibGljIG9uQ2xpY2soKTogdm9pZCB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiYnV0dG9uIHdhcyBjbGlja2VkXCIpO1xuICogICAgIH1cbiAqXG4gKiAgICAgcHVibGljIHBvc2l0aW9uQ2hhbmdlKHsgdGFyZ2V0IH0pOiB2b2lkIHtcbiAqICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGFyZ2V0LnZhbHVlO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIFRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IFwidG9wXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbGJhciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRvb2xiYXJ0ZW1wbGF0ZV9ncmlkICV9KSkuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAtIGB0b3BgJm1kYXNoO1Bvc2l0aW9ucyB0aGUgdG9vbGJhciBhYm92ZSB0aGUgZ3JvdXAgcGFuZWwgb3IgaGVhZGVyLlxuICAgICAqIC0gYGJvdHRvbWAmbWRhc2g7UG9zaXRpb25zIHRoZSB0b29sYmFyIGJlbG93IHRoZSBwYWdlci5cbiAgICAgKiAtIGBib3RoYCZtZGFzaDtEaXNwbGF5cyB0d28gdG9vbGJhciBpbnN0YW5jZXMuIFBvc2l0aW9ucyB0aGUgZmlyc3Qgb25lIGFib3ZlXG4gICAgICogdGhlIGdyb3VwIHBhbmVsIG9yIGhlYWRlciBhbmQgdGhlIHNlY29uZCBvbmUgYmVsb3cgdGhlIHBhZ2VyLlxuICAgICAqL1xuICAgIHNldCBwb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICBnZXQgcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoXCJwb3NpdGlvblwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBUb29sYmFyVGVtcGxhdGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIG51bGwpO1xuVG9vbGJhclRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkVG9vbGJhclRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgVG9vbGJhclRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTY3JvbGxTeW5jU2VydmljZSA9IGNsYXNzIFNjcm9sbFN5bmNTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLmhlYWRlclN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5ib2R5U3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuY2hhbmdlcy5zdWJzY3JpYmUoYXJncyA9PiB0aGlzLnNjcm9sbExlZnQoYXJncykpKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJFbWl0dGVyKGVsLCBzb3VyY2VUeXBlKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3Rlcihzb3VyY2VUeXBlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKHsgZWxlbWVudDogZWwsIHNvdXJjZVR5cGUgfSk7XG4gICAgICAgIGlmIChzb3VyY2VUeXBlID09PSBcImJvZHlcIiB8fCBzb3VyY2VUeXBlID09PSBcImhlYWRlclwiKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JzID0gZnJvbUV2ZW50KGVsLCBcInNjcm9sbFwiKS5waXBlKG1hcCgoeyB0YXJnZXQ6IHsgc2Nyb2xsTGVmdCB9IH0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGVcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG9icy5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCh4LCB5KSA9PiAoeC5zY3JvbGxMZWZ0ID09PSB5LnNjcm9sbExlZnQpKSwgZmlsdGVyKHggPT4gIXRoaXMuc291cmNlIHx8IHRoaXMuc291cmNlID09PSB4LnNvdXJjZVR5cGUpLCB0YXAoeCA9PiB0aGlzLnNvdXJjZSA9IHguc291cmNlVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHgpID0+IHRoaXMuY2hhbmdlcy5uZXh0KHgpKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uYWRkKG9icy5waXBlKGZpbHRlcih4ID0+IHRoaXMuc291cmNlICYmIHRoaXMuc291cmNlICE9PSB4LnNvdXJjZVR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc291cmNlID0gdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVR5cGUgPT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keVN1YnNjcmlwdGlvbi5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyU3Vic2NyaXB0aW9uLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5oZWFkZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5ib2R5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHNjcm9sbExlZnQoeyBzY3JvbGxMZWZ0LCBzb3VyY2VUeXBlIH0pIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoeCA9PiBzb3VyY2VUeXBlICE9PSB4LnNvdXJjZVR5cGUpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoc291cmNlVHlwZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZWxlbWVudHMuZmluZEluZGV4KHggPT4geC5zb3VyY2VUeXBlID09PSBzb3VyY2VUeXBlKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlID09PSBcImhlYWRlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlclN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5U3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblNjcm9sbFN5bmNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmdab25lXSlcbl0sIFNjcm9sbFN5bmNTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBSZXNpemVTZXJ2aWNlID0gY2xhc3MgUmVzaXplU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKCkgPT4geyB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1lbWJlci1vcmRlcmluZ1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLmRpc3BhdGNoZXIuYXNPYnNlcnZhYmxlKCkucGlwZSh0aHJvdHRsZVRpbWUoMTAwKSk7XG4gICAgfVxuICAgIGNvbm5lY3QocmVzaXplcykge1xuICAgICAgICB0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbi5hZGQocmVzaXplcy5zdWJzY3JpYmUodGhpcy5kaXNwYXRjaGVyKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5SZXNpemVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBSZXNpemVTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzTG9ja2VkID0gY29sdW1uID0+IGNvbHVtbi5wYXJlbnQgPyBpc0xvY2tlZChjb2x1bW4ucGFyZW50KSA6ICEhY29sdW1uLmxvY2tlZDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByZXNpemVBcmdzID0gKGNvbHVtbiwgZXh0cmEpID0+IE9iamVjdC5hc3NpZ24oe1xuICAgIGNvbHVtbnM6IGxlYWZDb2x1bW5zKFtjb2x1bW5dKSxcbiAgICBsb2NrZWQ6IGlzTG9ja2VkKGNvbHVtbilcbn0sIGV4dHJhKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTphbGlnblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb2x1bW5SZXNpemluZ1NlcnZpY2UgPSBjbGFzcyBDb2x1bW5SZXNpemluZ1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnRhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLmJhdGNoID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnQoY29sdW1uKSB7XG4gICAgICAgIHRoaXMudHJhY2tDb2x1bW5zKGNvbHVtbik7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSAodGhpcy5jb2x1bW4uaXNDb2x1bW5Hcm91cCA/IFtjb2x1bW5dIDogW10pXG4gICAgICAgICAgICAuY29uY2F0KGxlYWZDb2x1bW5zKFtjb2x1bW5dKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KHtcbiAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgICAgICBsb2NrZWQ6IGlzTG9ja2VkKHRoaXMuY29sdW1uKSxcbiAgICAgICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2l6ZUNvbHVtbnMoZGVsdGFQZXJjZW50KSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHJlc2l6ZUFyZ3ModGhpcy5jb2x1bW4sIHtcbiAgICAgICAgICAgIGRlbHRhUGVyY2VudCxcbiAgICAgICAgICAgIHR5cGU6ICdyZXNpemVDb2x1bW4nXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdChhY3Rpb24pO1xuICAgIH1cbiAgICByZXNpemVUYWJsZShjb2x1bW4sIGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHJlc2l6ZUFyZ3MoY29sdW1uLCB7XG4gICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgIHR5cGU6ICdyZXNpemVUYWJsZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KGFjdGlvbik7XG4gICAgfVxuICAgIHJlc2l6ZWRDb2x1bW4oc3RhdGUkJDEpIHtcbiAgICAgICAgdGhpcy5yZXNpemVkQ29sdW1ucy5wdXNoKHN0YXRlJCQxKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdCh7XG4gICAgICAgICAgICBjb2x1bW5zOiBbXSxcbiAgICAgICAgICAgIHJlc2l6ZWRDb2x1bW5zOiB0aGlzLnJlc2l6ZWRDb2x1bW5zLFxuICAgICAgICAgICAgdHlwZTogJ2VuZCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyVGFibGUodGFibGVNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnRhYmxlcy5wdXNoKHRhYmxlTWV0YWRhdGEpO1xuICAgICAgICBjb25zdCB1bnJlZ2lzdGVyVGFibGUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhYmxlcy5zcGxpY2UodGhpcy50YWJsZXMuaW5kZXhPZih0YWJsZU1ldGFkYXRhKSwgMSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB1bnJlZ2lzdGVyVGFibGU7XG4gICAgfVxuICAgIG1lYXN1cmVDb2x1bW5zKGluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2gucHVzaCguLi5pbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0ZpdEJhdGNoKGluZm8sICgpID0+IHRoaXMuZW5kKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF1dG9GaXQoLi4uY29sdW1ucykge1xuICAgICAgICBjb25zdCBub25Mb2NrZWRDb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICFjb2x1bW4uaXNMb2NrZWQpO1xuICAgICAgICB0aGlzLmF1dG9GaXRTdGFydChub25Mb2NrZWRDb2x1bW5zKTtcbiAgICAgICAgdGhpcy5hdXRvRml0QmF0Y2godGhpcy5iYXRjaCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vbkxvY2tlZENvbHVtbnMubGVuZ3RoIDwgY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NrZWRDb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5pc0xvY2tlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvRml0U3RhcnQobG9ja2VkQ29sdW1ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvRml0QmF0Y2godGhpcy5iYXRjaCwgKCkgPT4gdGhpcy5lbmQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJhY2tDb2x1bW5zKGNvbHVtbikge1xuICAgICAgICB0aGlzLnJlc2l6ZWRDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIH1cbiAgICBhdXRvRml0U3RhcnQoY29sdW1ucykge1xuICAgICAgICB0aGlzLmJhdGNoID0gW107XG4gICAgICAgIHRoaXMucmVzaXplZENvbHVtbnMgPSBbXTtcbiAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9ja2VkID0gY29sdW1uc1swXS5pc0xvY2tlZDtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoe1xuICAgICAgICAgICAgdHlwZTogJ3N0YXJ0JyxcbiAgICAgICAgICAgIGNvbHVtbnMsXG4gICAgICAgICAgICBsb2NrZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KHtcbiAgICAgICAgICAgIHR5cGU6ICd0cmlnZ2VyQXV0b0ZpdCcsXG4gICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgbG9ja2VkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdXRvRml0QmF0Y2goaW5mbywgb25Db21wbGV0ZSkge1xuICAgICAgICBjb25zdCBsb2NrZWQgPSBpbmZvLmxlbmd0aCA+IDAgPyBpbmZvWzBdLmNvbHVtbi5pc0xvY2tlZCA6IGZhbHNlO1xuICAgICAgICBjb25zdCBvYnNlcnZhYmxlcyA9IHRoaXMudGFibGVzXG4gICAgICAgICAgICAuZmlsdGVyKHRhYmxlID0+IHRhYmxlLmxvY2tlZCA9PT0gbG9ja2VkKVxuICAgICAgICAgICAgLm1hcCh0YWJsZSA9PiB0YWJsZS5hdXRvRml0KGluZm8pKTtcbiAgICAgICAgemlwKC4uLm9ic2VydmFibGVzKVxuICAgICAgICAgICAgLnBpcGUodGFrZSgxKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUod2lkdGhzID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBpbmZvLm1hcChpID0+IGkuY29sdW1uKSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXV0b0ZpdENvbXBsZXRlJyxcbiAgICAgICAgICAgICAgICB3aWR0aHMsXG4gICAgICAgICAgICAgICAgbG9ja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXRjaCA9IG51bGw7XG4gICAgfVxufTtcbkNvbHVtblJlc2l6aW5nU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgQ29sdW1uUmVzaXppbmdTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNGaWx0ZXJNZW51ID0gKHNldHRpbmdzKSA9PiB0eXBlb2Ygc2V0dGluZ3MgPT09ICdzdHJpbmcnICYmIHNldHRpbmdzLmluZGV4T2YoJ21lbnUnKSA+IC0xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc0ZpbHRlclJvdyA9IChzZXR0aW5ncykgPT4gc2V0dGluZ3MgPT09IHRydWUgfHwgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ3N0cmluZycgJiYgc2V0dGluZ3MuaW5kZXhPZigncm93JykgPiAtMSk7XG5cbmNvbnN0IGNvbnRhaW5zJDEgPSAobm9kZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGNsb3NlYCBldmVudCBvZiB0aGUgZmlsdGVyIGFuZCBjb2x1bW4tbWVudSBwb3B1cC5cbiAqL1xuY2xhc3MgUG9wdXBDbG9zZUV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBlO1xuICAgIH1cbn1cbmNvbnN0IERFRkFVTFRfUE9QVVBfQ0xBU1MgPSAnay1ncmlkLWZpbHRlci1wb3B1cCc7XG4vKipcbiAqIFRoZSBzZXJ2aWNlIHRoYXQgaXMgdXNlZCBmb3IgdGhlIHBvcHVwcyBvZiB0aGUgZmlsdGVyIGFuZCBjb2x1bW4gbWVudXNcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmV1c2FibGVjdXN0b21maWx0ZXJzX2dyaWQgJX0jdG9jLWZpbHRlci1tZW51LXdpdGgtcG9wdXApKS5cbiAqL1xubGV0IFNpbmdsZVBvcHVwU2VydmljZSA9IGNsYXNzIFNpbmdsZVBvcHVwU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlLCByZW5kZXJlciwgbmdab25lLCBzY3JvbGxTeW5jU2VydmljZSwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGZpbHRlciBvciBjb2x1bW4gbWVudXMgYXJlIGFib3V0IHRvIGNsb3NlIGJlY2F1c2UgdGhlIHVzZXIgY2xpY2tlZCBvdXRzaWRlIHRoZWlyIHBvcHVwcy5cbiAgICAgICAgICogVXNlZCB0byBwcmV2ZW50IHRoZSBwb3B1cCBmcm9tIGNsb3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbiA9IHNjcm9sbFN5bmNTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuZGVzdHJveSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9wZW4oYW5jaG9yLCB0ZW1wbGF0ZSwgcG9wdXBSZWYsIHBvcHVwQ2xhc3MgPSBERUZBVUxUX1BPUFVQX0NMQVNTKSB7XG4gICAgICAgIGNvbnN0IHRvZ2dsZSA9IGlzUHJlc2VudChwb3B1cFJlZikgJiYgdGhpcy5wb3B1cFJlZiA9PT0gcG9wdXBSZWY7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBpZiAoIXRvZ2dsZSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKHtcbiAgICAgICAgICAgICAgICBhbmNob3JBbGlnbjogeyB2ZXJ0aWNhbDogJ2JvdHRvbScsIGhvcml6b250YWw6IGRpcmVjdGlvbiB9LFxuICAgICAgICAgICAgICAgIHBvcHVwQWxpZ246IHsgdmVydGljYWw6ICd0b3AnLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgICAgICAgICAgICBwb3B1cENsYXNzOiBwb3B1cENsYXNzLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uTW9kZTogXCJhYnNvbHV0ZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50LCAnZGlyJywgdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gJ3J0bCcgOiAnbHRyJyk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaENsb3NlKGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdXBSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hDbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBkZXRhY2hDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xpY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2hDbG9zZShza2lwRWxlbWVudCkge1xuICAgICAgICB0aGlzLmRldGFjaENsb3NlKCk7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMucmVtb3ZlQ2xpY2sgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihcImRvY3VtZW50XCIsIFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghY29udGFpbnMkMShlLnRhcmdldCwgeCA9PiB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudCA9PT0geCB8fCB4ID09PSBza2lwRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gbmV3IFBvcHVwQ2xvc2VFdmVudChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UubmV4dChhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxufTtcblNpbmdsZVBvcHVwU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BvcHVwU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFNpbmdsZVBvcHVwU2VydmljZSk7XG5cbi8qIHRzbGludDpkaXNhYmxlOiBuby1iaXR3aXNlICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYXBwZW5kID0gKGVsZW1lbnQpID0+IHtcbiAgICBsZXQgYXBwZW5kZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWFwcGVuZGVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldERvY3VtZW50ID0gZWxlbWVudCA9PiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldFdpbmRvdyA9IGVsZW1lbnQgPT4gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG9mZnNldCA9IGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50VG9wLCBjbGllbnRMZWZ0IH0gPSBnZXREb2N1bWVudChlbGVtZW50KTtcbiAgICBjb25zdCB7IHBhZ2VZT2Zmc2V0LCBwYWdlWE9mZnNldCB9ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0IH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wICsgcGFnZVlPZmZzZXQgLSBjbGllbnRUb3AsXG4gICAgICAgIGxlZnQ6IGxlZnQgKyBwYWdlWE9mZnNldCAtIGNsaWVudExlZnRcbiAgICB9O1xufTtcbi8qKlxuICogQGhpZGRlblxuICogSWYgdGhlIHRhcmdldCBpcyBiZWZvcmUgdGhlIGRyYWdnYWJsZSBlbGVtZW50LCByZXR1cm5zIGB0cnVlYC5cbiAqXG4gKiBET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgPSA0XG4gKi9cbmNvbnN0IGlzVGFyZ2V0QmVmb3JlID0gKGRyYWdnYWJsZSwgdGFyZ2V0KSA9PiAodGFyZ2V0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGRyYWdnYWJsZSkgJiA0KSAhPT0gMDtcbi8qKlxuICogQGhpZGRlblxuICogSWYgdGhlIGNvbnRhaW5lciBhbmQgdGhlIGVsZW1lbnQgYXJlIHRoZSBzYW1lXG4gKiBvciBpZiB0aGUgY29udGFpbmVyIGhvbGRzIChjb250YWlucykgdGhlIGVsZW1lbnQsIHJldHVybnMgYHRydWVgLlxuICpcbiAqIERPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSA9IDE2XG4gKi9cbmNvbnN0IGNvbnRhaW5zJDIgPSAoZWxlbWVudCwgY29udGFpbmVyKSA9PiBlbGVtZW50ID09PSBjb250YWluZXIgfHxcbiAgICAoY29udGFpbmVyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQpICYgMTYpICE9PSAwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBvc2l0aW9uID0gKHRhcmdldCwgYmVmb3JlKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0UmVjdCA9IG9mZnNldCh0YXJnZXQpO1xuICAgIGNvbnN0IHsgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCB9ID0gdGFyZ2V0O1xuICAgIGNvbnN0IGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgKyAoYmVmb3JlID8gMCA6IG9mZnNldFdpZHRoKTtcbiAgICBjb25zdCB0b3AgPSB0YXJnZXRSZWN0LnRvcDtcbiAgICBjb25zdCBoZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XG4gICAgcmV0dXJuIHsgbGVmdCwgdG9wLCBoZWlnaHQgfTtcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRHJhZ0FuZERyb3BTZXJ2aWNlID0gY2xhc3MgRHJhZ0FuZERyb3BTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlciA9IFtdO1xuICAgICAgICB0aGlzLmxhc3RUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgICBhZGQodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIucHVzaCh0YXJnZXQpO1xuICAgIH1cbiAgICByZW1vdmUodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIgPSB0aGlzLnJlZ2lzdGVyLmZpbHRlcihjdXJyZW50ID0+IGN1cnJlbnQgIT09IHRhcmdldCk7XG4gICAgfVxuICAgIG5vdGlmeURyYWcoZHJhZ2dhYmxlLCBlbGVtZW50LCBtb3VzZUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0Rm9yKGVsZW1lbnQpO1xuICAgICAgICBpZiAodGhpcy5sYXN0VGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7XG4gICAgICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgICAgICBtb3VzZUV2ZW50LFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmxhc3RUYXJnZXQsXG4gICAgICAgICAgICB0eXBlOiAnbGVhdmUnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7XG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlLFxuICAgICAgICAgICAgICAgIG1vdXNlRXZlbnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdlbnRlcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFRhcmdldCA9IHRhcmdldDtcbiAgICB9XG4gICAgbm90aWZ5RHJvcChkcmFnZ2FibGUsIG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoe1xuICAgICAgICAgICAgZHJhZ2dhYmxlLFxuICAgICAgICAgICAgbW91c2VFdmVudCxcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5sYXN0VGFyZ2V0LFxuICAgICAgICAgICAgdHlwZTogJ2Ryb3AnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhc3RUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgICB0YXJnZXRGb3IoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBjb21wYXJlciA9IGNvbnRhaW5zJDIuYmluZChudWxsLCBlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXIuZmluZCgoeyBlbGVtZW50OiB7IG5hdGl2ZUVsZW1lbnQgfSB9KSA9PiBjb21wYXJlcihuYXRpdmVFbGVtZW50KSk7XG4gICAgfVxufTtcbkRyYWdBbmREcm9wU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgRHJhZ0FuZERyb3BTZXJ2aWNlKTtcblxuY29uc3QgdXBkYXRlQ2xhc3MgPSAoZWxlbWVudCwgdmFsaWQpID0+IHtcbiAgICBjb25zdCBpY29uID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuay1pY29uJyk7XG4gICAgaWNvbi5jbGFzc05hbWUgPSBpY29uLmNsYXNzTmFtZVxuICAgICAgICAucmVwbGFjZSgvKHBsdXN8Y2FuY2VsKS8sIHZhbGlkID8gJ3BsdXMnIDogJ2NhbmNlbCcpO1xufTtcbmNvbnN0IHVwZGF0ZUxvY2sgPSAoZWxlbWVudCwgbG9ja2VkID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IGljb24gPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5rLWljb24nKVsxXTtcbiAgICBjb25zdCB2YWx1ZSA9IGxvY2tlZCA9PSBudWxsID8gJycgOiAobG9ja2VkID8gJ2staS1sb2NrJyA6ICdrLWktdW5sb2NrJyk7XG4gICAgaWNvbi5jbGFzc05hbWUgPSBpY29uLmNsYXNzTmFtZVxuICAgICAgICAucmVwbGFjZSgvKGstaS11bmxvY2t8ay1pLWxvY2spLywgJycpICsgYCAke3ZhbHVlfWA7XG59O1xuY29uc3QgZGVjb3JhdGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ2staGVhZGVyIGstZHJhZy1jbHVlJztcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbGVtZW50LnN0eWxlLnpJbmRleCA9ICcyMDAwMCc7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEcmFnSGludFNlcnZpY2UgPSBjbGFzcyBEcmFnSGludFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNhbnRpemVyKSB7XG4gICAgICAgIHRoaXMuc2FudGl6ZXIgPSBzYW50aXplcjtcbiAgICB9XG4gICAgY3JlYXRlKHRpdGxlKSB7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGVjb3JhdGUodGhpcy5kb20pO1xuICAgICAgICBjb25zdCBzYWZlVGl0bGUgPSB0aGlzLnNhbnRpemVyLnNhbml0aXplKFNlY3VyaXR5Q29udGV4dC5IVE1MLCB0aXRsZSk7XG4gICAgICAgIHRoaXMuZG9tLmlubmVySFRNTCA9IGBcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstZHJhZy1zdGF0dXMgay1pLWNhbmNlbCBrLWljb24td2l0aC1tb2RpZmllclwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaWNvbi1tb2RpZmllclwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICR7c2FmZVRpdGxlfVxuICAgICAgICBgO1xuICAgIH1cbiAgICBhdHRhY2goKSB7XG4gICAgICAgIHJldHVybiBhcHBlbmQodGhpcy5kb20pO1xuICAgIH1cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbSAmJiB0aGlzLmRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKSk7XG4gICAgICAgICAgICB9KSh0aGlzLmRvbSk7IC8vIGhhY2sgZm9yIElFICsgcG9pbnRlciBldmVudHMhXG4gICAgICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICB1cGRhdGVDbGFzcyh0aGlzLmRvbSwgdHJ1ZSk7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHVwZGF0ZUNsYXNzKHRoaXMuZG9tLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlbW92ZUxvY2soKSB7XG4gICAgICAgIHVwZGF0ZUxvY2sodGhpcy5kb20pO1xuICAgIH1cbiAgICB0b2dnbGVMb2NrKGxvY2tlZCkge1xuICAgICAgICB1cGRhdGVMb2NrKHRoaXMuZG9tLCBsb2NrZWQpO1xuICAgIH1cbiAgICBtb3ZlKG1vdmUpIHtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUudG9wID0gbW92ZS5wYWdlWSArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLmxlZnQgPSBtb3ZlLnBhZ2VYICsgJ3B4JztcbiAgICB9XG59O1xuRHJhZ0hpbnRTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRG9tU2FuaXRpemVyXSlcbl0sIERyYWdIaW50U2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRHJvcEN1ZVNlcnZpY2UgPSBjbGFzcyBEcm9wQ3VlU2VydmljZSB7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9ICdrLWdyb3VwaW5nLWRyb3BjbHVlJztcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICAgIGF0dGFjaCgpIHtcbiAgICAgICAgcmV0dXJuIGFwcGVuZCh0aGlzLmRvbSk7XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMuZG9tLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcG9zaXRpb24oeyBsZWZ0LCB0b3AsIGhlaWdodCB9KSB7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZG9tLm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubGVmdCA9IGxlZnQgLSB3aWR0aCArICdweCc7XG4gICAgfVxufTtcbkRyb3BDdWVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBEcm9wQ3VlU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ29sdW1uUmVvcmRlclNlcnZpY2UgPSBjbGFzcyBDb2x1bW5SZW9yZGVyU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIHJlb3JkZXIoZSkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdChlKTtcbiAgICB9XG59O1xuQ29sdW1uUmVvcmRlclNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIENvbHVtblJlb3JkZXJTZXJ2aWNlKTtcblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgY29sdW1uUmVvcmRlcmAgZXZlbnQuXG4gKi9cbmNsYXNzIENvbHVtblJlb3JkZXJFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGNvbHVtbiwgbmV3SW5kZXgsIG9sZEluZGV4IH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgICAgICAgdGhpcy5vbGRJbmRleCA9IG9sZEluZGV4O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE5hdmlnYXRpb25NZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3IoZGF0YVJvd3MsIGhlYWRlclJvd3MsIGlzVmlydHVhbCwgaGFzUGFnZXIsIGhhc0RldGFpbFRlbXBsYXRlLCBncmlkRWxlbWVudCwgdmlydHVhbENvbHVtbnMsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5kYXRhUm93cyA9IGRhdGFSb3dzO1xuICAgICAgICB0aGlzLmhlYWRlclJvd3MgPSBoZWFkZXJSb3dzO1xuICAgICAgICB0aGlzLmlzVmlydHVhbCA9IGlzVmlydHVhbDtcbiAgICAgICAgdGhpcy5oYXNQYWdlciA9IGhhc1BhZ2VyO1xuICAgICAgICB0aGlzLmhhc0RldGFpbFRlbXBsYXRlID0gaGFzRGV0YWlsVGVtcGxhdGU7XG4gICAgICAgIHRoaXMuZ3JpZEVsZW1lbnQgPSBncmlkRWxlbWVudDtcbiAgICAgICAgdGhpcy52aXJ0dWFsQ29sdW1ucyA9IHZpcnR1YWxDb2x1bW5zO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgIH1cbiAgICBnZXQgbWF4TG9naWNhbFJvd0luZGV4KCkge1xuICAgICAgICBjb25zdCBkYXRhUm93cyA9IHRoaXMuaGFzRGV0YWlsVGVtcGxhdGUgPyB0aGlzLmRhdGFSb3dzICogMiA6IHRoaXMuZGF0YVJvd3M7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlclJvd3MgKyBkYXRhUm93cyAtIDE7XG4gICAgfVxufVxuXG5jb25zdCBOT19TVElDS1kgPSB7IGxlZnQ6ICcwcHgnLCByaWdodDogJzBweCcgfTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ29sdW1uSW5mb1NlcnZpY2UgPSBjbGFzcyBDb2x1bW5JbmZvU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubG9ja2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN0aWNreUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5SYW5nZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ29udGFpbmVyID0gbmV3IENvbHVtbnNDb250YWluZXIoKCkgPT4gW10pO1xuICAgIH1cbiAgICBnZXQgbG9ja2VkTGVhZkNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIubG9ja2VkTGVhZkNvbHVtbnM7XG4gICAgfVxuICAgIGdldCBub25Mb2NrZWRMZWFmQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc0NvbnRhaW5lci5ub25Mb2NrZWRMZWFmQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrZWRMZWFmQ29sdW1ucy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgdG90YWxMZXZlbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIudG90YWxMZXZlbHM7XG4gICAgfVxuICAgIGdldCBoaWRkZW5Db2x1bW5zKCkge1xuICAgICAgICBpZiAoIXRoaXMubGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QoKS5maWx0ZXIoY29sdW1uID0+ICFjb2x1bW4uaXNWaXNpYmxlKTtcbiAgICB9XG4gICAgZ2V0IGxlYWZOYW1lZENvbHVtbnMoKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBleHBhbmRDb2x1bW5zKHRoaXMubGlzdCgpLmZpbHRlclNvcnQoY29sdW1uID0+ICFjb2x1bW4uaXNDb2x1bW5Hcm91cCkpXG4gICAgICAgICAgICAuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4ubWF0Y2hlc01lZGlhICYmIGNvbHVtbi5kaXNwbGF5VGl0bGUpO1xuICAgICAgICByZXR1cm4gb3JkZXJCeShjb2x1bW5zLCBbeyBmaWVsZDogJ2xvY2tlZCcsIGRpcjogJ2Rlc2MnIH1dKTtcbiAgICB9XG4gICAgZ2V0IHVubG9ja2VkUm9vdENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0KCkucm9vdENvbHVtbnMoKS5maWx0ZXIoY29sdW1uID0+ICFjb2x1bW4ubG9ja2VkICYmIGNvbHVtbi5pc1Zpc2libGUpLmxlbmd0aDtcbiAgICB9XG4gICAgc3RpY2t5Q29sdW1uc1N0eWxlcyhjb2x1bW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0aWNreUNvbHVtbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RpY2t5Q29sdW1ucyA9IHRoaXMubGlzdCgpLnJvb3RDb2x1bW5zKCkuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uc3RpY2t5ICYmICFjb2x1bW4ubG9ja2VkICYmIGNvbHVtbi5pc1Zpc2libGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0aWNreUNvbHVtbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTk9fU1RJQ0tZO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RpY2t5Q29sdW1ucy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICAgICAgaWYgKGN1cnIubGVhZkluZGV4IDwgY29sdW1uLmxlYWZJbmRleCkge1xuICAgICAgICAgICAgICAgIGFjYy5sZWZ0ICs9IGN1cnIud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyLmxlYWZJbmRleCA+IGNvbHVtbi5sZWFmSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBhY2MucmlnaHQgKz0gY3Vyci53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHsgbGVmdDogMCwgcmlnaHQ6IDAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBgJHtyZXN1bHQubGVmdH1weGAsXG4gICAgICAgICAgICByaWdodDogYCR7cmVzdWx0LnJpZ2h0fXB4YFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0KGNvbHVtbnMsIGxpc3QpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ29udGFpbmVyID0gY29sdW1ucztcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5zdGlja3lDb2x1bW5zID0gbnVsbDtcbiAgICB9XG4gICAgY2hhbmdlVmlzaWJpbGl0eShjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuc3RpY2t5Q29sdW1ucyA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZS5lbWl0KGNvbHVtbnMpO1xuICAgIH1cbiAgICBjaGFuZ2VMb2NrZWQoY29sdW1ucykge1xuICAgICAgICB0aGlzLnN0aWNreUNvbHVtbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmxvY2tlZENoYW5nZS5lbWl0KGNvbHVtbnMpO1xuICAgIH1cbiAgICBjaGFuZ2VTdHVjayhjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuc3RpY2t5Q29sdW1ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RpY2t5Q2hhbmdlLmVtaXQoY29sdW1ucyk7XG4gICAgfVxufTtcbkNvbHVtbkluZm9TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBDb2x1bW5JbmZvU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTb3J0U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIHNvcnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQodmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgY29sdW1uVmlzaWJpbGl0eUNoYW5nZWAgZXZlbnQuXG4gKi9cbmNsYXNzIENvbHVtblZpc2liaWxpdHlDaGFuZ2VFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGNvbHVtbkxvY2tlZENoYW5nZWAgZXZlbnQuXG4gKi9cbmNsYXNzIENvbHVtbkxvY2tlZENoYW5nZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29sdW1ucykge1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEdST1VQX0NFTExfV0lEVEggPSAzMjsgLy8gdGhpcyBzaG91bGQgYmUgdGhlIHZhbHVlIG9mIGdyb3VwLWNlbGwgaW5zaWRlIHRoZSB0aGVtZSFcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBSRVNQT05TSVZFX0JSRUFLUE9JTlRfTUVESVVNID0gNjAwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFJFU1BPTlNJVkVfQlJFQUtQT0lOVF9MQVJHRSA9IDc2ODtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRUcmFja0J5KGluZGV4LCBpdGVtKSB7XG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2RhdGEnICYmIGl0ZW0uaXNFZGl0aW5nKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgY29sdW1uU3RpY2t5Q2hhbmdlYCBldmVudC5cbiAqL1xuY2xhc3MgQ29sdW1uU3RpY2t5Q2hhbmdlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHZpcnR1YWwgc2Nyb2xsaW5nIGNlbGwgdGVtcGxhdGUgb2YgdGhlIEdyaWQgd2hpbGUgbG9hZGluZyBuZXcgZGF0YS4gUHJvdmlkZXMgYW4gb3B0aW9uIHRvIGN1c3RvbWl6ZSB0aGVcbiAqIGFwcGVhcmFuY2Ugb2YgdGhlIGluZGljYXRvciB0aGF0IGlzIGRpc3BsYXllZCB3aGlsZSBuZXcgZGF0YSBpcyBsb2FkaW5nLiBUbyBkZWZpbmUgdGhlIGxvYWRpbmcgY2VsbCB0ZW1wbGF0ZSxcbiAqIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9HcmlkQ2VsbExvYWRpbmdUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBgPGtlbmRvLWdyaWQ+YCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHZpcnR1YWxzY3JvbGxpbmdfZ3JpZCAlfSN0b2MtY3VzdG9tLWxvYWRpbmctc2tlbGV0b24pKS5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgY29sdW1uLCBhbmQgdXRpbGl6ZXMgdGhlIGBsZXQteGAgc3ludGF4Jm1kYXNoO2ZvciBleGFtcGxlLCBgbGV0LWNvbHVtbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogICAgICAgPGtlbmRvLWdyaWQgW2RhdGFdPVwiZGF0YVwiIHNjcm9sbGFibGU9XCJ2aXJ0dWFsXCIgW3Jvd0hlaWdodF09XCIzNlwiPlxuICogICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkQ2VsbExvYWRpbmdUZW1wbGF0ZSBsZXQtY29sdW1uPlxuICogICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiBgYGBcbiAqL1xubGV0IENlbGxMb2FkaW5nVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBDZWxsTG9hZGluZ1RlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkNlbGxMb2FkaW5nVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRDZWxsTG9hZGluZ1RlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgQ2VsbExvYWRpbmdUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxvYWRpbmcgdGVtcGxhdGUgdGhhdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgbG9hZGluZyBpbmRpY2F0b3Igb2YgdGhlIEdyaWQgQ29tcG9uZW50LlxuICogVG8gZGVmaW5lIGEgbG9hZGluZyB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb0dyaWRMb2FkaW5nVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tZ3JpZD5gIHRhZ1xuICogW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGFiaW5kaW5nX2dyaWQgJX0jdG9jLWxvYWRpbmctdGVtcGxhdGUpLlxuICovXG5sZXQgTG9hZGluZ1RlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgTG9hZGluZ1RlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkxvYWRpbmdUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZExvYWRpbmdUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBMb2FkaW5nVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG5jb25zdCBjcmVhdGVDb250cm9sID0gKHNvdXJjZSkgPT4gKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSBuZXcgRm9ybUNvbnRyb2woc291cmNlW2tleV0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuY29uc3QgdmFsaWRhdGVDb2x1bW5zRmllbGQgPSAoY29sdW1ucykgPT4gZXhwYW5kQ29sdW1ucyhjb2x1bW5zLnRvQXJyYXkoKSlcbiAgICAuZmlsdGVyKGlzQ29sdW1uQ29tcG9uZW50KVxuICAgIC5maWx0ZXIoKHsgZmllbGQgfSkgPT4gIWlzVmFsaWRGaWVsZE5hbWUoZmllbGQpKVxuICAgIC5mb3JFYWNoKCh7IGZpZWxkIH0pID0+IGNvbnNvbGUud2FybihgXG4gICAgICAgICAgICAgICAgR3JpZCBjb2x1bW4gZmllbGQgbmFtZSAnJHtmaWVsZH0nIGRvZXMgbm90IGxvb2sgbGlrZSBhIHZhbGlkIEphdmFTY3JpcHQgaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICBJZGVudGlmaWVycyBjYW4gY29udGFpbiBvbmx5IGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIChpbmNsdWRpbmcgXCIkXCIgb3IgXCJfXCIpLCBhbmQgbWF5IG5vdCBzdGFydCB3aXRoIGEgZGlnaXQuXG4gICAgICAgICAgICAgICAgUGxlYXNlIHVzZSBvbmx5IHZhbGlkIGlkZW50aWZpZXIgbmFtZXMgdG8gZW5zdXJlIGVycm9yLWZyZWUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgYCkpO1xuY29uc3QgaGFuZGxlRXhwYW5kQ29sbGFwc2VHcm91cHNTZXJ2aWNlID0gKHNlcnZpY2UsIGV4cGFuZEVtaXR0ZXIsIGNvbGxhcHNlRW1pdHRlciwgbWFwJCQxKSA9PiAoc2VydmljZS5jaGFuZ2VzLnBpcGUoZmlsdGVyKCh7IGdyb3VwIH0pID0+IGlzUHJlc2VudChncm91cCkpKVxuICAgIC5zdWJzY3JpYmUoKHgpID0+IHguZXhwYW5kID8gZXhwYW5kRW1pdHRlci5lbWl0KG1hcCQkMSh4KSkgOiBjb2xsYXBzZUVtaXR0ZXIuZW1pdChtYXAkJDEoeCkpKSk7XG5jb25zdCBoYW5kbGVFeHBhbmRDb2xsYXBzZURldGFpbHNTZXJ2aWNlID0gKHNlcnZpY2UsIGV4cGFuZEVtaXR0ZXIsIGNvbGxhcHNlRW1pdHRlciwgbWFwJCQxKSA9PiAoc2VydmljZS5jaGFuZ2VzLnBpcGUoZmlsdGVyKCh7IGRhdGFJdGVtIH0pID0+IGlzUHJlc2VudChkYXRhSXRlbSkpKVxuICAgIC5zdWJzY3JpYmUoKHgpID0+IHguZXhwYW5kID8gZXhwYW5kRW1pdHRlci5lbWl0KG1hcCQkMSh4KSkgOiBjb2xsYXBzZUVtaXR0ZXIuZW1pdChtYXAkJDEoeCkpKSk7XG5jb25zdCBpc0luRWRpdGVkQ2VsbCA9IChlbGVtZW50LCBncmlkRWxlbWVudCkgPT4gY2xvc2VzdChlbGVtZW50LCBtYXRjaGVzQ2xhc3Nlcygnay1ncmlkLWVkaXQtY2VsbCcpKSAmJlxuICAgIGNsb3Nlc3QoZWxlbWVudCwgbWF0Y2hlc05vZGVOYW1lKCdrZW5kby1ncmlkJykpID09PSBncmlkRWxlbWVudDtcbmNvbnN0IMm1NSQxID0gRU1QVFlfQ0VMTF9DT05URVhUO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBLZW5kbyBVSSBHcmlkIGNvbXBvbmVudCBmb3IgQW5ndWxhci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJncmlkRGF0YVwiPlxuICogICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgcHVibGljIGdyaWREYXRhOiBhbnlbXSA9IHByb2R1Y3RzO1xuICogfVxuICpcbiAqIGNvbnN0IHByb2R1Y3RzID0gW3tcbiAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICogICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAqICB9LCB7XG4gKiAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gKiAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAqICB9XG4gKiBdO1xuICogYGBgXG4gKi9cbmxldCBHcmlkQ29tcG9uZW50ID0gY2xhc3MgR3JpZENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3VwcG9ydFNlcnZpY2UsIHNlbGVjdGlvblNlcnZpY2UsIGNlbGxTZWxlY3Rpb25TZXJ2aWNlLCB3cmFwcGVyLCBncm91cEluZm9TZXJ2aWNlLCBncm91cHNTZXJ2aWNlLCBjaGFuZ2VOb3RpZmljYXRpb24sIGRldGFpbHNTZXJ2aWNlLCBlZGl0U2VydmljZSwgZmlsdGVyU2VydmljZSwgcGRmU2VydmljZSwgcmVzcG9uc2l2ZVNlcnZpY2UsIHJlbmRlcmVyLCBleGNlbFNlcnZpY2UsIG5nWm9uZSwgc2Nyb2xsU3luY1NlcnZpY2UsIGRvbUV2ZW50cywgY29sdW1uUmVzaXppbmdTZXJ2aWNlLCBjaGFuZ2VEZXRlY3RvclJlZiwgY29sdW1uUmVvcmRlclNlcnZpY2UsIGNvbHVtbkluZm9TZXJ2aWNlLCBuYXZpZ2F0aW9uU2VydmljZSwgc29ydFNlcnZpY2UsIHNjcm9sbFJlcXVlc3RTZXJ2aWNlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5zdXBwb3J0U2VydmljZSA9IHN1cHBvcnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNlbGxTZWxlY3Rpb25TZXJ2aWNlID0gY2VsbFNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIHRoaXMuZ3JvdXBJbmZvU2VydmljZSA9IGdyb3VwSW5mb1NlcnZpY2U7XG4gICAgICAgIHRoaXMuZ3JvdXBzU2VydmljZSA9IGdyb3Vwc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hhbmdlTm90aWZpY2F0aW9uID0gY2hhbmdlTm90aWZpY2F0aW9uO1xuICAgICAgICB0aGlzLmRldGFpbHNTZXJ2aWNlID0gZGV0YWlsc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UgPSBlZGl0U2VydmljZTtcbiAgICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlID0gZmlsdGVyU2VydmljZTtcbiAgICAgICAgdGhpcy5wZGZTZXJ2aWNlID0gcGRmU2VydmljZTtcbiAgICAgICAgdGhpcy5yZXNwb25zaXZlU2VydmljZSA9IHJlc3BvbnNpdmVTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZXhjZWxTZXJ2aWNlID0gZXhjZWxTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZSA9IHNjcm9sbFN5bmNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IGRvbUV2ZW50cztcbiAgICAgICAgdGhpcy5jb2x1bW5SZXNpemluZ1NlcnZpY2UgPSBjb2x1bW5SZXNpemluZ1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYgPSBjaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgdGhpcy5jb2x1bW5SZW9yZGVyU2VydmljZSA9IGNvbHVtblJlb3JkZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlID0gY29sdW1uSW5mb1NlcnZpY2U7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5zb3J0U2VydmljZSA9IHNvcnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNjcm9sbFJlcXVlc3RTZXJ2aWNlID0gc2Nyb2xsUmVxdWVzdFNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGF0YSBvZiB0aGUgR3JpZC4gSWYgYW4gYXJyYXkgaXMgcHJvdmlkZWQsIHRoZSBHcmlkIGF1dG9tYXRpY2FsbHkgZ2V0cyB0aGUgdG90YWwgY291bnRcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIGRhdGFiaW5kaW5nX2dyaWQgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgc2Nyb2xsIG1vZGUgdXNlZCBieSB0aGUgR3JpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgICAgICogIC0gYG5vbmVgJm1kYXNoO1JlbmRlcnMgbm8gc2Nyb2xsYmFyLlxuICAgICAgICAgKiAgLSBgc2Nyb2xsYWJsZWAmbWRhc2g7VGhlIGRlZmF1bHQgc2Nyb2xsIG1vZGUuIEl0IHJlcXVpcmVzIHRoZSBzZXR0aW5nIG9mIHRoZSBgaGVpZ2h0YCBvcHRpb24uXG4gICAgICAgICAqICAtIGB2aXJ0dWFsYCZtZGFzaDtEaXNwbGF5cyBubyBwYWdlciBhbmQgcmVuZGVycyBhIHBvcnRpb24gb2YgdGhlIGRhdGEgKG9wdGltaXplZCByZW5kZXJpbmcpIHdoaWxlIHRoZSB1c2VyIGlzIHNjcm9sbGluZyB0aGUgY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZSA9ICdzY3JvbGxhYmxlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIHNpbmdsZS1yb3cgW3NlbGVjdGlvbl0oeyUgc2x1ZyBzZWxlY3Rpb25fZ3JpZCAlfSkgb2YgdGhlIEdyaWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGhvdyB0byB0cmFjayBjaGFuZ2VzIGZvciB0aGUgZGF0YSByb3dzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgR3JpZCB0cmFja3MgY2hhbmdlcyBieSB0aGUgaW5kZXggb2YgdGhlIGRhdGEgaXRlbS5cbiAgICAgICAgICogRWRpdGVkIHJvd3MgYXJlIHRyYWNrZWQgYnkgcmVmZXJlbmNlLlxuICAgICAgICAgKiBJbiBzb21lIGNhc2VzLCB5b3UgbWlnaHQgbmVlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvcixcbiAgICAgICAgICogZm9yIGV4YW1wbGUsIHdoZW4geW91IGltcGxlbWVudCBlZGl0aW5nIHdpdGggaW1tdXRhYmxlIGRhdGEgaXRlbXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZW1vbnN0cmF0ZXMgaG93IHRvIHRyYWNrIGl0ZW1zIG9ubHkgYnkgaW5kZXguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAgICAgKiBpbXBvcnQgeyBHcmlkSXRlbSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWdyaWQnO1xuICAgICAgICAgKlxuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICogICAgICAgIDxrZW5kby1ncmlkIFtkYXRhXT1cImdyaWREYXRhXCIgW3RyYWNrQnldPVwidHJhY2tCeVwiPlxuICAgICAgICAgKiAgICAgICAgPC9rZW5kby1ncmlkPlxuICAgICAgICAgKiAgICBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgIHB1YmxpYyBncmlkRGF0YTogYW55W10gPSBwcm9kdWN0cztcbiAgICAgICAgICpcbiAgICAgICAgICogICAgcHVibGljIHRyYWNrQnkoaW5kZXg6IG51bWJlciwgaXRlbTogR3JpZEl0ZW0pOiBhbnkge1xuICAgICAgICAgKiAgICAgICAgY29uc29sZS5sb2coaXRlbSk7XG4gICAgICAgICAqICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAqICAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBwcm9kdWN0cyA9IFt7XG4gICAgICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICAgICAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gICAgICAgICAqICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gICAgICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgICAgICogIH0sIHtcbiAgICAgICAgICogICAgXCJQcm9kdWN0SURcIjogMixcbiAgICAgICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICAgICAqICAgIFwiVW5pdFByaWNlXCI6IDE5LjAwMDAsXG4gICAgICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gICAgICAgICAqICB9XG4gICAgICAgICAqIF07XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja0J5ID0gZGVmYXVsdFRyYWNrQnk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCB0aGUgZ3JpZCB3aWxsIHJlbmRlciBvbmx5IHRoZSBjb2x1bW5zIGluIHRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aXJ0dWFsQ29sdW1ucyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcyB0aGUgW2ZpbHRlcmluZ10oeyUgc2x1ZyBmaWx0ZXJpbmdfZ3JpZCAlfSkgb2YgdGhlIEdyaWQgY29sdW1ucyB0aGF0IGhhdmUgdGhlaXIgYGZpZWxkYCBvcHRpb24gc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBbc29ydGluZ10oeyUgc2x1ZyBzb3J0aW5nX2dyaWQgJX0pIG9mIHRoZSBHcmlkIGNvbHVtbnMgdGhhdCBoYXZlIHRoZWlyIGBmaWVsZGAgb3B0aW9uIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyZXMgdGhlIHBhZ2VyIG9mIHRoZSBHcmlkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGFnaW5nX2dyaWQgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgICAgICogLSBgYnV0dG9uQ291bnQ6IE51bWJlcmAmbWRhc2g7U2V0cyB0aGUgbWF4aW11bSBudW1lcmljIGJ1dHRvbnMgY291bnQgYmVmb3JlIHRoZSBidXR0b25zIGFyZSBjb2xsYXBzZWQuIERlZmF1bHRzIHRvIGAxMGAuXG4gICAgICAgICAqIC0gYGluZm86IEJvb2xlYW5gJm1kYXNoO1RvZ2dsZXMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHBhZ2UgYW5kIHRoZSB0b3RhbCBudW1iZXIgb2YgcmVjb3Jkcy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgICAgICAgKiAtIGB0eXBlOiBQYWdlclR5cGVgJm1kYXNoO0FjY2VwdHMgdGhlIGBudW1lcmljYCAoYnV0dG9ucyB3aXRoIG51bWJlcnMpIGFuZCBgaW5wdXRgIChpbnB1dCBmb3IgdHlwaW5nIHRoZSBwYWdlIG51bWJlcikgdmFsdWVzLiBEZWZhdWx0cyB0byBgJ251bWVyaWMnYC5cbiAgICAgICAgICogLSBgcGFnZVNpemVzOiBCb29sZWFuYCBvciBgQXJyYXk8bnVtYmVyPmAmbWRhc2g7U2hvd3MgYSBtZW51IGZvciBzZWxlY3RpbmcgdGhlIHBhZ2Ugc2l6ZS4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAgICogLSBgcHJldmlvdXNOZXh0OiBCb29sZWFuYCZtZGFzaDtUb2dnbGVzIHRoZSAqKlByZXZpb3VzKiogYW5kICoqTmV4dCoqIGJ1dHRvbnMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAgICAgICogLSBgcmVzcG9uc2l2ZTogQm9vbGVhbmAmbWRhc2g7VG9nZ2xlcyB0aGUgYnVpbHQtaW4gcmVzcG9uc2l2ZSBiZWhhdmlvciBvZiB0aGUgUGFnZXIuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFnZWFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB1c2VyIGNhbiBncm91cCB0aGUgR3JpZCBieSBkcmFnZ2luZyB0aGUgY29sdW1uIGhlYWRlciBjZWxscy5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgZ3JvdXBpbmcgaXMgZGlzYWJsZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBncm91cGluZ2Jhc2ljc19ncmlkICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwYWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHVzZXIgY2FuIHVzZSBkZWRpY2F0ZWQgc2hvcnRjdXRzIHRvIGludGVyYWN0IHdpdGggdGhlIEdyaWQuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIG5hdmlnYXRpb24gaXMgZGlzYWJsZWQgYW5kIHRoZSBHcmlkIGNvbnRlbnQgaXMgYWNjZXNzaWJsZSBpbiB0aGUgbm9ybWFsIHRhYiBzZXF1ZW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmF2aWdhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgR3JpZCBjb2x1bW5zIHdpbGwgYmUgcmVzaXplZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24gc28gdGhhdFxuICAgICAgICAgKiB0aGV5IGZpdCB0aGVpciBoZWFkZXJzIGFuZCByb3cgY29udGVudC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAgICogQ29sdW1ucyB3aXRoIGBhdXRvU2l6ZWAgc2V0IHRvIGBmYWxzZWAgYXJlIGV4Y2x1ZGVkLlxuICAgICAgICAgKiBUbyBkeW5hbWljYWxseSB1cGRhdGUgdGhlIGNvbHVtbiB3aWR0aCB0byBtYXRjaCB0aGUgbmV3IGNvbnRlbnQsXG4gICAgICAgICAqIHJlZmVyIHRvIFt0aGlzIGV4YW1wbGVdKHslIHNsdWcgcmVzaXppbmdfY29sdW1uc19ncmlkICV9KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b1NpemUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB1c2VyIGNhbiByZXNpemUgY29sdW1ucyBieSBkcmFnZ2luZyB0aGUgZWRnZXMgKHJlc2l6ZSBoYW5kbGVzKSBvZiB0aGVpciBoZWFkZXIgY2VsbHNcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZXNpemluZ19jb2x1bW5zX2dyaWQgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXphYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCB0aGUgdXNlciBjYW4gcmVvcmRlciBjb2x1bW5zIGJ5IGRyYWdnaW5nIHRoZWlyIGhlYWRlciBjZWxsc1xuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlb3JkZXJpbmdfY29sdW1uc19ncmlkICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlb3JkZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIG9mIHRoZSBHcmlkIHdpbGwgYmUgZGlzcGxheWVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0YWJpbmRpbmdfZ3JpZCAlfSkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGNvbHVtbiBtZW51IG9mIHRoZSBjb2x1bW5zIHdpbGwgYmUgZGlzcGxheWVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sdW1ubWVudV9ncmlkICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbk1lbnUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgaGVhZGVyIG9mIHRoZSBncmlkIHdpbGwgYmUgaGlkZGVuLiBUaGUgaGVhZGVyIGlzIHZpc2libGUgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUaGUgaGVhZGVyIGluY2x1ZGVzIGNvbHVtbiBoZWFkZXJzIGFuZCB0aGUgW2ZpbHRlciByb3ddKHslIHNsdWcgZmlsdGVyaW5nX2dyaWQgJX0jdG9jLWZpbHRlci1yb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWRlSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBHcmlkIGZpbHRlciBpcyBtb2RpZmllZCB0aHJvdWdoIHRoZSBVSS5cbiAgICAgICAgICogWW91IGhhdmUgdG8gaGFuZGxlIHRoZSBldmVudCB5b3Vyc2VsZiBhbmQgZmlsdGVyIHRoZSBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwYWdlIG9mIHRoZSBHcmlkIGlzIGNoYW5nZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwYWdpbmdfZ3JpZCAlfSkpLlxuICAgICAgICAgKiBZb3UgaGF2ZSB0byBoYW5kbGUgdGhlIGV2ZW50IHlvdXJzZWxmIGFuZCBwYWdlIHRoZSBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZ3JvdXBpbmcgb2YgdGhlIEdyaWQgaXMgY2hhbmdlZC5cbiAgICAgICAgICogWW91IGhhdmUgdG8gaGFuZGxlIHRoZSBldmVudCB5b3Vyc2VsZiBhbmQgZ3JvdXAgdGhlIGRhdGEgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBncm91cGluZ2Jhc2ljc19ncmlkICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwQ2hhbmdlID0gbmV3IFpvbmVBd2FyZUV2ZW50RW1pdHRlcih0aGlzLm5nWm9uZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBzb3J0aW5nIG9mIHRoZSBHcmlkIGlzIGNoYW5nZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzb3J0aW5nX2dyaWQgJX0pKS5cbiAgICAgICAgICogWW91IGhhdmUgdG8gaGFuZGxlIHRoZSBldmVudCB5b3Vyc2VsZiBhbmQgc29ydCB0aGUgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIEdyaWQgcm93LlxuICAgICAgICAgKiBFbWl0cyB0aGUgW1NlbGVjdGlvbkV2ZW50XSh7JSBzbHVnIGFwaV9ncmlkX3NlbGVjdGlvbmV2ZW50ICV9I3RvYy1zZWxlY3Rpb25jaGFuZ2UpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBkYXRhIHN0YXRlIG9mIHRoZSBHcmlkIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFTdGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgZXhwYW5kcyBhIGdyb3VwIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXBFeHBhbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNvbGxhcHNlcyBhIGdyb3VwIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXBDb2xsYXBzZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgZXhwYW5kcyBhIG1hc3RlciByb3cuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRldGFpbEV4cGFuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY29sbGFwc2VzIGEgbWFzdGVyIHJvdy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGV0YWlsQ29sbGFwc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgKipFZGl0KiogY29tbWFuZCBidXR0b24gdG8gZWRpdCBhIHJvd1xuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfZ3JpZCAlfSN0b2MtZWRpdGluZy1yZWNvcmRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgKipDYW5jZWwqKiBjb21tYW5kIGJ1dHRvbiB0byBjbG9zZSBhIHJvd1xuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfZ3JpZCAlfSN0b2MtY2FuY2VsbGluZy1lZGl0aW5nKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSAqKlNhdmUqKiBjb21tYW5kIGJ1dHRvbiB0byBzYXZlIGNoYW5nZXMgaW4gYSByb3dcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RlbXBsYXRlX2Zvcm1zX2dyaWQgJX0jdG9jLXNhdmluZy1yZWNvcmRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgKipSZW1vdmUqKiBjb21tYW5kIGJ1dHRvbiB0byByZW1vdmUgYSByb3dcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RlbXBsYXRlX2Zvcm1zX2dyaWQgJX0jdG9jLXJlbW92aW5nLXJlY29yZHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlICoqQWRkKiogY29tbWFuZCBidXR0b24gdG8gYWRkIGEgbmV3IHJvd1xuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfZ3JpZCAlfSN0b2MtYWRkaW5nLXJlY29yZHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBsZWF2ZXMgYW4gZWRpdGVkIGNlbGwgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX2luY2VsbF9ncmlkICV9I3RvYy1iYXNpYy1jb25jZXB0cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZWxsQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhIGNlbGwgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX2luY2VsbF9ncmlkICV9I3RvYy1iYXNpYy1jb25jZXB0cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZWxsQ2xpY2sgPSBuZXcgWm9uZUF3YXJlRXZlbnRFbWl0dGVyKHRoaXMubmdab25lKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSAqKkV4cG9ydCB0byBQREYqKiBjb21tYW5kIGJ1dHRvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGRmRXhwb3J0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlICoqRXhwb3J0IHRvIEV4Y2VsKiogY29tbWFuZCBidXR0b24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4Y2VsRXhwb3J0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIHJlc2l6aW5nIG9mIHRoZSBjb2x1bW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtblJlc2l6ZSA9IG5ldyBab25lQXdhcmVFdmVudEVtaXR0ZXIodGhpcy5uZ1pvbmUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIHJlb3JkZXJpbmcgb2YgdGhlIGNvbHVtbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sdW1uUmVvcmRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2hhbmdlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgY29sdW1ucyBmcm9tIHRoZSBjb2x1bW4gbWVudSBvciBjb2x1bW4gY2hvb3Nlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sdW1uVmlzaWJpbGl0eUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2hhbmdlcyB0aGUgbG9ja2VkIHN0YXRlIG9mIHRoZSBjb2x1bW5zIGZyb20gdGhlIGNvbHVtbiBtZW51IG9yIGJ5IHJlb3JkZXJpbmcgdGhlIGNvbHVtbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbkxvY2tlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2hhbmdlcyB0aGUgc3RpY2t5IHN0YXRlIG9mIHRoZSBjb2x1bW5zIGZyb20gdGhlIGNvbHVtbiBtZW51LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5TdGlja3lDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgdG8gdGhlIGxhc3QgcmVjb3JkIG9uIHRoZSBwYWdlIGFuZCBlbmFibGVzIGVuZGxlc3Mgc2Nyb2xsaW5nXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2Nyb2xsbW1vZGVzX2dyaWQgJX0jdG9jLWVuZGxlc3Mtc2Nyb2xsaW5nKSkuXG4gICAgICAgICAqIFlvdSBoYXZlIHRvIGhhbmRsZSB0aGUgZXZlbnQgeW91cnNlbGYgYW5kIHBhZ2UgdGhlIGRhdGEuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbEJvdHRvbSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGdyaWQgY29udGVudCBpcyBzY3JvbGxlZC5cbiAgICAgICAgICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQgb3V0c2lkZSB0aGUgQW5ndWxhciB6b25lLiBFbnRlciB0aGUgQW5ndWxhciB6b25lIGlmIHlvdSBtYWtlIGFueSBjaGFuZ2VzIHRoYXQgcmVxdWlyZSBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZW50U2Nyb2xsID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBxdWVyeSBsaXN0IG9mIGFsbCBkZWNsYXJlZCBjb2x1bW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLmZvb3RlciA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25EaXJlY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ29udGFpbmVyID0gbmV3IENvbHVtbnNDb250YWluZXIoKCkgPT4gdGhpcy5jb2x1bW5MaXN0LmZpbHRlckhpZXJhcmNoeShjb2x1bW4gPT4ge1xuICAgICAgICAgICAgY29sdW1uLm1hdGNoZXNNZWRpYSA9IHRoaXMubWF0Y2hlc01lZGlhKGNvbHVtbik7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uLmlzVmlzaWJsZTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YUNvbGxlY3Rpb24oKCkgPT4gbmV3IERhdGFSZXN1bHRJdGVyYXRvcih0aGlzLmRhdGEsIHRoaXMuc2tpcCwgdGhpcy5oYXNHcm91cEZvb3RlcnMpKTtcbiAgICAgICAgdGhpcy5zaG91bGRHZW5lcmF0ZUNvbHVtbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zb3J0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuX2dyb3VwID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuX3NraXAgPSAwO1xuICAgICAgICB0aGlzLmNhY2hlZFdpbmRvd1dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fcm93U2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jZWxsU2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLnJ0bCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yb3dDbGFzcyA9ICgpID0+IG51bGw7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJ0bCA9IHJ0bDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncm91cEluZm9TZXJ2aWNlLnJlZ2lzdGVyQ29sdW1uc0NvbnRhaW5lcigoKSA9PiB0aGlzLmNvbHVtbkxpc3QpO1xuICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLmluaXQodGhpcy5jb2x1bW5zQ29udGFpbmVyLCAoKSA9PiB0aGlzLmNvbHVtbkxpc3QpO1xuICAgICAgICB0aGlzLmNvbHVtblZpc2liaWxpdHlDaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLnZpc2liaWxpdHlDaGFuZ2Uuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtblZpc2liaWxpdHlDaGFuZ2UuZW1pdChuZXcgQ29sdW1uVmlzaWJpbGl0eUNoYW5nZUV2ZW50KGNoYW5nZWQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29sdW1uTG9ja2VkQ2hhbmdlU3Vic2NyaXB0aW9uID0gdGhpcy5jb2x1bW5JbmZvU2VydmljZS5sb2NrZWRDaGFuZ2Uuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkxvY2tlZENoYW5nZS5lbWl0KG5ldyBDb2x1bW5Mb2NrZWRDaGFuZ2VFdmVudChjaGFuZ2VkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbHVtblN0aWNreUNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMuY29sdW1uSW5mb1NlcnZpY2Uuc3RpY2t5Q2hhbmdlLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5TdGlja3lDaGFuZ2UuZW1pdChuZXcgQ29sdW1uU3RpY2t5Q2hhbmdlRXZlbnQoY2hhbmdlZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncm91cEV4cGFuZENvbGxhcHNlU3Vic2NyaXB0aW9uID0gaGFuZGxlRXhwYW5kQ29sbGFwc2VHcm91cHNTZXJ2aWNlKGdyb3Vwc1NlcnZpY2UsIHRoaXMuZ3JvdXBFeHBhbmQsIHRoaXMuZ3JvdXBDb2xsYXBzZSwgKHsgZ3JvdXAsIGdyb3VwSW5kZXgsIHBhcmVudEdyb3VwIH0pID0+ICh7IGdyb3VwLCBncm91cEluZGV4LCBwYXJlbnRHcm91cCB9KSk7XG4gICAgICAgIHRoaXMuZGV0YWlsc1NlcnZpY2VTdWJzY3JpcHRpb24gPSBoYW5kbGVFeHBhbmRDb2xsYXBzZURldGFpbHNTZXJ2aWNlKGRldGFpbHNTZXJ2aWNlLCB0aGlzLmRldGFpbEV4cGFuZCwgdGhpcy5kZXRhaWxDb2xsYXBzZSwgYXJncyA9PiBhcmdzKTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdWJzY3JpcHRpb24gPSB0aGlzLmZpbHRlclNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUoeCA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckNoYW5nZS5lbWl0KHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb3J0U3Vic2NyaXB0aW9uID0gdGhpcy5zb3J0U2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSh4ID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ydENoYW5nZS5lbWl0KHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdHRhY2hTdGF0ZUNoYW5nZXNFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYXR0YWNoRWRpdEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuYXR0YWNoRG9tRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLnBkZlN1YnNjcmlwdGlvbiA9IHRoaXMucGRmU2VydmljZS5leHBvcnRDbGljay5zdWJzY3JpYmUodGhpcy5lbWl0UERGRXhwb3J0RXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXhjZWxTdWJzY3JpcHRpb24gPSB0aGlzLmV4Y2VsU2VydmljZS5leHBvcnRDbGljay5zdWJzY3JpYmUodGhpcy5zYXZlQXNFeGNlbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ29udGFpbmVyQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ29sdW1uUmVzaXplKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTGlzdCA9IG5ldyBDb2x1bW5MaXN0KHRoaXMuY29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uUmVvcmRlclN1YnNjcmlwdGlvbiA9IHRoaXMuY29sdW1uUmVvcmRlclNlcnZpY2VcbiAgICAgICAgICAgIC5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLnJlb3JkZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY29sdW1uUmFuZ2VDaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLmNvbHVtblJhbmdlQ2hhbmdlLnN1YnNjcmliZSh0aGlzLm9uQ29sdW1uUmFuZ2VDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIG51bWJlciBvZiByZWNvcmRzIHRvIGJlIHNraXBwZWQgYnkgdGhlIHBhZ2VyLlxuICAgICAqIFJlcXVpcmVkIGJ5IHRoZSBbcGFnaW5nXSh7JSBzbHVnIHBhZ2luZ19ncmlkICV9KSBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIGdldCBza2lwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2tpcDtcbiAgICB9XG4gICAgc2V0IHNraXAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NraXAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRvcnMgYnkgd2hpY2ggdGhlIGRhdGEgd2lsbCBiZSBzb3J0ZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzb3J0aW5nX2dyaWQgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgc29ydCh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc29ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdG9ycyBieSB3aGljaCB0aGUgZGF0YSB3aWxsIGJlIGdyb3VwZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBncm91cGluZ2Jhc2ljc19ncmlkICV9KSkuXG4gICAgICovXG4gICAgc2V0IGdyb3VwKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKi9cbiAgICBnZXQgZ3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzaG93VG9wVG9vbGJhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhclRlbXBsYXRlICYmIFsndG9wJywgJ2JvdGgnXS5pbmRleE9mKHRoaXMudG9vbGJhclRlbXBsYXRlLnBvc2l0aW9uKSA+IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHNob3dCb3R0b21Ub29sYmFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b29sYmFyVGVtcGxhdGUgJiYgWydib3R0b20nLCAnYm90aCddLmluZGV4T2YodGhpcy50b29sYmFyVGVtcGxhdGUucG9zaXRpb24pID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc2hvd1RvcFBhZ2VyKCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucGFnZWFibGUucG9zaXRpb247XG4gICAgICAgIHJldHVybiAhdGhpcy5pc1ZpcnR1YWwgJiYgdGhpcy5wYWdlYWJsZSAhPT0gZmFsc2UgJiYgWyd0b3AnLCAnYm90aCddLmluZGV4T2YocG9zaXRpb24pID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc2hvd0JvdHRvbVBhZ2VyKCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucGFnZWFibGUucG9zaXRpb247XG4gICAgICAgIHJldHVybiAhdGhpcy5pc1ZpcnR1YWwgJiYgdGhpcy5wYWdlYWJsZSAhPT0gZmFsc2UgJiYgcG9zaXRpb24gIT09ICd0b3AnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhhc1BhZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93VG9wUGFnZXIgfHwgdGhpcy5zaG93Qm90dG9tUGFnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc2hvd0dyb3VwUGFuZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwYWJsZSAmJiB0aGlzLmdyb3VwYWJsZS5lbmFibGVkICE9PSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBncm91cGFibGVFbXB0eVRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwYWJsZS5lbXB0eVRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgbWFycXVlZVNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU2VydmljZS5lbmFibGVNYXJxdWVlIHx8IHRoaXMuY2VsbFNlbGVjdGlvblNlcnZpY2UuZW5hYmxlTWFycXVlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQW4gYWxpYXMgZm9yIGBuYXZpZ2FibGVgIGZvciB1c2VycyB3aG8gbWlncmF0ZSBmcm9tIEtlbmRvIFVJIGZvciBqUXVlcnkuXG4gICAgICovXG4gICAgc2V0IG5hdmlnYXRhYmxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubmF2aWdhYmxlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgbmF2aWdhdGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgZm9yIGV2ZXJ5IGRhdGEgcm93IGluIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqIGltcG9ydCB7IFJvd0NsYXNzQXJncyB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWdyaWQnO1xuICAgICAqXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAqICAgIHN0eWxlczogW2BcbiAgICAgKiAgICAgICAgLmstZ3JpZCB0ci5ldmVuIHsgYmFja2dyb3VuZC1jb2xvcjogI2Y0NWM0MjsgfVxuICAgICAqICAgICAgICAuay1ncmlkIHRyLm9kZCB7IGJhY2tncm91bmQtY29sb3I6ICM0MWY0ZGY7IH1cbiAgICAgKiAgICBgXSxcbiAgICAgKiAgICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJncmlkRGF0YVwiIFtyb3dDbGFzc109XCJyb3dDYWxsYmFja1wiPlxuICAgICAqICAgICAgICA8L2tlbmRvLWdyaWQ+XG4gICAgICogICAgYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgICBwdWJsaWMgZ3JpZERhdGE6IGFueVtdID0gcHJvZHVjdHM7XG4gICAgICpcbiAgICAgKiAgICBwdWJsaWMgcm93Q2FsbGJhY2soY29udGV4dDogUm93Q2xhc3NBcmdzKSB7XG4gICAgICogICAgICAgIGNvbnN0IGlzRXZlbiA9IGNvbnRleHQuaW5kZXggJSAyID09IDA7XG4gICAgICogICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICAgICBldmVuOiBpc0V2ZW4sXG4gICAgICogICAgICAgICAgICBvZGQ6ICFpc0V2ZW5cbiAgICAgKiAgICAgICAgfTtcbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgKiAgfSwge1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogXTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgcm93Q2xhc3MoZm4pIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSAmJiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcm93Q2xhc3MgbXVzdCBiZSBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShmbil9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvd0NsYXNzID0gZm47XG4gICAgfVxuICAgIGdldCByb3dDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd0NsYXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBmb3IgZXZlcnkgZGF0YSByb3cgaW4gdGhlIGNvbXBvbmVudCxcbiAgICAgKiBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSByb3cgd2lsbCBiZSBzdGlja3ksIGkuZS4gYWx3YXlzIHZpc2libGUgYWZ0ZXIgc2Nyb2xsaW5nLlxuICAgICAqL1xuICAgIHNldCByb3dTdGlja3koZm4pIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSAmJiBpc1ByZXNlbnQoZm4pICYmIHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByb3dTdGlja3kgbXVzdCBiZSBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShmbil9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZm4pKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dTdGlja3kgPSBmbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcm93U3RpY2t5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm93U3RpY2t5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgQm9vbGVhbiBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIGZvciBlYWNoIGRhdGEgcm93IGluIHRoZSBjb21wb25lbnRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGdyaWRfc2VsZWN0aW9uX2N1c3RvbSAlfSN0b2Mtc2V0dGluZy10aGUtc2VsZWN0ZWQtcm93cykpLlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcm93IHdpbGwgYmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgc2V0IHJvd1NlbGVjdGVkKGZuKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUgJiYgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJvd1NlbGVjdGVkIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoZm4pfS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3dTZWxlY3RlZCA9IGZuO1xuICAgIH1cbiAgICBnZXQgcm93U2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3dTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgYSBkYXRhIGNlbGwuXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgc2VsZWN0ZWRgIGFuZCBgaXRlbWAgcHJvcGVydGllcy5cbiAgICAgKiBUaGUgY2VsbCBpcyBtYXJrZWQgYXMgc2VsZWN0ZWQgb25seSBpZiB0aGUgYHNlbGVjdGVkYCBwcm9wZXJ0eSBlcXVhbHMgYHRydWVgLlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGZvciBlYWNoIGRhdGEgY2VsbCBhbmQgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgICAqIGFzIHBhcnQgb2YgYSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGdyaWRfc2VsZWN0aW9uX2N1c3RvbSAlfSN0b2Mtc2V0dGluZy10aGUtc2VsZWN0ZWQtY2VsbHMpKVxuICAgICAqL1xuICAgIHNldCBjZWxsU2VsZWN0ZWQoZm4pIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSAmJiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2VsbFNlbGVjdGVkIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoZm4pfS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jZWxsU2VsZWN0ZWQgPSBmbjtcbiAgICB9XG4gICAgZ2V0IGNlbGxTZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbGxTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IGZvY3VzZWQgY2VsbCAoaWYgYW55KS5cbiAgICAgKi9cbiAgICBnZXQgYWN0aXZlQ2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuYWN0aXZlQ2VsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IGZvY3VzZWQgcm93IChpZiBhbnkpLlxuICAgICAqL1xuICAgIGdldCBhY3RpdmVSb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmFjdGl2ZVJvdztcbiAgICB9XG4gICAgZ2V0IGRpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xuICAgIH1cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgbG9ja2VkQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IHZpcnR1YWxDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZpcnR1YWw7XG4gICAgfVxuICAgIGdldCBub1Njcm9sbGJhckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxiYXJXaWR0aCA9PT0gMDtcbiAgICB9XG4gICAgZ2V0IGRldGFpbFRlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VzdG9tRGV0YWlsVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXN0b21EZXRhaWxUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxUZW1wbGF0ZUNoaWxkcmVuID8gdGhpcy5kZXRhaWxUZW1wbGF0ZUNoaWxkcmVuLmZpcnN0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXQgZGV0YWlsVGVtcGxhdGUoZGV0YWlsVGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fY3VzdG9tRGV0YWlsVGVtcGxhdGUgPSBkZXRhaWxUZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IGNlbGxMb2FkaW5nVGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jZWxsTG9hZGluZ1RlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tRGV0YWlsVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbExvYWRpbmdUZW1wbGF0ZUNoaWxkcmVuID8gdGhpcy5jZWxsTG9hZGluZ1RlbXBsYXRlQ2hpbGRyZW4uZmlyc3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldCBjZWxsTG9hZGluZ1RlbXBsYXRlKGNlbGxMb2FkaW5nVGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fY2VsbExvYWRpbmdUZW1wbGF0ZSA9IGNlbGxMb2FkaW5nVGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBsb2FkaW5nVGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2FkaW5nVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkaW5nVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZ1RlbXBsYXRlQ2hpbGRyZW4gPyB0aGlzLmxvYWRpbmdUZW1wbGF0ZUNoaWxkcmVuLmZpcnN0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXQgbG9hZGluZ1RlbXBsYXRlKGxvYWRpbmdUZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLl9sb2FkaW5nVGVtcGxhdGUgPSBsb2FkaW5nVGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBub1JlY29yZHNUZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1c3RvbU5vUmVjb3Jkc1RlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tTm9SZWNvcmRzVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9SZWNvcmRzVGVtcGxhdGVDaGlsZHJlbiA/IHRoaXMubm9SZWNvcmRzVGVtcGxhdGVDaGlsZHJlbi5maXJzdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0IG5vUmVjb3Jkc1RlbXBsYXRlKGN1c3RvbU5vUmVjb3Jkc1RlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbU5vUmVjb3Jkc1RlbXBsYXRlID0gY3VzdG9tTm9SZWNvcmRzVGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBwYWdlclRlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VzdG9tUGFnZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1c3RvbVBhZ2VyVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZXJUZW1wbGF0ZUNoaWxkcmVuID8gdGhpcy5wYWdlclRlbXBsYXRlQ2hpbGRyZW4uZmlyc3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldCBwYWdlclRlbXBsYXRlKGN1c3RvbVBhZ2VyVGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fY3VzdG9tUGFnZXJUZW1wbGF0ZSA9IGN1c3RvbVBhZ2VyVGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCB0b29sYmFyVGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXN0b21Ub29sYmFyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXN0b21Ub29sYmFyVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhclRlbXBsYXRlQ2hpbGRyZW4gPyB0aGlzLnRvb2xiYXJUZW1wbGF0ZUNoaWxkcmVuLmZpcnN0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXQgdG9vbGJhclRlbXBsYXRlKGN1c3RvbVRvb2xiYXJUZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLl9jdXN0b21Ub29sYmFyVGVtcGxhdGUgPSBjdXN0b21Ub29sYmFyVGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBzY3JvbGxiYXJXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydFNlcnZpY2Uuc2Nyb2xsYmFyV2lkdGg7XG4gICAgfVxuICAgIGdldCBoZWFkZXJQYWRkaW5nKCkge1xuICAgICAgICBpZiAoaXNVbml2ZXJzYWwoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IE1hdGgubWF4KDAsIHRoaXMuc2Nyb2xsYmFyV2lkdGgpICsgJ3B4JztcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnJ0bCA/IDAgOiBwYWRkaW5nO1xuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5ydGwgPyBwYWRkaW5nIDogMDtcbiAgICAgICAgcmV0dXJuIGAwICR7cmlnaHR9IDAgJHtsZWZ0fWA7XG4gICAgfVxuICAgIGdldCBoYXNHcm91cEZvb3RlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIuaGFzR3JvdXBGb290ZXI7XG4gICAgfVxuICAgIGdldCBzaG93Rm9vdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zQ29udGFpbmVyLmhhc0Zvb3RlcjtcbiAgICB9XG4gICAgZ2V0IHNob3dHcm91cEZvb3RlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwYWJsZSAmJiB0aGlzLmdyb3VwYWJsZS5zaG93Rm9vdGVyO1xuICAgIH1cbiAgICBnZXQgYXJpYVJvd0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbENvbHVtbkxldmVscyArIDEgKyB0aGlzLnZpZXcudG90YWw7XG4gICAgfVxuICAgIGdldCBhcmlhQ29sQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIubGVhZkNvbHVtbnNUb1JlbmRlci5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBpc1ZpcnR1YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbGFibGUgPT09ICd2aXJ0dWFsJztcbiAgICB9XG4gICAgZ2V0IGlzU2Nyb2xsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsYWJsZSAhPT0gJ25vbmUnO1xuICAgIH1cbiAgICBnZXQgdmlzaWJsZUNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIuYWxsQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IGxvY2tlZENvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIubG9ja2VkQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IG5vbkxvY2tlZENvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIubm9uTG9ja2VkQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IGxvY2tlZExlYWZDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zQ29udGFpbmVyLmxvY2tlZExlYWZDb2x1bW5zO1xuICAgIH1cbiAgICBnZXQgc3RpY2t5Q29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5zdGlja3kpO1xuICAgIH1cbiAgICBnZXQgbm9uTG9ja2VkTGVhZkNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIubm9uTG9ja2VkTGVhZkNvbHVtbnM7XG4gICAgfVxuICAgIGdldCBsZWFmQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc0NvbnRhaW5lci5sZWFmQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IHRvdGFsQ29sdW1uTGV2ZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zQ29udGFpbmVyLnRvdGFsTGV2ZWxzO1xuICAgIH1cbiAgICBnZXQgaGVhZGVyQ29sdW1ucygpIHtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbENvbHVtbnMgJiYgIXRoaXMucGRmU2VydmljZS5leHBvcnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0Q29sdW1ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub25Mb2NrZWRDb2x1bW5zO1xuICAgIH1cbiAgICBnZXQgaGVhZGVyTGVhZkNvbHVtbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWxDb2x1bW5zICYmICF0aGlzLnBkZlNlcnZpY2UuZXhwb3J0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWFmVmlld3BvcnRDb2x1bW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vbkxvY2tlZExlYWZDb2x1bW5zO1xuICAgIH1cbiAgICBnZXQgbG9ja2VkV2lkdGgoKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwQ2VsbHNXaWR0aCA9IHRoaXMuZ3JvdXAubGVuZ3RoICogR1JPVVBfQ0VMTF9XSURUSDtcbiAgICAgICAgcmV0dXJuIGV4cGFuZENvbHVtbnModGhpcy5sb2NrZWRMZWFmQ29sdW1ucy50b0FycmF5KCkpLnJlZHVjZSgocHJldiwgY3VycikgPT4gcHJldiArIChjdXJyLndpZHRoIHx8IDApLCBncm91cENlbGxzV2lkdGgpO1xuICAgIH1cbiAgICBnZXQgbm9uTG9ja2VkV2lkdGgoKSB7XG4gICAgICAgIGlmICgoIXRoaXMucnRsICYmIHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoKSB8fCB0aGlzLnZpcnR1YWxDb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMudmlydHVhbENvbHVtbnMgPyB0aGlzLmNvbHVtbnNDb250YWluZXIudW5sb2NrZWRXaWR0aCA6XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmVmlld3BvcnRDb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2x1bW4pID0+IGFjYyArIChjb2x1bW4ud2lkdGggfHwgMCksIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBzZWxlY3RhYmxlU2V0dGluZ3MoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2Uub3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgY29sdW1uTWVudVRlbXBsYXRlKCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuY29sdW1uTWVudVRlbXBsYXRlcy5maXJzdDtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlID8gdGVtcGxhdGUudGVtcGxhdGVSZWYgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgdG90YWxDb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXJ0dWFsIHx8ICFpc1ByZXNlbnQodGhpcy5wYWdlU2l6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXcudG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIHNwZWNpZmllZCBtYXN0ZXIgcm93IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaGllcmFyY2h5X2dyaWQgJX0pKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIG9ubHkgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggbGVnYWN5IHZlcnNpb25zLlxuICAgICAqIFRoZXNlIHZlcnNpb25zIHRyYWNrZWQgdGhlIGV4cGFuZGVkIHN0YXRlIGludGVybmFsbHkgdXNpbmcgdGhlIGRhdGEgcm93IGluZGV4LlxuICAgICAqXG4gICAgICogRm9yIG5ldyBkZXZlbG9wbWVudCwgdXNlIHRoZSBba2VuZG9HcmlkRGV0YWlsc0V4cGFuZEJ5IGRpcmVjdGl2ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9leHBhbmRkZXRhaWxzZGlyZWN0aXZlICV9KVxuICAgICAqIG9yIHByb3ZpZGUgYW4gaXNEZXRhaWxFeHBhbmRlZCBjYWxsYmFjay4gU2VlIFtDb250cm9sbGluZyB0aGUgRXhwYW5kZWQgU3RhdGVdKHslIHNsdWcgbWFzdGVyX2RldGFpbF9leHBhbmRlZF9zdGF0ZV9ncmlkICV9KVxuICAgICAqIGZvciBleGFtcGxlcyBvbiBob3cgdG8gY29udHJvbCB0aGUgZXhwYW5kZWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgZGF0YSByb3cgaW5kZXggb2YgdGhlIG1hc3RlciByb3cuXG4gICAgICovXG4gICAgZXhwYW5kUm93KGluZGV4KSB7XG4gICAgICAgIHRoaXMudG9nZ2xlRGV0YWlsUm93TGVnYWN5KGluZGV4LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIHRoZSBzcGVjaWZpZWQgbWFzdGVyIHJvdyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGhpZXJhcmNoeV9ncmlkICV9KSkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBvbmx5IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aXRoIGxlZ2FjeSB2ZXJzaW9ucy5cbiAgICAgKiBUaGVzZSB2ZXJzaW9ucyB0cmFja2VkIHRoZSBleHBhbmRlZCBzdGF0ZSBpbnRlcm5hbGx5IHVzaW5nIHRoZSBkYXRhIHJvdyBpbmRleC5cbiAgICAgKlxuICAgICAqIEZvciBuZXcgZGV2ZWxvcG1lbnQsIHVzZSB0aGUgW2tlbmRvR3JpZERldGFpbHNFeHBhbmRCeSBkaXJlY3RpdmVdKHslIHNsdWcgYXBpX2dyaWRfZXhwYW5kZGV0YWlsc2RpcmVjdGl2ZSAlfSlcbiAgICAgKiBvciBwcm92aWRlIGFuIGlzRGV0YWlsRXhwYW5kZWQgY2FsbGJhY2suIFNlZSBbQ29udHJvbGxpbmcgdGhlIEV4cGFuZGVkIFN0YXRlXSh7JSBzbHVnIG1hc3Rlcl9kZXRhaWxfZXhwYW5kZWRfc3RhdGVfZ3JpZCAlfSlcbiAgICAgKiBmb3IgZXhhbXBsZXMgb24gaG93IHRvIGNvbnRyb2wgdGhlIGV4cGFuZGVkIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGRhdGEgcm93IGluZGV4IG9mIHRoZSBtYXN0ZXIgcm93LlxuICAgICAqL1xuICAgIGNvbGxhcHNlUm93KGluZGV4KSB7XG4gICAgICAgIHRoaXMudG9nZ2xlRGV0YWlsUm93TGVnYWN5KGluZGV4LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYSBncm91cCBoZWFkZXIgaXRlbSBmb3IgdGhlIGdpdmVuIGluZGV4LiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgMF8xYCBleHBhbmRzIHRoZSBzZWNvbmQgaW5uZXIgZ3JvdXAgb2YgdGhlIGZpcnN0IG1hc3RlciBncm91cC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIG9ubHkgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggbGVnYWN5IHZlcnNpb25zLlxuICAgICAqIFRoZXNlIHZlcnNpb25zIHRyYWNrZWQgdGhlIGV4cGFuZGVkIGdyb3VwIHN0YXRlIGludGVybmFsbHkgdXNpbmcgdGhlIGhpZXJhcmNoaWNhbCBncm91cCBpbmRleC5cbiAgICAgKlxuICAgICAqID4gKiBXaGVuIHlvdSB1c2UgdGhlIFtrZW5kb0dyaWRHcm91cEJpbmRpbmddKHslIHNsdWcgYXBpX2dyaWRfZ3JvdXBiaW5kaW5nZGlyZWN0aXZlICV9KSBkaXJlY3RpdmUsXG4gICAgICogPiB0aGUgYGV4cGFuZEdyb3VwYCBtZXRob2QgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgKiA+ICogV2hlbiBhIEdyaWQgaXMgcGFnZWFibGUsIHRoZSBpbmRleGVzIG9mIHRoZSBncm91cHMgYXJlIG9mZnNldCBieSB0aGUgY3VycmVudCBHcmlkIFtza2lwXSh7JSBzbHVnIGFwaV9ncmlkX2dyaWRjb21wb25lbnQgJX0jdG9jLXNraXApLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4IC0gVGhlIHVuZGVyc2NvcmUgc2VwYXJhdGVkIGhpZXJhcmNoaWNhbCBpbmRleCBvZiB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgZXhwYW5kR3JvdXAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy50b2dnbGVHcm91cFJvd0xlZ2FjeShpbmRleCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBhIGdyb3VwIGhlYWRlciBpdGVtIGZvciB0aGUgZ2l2ZW4gaW5kZXguIEZvciBleGFtcGxlLFxuICAgICAqIGAwXzFgIGNvbGxhcHNlcyB0aGUgc2Vjb25kIGlubmVyIGdyb3VwIG9mIHRoZSBmaXJzdCBtYXN0ZXIgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBvbmx5IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aXRoIGxlZ2FjeSB2ZXJzaW9ucy5cbiAgICAgKiBUaGVzZSB2ZXJzaW9ucyB0cmFja2VkIHRoZSBleHBhbmRlZCBncm91cCBzdGF0ZSBpbnRlcm5hbGx5IHVzaW5nIHRoZSBoaWVyYXJjaGljYWwgZ3JvdXAgaW5kZXguXG4gICAgICpcbiAgICAgKiA+ICogV2hlbiB5b3UgdXNlIHRoZSBba2VuZG9HcmlkR3JvdXBCaW5kaW5nXSh7JSBzbHVnIGFwaV9ncmlkX2dyb3VwYmluZGluZ2RpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlLFxuICAgICAqID4gdGhlIGBjb2xsYXBzZUdyb3VwYCBtZXRob2QgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgKiA+ICogV2hlbiBhIEdyaWQgaXMgcGFnZWFibGUsIHRoZSBpbmRleGVzIG9mIHRoZSBncm91cHMgYXJlIG9mZnNldCBieSB0aGUgY3VycmVudCBHcmlkIFtza2lwXSh7JSBzbHVnIGFwaV9ncmlkX2dyaWRjb21wb25lbnQgJX0jdG9jLXNraXApLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4IC0gVGhlIHVuZGVyc2NvcmUgc2VwYXJhdGVkIGhpZXJhcmNoaWNhbCBpbmRleCBvZiB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgY29sbGFwc2VHcm91cChpbmRleCkge1xuICAgICAgICB0aGlzLnRvZ2dsZUdyb3VwUm93TGVnYWN5KGluZGV4LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZXNldEdyb3Vwc1N0YXRlKCkge1xuICAgICAgICB0aGlzLmdyb3Vwc1NlcnZpY2UucmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGV4cGFuZEdyb3VwQ2hpbGRyZW4oZ3JvdXBJbmRleCkge1xuICAgICAgICB0aGlzLmdyb3Vwc1NlcnZpY2UuZXhwYW5kQ2hpbGRyZW4oZ3JvdXBJbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkRhdGFDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuYXV0b0dlbmVyYXRlQ29sdW1ucygpO1xuICAgICAgICB0aGlzLmNoYW5nZU5vdGlmaWNhdGlvbi5ub3RpZnkoKTtcbiAgICAgICAgdGhpcy5wZGZTZXJ2aWNlLmRhdGFDaGFuZ2VkLmVtaXQoKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRlZmF1bHRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZWxlY3Rpb24ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRTZWxlY3Rpb25TZXJ2aWNlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTmF2aWdhdGlvbk1ldGFkYXRhKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGlzQ2hhbmdlZChcImRhdGFcIiwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoICYmIGFueUNoYW5nZWQoW1wicGFnZVNpemVcIiwgXCJza2lwXCIsIFwic29ydFwiLCBcImdyb3VwXCJdLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VOb3RpZmljYXRpb24ubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZWQoW1wicGFnZVNpemVcIiwgXCJzY3JvbGxhYmxlXCIsICd2aXJ0dWFsQ29sdW1ucyddLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOYXZpZ2F0aW9uTWV0YWRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKFwidmlydHVhbENvbHVtbnNcIiwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRDb2x1bW5zID0gdGhpcy5sZWFmVmlld3BvcnRDb2x1bW5zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKFwiaGVpZ2h0XCIsIGNoYW5nZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIGAke3RoaXMuaGVpZ2h0fXB4YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2hhbmdlZChcImZpbHRlcmFibGVcIiwgY2hhbmdlcykgJiYgdGhpcy5sb2NrZWRDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zeW5jSGVhZGVySGVpZ2h0KHRoaXMubmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFtcImNvbHVtbk1lbnVcIiwgXCJzb3J0YWJsZVwiLCBcImZpbHRlcmFibGVcIl0sIGNoYW5nZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5NZW51T3B0aW9ucyA9IHRoaXMuY29sdW1uTWVudSAmJiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IEJvb2xlYW4odGhpcy5maWx0ZXJhYmxlKSxcbiAgICAgICAgICAgICAgICBzb3J0OiBCb29sZWFuKHRoaXMuc29ydGFibGUpXG4gICAgICAgICAgICB9LCB0aGlzLmNvbHVtbk1lbnUpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmFsaWduXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2hhbmdlZChcInNjcm9sbGFibGVcIiwgY2hhbmdlcykgJiYgdGhpcy5pc1Njcm9sbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLm9uU3RhYmxlLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuYXR0YWNoU2Nyb2xsU3luYygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKFwic2VsZWN0YWJsZVwiLCBjaGFuZ2VzKSAmJiB0aGlzLnNob3VsZFJlc2V0U2VsZWN0aW9uKGNoYW5nZXMuc2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRTZWxlY3Rpb24ucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25EaXJlY3RpdmUucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdncm91cGFibGUnLCBjaGFuZ2VzLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cGFibGUgPSBjaGFuZ2VzLmdyb3VwYWJsZS5jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmF0dGFjaFNjcm9sbFN5bmMoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hFbGVtZW50RXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZU5hdmlnYXRpb25NZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmFwcGx5QXV0b1NpemUoKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICB0aGlzLmNvbHVtbnNDb250YWluZXIucmVmcmVzaCgpO1xuICAgICAgICB0aGlzLnZlcmlmeVNldHRpbmdzKCk7XG4gICAgICAgIHRoaXMuaW5pdFNlbGVjdGlvblNlcnZpY2UoKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnNob3VsZEdlbmVyYXRlQ29sdW1ucyA9ICF0aGlzLmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICB0aGlzLmF1dG9HZW5lcmF0ZUNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5MaXN0ID0gbmV3IENvbHVtbkxpc3QodGhpcy5jb2x1bW5zKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ2hhbmdlU3Vic2NyaXB0aW9uID0gdGhpcy5jb2x1bW5zLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMudmVyaWZ5U2V0dGluZ3MoKSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuaW5pdCh0aGlzLm5hdmlnYXRpb25NZXRhZGF0YSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBFeHBhbmRDb2xsYXBzZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5ncm91cEV4cGFuZENvbGxhcHNlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGV0YWlsc1NlcnZpY2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWlsc1NlcnZpY2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0U2VydmljZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBkZlN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wZGZTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWx0ZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc29ydFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zb3J0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uc0NoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjZWxTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZXhjZWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2x1bW5zQ29udGFpbmVyQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnNDb250YWluZXJDaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY3JvbGxTeW5jU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGV0YWNoRWxlbWVudEV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoRWxlbWVudEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNlbGxDbGlja1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jZWxsQ2xpY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb290ZXJDaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZm9vdGVyQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5SZXNpemluZ1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5SZXNpemluZ1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbHVtblJlb3JkZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uUmVvcmRlclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvY2FsaXphdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2x1bW5WaXNpYmlsaXR5Q2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtblZpc2liaWxpdHlDaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2x1bW5Mb2NrZWRDaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uTG9ja2VkQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uU3RpY2t5Q2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtblN0aWNreUNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvY3VzRWxlbWVudFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0VsZW1lbnRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtblJhbmdlQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBhdHRhY2hTY3JvbGxTeW5jKCkge1xuICAgICAgICBpZiAoaXNVbml2ZXJzYWwoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZS5yZWdpc3RlckVtaXR0ZXIodGhpcy5oZWFkZXIubmF0aXZlRWxlbWVudCwgXCJoZWFkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9vdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmZvb3RlckNoYW5nZVN1YnNjcmlwdGlvbiA9IG9ic2VydmUodGhpcy5mb290ZXIpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShmb290ZXJzID0+IGZvb3RlcnNcbiAgICAgICAgICAgICAgICAubWFwKGZvb3RlciA9PiBmb290ZXIubmF0aXZlRWxlbWVudClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGlzUHJlc2VudClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChlbGVtZW50ID0+IHRoaXMuc2Nyb2xsU3luY1NlcnZpY2UucmVnaXN0ZXJFbWl0dGVyKGVsZW1lbnQsIFwiZm9vdGVyXCIpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBhcmlhTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2dyaWRMYWJlbCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0aGUgc3BlY2lmaWVkIHRhYmxlIHJvdyBpbiB0aGUgZWRpdCBtb2RlIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ190ZW1wbGF0ZV9mb3Jtc19ncmlkICV9I3RvYy1lZGl0aW5nLXJlY29yZHMpKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3dJbmRleCAtIFRoZSBkYXRhIHJvdyBpbmRleCB0aGF0IHdpbGwgYmUgc3dpdGNoZWQgaW4gdGhlIGVkaXQgbW9kZS5cbiAgICAgKiBAcGFyYW0gZ3JvdXAgLSBUaGUgW0Zvcm1Hcm91cF0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnZm9ybWdyb3VwYXBpJ10gfX0pXG4gICAgICogdGhhdCBkZXNjcmliZXMgdGhlIGVkaXQgZm9ybS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBjb25maWd1cmluZyB0aGUgZm9jdXMgdGFyZ2V0IG9uY2UgdGhlIGVkaXRvciBvcGVucy5cbiAgICAgKi9cbiAgICBlZGl0Um93KHJvd0luZGV4LCBncm91cCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmVkaXRSb3cocm93SW5kZXgsIGdyb3VwKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChvcHRpb25zKSAmJiBvcHRpb25zLnNraXBGb2N1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdyA9IGB0cltkYXRhLWtlbmRvLWdyaWQtaXRlbS1pbmRleD1cIiR7cm93SW5kZXh9XCJdYDtcbiAgICAgICAgY29uc3QgY29sdW1uSW5kZXggPSBvcHRpb25zICYmIG9wdGlvbnMuY29sdW1uSW5kZXg7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGlzTmFOKGNvbHVtbkluZGV4KSA/IHJvdyA6IGAke3Jvd30gdGRbZGF0YS1rZW5kby1ncmlkLWNvbHVtbi1pbmRleD1cIiR7Y29sdW1uSW5kZXh9XCJdYDtcbiAgICAgICAgdGhpcy5mb2N1c0VkaXRFbGVtZW50KHRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgZWRpdG9yIGZvciBhIGdpdmVuIHJvdyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfZ3JpZCAlfSN0b2MtY2FuY2VsbGluZy1lZGl0aW5nKSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgcm93IGluZGV4IHRoYXQgd2lsbCBiZSBzd2l0Y2hlZCBvdXQgb2YgdGhlIGVkaXQgbW9kZS4gSWYgbm8gaW5kZXggaXMgcHJvdmlkZWQsIGl0IGlzIGFzc3VtZWRcbiAgICAgKiB0aGF0IHRoZSBuZXcgaXRlbSBlZGl0b3Igd2lsbCBiZSBjbG9zZWQuXG4gICAgICovXG4gICAgY2xvc2VSb3coaW5kZXgpIHtcbiAgICAgICAgdGhpcy5lZGl0U2VydmljZS5jbG9zZShpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcm93IGVkaXRvciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfZ3JpZCAlfSN0b2MtYWRkaW5nLXJlY29yZHMpKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Rm9ybUdyb3VwfSBncm91cCAtIFRoZSBbRm9ybUdyb3VwXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWydmb3JtZ3JvdXBhcGknXSB9fSkgdGhhdCBkZXNjcmliZXNcbiAgICAgKiB0aGUgZWRpdCBmb3JtLiBJZiBjYWxsZWQgd2l0aCBhIGRhdGEgaXRlbSwgaXQgd2lsbCBidWlsZCB0aGUgYEZvcm1Hcm91cGAgZnJvbSB0aGUgZGF0YSBpdGVtIGZpZWxkcy5cbiAgICAgKi9cbiAgICBhZGRSb3coZ3JvdXApIHtcbiAgICAgICAgY29uc3QgaXNGb3JtR3JvdXAgPSBncm91cCBpbnN0YW5jZW9mIEZvcm1Hcm91cDtcbiAgICAgICAgaWYgKCFpc0Zvcm1Hcm91cCkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXMoZ3JvdXApLnJlZHVjZShjcmVhdGVDb250cm9sKGdyb3VwKSwge30pOyAvLyBGb3JtQnVpbGRlcj9cbiAgICAgICAgICAgIGdyb3VwID0gbmV3IEZvcm1Hcm91cChmaWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuYWRkUm93KGdyb3VwKTtcbiAgICAgICAgdGhpcy5mb2N1c0VkaXRFbGVtZW50KCcuay1ncmlkLWFkZC1yb3cnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHV0cyB0aGUgY2VsbCB0aGF0IGlzIHNwZWNpZmllZCBieSB0aGUgdGFibGUgcm93IGFuZCBjb2x1bW4gaW4gZWRpdCBtb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIGRhdGEgcm93IGluZGV4IHRoYXQgd2lsbCBiZSBzd2l0Y2hlZCBpbiB0aGUgZWRpdCBtb2RlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xhbnl9IGNvbHVtbiAtIFRoZSBsZWFmIGNvbHVtbiBpbmRleCwgb3IgdGhlIGZpZWxkIG5hbWUgb3IgdGhlIGNvbHVtbiBpbnN0YW5jZSB0aGF0IHNob3VsZCBiZSBlZGl0ZWQuXG4gICAgICogQHBhcmFtIHtGb3JtR3JvdXB9IGdyb3VwIC0gVGhlIFtGb3JtR3JvdXBdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ2Zvcm1ncm91cGFwaSddIH19KVxuICAgICAqIHRoYXQgZGVzY3JpYmVzIHRoZSBlZGl0IGZvcm0uXG4gICAgICovXG4gICAgZWRpdENlbGwocm93SW5kZXgsIGNvbHVtbiwgZ3JvdXApIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmNvbHVtbkluc3RhbmNlKGNvbHVtbik7XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuZWRpdENlbGwocm93SW5kZXgsIGluc3RhbmNlLCBncm91cCk7XG4gICAgICAgIHRoaXMuZm9jdXNFZGl0RWxlbWVudCgnLmstZ3JpZC1lZGl0LWNlbGwnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjdXJyZW50IGNlbGwgaW4gZWRpdCBtb2RlIGFuZCBmaXJlc1xuICAgICAqIHRoZSBbY2VsbENsb3NlXSh7JSBzbHVnIGFwaV9ncmlkX2dyaWRjb21wb25lbnQgJX0jdG9jLWNlbGxjbG9zZSkgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZWRpdGVkIGNlbGwgd2FzIGNsb3NlZC5cbiAgICAgKiBBIGBmYWxzZWAgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlXG4gICAgICogW2NlbGxDbG9zZV0oeyUgc2x1ZyBhcGlfZ3JpZF9ncmlkY29tcG9uZW50ICV9I3RvYy1jZWxsY2xvc2UpIGV2ZW50IHdhcyBwcmV2ZW50ZWQuXG4gICAgICovXG4gICAgY2xvc2VDZWxsKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZWRpdFNlcnZpY2UuY2xvc2VDZWxsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY3VycmVudCBjZWxsIGluIGVkaXQgbW9kZS5cbiAgICAgKi9cbiAgICBjYW5jZWxDZWxsKCkge1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmNhbmNlbENlbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGEgcm93IG9yIGEgY2VsbCBpcyBjdXJyZW50bHkgZWRpdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQSBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiBhIHJvdyBvciBhIGNlbGwgaXMgY3VycmVudGx5IGVkaXRlZC5cbiAgICAgKi9cbiAgICBpc0VkaXRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYSBjZWxsIGlzIGN1cnJlbnRseSBlZGl0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBBIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGEgY2VsbCBpcyBjdXJyZW50bHkgYmVpbmcgZWRpdGVkLlxuICAgICAqL1xuICAgIGlzRWRpdGluZ0NlbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGluZ0NlbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGVzIHRoZSBQREYgZXhwb3J0IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGRmZXhwb3J0X2dyaWQgJX0pKS5cbiAgICAgKi9cbiAgICBzYXZlQXNQREYoKSB7XG4gICAgICAgIHRoaXMucGRmU2VydmljZS5zYXZlKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSBHcmlkIGVsZW1lbnQgdG8gYSBEcmF3aW5nIFtHcm91cF0oeyUgc2x1ZyBhcGlfa2VuZG8tZHJhd2luZ19ncm91cCAlfSkgYnkgdXNpbmcgdGhlIGBrZW5kby1ncmlkLXBkZmAgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwZGZleHBvcnRfZ3JpZCAlfSN0b2MtZXhwb3J0aW5nLW11bHRpcGxlLWdyaWRzLXRvLXRoZS1zYW1lLXBkZikpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIERyYXdpbmcgYEdyb3VwYC5cbiAgICAgKi9cbiAgICBkcmF3UERGKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLnBkZlNlcnZpY2UuZHJhdyh0aGlzLCBwcm9taXNlKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlcyB0aGUgRXhjZWwgZXhwb3J0IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZXhjZWxleHBvcnRfZ3JpZCAlfSkpLlxuICAgICAqL1xuICAgIHNhdmVBc0V4Y2VsKCkge1xuICAgICAgICB0aGlzLmV4Y2VsU2VydmljZS5zYXZlKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBtaW5pbXVtIHBvc3NpYmxlIHdpZHRoIGZvciB0aGUgc3BlY2lmaWVkIGNvbHVtbixcbiAgICAgKiBzbyB0aGF0IHRoZSB3aG9sZSB0ZXh0IGZpdHMgd2l0aG91dCB3cmFwcGluZy4gVGhpcyBtZXRob2QgZXhwZWN0cyB0aGUgR3JpZFxuICAgICAqIHRvIGJlIHJlc2l6YWJsZSAoc2V0IGByZXNpemFibGVgIHRvIGB0cnVlYCkuXG4gICAgICogTWFrZXMgc2Vuc2UgdG8gZXhlY3V0ZSB0aGlzIG1ldGhvZCBvbmx5XG4gICAgICogYWZ0ZXIgdGhlIEdyaWQgaXMgYWxyZWFkeSBwb3B1bGF0ZWQgd2l0aCBkYXRhLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgICAgPGtlbmRvLWdyaWRcbiAgICAgKiAgICAgICAgICAgICNncmlkXG4gICAgICogICAgICAgICAgICBbZGF0YV09XCJncmlkRGF0YVwiXG4gICAgICogICAgICAgICAgICBbcmVzaXphYmxlXT1cInRydWVcIlxuICAgICAqICAgICAgICAgICAgc3R5bGU9XCJoZWlnaHQ6IDMwMHB4XCI+XG4gICAgICogICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkVG9vbGJhclRlbXBsYXRlPlxuICAgICAqICAgICAgICAgICAgICAgICA8YnV0dG9uIGtlbmRvQnV0dG9uIChjbGljayk9XCJncmlkLmF1dG9GaXRDb2x1bW4oZ3JvdXBDb2x1bW4pXCI+XG4gICAgICogICAgICAgICAgICAgICAgICAgICBBdXRvLWZpdCB0aGUgZ3JvdXAgY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAqICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbi1ncm91cCAjZ3JvdXBDb2x1bW4gdGl0bGU9XCJQcm9kdWN0IEluZm9cIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgZmllbGQ9XCJQcm9kdWN0SURcIlxuICAgICAqICAgICAgICAgICAgICAgICAgICBbd2lkdGhdPVwiNTBcIlxuICAgICAqICAgICAgICAgICAgICAgICAgICBbbWluUmVzaXphYmxlV2lkdGhdPVwiMzBcIlxuICAgICAqICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIklEXCI+XG4gICAgICogICAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtblxuICAgICAqICAgICAgICAgICAgICAgICAgICBmaWVsZD1cIlByb2R1Y3ROYW1lXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICAgICAqICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbi1ncm91cD5cbiAgICAgKlxuICAgICAqICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgZmllbGQ9XCJVbml0UHJpY2VcIlxuICAgICAqICAgICAgICAgICAgICAgIHRpdGxlPVwiVW5pdCBQcmljZVwiXG4gICAgICogICAgICAgICAgICAgICAgW3dpZHRoXT1cIjE4MFwiXG4gICAgICogICAgICAgICAgICAgICAgZmlsdGVyPVwibnVtZXJpY1wiXG4gICAgICogICAgICAgICAgICAgICAgZm9ybWF0PVwiezA6Y31cIj5cbiAgICAgKiAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gICAgICogICAgICAgIDwva2VuZG8tZ3JpZD5cbiAgICAgKiAgICBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgIHB1YmxpYyBncmlkRGF0YTogYW55W10gPSBwcm9kdWN0cztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zdCBwcm9kdWN0cyA9IFt7XG4gICAgICogICAgXCJQcm9kdWN0SURcIjogMSxcbiAgICAgKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICAgICAqICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gICAgICogICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICAgICAqICB9LCB7XG4gICAgICogICAgXCJQcm9kdWN0SURcIjogMixcbiAgICAgKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKiBdO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGF1dG9GaXRDb2x1bW4oY29sdW1uKSB7XG4gICAgICAgIHRoaXMuY29sdW1uUmVzaXppbmdTZXJ2aWNlLmF1dG9GaXQoY29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgd2lkdGggb2YgdGhlIHNwZWNpZmllZCBjb2x1bW5zIHRvIGZpdCB0aGUgZW50aXJlIGNvbnRlbnQsIGluY2x1ZGluZyBoZWFkZXJzLCB3aXRob3V0IHdyYXBwaW5nLlxuICAgICAqIElmIG5vIGNvbHVtbnMgYXJlIHNwZWNpZmllZCwgYGF1dG9GaXRDb2x1bW5zYCBpcyBhcHBsaWVkIHRvIGFsbCBjb2x1bW5zLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmVxdWlyZXMgdGhlIEdyaWQgdG8gYmUgcmVzaXphYmxlIChzZXQgYHJlc2l6YWJsZWAgdG8gYHRydWVgKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqICAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgICA8a2VuZG8tZ3JpZFxuICAgICAqICAgICAgICAgICNncmlkXG4gICAgICogICAgICAgICAgW2RhdGFdPVwiZ3JpZERhdGFcIlxuICAgICAqICAgICAgICAgIFtyZXNpemFibGVdPVwidHJ1ZVwiXG4gICAgICogICAgICAgICAgc3R5bGU9XCJoZWlnaHQ6IDMwMHB4XCI+XG4gICAgICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZFRvb2xiYXJUZW1wbGF0ZT5cbiAgICAgKiAgICAgICAgICAgICAgPGJ1dHRvbiBrZW5kb0J1dHRvbiAoY2xpY2spPVwiZ3JpZC5hdXRvRml0Q29sdW1ucyhbZmlyc3RDb2x1bW4sIGxhc3RDb2x1bW5dKVwiPlxuICAgICAqICAgICAgICAgICAgICAgICAgQXV0by1maXQgdGhlIGZpcnN0IGFuZCBsYXN0IGNvbHVtblxuICAgICAqICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgKiAgICAgICAgICAgICAgPGJ1dHRvbiBrZW5kb0J1dHRvbiAoY2xpY2spPVwiZ3JpZC5hdXRvRml0Q29sdW1ucygpXCI+XG4gICAgICogICAgICAgICAgICAgICAgICBBdXRvLWZpdCBhbGwgY29sdW1uc1xuICAgICAqICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbi1ncm91cCB0aXRsZT1cIlByb2R1Y3QgSW5mb1wiPlxuICAgICAqICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgICAgICNmaXJzdENvbHVtblxuICAgICAqICAgICAgICAgICAgICAgICAgZmllbGQ9XCJQcm9kdWN0SURcIlxuICAgICAqICAgICAgICAgICAgICAgICAgW3dpZHRoXT1cIjUwXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgIFttaW5SZXNpemFibGVXaWR0aF09XCIzMFwiXG4gICAgICogICAgICAgICAgICAgICAgICB0aXRsZT1cIklEXCI+XG4gICAgICogICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgICBmaWVsZD1cIlByb2R1Y3ROYW1lXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgID5cbiAgICAgKiAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAgICAgKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uLWdyb3VwPlxuICAgICAqXG4gICAgICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICNsYXN0Q29sdW1uXG4gICAgICogICAgICAgICAgICAgIGZpZWxkPVwiVW5pdFByaWNlXCJcbiAgICAgKiAgICAgICAgICAgICAgdGl0bGU9XCJVbml0IFByaWNlXCJcbiAgICAgKiAgICAgICAgICAgICAgW3dpZHRoXT1cIjE4MFwiXG4gICAgICogICAgICAgICAgICAgIGZpbHRlcj1cIm51bWVyaWNcIlxuICAgICAqICAgICAgICAgICAgICBmb3JtYXQ9XCJ7MDpjfVwiPlxuICAgICAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gICAgICogICAgICA8L2tlbmRvLWdyaWQ+XG4gICAgICogICAgYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgICBwdWJsaWMgZ3JpZERhdGE6IGFueVtdID0gcHJvZHVjdHM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgKiAgfSwge1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogXTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhdXRvRml0Q29sdW1ucyhjb2x1bW5zID0gdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgIGxldCBjb2xzO1xuICAgICAgICBpZiAoY29sdW1ucyBpbnN0YW5jZW9mIFF1ZXJ5TGlzdCkge1xuICAgICAgICAgICAgY29scyA9IGNvbHVtbnMudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29scyA9IGNvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5SZXNpemluZ1NlcnZpY2UuYXV0b0ZpdCguLi5jb2xzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5vdGlmeVBhZ2VDaGFuZ2Uoc291cmNlLCBldmVudCkge1xuICAgICAgICBpZiAoc291cmNlID09PSBcImxpc3RcIiAmJiAhdGhpcy5pc1ZpcnR1YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdChldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBub3RpZnlTY3JvbGxCb3R0b20oKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGFibGUgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5zY3JvbGxCb3R0b20pKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5zY3JvbGxCb3R0b20uZW1pdCh7IHNlbmRlcjogdGhpcyB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGZvY3VzRWRpdEVsZW1lbnQoY29udGFpbmVyU2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNFbGVtZW50U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzRWxlbWVudFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNFbGVtZW50U3Vic2NyaXB0aW9uID0gdGhpcy5uZ1pvbmUub25TdGFibGUuYXNPYnNlcnZhYmxlKCkucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2V0RWRpdEZvY3VzKHdyYXBwZXIucXVlcnlTZWxlY3Rvcihjb250YWluZXJTZWxlY3RvcikpICYmIHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFZGl0Rm9jdXMod3JhcHBlci5xdWVyeVNlbGVjdG9yKGAuay1ncmlkLWNvbnRlbnQgJHtjb250YWluZXJTZWxlY3Rvcn1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNFbGVtZW50U3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbGFzdCBhY3RpdmUgb3IgdGhlIGZpcnN0IGNlbGwgb2YgdGhlIEdyaWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TmF2aWdhdGlvbkNlbGx9IFRoZSBmb2N1c2VkIGNlbGwuXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0TmF2aWdhYmxlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzQ2VsbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBjZWxsIHdpdGggdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtbiBpbmRleC5cbiAgICAgKlxuICAgICAqIFRoZSByb3cgaW5kZXggaXMgYmFzZWQgb24gdGhlIGxvZ2ljYWwgc3RydWN0dXJlIG9mIHRoZSBHcmlkIGFuZCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBkYXRhIGl0ZW0gaW5kZXg6XG4gICAgICogKiBIZWFkZXIgcm93cyBhcmUgaW5jbHVkZWQsIHN0YXJ0aW5nIGF0IGluZGV4IDAuXG4gICAgICogKiBHcm91cCBoZWFkZXJzIGFuZCBmb290ZXJzIGFyZSBpbmNsdWRlZC5cbiAgICAgKiAqIFRoZSByb3cgaW5kZXhpbmcgaXMgYWJzb2x1dGUgYW5kIGRvZXMgbm90IGNoYW5nZSB3aXRoIHBhZ2luZy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBHcmlkIGlzIGNvbmZpZ3VyZWQgZm9yIHNjcm9sbGluZywgaW5jbHVkaW5nIHZpcnR1YWwgc2Nyb2xsaW5nLCB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZC5cbiAgICAgKiBJZiB0aGUgcm93IGlzIG5vdCBwcmVzZW50IG9uIHRoZSBjdXJyZW50IHBhZ2UsIHRoZSBtZXRob2Qgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3dJbmRleCAtIFRoZSBsb2dpY2FsIHJvdyBpbmRleCB0byBmb2N1cy4gVGhlIHRvcCBoZWFkZXIgcm93IGhhcyBhbiBpbmRleCAwLlxuICAgICAqIEBwYXJhbSBjb2xJbmRleCAtIFRoZSBjb2x1bW4gaW5kZXggdG8gZm9jdXMuXG4gICAgICogQHJldHVybnMge05hdmlnYXRpb25DZWxsfSBUaGUgZm9jdXNlZCBjZWxsLlxuICAgICAqXG4gICAgICovXG4gICAgZm9jdXNDZWxsKHJvd0luZGV4LCBjb2xJbmRleCkge1xuICAgICAgICB0aGlzLmFzc2VydE5hdmlnYWJsZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5mb2N1c0NlbGwocm93SW5kZXgsIGNvbEluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbmV4dCBjZWxsLCBvcHRpb25hbGx5IHdyYXBwaW5nIHRvIHRoZSBuZXh0IHJvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3cmFwIC0gQSBCb29sZWFuIHZhbHVlIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgZm9jdXMgd2lsbCBtb3ZlIHRvIHRoZSBuZXh0IHJvdy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgICAqIEByZXR1cm5zIHtOYXZpZ2F0aW9uQ2VsbH0gVGhlIGZvY3VzZWQgY2VsbC4gSWYgdGhlIGZvY3VzIGlzIGFscmVhZHkgb24gdGhlIGxhc3QgY2VsbCwgcmV0dXJucyBgbnVsbGAuXG4gICAgICovXG4gICAgZm9jdXNOZXh0Q2VsbCh3cmFwID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydE5hdmlnYWJsZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5mb2N1c05leHRDZWxsKHdyYXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBwcmV2aW91cyBjZWxsLiBPcHRpb25hbGx5IHdyYXBzIHRvIHRoZSBwcmV2aW91cyByb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd3JhcCAtIEEgQm9vbGVhbiB2YWx1ZSB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIGZvY3VzIHdpbGwgbW92ZSB0byB0aGUgbmV4dCByb3cuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJucyB7TmF2aWdhdGlvbkNlbGx9IFRoZSBmb2N1c2VkIGNlbGwuIElmIHRoZSBmb2N1cyBpcyBhbHJlYWR5IG9uIHRoZSBmaXJzdCBjZWxsLCByZXR1cm5zIGBudWxsYC5cbiAgICAgKi9cbiAgICBmb2N1c1ByZXZDZWxsKHdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0TmF2aWdhYmxlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzUHJldkNlbGwod3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtbiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNjcm9sbG1tb2Rlc19ncmlkICV9I3RvYy1zY3JvbGxpbmctdG8tYS1zcGVjaWZpYy1yb3ctYW5kLWNvbHVtbi1pbmRleCkpLlxuICAgICAqL1xuICAgIHNjcm9sbFRvKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXF1ZXN0U2VydmljZS5zY3JvbGxUbyhyZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHNwZWNpZmllZCBjb2x1bW4uXG4gICAgICogVGhlIHJlb3JkZXJpbmcgb2YgY29sdW1ucyBvcGVyYXRlcyBvbmx5IG9uIHRoZSBsZXZlbFxuICAgICAqIHdoaWNoIGlzIGluZmVycmVkIGJ5IHRoZSBzb3VyY2UgY29sdW1uLlxuICAgICAqIEZvciB0aGUgYHJlb3JkZXJDb2x1bW5gIG1ldGhvZCB0byB3b3JrIHByb3Blcmx5LFxuICAgICAqIHRoZSBgc291cmNlYCBjb2x1bW4gaGFzIHRvIGJlIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbHVtbkJhc2V9IHNvdXJjZSAtIFRoZSBjb2x1bW4gd2hvc2UgcG9zaXRpb24gd2lsbCBiZSBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0SW5kZXggLSBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtDb2x1bW5SZW9yZGVyQ29uZmlnfSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgICAgPGtlbmRvLWdyaWRcbiAgICAgKiAgICAgICAgICAgICNncmlkXG4gICAgICogICAgICAgICAgICBbZGF0YV09XCJncmlkRGF0YVwiXG4gICAgICogICAgICAgICAgICBbcmVvcmRlcmFibGVdPVwidHJ1ZVwiXG4gICAgICogICAgICAgICAgICBzdHlsZT1cImhlaWdodDogMzAwcHhcIj5cbiAgICAgKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRUb29sYmFyVGVtcGxhdGU+XG4gICAgICogICAgICAgICAgICAgICAgIDxidXR0b24ga2VuZG9CdXR0b25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJncmlkLnJlb3JkZXJDb2x1bW4oZ3JvdXBDb2x1bW4sIDIsIHsgYmVmb3JlOiB0cnVlIH0pXCI+XG4gICAgICogICAgICAgICAgICAgICAgICAgICBNb3ZlIHRoZSBncm91cCBjb2x1bW4gYmVmb3JlIHRoZSBsYXN0IG9uZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uLWdyb3VwICNncm91cENvbHVtbiB0aXRsZT1cIlByb2R1Y3QgSW5mb1wiPlxuICAgICAqICAgICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtblxuICAgICAqICAgICAgICAgICAgICAgICAgICBmaWVsZD1cIlByb2R1Y3RJRFwiXG4gICAgICogICAgICAgICAgICAgICAgICAgIFt3aWR0aF09XCI1MFwiXG4gICAgICogICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiSURcIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgICAgIGZpZWxkPVwiUHJvZHVjdE5hbWVcIlxuICAgICAqICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlByb2R1Y3QgTmFtZVwiPlxuICAgICAqICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gICAgICogICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uLWdyb3VwPlxuICAgICAqXG4gICAgICogICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgICBmaWVsZD1cIlVuaXRQcmljZVwiXG4gICAgICogICAgICAgICAgICAgICAgdGl0bGU9XCJVbml0IFByaWNlXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbd2lkdGhdPVwiMTgwXCJcbiAgICAgKiAgICAgICAgICAgICAgICBmb3JtYXQ9XCJ7MDpjfVwiPlxuICAgICAqICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAgICAgKlxuICAgICAqICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgZmllbGQ9XCJEaXNjb250aW51ZWRcIlxuICAgICAqICAgICAgICAgICAgICAgIHRpdGxlPVwiRGlzY29udGludWVkXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbd2lkdGhdPVwiMTAwXCI+XG4gICAgICogICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICAgICAqICAgICAgICA8L2tlbmRvLWdyaWQ+XG4gICAgICogICAgYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgICBwdWJsaWMgZ3JpZERhdGE6IGFueVtdID0gcHJvZHVjdHM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgKiAgfSwge1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogXTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByZW9yZGVyQ29sdW1uKHNvdXJjZSwgZGVzdEluZGV4LCBvcHRpb25zID0geyBiZWZvcmU6IGZhbHNlIH0pIHtcbiAgICAgICAgY29uc3QgY29sdW1uc0ZvckxldmVsID0gc29ydENvbHVtbnModGhpcy5hbGxDb2x1bW5zRm9yTGV2ZWwoc291cmNlLmxldmVsKSk7XG4gICAgICAgIGxldCB0YXJnZXQgPSBjb2x1bW5zRm9yTGV2ZWxbZGVzdEluZGV4XTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0Tm9uTG9ja2VkID0gdGFyZ2V0LmlzTG9ja2VkICYmXG4gICAgICAgICAgICAhc291cmNlLmlzTG9ja2VkICYmXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnNDb250YWluZXIubm9uTG9ja2VkQ29sdW1ucy5sZW5ndGggPT09IDE7XG4gICAgICAgIGlmIChsYXN0Tm9uTG9ja2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3BhbkNvbHVtbkNvbXBvbmVudCh0YXJnZXQpICYmICFvcHRpb25zLmJlZm9yZSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmNoaWxkQ29sdW1ucy5sYXN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVvcmRlcih7XG4gICAgICAgICAgICBiZWZvcmU6IG9wdGlvbnMuYmVmb3JlLFxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgc3BlY2lmaWMgcm93IGlzIGV4cGFuZGVkLlxuICAgICAqL1xuICAgIHNldCBpc0RldGFpbEV4cGFuZGVkKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZGV0YWlsc1NlcnZpY2UudXNlckNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGdldCBpc0RldGFpbEV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxzU2VydmljZS51c2VyQ2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhIHNwZWNpZmljIGdyb3VwIHJvdyBpcyBleHBhbmRlZC5cbiAgICAgKi9cbiAgICBzZXQgaXNHcm91cEV4cGFuZGVkKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzU2VydmljZS51c2VyQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5ncm91cGFibGUgPSBpc1ByZXNlbnQoY2FsbGJhY2spO1xuICAgIH1cbiAgICBnZXQgaXNHcm91cEV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHNTZXJ2aWNlLnVzZXJDYWxsYmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlb3JkZXIoeyB0YXJnZXQsIHNvdXJjZSwgYmVmb3JlLCBjaGFuZ2VDb250YWluZXIgfSkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sdW1uc0ZvckxldmVsID0gc29ydENvbHVtbnModGhpcy5hbGxDb2x1bW5zRm9yTGV2ZWwoc291cmNlLmxldmVsKSk7XG4gICAgICAgICAgICBsZXQgbmV3SW5kZXggPSBjb2x1bW5zRm9yTGV2ZWwuaW5kZXhPZih0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5wYXJlbnQgJiYgdGFyZ2V0LnBhcmVudC5pc1NwYW5Db2x1bW4pIHtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGNvbHVtbnNGb3JMZXZlbC5pbmRleE9mKHRhcmdldC5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2xkSW5kZXggPSBjb2x1bW5zRm9yTGV2ZWwuaW5kZXhPZihzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgJiYgMCA8IG5ld0luZGV4ICYmIG9sZEluZGV4IDwgbmV3SW5kZXgpIHsgLy8gZHJvcHBlZCBiZWZvcmUgdGhlIGZpcnN0IG5vdCBsb2NrZWQgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFiZWZvcmUgJiYgb2xkSW5kZXggPiBuZXdJbmRleCkgeyAvLyBkcm9wcGVkIGFmdGVyIHRoZSBsYXN0IGxvY2tlZCBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gbmV3IENvbHVtblJlb3JkZXJFdmVudCh7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgb2xkSW5kZXg6IG9sZEluZGV4LFxuICAgICAgICAgICAgICAgIG5ld0luZGV4OiBuZXdJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtblJlb3JkZXIuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIGlmIChhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uTG9ja2VkQ2hhbmdlLmVtaXQobmV3IENvbHVtbkxvY2tlZENoYW5nZUV2ZW50KFtzb3VyY2VdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbHVtbkluZGljZXMoeyBjb2x1bW5zRm9yTGV2ZWwsIHNvdXJjZSwgdGFyZ2V0LCBiZWZvcmUgfSk7XG4gICAgICAgICAgICBpZiAoc291cmNlLmxvY2tlZCAhPT0gdGFyZ2V0LmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5sb2NrZWQgPSB0YXJnZXQubG9ja2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zQ29udGFpbmVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVDb2x1bW5JbmRpY2VzKHsgY29sdW1uc0ZvckxldmVsLCBzb3VyY2UsIHRhcmdldCwgYmVmb3JlIH0pIHtcbiAgICAgICAgY29uc3QgZXhwYW5kZWRDb2x1bW5zID0gZXhwYW5kQ29sdW1uc1dpdGhTcGFuKGNvbHVtbnNGb3JMZXZlbCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUNvbHVtbkluZGV4ID0gZXhwYW5kZWRDb2x1bW5zLmluZGV4T2Yoc291cmNlKTtcbiAgICAgICAgbGV0IG5leHRTb3VyY2VJbmRleCA9IDA7XG4gICAgICAgIGxldCBuZXh0SW5kZXggPSAwO1xuICAgICAgICBsZXQgdG9Ta2lwID0gMTtcbiAgICAgICAgLy8gUG9zc2libGUgb25seSB3aGVuIGNhbGxlZCBmcm9tIHRoZSBBUEkuXG4gICAgICAgIGlmIChzb3VyY2UuaXNTcGFuQ29sdW1uKSB7XG4gICAgICAgICAgICB0b1NraXAgKz0gc291cmNlLmNoaWxkQ29sdW1ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGV4cGFuZGVkQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSBleHBhbmRlZENvbHVtbnNbaV07XG4gICAgICAgICAgICBpZiAoY29sdW1uID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBuZXh0U291cmNlSW5kZXggPSBiZWZvcmUgPyBuZXh0SW5kZXggOiBuZXh0SW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IGJlZm9yZSA/IG5leHRJbmRleCArIHRvU2tpcCA6IG5leHRJbmRleDtcbiAgICAgICAgICAgICAgICBjb2x1bW4ub3JkZXJJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNvdXJjZUluZGV4ID09PSBuZXh0SW5kZXggKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJbmRleCArPSB0b1NraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29sdW1uID09PSBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpICs9IHRvU2tpcDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5vcmRlckluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gc291cmNlQ29sdW1uSW5kZXg7IGkgPCBzb3VyY2VDb2x1bW5JbmRleCArIHRvU2tpcDsgaSsrKSB7XG4gICAgICAgICAgICBleHBhbmRlZENvbHVtbnNbaV0ub3JkZXJJbmRleCA9IG5leHRTb3VyY2VJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlSW5kaWNlc0ZvckxldmVsKHNvdXJjZS5sZXZlbCArIDEpO1xuICAgIH1cbiAgICB1cGRhdGVJbmRpY2VzRm9yTGV2ZWwobGV2ZWwpIHtcbiAgICAgICAgY29uc3QgY29sc0ZvclBhcmVudExldmVsID0gdGhpcy5hbGxDb2x1bW5zRm9yTGV2ZWwobGV2ZWwgLSAxKTtcbiAgICAgICAgY29uc3QgY29sc0ZvckxldmVsID0gW107XG4gICAgICAgIHNvcnRDb2x1bW5zKGNvbHNGb3JQYXJlbnRMZXZlbCkuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKGMuaXNDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIGNvbHNGb3JMZXZlbC5wdXNoKC4uLmMuY2hpbGRyZW5BcnJheS5zb3J0KChhLCBiKSA9PiBhLm9yZGVySW5kZXggLSBiLm9yZGVySW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGFuZENvbHVtbnNXaXRoU3Bhbihjb2xzRm9yTGV2ZWwpLm1hcCgoYywgaSkgPT4gYy5vcmRlckluZGV4ID0gaSk7XG4gICAgICAgIGlmIChsZXZlbCA8IHRoaXMuY29sdW1uTGlzdC50b3RhbENvbHVtbkxldmVscygpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluZGljZXNGb3JMZXZlbChsZXZlbCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFsbENvbHVtbnNGb3JMZXZlbChsZXZlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5MaXN0LnRvQXJyYXkoKS5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5sZXZlbCA9PT0gbGV2ZWwpO1xuICAgIH1cbiAgICBpbml0U2VsZWN0aW9uU2VydmljZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5uZ09uRGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5jZWxsU2VsZWN0aW9uU2VydmljZS5uZ09uRGVzdHJveSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25EaXJlY3RpdmUgJiYgIWlzUHJlc2VudCh0aGlzLmRlZmF1bHRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKHRoaXMsIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGxTZWxlY3Rpb25Nb2RlID0gdGhpcy5zZWxlY3RhYmxlWydjZWxsJ107XG4gICAgICAgIGNvbnN0IGFjdGl2ZVNlcnZpY2UgPSBjZWxsU2VsZWN0aW9uTW9kZSA/IHRoaXMuY2VsbFNlbGVjdGlvblNlcnZpY2UgOiB0aGlzLnNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIGNvbnN0IGluYWN0aXZlU2VydmljZSA9IGNlbGxTZWxlY3Rpb25Nb2RlID8gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlIDogdGhpcy5jZWxsU2VsZWN0aW9uU2VydmljZTtcbiAgICAgICAgaWYgKGluYWN0aXZlU2VydmljZS5hY3RpdmUpIHtcbiAgICAgICAgICAgIGluYWN0aXZlU2VydmljZS5uZ09uRGVzdHJveSgpO1xuICAgICAgICAgICAgYWN0aXZlU2VydmljZS5hZGRTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICBpbmFjdGl2ZVNlcnZpY2UuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlU2VydmljZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBhY3RpdmVTZXJ2aWNlLmluaXQoe1xuICAgICAgICAgICAgY2VsbFNlbGVjdGVkOiBjZWxsU2VsZWN0aW9uTW9kZSA/IHRoaXMuY2VsbFNlbGVjdGVkIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcm93U2VsZWN0ZWQ6IGNlbGxTZWxlY3Rpb25Nb2RlID8gdW5kZWZpbmVkIDogdGhpcy5yb3dTZWxlY3RlZCxcbiAgICAgICAgICAgIHNlbGVjdGFibGU6IHRoaXMuc2VsZWN0YWJsZSxcbiAgICAgICAgICAgIHZpZXc6IHRoaXMudmlldyxcbiAgICAgICAgICAgIGNvbHVtbnM6IGNlbGxTZWxlY3Rpb25Nb2RlID8gdGhpcy5jb2x1bW5MaXN0LnRvQXJyYXkoKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkRpcmVjdGl2ZSAmJiAhdGhpcy5zZWxlY3RhYmxlU2V0dGluZ3MuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2VsZWN0aW9uLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdWJzY3JpcHRpb24gPSB0aGlzLmNlbGxTZWxlY3Rpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KGV2ZW50KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3Vic2NyaXB0aW9uID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KGV2ZW50KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFZGl0Rm9jdXMoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UudHJ5Rm9jdXMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sdW1uSW5zdGFuY2UoY29sdW1uKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuY29sdW1uc0NvbnRhaW5lci5sb2NrZWRMZWFmQ29sdW1ucy50b0FycmF5KClcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuY29sdW1uc0NvbnRhaW5lci5ub25Mb2NrZWRMZWFmQ29sdW1ucy50b0FycmF5KCkpW2NvbHVtbl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gdGhpcy5jb2x1bW5MaXN0LmZpbHRlcigoaXRlbSkgPT4gaXRlbS5maWVsZCA9PT0gY29sdW1uKVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5zdGFuY2UgJiYgaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2x1bW4gJHtjb2x1bW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICB2ZXJpZnlTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NrZWQgPSB0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCB8fCAodGhpcy5jb2x1bW5NZW51ICYmIHRoaXMuY29sdW1uTWVudS5sb2NrKTtcbiAgICAgICAgICAgIGNvbnN0IHN0aWNreUNvbHVtbnMgPSB0aGlzLnN0aWNreUNvbHVtbnMubGVuZ3RoIHx8ICh0aGlzLmNvbHVtbk1lbnUgJiYgdGhpcy5jb2x1bW5NZW51LnN0aWNrKTtcbiAgICAgICAgICAgIGlmIChsb2NrZWQgJiYgdGhpcy5kZXRhaWxUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGF2aW5nIGJvdGggZGV0YWlsIHRlbXBsYXRlIGFuZCBsb2NrZWQgY29sdW1ucyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoICYmICF0aGlzLm5vbkxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IG9uZSBub24tbG9ja2VkIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsb2NrZWQgfHwgdGhpcy52aXJ0dWFsQ29sdW1ucykgJiYgZXhwYW5kQ29sdW1ucyh0aGlzLmNvbHVtbkxpc3QudG9BcnJheSgpKS5maWx0ZXIoY29sdW1uID0+ICFjb2x1bW4ud2lkdGggJiYgIWlzQ29sdW1uR3JvdXBDb21wb25lbnQoY29sdW1uKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChsb2NrZWQgPyAnTG9ja2VkJyA6ICdWaXJ0dWFsJykgKyAnIGNvbHVtbnMgZmVhdHVyZSByZXF1aXJlcyBhbGwgY29sdW1ucyB0byBoYXZlIHNldCB3aWR0aC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NrZWQgJiYgIXRoaXMuaXNTY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NrZWQgY29sdW1ucyBhcmUgb25seSBzdXBwb3J0ZWQgd2hlbiBzY3JvbGxpbmcgaXMgZW5hYmxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbkxpc3QuZmlsdGVyKGlzQ29sdW1uR3JvdXBDb21wb25lbnQpLmZpbHRlcigoeCkgPT4gIXguaGFzQ2hpbGRyZW4pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sdW1uR3JvdXBDb21wb25lbnQgc2hvdWxkIGNvbnRhaW4gQ29sdW1uQ29tcG9uZW50IG9yIENvbW1hbmRDb2x1bW5Db21wb25lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5MaXN0LmZpbHRlcih4ID0+IHgubG9ja2VkICYmIHgucGFyZW50ICYmICF4LnBhcmVudC5pc0xvY2tlZCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NrZWQgY2hpbGQgY29sdW1ucyByZXF1aXJlIHRoZWlyIHBhcmVudCBjb2x1bW5zIHRvIGJlIGxvY2tlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5yb3dIZWlnaHQgfHwgdGhpcy5kZXRhaWxSb3dIZWlnaHQpICYmICF0aGlzLmlzVmlydHVhbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm93IGhlaWdodCBhbmQgZGV0YWlsIHJvdyBoZWlnaHQgc2V0dGluZ3MgcmVxdWlyZSB2aXJ0dWFsIHNjcm9sbGluZyBtb2RlIHRvIGJlIGVuYWJsZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RpY2t5Q29sdW1ucyAmJiBleHBhbmRDb2x1bW5zKHRoaXMuY29sdW1uTGlzdC50b0FycmF5KCkpLmZpbHRlcihjb2x1bW4gPT4gIWNvbHVtbi53aWR0aCAmJiAhaXNDb2x1bW5Hcm91cENvbXBvbmVudChjb2x1bW4pKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0aWNreSBjb2x1bW5zIGZlYXR1cmUgcmVxdWlyZXMgYWxsIGNvbHVtbnMgdG8gaGF2ZSBzZXQgd2lkdGguJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RpY2t5Q29sdW1ucyAmJiAhdGhpcy5pc1Njcm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0aWNreSBjb2x1bW5zIGFyZSBvbmx5IHN1cHBvcnRlZCB3aGVuIHNjcm9sbGluZyBpcyBlbmFibGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0aWNreUNvbHVtbnMgJiYgdGhpcy52aXJ0dWFsQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGF2aW5nIGJvdGggc3RpY2t5IGNvbHVtbnMgYW5kIGNvbHVtbiB2aXJ0dWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm93U3RpY2t5ICYmIHRoaXMuc2Nyb2xsYWJsZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXZpbmcgYm90aCBzdGlja3kgcm93cyBhbmQgcm93IHZpcnR1YWxpemF0aW9uIChzY3JvbGxhYmxlPVwidmlydHVhbFwiKSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm93U3RpY2t5ICYmIHRoaXMuZ3JvdXBhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXZpbmcgYm90aCBzdGlja3kgcm93cyBhbmQgZ3JvdXBpbmcgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlQ29sdW1uc0ZpZWxkKHRoaXMuY29sdW1uTGlzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXV0b0dlbmVyYXRlQ29sdW1ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkR2VuZXJhdGVDb2x1bW5zICYmICF0aGlzLmNvbHVtbnMubGVuZ3RoICYmIHRoaXMudmlldy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5yZXNldChPYmplY3Qua2V5cyh0aGlzLnZpZXcuYXQoMCkpLm1hcChmaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbiA9IG5ldyBDb2x1bW5Db21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4uZmllbGQgPSBmaWVsZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFN0YXRlQ2hhbmdlc0VtaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VTdWJzY3JpcHRpb24gPVxuICAgICAgICAgICAgbWVyZ2UodGhpcy5wYWdlQ2hhbmdlLnBpcGUobWFwKHggPT4gKHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyLCBncm91cDogdGhpcy5ncm91cCwgc2tpcDogeC5za2lwLCBzb3J0OiB0aGlzLnNvcnQsIHRha2U6IHgudGFrZVxuICAgICAgICAgICAgfSkpKSwgdGhpcy5zb3J0Q2hhbmdlLnBpcGUobWFwKHNvcnQgPT4gKHsgZmlsdGVyOiB0aGlzLmZpbHRlciwgZ3JvdXA6IHRoaXMuZ3JvdXAsIHNraXA6IHRoaXMuc2tpcCwgc29ydDogc29ydCwgdGFrZTogdGhpcy5wYWdlU2l6ZSB9KSkpLCB0aGlzLmdyb3VwQ2hhbmdlLnBpcGUobWFwKGdyb3VwID0+ICh7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlciwgZ3JvdXA6IGdyb3VwLCBza2lwOiB0aGlzLnNraXAsIHNvcnQ6IHRoaXMuc29ydCwgdGFrZTogdGhpcy5wYWdlU2l6ZVxuICAgICAgICAgICAgfSkpKSwgdGhpcy5maWx0ZXJDaGFuZ2UucGlwZShtYXAoZmlsdGVyJCQxID0+ICh7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIkJDEsIGdyb3VwOiB0aGlzLmdyb3VwLCBza2lwOiAwLCBzb3J0OiB0aGlzLnNvcnQsIHRha2U6IHRoaXMucGFnZVNpemVcbiAgICAgICAgICAgIH0pKSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSh4ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQ2VsbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsQ2VsbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVN0YXRlQ2hhbmdlLmVtaXQoeCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgYXR0YWNoRWRpdEhhbmRsZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWRpdFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlU3Vic2NyaXB0aW9uID0gdGhpcy5lZGl0U2VydmljZVxuICAgICAgICAgICAgLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMuZW1pdENSVURFdmVudC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgZW1pdENSVURFdmVudChhcmdzKSB7XG4gICAgICAgIGNvbnN0IHsgYWN0aW9uLCByb3dJbmRleCwgZm9ybUdyb3VwIH0gPSBhcmdzO1xuICAgICAgICBsZXQgZGF0YUl0ZW0gPSB0aGlzLnZpZXcuYXQocm93SW5kZXggLSB0aGlzLnNraXApO1xuICAgICAgICBpZiAoYWN0aW9uICE9PSAnYWRkJyAmJiAhZGF0YUl0ZW0pIHtcbiAgICAgICAgICAgIGRhdGFJdGVtID0gZm9ybUdyb3VwLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VDZWxsKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXJncywge1xuICAgICAgICAgICAgZGF0YUl0ZW06IGRhdGFJdGVtLFxuICAgICAgICAgICAgc2VuZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmFkZC5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2FuY2VsJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZWRpdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0LmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlLmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzYXZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmUuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbGxDbG9zZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsQ2xvc2UuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaERvbUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuY2VsbENsaWNrU3Vic2NyaXB0aW9uID0gdGhpcy5kb21FdmVudHMuY2VsbENsaWNrLnN1YnNjcmliZSgoYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jZWxsQ2xpY2suZW1pdChPYmplY3QuYXNzaWduKHsgc2VuZGVyOiB0aGlzIH0sIGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaEVsZW1lbnRFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBpZiAoaXNVbml2ZXJzYWwoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgYXJpYVJvb3QgPSB0aGlzLmFyaWFSb290Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZUNoZWNrID0gdGhpcy5yZXNpemVDaGVjay5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ3dpbmRvdycsICdyZXNpemUnLCByZXNpemVDaGVjayk7XG4gICAgICAgICAgICBjb25zdCBvcmllbnRhdGlvblN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCd3aW5kb3cnLCAnb3JpZW50YXRpb25jaGFuZ2UnLCByZXNpemVDaGVjayk7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudENsaWNrU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2NsaWNrJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lZGl0U2VydmljZS5zaG91bGRDbG9zZUNlbGwoKSAmJlxuICAgICAgICAgICAgICAgICAgICAhY2xvc2VzdChhcmdzLnRhcmdldCwgbWF0Y2hlc0NsYXNzZXMoJ2stYW5pbWF0aW9uLWNvbnRhaW5lciBrLWdyaWQtaWdub3JlLWNsaWNrJykpICYmXG4gICAgICAgICAgICAgICAgICAgICEoYWN0aXZlRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNsb3Nlc3QoYWN0aXZlRWxlbWVudCwgbWF0Y2hlc0NsYXNzZXMoJ2stYW5pbWF0aW9uLWNvbnRhaW5lcicpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5FZGl0ZWRDZWxsKGFjdGl2ZUVsZW1lbnQsIHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuY2xvc2VDZWxsKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgd2luZG93Qmx1clN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCd3aW5kb3cnLCAnYmx1cicsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgIShtYXRjaGVzTm9kZU5hbWUoJ2lucHV0JykoYWN0aXZlRWxlbWVudCkgJiYgYWN0aXZlRWxlbWVudC50eXBlID09PSAnZmlsZScgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbkVkaXRlZENlbGwoYWN0aXZlRWxlbWVudCwgdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmNsb3NlQ2VsbChhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kb21FdmVudHMud2luZG93Qmx1ci5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjbGlja1N1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHdyYXBwZXIsICdjbGljaycsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21FdmVudHMuY2xpY2suZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qga2V5ZG93blN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHdyYXBwZXIsICdrZXlkb3duJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUV2ZW50cy5rZXlkb3duLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGZvY3VzSW4gYW5kIGZvY3VzT3V0IGFyZSByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCB3aXRoIEFSSUEgcm9sZSBcImdyaWRcIlxuICAgICAgICAgICAgbGV0IGZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzSW5TdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihhcmlhUm9vdCwgJ2ZvY3VzaW4nLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmZvY3VzLmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmZvY3VzSW4uZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmb2N1c091dFN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKGFyaWFSb290LCAnZm9jdXNvdXQnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBhcmdzLnJlbGF0ZWRUYXJnZXQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRzaWRlID0gIWNsb3Nlc3QobmV4dCwgKG5vZGUpID0+IG5vZGUgPT09IGFyaWFSb290KTtcbiAgICAgICAgICAgICAgICBpZiAob3V0c2lkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbUV2ZW50cy5mb2N1c091dC5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRldGFjaEVsZW1lbnRFdmVudEhhbmRsZXJzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc2l6ZVN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRDbGlja1N1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHdpbmRvd0JsdXJTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBjbGlja1N1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGtleWRvd25TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBmb2N1c0luU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgZm9jdXNPdXRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXRjaGVzTWVkaWEoYykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zaXZlU2VydmljZS5tYXRjaGVzTWVkaWEoYy5tZWRpYSk7XG4gICAgfVxuICAgIHJlc2l6ZUNoZWNrKCkge1xuICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggIT09IHRoaXMuY2FjaGVkV2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkV2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkxpc3QuZmlsdGVySGllcmFyY2h5KGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlc01lZGlhID0gdGhpcy5tYXRjaGVzTWVkaWEoY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLm1hdGNoZXNNZWRpYSAhPT0gbWF0Y2hlc01lZGlhKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubWF0Y2hlc01lZGlhID0gbWF0Y2hlc01lZGlhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLmlzVmlzaWJsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc0NoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRQREZFeHBvcnRFdmVudCgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IG5ldyBQREZFeHBvcnRFdmVudCgpO1xuICAgICAgICB0aGlzLnBkZkV4cG9ydC5lbWl0KGFyZ3MpO1xuICAgICAgICBpZiAoIWFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZUFzUERGKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luY0hlYWRlckhlaWdodChvYnNlcnZhYmxlKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gaXNQcmVzZW50KHRoaXMubG9ja2VkSGVhZGVyKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHN5bmNSb3dzSGVpZ2h0KHRoaXMubG9ja2VkSGVhZGVyLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0sIHRoaXMuaGVhZGVyLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0pKTtcbiAgICB9XG4gICAgY29sdW1uc0NvbnRhaW5lckNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ29udGFpbmVyQ2hhbmdlU3Vic2NyaXB0aW9uID1cbiAgICAgICAgICAgIHRoaXMuc3luY0hlYWRlckhlaWdodCh0aGlzLmNvbHVtbnNDb250YWluZXIuY2hhbmdlcy5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmxvY2tlZENvbHVtbnMubGVuZ3RoID4gMCksIHN3aXRjaE1hcCgoKSA9PiB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpKSkpO1xuICAgIH1cbiAgICBoYW5kbGVDb2x1bW5SZXNpemUoKSB7XG4gICAgICAgIGNvbnN0IHJlc2l6ZXMgPSB0aGlzLmNvbHVtblJlc2l6aW5nU2VydmljZS5jaGFuZ2VzO1xuICAgICAgICB0aGlzLmNvbHVtblJlc2l6aW5nU3Vic2NyaXB0aW9uID0gcmVzaXplcy5waXBlKHRhcChlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LCAnay1ncmlkLWNvbHVtbi1yZXNpemluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS50eXBlID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsICdrLWdyaWQtY29sdW1uLXJlc2l6aW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICdzdGFydCcpLCBzd2l0Y2hNYXAoKCkgPT4gcmVzaXplcy5waXBlKFxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHJ4anMtbm8tdW5zYWZlLXRha2V1bnRpbFxuICAgICAgICB0YWtlVW50aWwocmVzaXplcy5waXBlKGZpbHRlcihlID0+IGUudHlwZSA9PT0gJ3RyaWdnZXJBdXRvRml0JykpKSwgZmlsdGVyKGUgPT4gZS50eXBlID09PSAnZW5kJykpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5ub3RpZnlSZXNpemUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIG5vdGlmeVJlc2l6ZShlKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBlLnJlc2l6ZWRDb2x1bW5zXG4gICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXNUcnV0aHkoaXRlbS5jb2x1bW4ucmVzaXphYmxlKSAmJiAhaXRlbS5jb2x1bW4uaXNDb2x1bW5Hcm91cClcbiAgICAgICAgICAgIC5tYXAoaXRlbSA9PiAoe1xuICAgICAgICAgICAgY29sdW1uOiBpdGVtLmNvbHVtbixcbiAgICAgICAgICAgIG5ld1dpZHRoOiBpdGVtLmNvbHVtbi53aWR0aCxcbiAgICAgICAgICAgIG9sZFdpZHRoOiBpdGVtLm9sZFdpZHRoXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5jb2x1bW5SZXNpemUuZW1pdChhcmdzKTtcbiAgICB9XG4gICAgYXNzZXJ0TmF2aWdhYmxlKCkge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgIXRoaXMubmF2aWdhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBHcmlkIHNob3VsZCBiZSBjb25maWd1cmVkIGFzIFtuYXZpZ2FibGVdPVwidHJ1ZVwiIHRvIGNvbnRyb2wgZm9jdXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuYXZpZ2F0aW9uTWV0YWRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGlzVmlydHVhbCA9IHRoaXMuaXNWaXJ0dWFsO1xuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IHRoaXMucGFnZVNpemU7XG4gICAgICAgIGNvbnN0IGRhdGFSb3dzID0gaXNWaXJ0dWFsID8gdGhpcy52aWV3LnRvdGFsIDogcGFnZVNpemU7XG4gICAgICAgIGNvbnN0IGFkZFJvd09mZnNldCA9IHRoaXMuZWRpdFNlcnZpY2UuaGFzTmV3SXRlbSA/IDEgOiAwO1xuICAgICAgICBjb25zdCBmaWx0ZXJSb3dPZmZzZXQgPSBoYXNGaWx0ZXJSb3codGhpcy5maWx0ZXJhYmxlKSA/IDEgOiAwO1xuICAgICAgICBjb25zdCBoZWFkZXJSb3dzID0gdGhpcy50b3RhbENvbHVtbkxldmVscyArIDEgKyBmaWx0ZXJSb3dPZmZzZXQgKyBhZGRSb3dPZmZzZXQ7XG4gICAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvbk1ldGFkYXRhKGRhdGFSb3dzLCBoZWFkZXJSb3dzLCBpc1ZpcnR1YWwsIHRoaXMuaGFzUGFnZXIsIGlzUHJlc2VudCh0aGlzLmRldGFpbFRlbXBsYXRlKSwgdGhpcy53cmFwcGVyLCB0aGlzLnZpcnR1YWxDb2x1bW5zLCB0aGlzLmNvbHVtbnNDb250YWluZXIpO1xuICAgIH1cbiAgICB1cGRhdGVOYXZpZ2F0aW9uTWV0YWRhdGEoKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UubWV0YWRhdGEgPSB0aGlzLm5hdmlnYXRpb25NZXRhZGF0YSgpO1xuICAgIH1cbiAgICBhcHBseUF1dG9TaXplKCkge1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5jb2x1bW5zLmZpbHRlcigoYykgPT4gdGhpcy5hdXRvU2l6ZSA/IGMuYXV0b1NpemUgIT09IGZhbHNlIDogYy5hdXRvU2l6ZSk7XG4gICAgICAgIGlmIChjb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLm9uU3RhYmxlLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKF8gPT4gdGhpcy5hdXRvRml0Q29sdW1ucyhjb2xzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Db2x1bW5SYW5nZUNoYW5nZShyYW5nZSkge1xuICAgICAgICBjb25zdCB2aWV3cG9ydENvbHVtbnMgPSB0aGlzLnZpZXdwb3J0Q29sdW1ucyA9IFtdO1xuICAgICAgICBjb25zdCBsZWFmVmlld3BvcnRDb2x1bW5zID0gdGhpcy5jb2x1bW5zQ29udGFpbmVyXG4gICAgICAgICAgICAubm9uTG9ja2VkTGVhZkNvbHVtbnMudG9BcnJheSgpLnNsaWNlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQgKyAxKTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgbGVhZlZpZXdwb3J0Q29sdW1ucy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gbGVhZlZpZXdwb3J0Q29sdW1uc1tpZHhdO1xuICAgICAgICAgICAgd2hpbGUgKGNvbHVtbi5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW4ucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9BZGQgPSBbY29sdW1uXTtcbiAgICAgICAgICAgIHdoaWxlICh0b0FkZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSB0b0FkZC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0Q29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5pc0NvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvQWRkLnVuc2hpZnQuYXBwbHkodG9BZGQsIGNvbHVtbi5jaGlsZHJlbkFycmF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXN0RnJvbUdyb3VwID0gdmlld3BvcnRDb2x1bW5zW3ZpZXdwb3J0Q29sdW1ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbHVtbiA9IGxlYWZWaWV3cG9ydENvbHVtbnNbaWR4XTtcbiAgICAgICAgICAgIHdoaWxlIChjb2x1bW4gIT09IGxhc3RGcm9tR3JvdXAgJiYgaWR4IDwgbGVhZlZpZXdwb3J0Q29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBsZWFmVmlld3BvcnRDb2x1bW5zW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBsZWFmVmlld3BvcnRDb2x1bW5zWzBdO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJhbmdlLm9mZnNldDtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdmlld3BvcnRDb2x1bW5zWzBdO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBmaXJzdCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCAtPSBjdXJyZW50LmlzQ29sdW1uR3JvdXAgPyAwIDogY3VycmVudC53aWR0aDtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB2aWV3cG9ydENvbHVtbnNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbExldmVscyA9IHRoaXMuY29sdW1uc0NvbnRhaW5lci50b3RhbExldmVscztcbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDw9IHRvdGFsTGV2ZWxzOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRDb2x1bW4gPSBpZHggPCB0b3RhbExldmVscyA/IG5ldyBDb2x1bW5Hcm91cENvbXBvbmVudChwcmV2aW91cykgOiBuZXcgQ29sdW1uQmFzZSQxKHByZXZpb3VzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBvZmZzZXRDb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldENvbHVtbi50aXRsZSA9IFwiXFx1MDBBMFwiO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRDb2x1bW4ud2lkdGggPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0Q29sdW1ucy51bnNoaWZ0KG9mZnNldENvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVhZlZpZXdwb3J0Q29sdW1ucyA9IHZpZXdwb3J0Q29sdW1ucy5maWx0ZXIoYyA9PiAhYy5pc0NvbHVtbkdyb3VwKTtcbiAgICB9XG4gICAgdG9nZ2xlRGV0YWlsUm93TGVnYWN5KGluZGV4LCBleHBhbmQpIHtcbiAgICAgICAgY29uc3QgaGFzQ2FsbGJhY2sgPSB0eXBlb2YgdGhpcy5pc0RldGFpbEV4cGFuZGVkID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGV4cGFuZFJvdyBhbmQgY29sbGFwc2VSb3cgbWV0aG9kcyBzaG91bGQgbm90IGJlIGNhbGxlZCB3aGVuIHVzaW5nIHRoZSAnICtcbiAgICAgICAgICAgICAgICAna2VuZG9HcmlkRGV0YWlsc0V4cGFuZEJ5IGRpcmVjdGl2ZSBvciB0aGUgaXNEZXRhaWxFeHBhbmRlZCBjYWxsYmFjay4gJyArXG4gICAgICAgICAgICAgICAgJ1RoZXNlIG1ldGhvZHMgYXJlIHByb3ZpZGVkIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggbGVnYWN5IHZlcnNpb25zLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkgJiYgaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXRhaWxzU2VydmljZS5pc0V4cGFuZGVkKGluZGV4LCBudWxsKSAhPT0gZXhwYW5kKSB7XG4gICAgICAgICAgICB0aGlzLmRldGFpbHNTZXJ2aWNlLnRvZ2dsZVJvdyhpbmRleCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9nZ2xlR3JvdXBSb3dMZWdhY3koaW5kZXgsIGV4cGFuZCkge1xuICAgICAgICBjb25zdCBoYXNDYWxsYmFjayA9IHR5cGVvZiB0aGlzLmlzR3JvdXBFeHBhbmRlZCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmIGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBleHBhbmRHcm91cCBhbmQgY29sbGFwc2VHcm91cCBtZXRob2RzIHNob3VsZCBub3QgYmUgY2FsbGVkIHdoZW4gdXNpbmcgdGhlICcgK1xuICAgICAgICAgICAgICAgICdrZW5kb0dyaWRFeHBhbmRHcm91cEJ5IGRpcmVjdGl2ZSBvciB0aGUgaXNHcm91cEV4cGFuZGVkIGNhbGxiYWNrLiAnICtcbiAgICAgICAgICAgICAgICAnVGhlc2UgbWV0aG9kcyBhcmUgcHJvdmlkZWQgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBsZWdhY3kgdmVyc2lvbnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSAmJiBoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyb3Vwc1NlcnZpY2UuaXNFeHBhbmRlZCh7IGdyb3VwSW5kZXg6IGluZGV4IH0pICE9PSBleHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzU2VydmljZS50b2dnbGVSb3coeyBpbmRleCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRSZXNldFNlbGVjdGlvbihzZWxlY3RhYmxlQ2hhbmdlcykge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gc2VsZWN0YWJsZUNoYW5nZXMucHJldmlvdXNWYWx1ZTtcbiAgICAgICAgaWYgKCFwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24gd2FzIGRpc2FibGVkLCBubyBuZWVkIHRvIHJlc2V0LlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGFibGVDaGFuZ2VzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgaWYgKCFjdXJyZW50VmFsdWUgfHwgY3VycmVudFZhbHVlLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24gZGlzYWJsZWQsIHJlc2V0LlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUuY2VsbCAhPT0gY3VycmVudFZhbHVlLmNlbGw7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInBhZ2VTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvd0hlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGV0YWlsUm93SGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInNraXBcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzb3J0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmFja0J5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3VwXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInZpcnR1YWxDb2x1bW5zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzb3J0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwicGFnZWFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3VwYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYXRhYmxlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9TaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3dDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvd1N0aWNreVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvd1NlbGVjdGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRnVuY3Rpb25dKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFNlbGVjdGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInJlb3JkZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwibG9hZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uTWVudVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImhpZGVIZWFkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWdlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzb3J0Q2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVN0YXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBFeHBhbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cENvbGxhcHNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGV0YWlsRXhwYW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGV0YWlsQ29sbGFwc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlZGl0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FuY2VsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2F2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInJlbW92ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImFkZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxDbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInBkZkV4cG9ydFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImV4Y2VsRXhwb3J0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uUmVzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uUmVvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtblZpc2liaWxpdHlDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5Mb2NrZWRDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5TdGlja3lDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxCb3R0b21cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZW50U2Nyb2xsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oQ29sdW1uQmFzZSQxKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZ3JpZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3Nlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWdyaWQtbG9ja2VkY29sdW1ucycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsb2NrZWRDbGFzc2VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZ3JpZC12aXJ0dWFsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInZpcnR1YWxDbGFzc2VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZ3JpZC1uby1zY3JvbGxiYXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9TY3JvbGxiYXJDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihEZXRhaWxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImRldGFpbFRlbXBsYXRlQ2hpbGRyZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihDZWxsTG9hZGluZ1RlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbExvYWRpbmdUZW1wbGF0ZUNoaWxkcmVuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oTG9hZGluZ1RlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwibG9hZGluZ1RlbXBsYXRlQ2hpbGRyZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihOb1JlY29yZHNUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcIm5vUmVjb3Jkc1RlbXBsYXRlQ2hpbGRyZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihQYWdlclRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwicGFnZXJUZW1wbGF0ZUNoaWxkcmVuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oVG9vbGJhclRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbGJhclRlbXBsYXRlQ2hpbGRyZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihDb2x1bW5NZW51VGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5NZW51VGVtcGxhdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2xvY2tlZEhlYWRlcicsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwibG9ja2VkSGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2hlYWRlcicsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGRyZW4oJ2Zvb3RlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb290ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnYXJpYVJvb3QnLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIEdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImFyaWFSb290XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0RldGFpbEV4cGFuZGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRnVuY3Rpb25dKVxuXSwgR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNHcm91cEV4cGFuZGVkXCIsIG51bGwpO1xuR3JpZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9HcmlkJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBCcm93c2VyU3VwcG9ydFNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgQ29sdW1uSW5mb1NlcnZpY2UsXG4gICAgICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICAgICAgQ2VsbFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBEZXRhaWxzU2VydmljZSxcbiAgICAgICAgICAgIEdyb3Vwc1NlcnZpY2UsXG4gICAgICAgICAgICBHcm91cEluZm9TZXJ2aWNlLFxuICAgICAgICAgICAgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgICAgIEVkaXRTZXJ2aWNlLFxuICAgICAgICAgICAgUERGU2VydmljZSxcbiAgICAgICAgICAgIFN1c3BlbmRTZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENFTExfQ09OVEVYVCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogybU1JDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5ncmlkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEZpbHRlclNlcnZpY2UsXG4gICAgICAgICAgICBSZXNwb25zaXZlU2VydmljZSxcbiAgICAgICAgICAgIFBhZ2VyQ29udGV4dFNlcnZpY2UsXG4gICAgICAgICAgICBFeGNlbFNlcnZpY2UsXG4gICAgICAgICAgICBTY3JvbGxTeW5jU2VydmljZSxcbiAgICAgICAgICAgIFJlc2l6ZVNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbERhdGFDaGFuZ2VzU2VydmljZSxcbiAgICAgICAgICAgIERvbUV2ZW50c1NlcnZpY2UsXG4gICAgICAgICAgICBDb2x1bW5SZXNpemluZ1NlcnZpY2UsXG4gICAgICAgICAgICBTaW5nbGVQb3B1cFNlcnZpY2UsXG4gICAgICAgICAgICBEcmFnQW5kRHJvcFNlcnZpY2UsXG4gICAgICAgICAgICBEcmFnSGludFNlcnZpY2UsXG4gICAgICAgICAgICBEcm9wQ3VlU2VydmljZSxcbiAgICAgICAgICAgIENvbHVtblJlb3JkZXJTZXJ2aWNlLFxuICAgICAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBGb2N1c1Jvb3QsXG4gICAgICAgICAgICBJZFNlcnZpY2UsXG4gICAgICAgICAgICBTY3JvbGxSZXF1ZXN0U2VydmljZSxcbiAgICAgICAgICAgIFNvcnRTZXJ2aWNlXG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZCcsXG4gICAgICAgIHN0eWxlczogW1xuICAgICAgICAgICAgLy8gU3R5bGVzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGtlbmRvLXRoZW1lLWRlZmF1bHRAdjIuNDYuMCBhbmQgZWFybGllci5cbiAgICAgICAgICAgIGAgICAuay1ncmlkIC5rLWdyaWQtYXJpYS1yb290IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgZmxleDogMSAxIGF1dG87XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLmstZ3JpZCAuay1maWx0ZXItcm93IHRkIHtcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgIH1gXG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIga2VuZG9HcmlkTG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgICAgIGkxOG4tZ3JvdXBQYW5lbEVtcHR5PVwia2VuZG8uZ3JpZC5ncm91cFBhbmVsRW1wdHl8VGhlIGxhYmVsIHZpc2libGUgaW4gdGhlIEdyaWQgZ3JvdXAgcGFuZWwgd2hlbiBpdCBpcyBlbXB0eVwiXG4gICAgICAgICAgICBncm91cFBhbmVsRW1wdHk9XCJEcmFnIGEgY29sdW1uIGhlYWRlciBhbmQgZHJvcCBpdCBoZXJlIHRvIGdyb3VwIGJ5IHRoYXQgY29sdW1uXCJcblxuICAgICAgICAgICAgaTE4bi1ub1JlY29yZHM9XCJrZW5kby5ncmlkLm5vUmVjb3Jkc3xUaGUgbGFiZWwgdmlzaWJsZSBpbiB0aGUgR3JpZCB3aGVuIHRoZXJlIGFyZSBubyByZWNvcmRzXCJcbiAgICAgICAgICAgIG5vUmVjb3Jkcz1cIk5vIHJlY29yZHMgYXZhaWxhYmxlLlwiXG5cbiAgICAgICAgICAgIGkxOG4tcGFnZXJMYWJlbD1cImtlbmRvLmdyaWQucGFnZXJMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBHcmlkIHBhZ2VyXCJcbiAgICAgICAgICAgIHBhZ2VyTGFiZWw9XCJ7eyAnUGFnZSBuYXZpZ2F0aW9uLCBwYWdlIHtjdXJyZW50UGFnZX0gb2Yge3RvdGFsUGFnZXN9JyB9fVwiXG5cbiAgICAgICAgICAgIGkxOG4tcGFnZXJGaXJzdFBhZ2U9XCJrZW5kby5ncmlkLnBhZ2VyRmlyc3RQYWdlfFRoZSBsYWJlbCBmb3IgdGhlIGZpcnN0IHBhZ2UgYnV0dG9uIGluIEdyaWQgcGFnZXJcIlxuICAgICAgICAgICAgcGFnZXJGaXJzdFBhZ2U9XCJHbyB0byB0aGUgZmlyc3QgcGFnZVwiXG5cbiAgICAgICAgICAgIGkxOG4tcGFnZXJQcmV2aW91c1BhZ2U9XCJrZW5kby5ncmlkLnBhZ2VyUHJldmlvdXNQYWdlfFRoZSBsYWJlbCBmb3IgdGhlIHByZXZpb3VzIHBhZ2UgYnV0dG9uIGluIEdyaWQgcGFnZXJcIlxuICAgICAgICAgICAgcGFnZXJQcmV2aW91c1BhZ2U9XCJHbyB0byB0aGUgcHJldmlvdXMgcGFnZVwiXG5cbiAgICAgICAgICAgIGkxOG4tcGFnZXJOZXh0UGFnZT1cImtlbmRvLmdyaWQucGFnZXJOZXh0UGFnZXxUaGUgbGFiZWwgZm9yIHRoZSBuZXh0IHBhZ2UgYnV0dG9uIGluIEdyaWQgcGFnZXJcIlxuICAgICAgICAgICAgcGFnZXJOZXh0UGFnZT1cIkdvIHRvIHRoZSBuZXh0IHBhZ2VcIlxuXG4gICAgICAgICAgICBpMThuLXBhZ2VyTGFzdFBhZ2U9XCJrZW5kby5ncmlkLnBhZ2VyTGFzdFBhZ2V8VGhlIGxhYmVsIGZvciB0aGUgbGFzdCBwYWdlIGJ1dHRvbiBpbiBHcmlkIHBhZ2VyXCJcbiAgICAgICAgICAgIHBhZ2VyTGFzdFBhZ2U9XCJHbyB0byB0aGUgbGFzdCBwYWdlXCJcblxuICAgICAgICAgICAgaTE4bi1wYWdlclBhZ2U9XCJrZW5kby5ncmlkLnBhZ2VyUGFnZXxUaGUgbGFiZWwgYmVmb3JlIHRoZSBjdXJyZW50IHBhZ2UgbnVtYmVyIGluIHRoZSBHcmlkIHBhZ2VyXCJcbiAgICAgICAgICAgIHBhZ2VyUGFnZT1cIlBhZ2VcIlxuXG4gICAgICAgICAgICBpMThuLXBhZ2VyT2Y9XCJrZW5kby5ncmlkLnBhZ2VyT2Z8VGhlIGxhYmVsIGJlZm9yZSB0aGUgdG90YWwgcGFnZXMgbnVtYmVyIGluIHRoZSBHcmlkIHBhZ2VyXCJcbiAgICAgICAgICAgIHBhZ2VyT2Y9XCJvZlwiXG5cbiAgICAgICAgICAgIGkxOG4tcGFnZXJJdGVtcz1cImtlbmRvLmdyaWQucGFnZXJJdGVtc3xUaGUgbGFiZWwgYWZ0ZXIgdGhlIHRvdGFsIHBhZ2VzIG51bWJlciBpbiB0aGUgR3JpZCBwYWdlclwiXG4gICAgICAgICAgICBwYWdlckl0ZW1zPVwiaXRlbXNcIlxuXG4gICAgICAgICAgICBpMThuLXBhZ2VyUGFnZU51bWJlcklucHV0VGl0bGU9XCJrZW5kby5ncmlkLnBhZ2VyUGFnZU51bWJlcklucHV0VGl0bGV8VGhlIGxhYmVsIGZvciB0aGUgcGFnZXIgaW5wdXQgaW4gdGhlIEdyaWQgcGFnZXJcIlxuICAgICAgICAgICAgcGFnZXJQYWdlTnVtYmVySW5wdXRUaXRsZT1cIlBhZ2UgTnVtYmVyXCJcblxuICAgICAgICAgICAgaTE4bi1wYWdlckl0ZW1zUGVyUGFnZT1cImtlbmRvLmdyaWQucGFnZXJJdGVtc1BlclBhZ2V8VGhlIGxhYmVsIGZvciB0aGUgcGFnZSBzaXplIGNob29zZXIgaW4gdGhlIEdyaWQgcGFnZXJcIlxuICAgICAgICAgICAgcGFnZXJJdGVtc1BlclBhZ2U9XCJpdGVtcyBwZXIgcGFnZVwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyPVwia2VuZG8uZ3JpZC5maWx0ZXJ8VGhlIGxhYmVsIG9mIHRoZSBmaWx0ZXIgY2VsbCBvciBpY29uXCJcbiAgICAgICAgICAgIGZpbHRlcj1cIkZpbHRlclwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVySW5wdXRMYWJlbD1cImtlbmRvLmdyaWQuZmlsdGVySW5wdXRMYWJlbHxUaGUgbGFiZWwgb2YgdGhlIGZpbHRlciByb3cgYW5kIG1lbnUgaW5wdXRzXCJcbiAgICAgICAgICAgIGZpbHRlcklucHV0TGFiZWw9XCJ7eyAne2NvbHVtbk5hbWV9IEZpbHRlcicgfX1cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlck1lbnVUaXRsZT1cImtlbmRvLmdyaWQuZmlsdGVyTWVudVRpdGxlfFRoZSB0aXRsZSBvZiB0aGUgZmlsdGVyIG1lbnUgaWNvblwiXG4gICAgICAgICAgICBmaWx0ZXJNZW51VGl0bGU9XCJ7eyAne2NvbHVtbk5hbWV9IEZpbHRlciBNZW51JyB9fVwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyTWVudU9wZXJhdG9yc0Ryb3BEb3duTGFiZWw9XCJrZW5kby5ncmlkLmZpbHRlck1lbnVPcGVyYXRvcnNEcm9wRG93bkxhYmVsfFRoZSBsYWJlbCBvZiB0aGUgZmlsdGVyIG1lbnUgb3BlcmF0b3JzIGRyb3Bkb3duXCJcbiAgICAgICAgICAgIGZpbHRlck1lbnVPcGVyYXRvcnNEcm9wRG93bkxhYmVsPVwie3sgJ3tjb2x1bW5OYW1lfSBGaWx0ZXIgT3BlcmF0b3JzJyB9fVwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyTWVudUxvZ2ljRHJvcERvd25MYWJlbD1cImtlbmRvLmdyaWQuZmlsdGVyTWVudUxvZ2ljRHJvcERvd25MYWJlbHxUaGUgbGFiZWwgb2YgdGhlIGZpbHRlciBtZW51IGxvZ2ljIGRyb3Bkb3duXCJcbiAgICAgICAgICAgIGZpbHRlck1lbnVMb2dpY0Ryb3BEb3duTGFiZWw9XCJ7eyAne2NvbHVtbk5hbWV9IEZpbHRlciBMb2dpYycgfX1cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckVxT3BlcmF0b3I9XCJrZW5kby5ncmlkLmZpbHRlckVxT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGVxdWFsIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJFcU9wZXJhdG9yPVwiSXMgZXF1YWwgdG9cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlck5vdEVxT3BlcmF0b3I9XCJrZW5kby5ncmlkLmZpbHRlck5vdEVxT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIG5vdCBlcXVhbCBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyTm90RXFPcGVyYXRvcj1cIklzIG5vdCBlcXVhbCB0b1wiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVySXNOdWxsT3BlcmF0b3I9XCJrZW5kby5ncmlkLmZpbHRlcklzTnVsbE9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBpcyBudWxsIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJJc051bGxPcGVyYXRvcj1cIklzIG51bGxcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlcklzTm90TnVsbE9wZXJhdG9yPVwia2VuZG8uZ3JpZC5maWx0ZXJJc05vdE51bGxPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgaXMgbm90IG51bGwgZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlcklzTm90TnVsbE9wZXJhdG9yPVwiSXMgbm90IG51bGxcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlcklzRW1wdHlPcGVyYXRvcj1cImtlbmRvLmdyaWQuZmlsdGVySXNFbXB0eU9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBpcyBlbXB0eSBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVySXNFbXB0eU9wZXJhdG9yPVwiSXMgZW1wdHlcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlcklzTm90RW1wdHlPcGVyYXRvcj1cImtlbmRvLmdyaWQuZmlsdGVySXNOb3RFbXB0eU9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBpcyBub3QgZW1wdHkgZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlcklzTm90RW1wdHlPcGVyYXRvcj1cIklzIG5vdCBlbXB0eVwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyU3RhcnRzV2l0aE9wZXJhdG9yPVwia2VuZG8uZ3JpZC5maWx0ZXJTdGFydHNXaXRoT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIHN0YXJ0cyB3aXRoIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJTdGFydHNXaXRoT3BlcmF0b3I9XCJTdGFydHMgd2l0aFwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyQ29udGFpbnNPcGVyYXRvcj1cImtlbmRvLmdyaWQuZmlsdGVyQ29udGFpbnNPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgY29udGFpbnMgZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlckNvbnRhaW5zT3BlcmF0b3I9XCJDb250YWluc1wiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyTm90Q29udGFpbnNPcGVyYXRvcj1cImtlbmRvLmdyaWQuZmlsdGVyTm90Q29udGFpbnNPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgZG9lcyBub3QgY29udGFpbiBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyTm90Q29udGFpbnNPcGVyYXRvcj1cIkRvZXMgbm90IGNvbnRhaW5cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckVuZHNXaXRoT3BlcmF0b3I9XCJrZW5kby5ncmlkLmZpbHRlckVuZHNXaXRoT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGVuZHMgd2l0aCBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyRW5kc1dpdGhPcGVyYXRvcj1cIkVuZHMgd2l0aFwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyR3RlT3BlcmF0b3I9XCJrZW5kby5ncmlkLmZpbHRlckd0ZU9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlckd0ZU9wZXJhdG9yPVwiSXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJHdE9wZXJhdG9yPVwia2VuZG8uZ3JpZC5maWx0ZXJHdE9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBncmVhdGVyIHRoYW4gZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlckd0T3BlcmF0b3I9XCJJcyBncmVhdGVyIHRoYW5cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckx0ZU9wZXJhdG9yPVwia2VuZG8uZ3JpZC5maWx0ZXJMdGVPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgbGVzcyB0aGFuIG9yIGVxdWFsIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJMdGVPcGVyYXRvcj1cIklzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1wiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyTHRPcGVyYXRvcj1cImtlbmRvLmdyaWQuZmlsdGVyTHRPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgbGVzcyB0aGFuIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJMdE9wZXJhdG9yPVwiSXMgbGVzcyB0aGFuXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJJc1RydWU9XCJrZW5kby5ncmlkLmZpbHRlcklzVHJ1ZXxUaGUgdGV4dCBvZiB0aGUgSXNUcnVlIGJvb2xlYW4gZmlsdGVyIG9wdGlvblwiXG4gICAgICAgICAgICBmaWx0ZXJJc1RydWU9XCJJcyBUcnVlXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJJc0ZhbHNlPVwia2VuZG8uZ3JpZC5maWx0ZXJJc0ZhbHNlfFRoZSB0ZXh0IG9mIHRoZSBJc0ZhbHNlIGJvb2xlYW4gZmlsdGVyIG9wdGlvblwiXG4gICAgICAgICAgICBmaWx0ZXJJc0ZhbHNlPVwiSXMgRmFsc2VcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckJvb2xlYW5BbGw9XCJrZW5kby5ncmlkLmZpbHRlckJvb2xlYW5BbGx8VGhlIHRleHQgb2YgdGhlIChBbGwpIGJvb2xlYW4gZmlsdGVyIG9wdGlvblwiXG4gICAgICAgICAgICBmaWx0ZXJCb29sZWFuQWxsPVwiKEFsbClcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckFmdGVyT3JFcXVhbE9wZXJhdG9yPVwia2VuZG8uZ3JpZC5maWx0ZXJBZnRlck9yRXF1YWxPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgYWZ0ZXIgb3IgZXF1YWwgZGF0ZSBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyQWZ0ZXJPckVxdWFsT3BlcmF0b3I9XCJJcyBhZnRlciBvciBlcXVhbCB0b1wiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyQWZ0ZXJPcGVyYXRvcj1cImtlbmRvLmdyaWQuZmlsdGVyQWZ0ZXJPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgYWZ0ZXIgZGF0ZSBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyQWZ0ZXJPcGVyYXRvcj1cIklzIGFmdGVyXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJCZWZvcmVPcGVyYXRvcj1cImtlbmRvLmdyaWQuZmlsdGVyQmVmb3JlT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGJlZm9yZSBkYXRlIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJCZWZvcmVPcGVyYXRvcj1cIklzIGJlZm9yZVwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyQmVmb3JlT3JFcXVhbE9wZXJhdG9yPVwia2VuZG8uZ3JpZC5maWx0ZXJCZWZvcmVPckVxdWFsT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGJlZm9yZSBvciBlcXVhbCBkYXRlIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJCZWZvcmVPckVxdWFsT3BlcmF0b3I9XCJJcyBiZWZvcmUgb3IgZXF1YWwgdG9cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckZpbHRlckJ1dHRvbj1cImtlbmRvLmdyaWQuZmlsdGVyRmlsdGVyQnV0dG9ufFRoZSB0ZXh0IG9mIHRoZSBmaWx0ZXIgYnV0dG9uXCJcbiAgICAgICAgICAgIGZpbHRlckZpbHRlckJ1dHRvbj1cIkZpbHRlclwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyQ2xlYXJCdXR0b249XCJrZW5kby5ncmlkLmZpbHRlckNsZWFyQnV0dG9ufFRoZSB0ZXh0IG9mIHRoZSBjbGVhciBmaWx0ZXIgYnV0dG9uXCJcbiAgICAgICAgICAgIGZpbHRlckNsZWFyQnV0dG9uPVwiQ2xlYXJcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckFuZExvZ2ljPVwia2VuZG8uZ3JpZC5maWx0ZXJBbmRMb2dpY3xUaGUgdGV4dCBvZiB0aGUgQW5kIGZpbHRlciBsb2dpY1wiXG4gICAgICAgICAgICBmaWx0ZXJBbmRMb2dpYz1cIkFuZFwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyT3JMb2dpYz1cImtlbmRvLmdyaWQuZmlsdGVyT3JMb2dpY3xUaGUgdGV4dCBvZiB0aGUgT3IgZmlsdGVyIGxvZ2ljXCJcbiAgICAgICAgICAgIGZpbHRlck9yTG9naWM9XCJPclwiXG5cbiAgICAgICAgICAgIGkxOG4tbG9hZGluZz1cImtlbmRvLmdyaWQubG9hZGluZ3xUaGUgbG9hZGluZyB0ZXh0XCJcbiAgICAgICAgICAgIGxvYWRpbmc9XCJMb2FkaW5nXCJcblxuICAgICAgICAgICAgaTE4bi1ncmlkTGFiZWw9XCJrZW5kby5ncmlkLmdyaWRMYWJlbHxUaGUgR3JpZCBhcmlhLWxhYmVsXCJcbiAgICAgICAgICAgIGdyaWRMYWJlbD1cIkRhdGEgdGFibGVcIlxuXG4gICAgICAgICAgICBpMThuLWNvbHVtbk1lbnU9XCJrZW5kby5ncmlkLmNvbHVtbk1lbnV8VGhlIHRpdGxlIG9mIHRoZSBjb2x1bW4gbWVudSBpY29uXCJcbiAgICAgICAgICAgIGNvbHVtbk1lbnU9XCJ7eyAne2NvbHVtbk5hbWV9IENvbHVtbiBNZW51JyB9fVwiXG5cbiAgICAgICAgICAgIGkxOG4tY29sdW1ucz1cImtlbmRvLmdyaWQuY29sdW1uc3xUaGUgdGV4dCBzaG93biBpbiB0aGUgY29sdW1uIG1lbnUgZm9yIHRoZSBjb2x1bW5zIGl0ZW1cIlxuICAgICAgICAgICAgY29sdW1ucz1cIkNvbHVtbnNcIlxuXG4gICAgICAgICAgICBpMThuLWxvY2s9XCJrZW5kby5ncmlkLmxvY2t8VGhlIHRleHQgc2hvd24gaW4gdGhlIGNvbHVtbiBtZW51IGZvciB0aGUgbG9jayBpdGVtXCJcbiAgICAgICAgICAgIGxvY2s9XCJMb2NrXCJcblxuICAgICAgICAgICAgaTE4bi11bmxvY2s9XCJrZW5kby5ncmlkLnVubG9ja3xUaGUgdGV4dCBzaG93biBpbiB0aGUgY29sdW1uIG1lbnUgZm9yIHRoZSB1bmxvY2sgaXRlbVwiXG4gICAgICAgICAgICB1bmxvY2s9XCJVbmxvY2tcIlxuXG4gICAgICAgICAgICBpMThuLXNldENvbHVtblBvc2l0aW9uPVwia2VuZG8uZ3JpZC5zZXRDb2x1bW5Qb3NpdGlvbnxUaGUgdGV4dCBzaG93biBpbiB0aGUgY29sdW1uIG1lbnUgZm9yIHRoZSBzZXQgY29sdW1uIHBvc2l0aW9uIGl0ZW1cIlxuICAgICAgICAgICAgc2V0Q29sdW1uUG9zaXRpb249XCJTZXQgQ29sdW1uIFBvc2l0aW9uXCJcblxuICAgICAgICAgICAgaTE4bi1zdGljaz1cImtlbmRvLmdyaWQuc3RpY2t8VGhlIHRleHQgc2hvd24gaW4gdGhlIGNvbHVtbiBtZW51IGZvciB0aGUgc3RpY2sgaXRlbVwiXG4gICAgICAgICAgICBzdGljaz1cIlN0aWNrXCJcblxuICAgICAgICAgICAgaTE4bi11bnN0aWNrPVwia2VuZG8uZ3JpZC51bnN0aWNrfFRoZSB0ZXh0IHNob3duIGluIHRoZSBjb2x1bW4gbWVudSBmb3IgdGhlIHVuc3RpY2sgaXRlbVwiXG4gICAgICAgICAgICB1bnN0aWNrPVwiVW5zdGlja1wiXG5cbiAgICAgICAgICAgIGkxOG4tc29ydGFibGU9XCJrZW5kby5ncmlkLnNvcnRhYmxlfFRoZSBsYWJlbCBvZiB0aGUgc29ydCBpY29uXCJcbiAgICAgICAgICAgIHNvcnRhYmxlPVwiU29ydGFibGVcIlxuXG4gICAgICAgICAgICBpMThuLXNvcnRBc2NlbmRpbmc9XCJrZW5kby5ncmlkLnNvcnRBc2NlbmRpbmd8VGhlIHRleHQgc2hvd24gaW4gdGhlIGNvbHVtbiBtZW51IGZvciB0aGUgc29ydCBhc2NlbmRpbmcgaXRlbVwiXG4gICAgICAgICAgICBzb3J0QXNjZW5kaW5nPVwiU29ydCBBc2NlbmRpbmdcIlxuXG4gICAgICAgICAgICBpMThuLXNvcnREZXNjZW5kaW5nPVwia2VuZG8uZ3JpZC5zb3J0RGVzY2VuZGluZ3xUaGUgdGV4dCBzaG93biBpbiB0aGUgY29sdW1uIG1lbnUgZm9yIHRoZSBzb3J0IGRlc2NlbmRpbmcgaXRlbVwiXG4gICAgICAgICAgICBzb3J0RGVzY2VuZGluZz1cIlNvcnQgRGVzY2VuZGluZ1wiXG5cbiAgICAgICAgICAgIGkxOG4tc29ydGVkQXNjZW5kaW5nPVwia2VuZG8uZ3JpZC5zb3J0ZWRBc2NlbmRpbmd8VGhlIHN0YXR1cyBhbm5vdW5jZW1lbnQgd2hlbiBhIGNvbHVtbiBpcyBzb3J0ZWQgYXNjZW5kaW5nXCJcbiAgICAgICAgICAgIHNvcnRlZEFzY2VuZGluZz1cIlNvcnRlZCBBc2NlbmRpbmdcIlxuXG4gICAgICAgICAgICBpMThuLXNvcnRlZERlc2NlbmRpbmc9XCJrZW5kby5ncmlkLnNvcnRlZERlc2NlbmRpbmd8VGhlIHN0YXR1cyBhbm5vdW5jZW1lbnQgd2hlbiBhIGNvbHVtbiBpcyBzb3J0ZWQgZGVzY2VuZGluZ1wiXG4gICAgICAgICAgICBzb3J0ZWREZXNjZW5kaW5nPVwiU29ydGVkIERlc2NlbmRpbmdcIlxuXG4gICAgICAgICAgICBpMThuLXNvcnRlZERlZmF1bHQ9XCJrZW5kby5ncmlkLnNvcnRlZERlZmF1bHR8VGhlIHN0YXR1cyBhbm5vdW5jZW1lbnQgd2hlbiBhIGNvbHVtbiBpcyBubyBsb25nZXIgc29ydGVkXCJcbiAgICAgICAgICAgIHNvcnRlZERlZmF1bHQ9XCJOb3QgU29ydGVkXCJcblxuICAgICAgICAgICAgaTE4bi1jb2x1bW5zQXBwbHk9XCJrZW5kby5ncmlkLmNvbHVtbnNBcHBseXxUaGUgdGV4dCBzaG93biBpbiB0aGUgY29sdW1uIG1lbnUgb3IgY29sdW1uIGNob29zZXIgZm9yIHRoZSBjb2x1bW5zIGFwcGx5IGJ1dHRvblwiXG4gICAgICAgICAgICBjb2x1bW5zQXBwbHk9XCJBcHBseVwiXG5cbiAgICAgICAgICAgIGkxOG4tY29sdW1uc1Jlc2V0PVwia2VuZG8uZ3JpZC5jb2x1bW5zUmVzZXR8VGhlIHRleHQgc2hvd24gaW4gdGhlIGNvbHVtbiBtZW51IG9yIGNvbHVtbiBjaG9vc2VyIGZvciB0aGUgY29sdW1ucyByZXNldCBidXR0b25cIlxuICAgICAgICAgICAgY29sdW1uc1Jlc2V0PVwiUmVzZXRcIlxuXG4gICAgICAgICAgICBpMThuLWRldGFpbEV4cGFuZD1cImtlbmRvLmdyaWQuZGV0YWlsRXhwYW5kfFRoZSB0aXRsZSBvZiB0aGUgZXhwYW5kIGljb24gb2YgZGV0YWlsIHJvd3MuXCJcbiAgICAgICAgICAgIGRldGFpbEV4cGFuZD1cIkV4cGFuZCBEZXRhaWxzXCJcblxuICAgICAgICAgICAgaTE4bi1kZXRhaWxDb2xsYXBzZT1cImtlbmRvLmdyaWQuZGV0YWlsQ29sbGFwc2V8VGhlIHRpdGxlIG9mIHRoZSBjb2xsYXBzZSBpY29uIG9mIGRldGFpbCByb3dzLlwiXG4gICAgICAgICAgICBkZXRhaWxDb2xsYXBzZT1cIkNvbGxhcHNlIERldGFpbHNcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckRhdGVUb2RheT1cImtlbmRvLmdyaWQuZmlsdGVyRGF0ZVRvZGF5fFRoZSB0ZXh0IG9mIHRoZSBUb2RheSBidXR0b24gb2YgdGhlIERhdGUgZmlsdGVyLlwiXG4gICAgICAgICAgICBmaWx0ZXJEYXRlVG9kYXk9XCJUT0RBWVwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyRGF0ZVRvZ2dsZT1cImtlbmRvLmdyaWQuZmlsdGVyRGF0ZVRvZ2dsZXxUaGUgdGl0bGUgb2YgdGhlIFRvZ2dsZSBidXR0b24gb2YgdGhlIERhdGUgZmlsdGVyLlwiXG4gICAgICAgICAgICBmaWx0ZXJEYXRlVG9nZ2xlPVwiVG9nZ2xlIENhbGVuZGFyXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJOdW1lcmljRGVjcmVtZW50PVwia2VuZG8uZ3JpZC5maWx0ZXJOdW1lcmljRGVjcmVtZW50fFRoZSB0aXRsZSBvZiB0aGUgRGVjcmVtZW50IGJ1dHRvbiBvZiB0aGUgTnVtZXJpYyBmaWx0ZXIuXCJcbiAgICAgICAgICAgIGZpbHRlck51bWVyaWNEZWNyZW1lbnQ9XCJEZWNyZW1lbnRcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlck51bWVyaWNJbmNyZW1lbnQ9XCJrZW5kby5ncmlkLmZpbHRlck51bWVyaWNJbmNyZW1lbnR8VGhlIHRpdGxlIG9mIHRoZSBJbmNyZW1lbnQgYnV0dG9uIG9mIHRoZSBOdW1lcmljIGZpbHRlci5cIlxuICAgICAgICAgICAgZmlsdGVyTnVtZXJpY0luY3JlbWVudD1cIkluY3JlbWVudFwiXG5cbiAgICAgICAgICAgIGkxOG4tc2VsZWN0aW9uQ2hlY2tib3hMYWJlbD1cImtlbmRvLmdyaWQuc2VsZWN0aW9uQ2hlY2tib3hMYWJlbHxUaGUgbGFiZWxzIG9mIHRoZSBjaGVja2JveCBjb2x1bW4gY2hlY2tib3hlcy5cIlxuICAgICAgICAgICAgc2VsZWN0aW9uQ2hlY2tib3hMYWJlbD1cIlNlbGVjdCBSb3dcIlxuXG4gICAgICAgICAgICBpMThuLXNlbGVjdEFsbENoZWNrYm94TGFiZWw9XCJrZW5kby5ncmlkLnNlbGVjdEFsbENoZWNrYm94TGFiZWx8VGhlIGxhYmVsIG9mIHRoZSBjaGVja2JveCBjb2x1bW4gc2VsZWN0IGFsbCBjaGVja2JveC5cIlxuICAgICAgICAgICAgc2VsZWN0QWxsQ2hlY2tib3hMYWJlbD1cIlNlbGVjdCBBbGwgUm93c1wiXG5cbiAgICAgICAgICAgIGkxOG4tZ3JvdXBDb2xsYXBzZT1cImtlbmRvLmdyaWQuZ3JvdXBDb2xsYXBzZXxUaGUgdGV4dCBvZiB0aGUgdGl0bGUgYW5kIGFyaWEtbGFiZWwgYXR0cmlidXRlcyBhcHBsaWVkIHRvIHRoZSBjb2xsYXBzZSBpY29uIG9mIGdyb3VwIHJvd3MuXCJcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2U9XCJDb2xsYXBzZSBHcm91cFwiXG5cbiAgICAgICAgICAgIGkxOG4tZ3JvdXBFeHBhbmQ9XCJrZW5kby5ncmlkLmdyb3VwRXhwYW5kfFRoZSB0ZXh0IG9mIHRoZSB0aXRsZSBhbmQgYXJpYS1sYWJlbCBhdHRyaWJ1dGVzIGFwcGxpZWQgdG8gdGhlIGV4cGFuZCBpY29uIG9mIGdyb3VwIHJvd3MuXCJcbiAgICAgICAgICAgIGdyb3VwRXhwYW5kPVwiRXhwYW5kIEdyb3VwXCJcbiAgICAgICAgPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPGtlbmRvLWdyaWQtdG9vbGJhciBjbGFzcz1cImstdG9vbGJhciBrLWdyaWQtdG9vbGJhclwiICpuZ0lmPVwic2hvd1RvcFRvb2xiYXJcIiBwb3NpdGlvbj1cInRvcFwiPjwva2VuZG8tZ3JpZC10b29sYmFyPlxuICAgICAgICA8a2VuZG8tcGFnZXJcbiAgICAgICAgICAgICpuZ0lmPVwic2hvd1RvcFBhZ2VyXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCJuYXZpZ2FibGUgPyAnMCcgOiAnLTEnXCJcbiAgICAgICAgICAgIFthdHRyLnJvbGVdPVwibmF2aWdhYmxlID8gJ25hdmlnYXRpb24nIDogdW5kZWZpbmVkXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay1ncmlkLXBhZ2VyLXRvcFwiXG4gICAgICAgICAgICBbdGVtcGxhdGVdPVwicGFnZXJUZW1wbGF0ZVwiXG4gICAgICAgICAgICBbcGFnZVNpemVdPVwicGFnZVNpemVcIlxuICAgICAgICAgICAgW3RvdGFsXT1cInZpZXcudG90YWxcIlxuICAgICAgICAgICAgW3NraXBdPVwic2tpcFwiXG4gICAgICAgICAgICBbb3B0aW9uc109XCJwYWdlYWJsZVwiXG4gICAgICAgICAgICAocGFnZUNoYW5nZSk9XCJub3RpZnlQYWdlQ2hhbmdlKCdwYWdlcicsICRldmVudClcIj5cbiAgICAgICAgPC9rZW5kby1wYWdlcj5cbiAgICAgICAgPGtlbmRvLWdyaWQtZ3JvdXAtcGFuZWxcbiAgICAgICAgICAgICpuZ0lmPVwic2hvd0dyb3VwUGFuZWxcIlxuICAgICAgICAgICAgW3RleHRdPVwiZ3JvdXBhYmxlRW1wdHlUZXh0XCJcbiAgICAgICAgICAgIFtncm91cHNdPVwiZ3JvdXBcIlxuICAgICAgICAgICAgKGNoYW5nZSk9XCJncm91cENoYW5nZS5lbWl0KCRldmVudClcIj5cbiAgICAgICAgPC9rZW5kby1ncmlkLWdyb3VwLXBhbmVsPlxuICAgICAgICA8ZGl2ICNhcmlhUm9vdFxuICAgICAgICAgICAgY2xhc3M9XCJrLWdyaWQtYXJpYS1yb290XCJcbiAgICAgICAgICAgIHJvbGU9XCJncmlkXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtcm93Y291bnRdPVwiYXJpYVJvd0NvdW50XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtY29sY291bnRdPVwiYXJpYUNvbENvdW50XCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc1Njcm9sbGFibGVcIj5cbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCIhaGlkZUhlYWRlclwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWdyaWQtaGVhZGVyXCJcbiAgICAgICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUucGFkZGluZ109XCJoZWFkZXJQYWRkaW5nXCI+XG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cImlzTG9ja2VkXCJcbiAgICAgICAgICAgICAgICAgICAgICNsb2NrZWRIZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWdyaWQtaGVhZGVyLWxvY2tlZFwiXG4gICAgICAgICAgICAgICAgICAgICBbc3R5bGUud2lkdGgucHhdPVwibG9ja2VkV2lkdGhcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIFtsb2NrZWRdPVwidHJ1ZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiBbc3R5bGUud2lkdGgucHhdPVwibG9ja2VkV2lkdGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2xncm91cCBrZW5kb0dyaWRDb2xHcm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxvY2tlZExlYWZDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBzXT1cImdyb3VwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGV0YWlsVGVtcGxhdGVdPVwiZGV0YWlsVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29sZ3JvdXA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQga2VuZG9HcmlkSGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Jlc2l6YWJsZV09XCJyZXNpemFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzY3JvbGxhYmxlXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxvY2tlZENvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0b3RhbENvbHVtbkxldmVsc109XCJ0b3RhbENvbHVtbkxldmVsc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NvcnRdPVwic29ydFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2dyb3Vwc109XCJncm91cFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJhYmxlXT1cImZpbHRlcmFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtncm91cGFibGVdPVwic2hvd0dyb3VwUGFuZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZW9yZGVyYWJsZV09XCJyZW9yZGVyYWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NvcnRhYmxlXT1cInNvcnRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uTWVudV09XCJjb2x1bW5NZW51T3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbk1lbnVUZW1wbGF0ZV09XCJjb2x1bW5NZW51VGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0b3RhbENvbHVtbnNDb3VudF09XCJsZWFmQ29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkZXRhaWxUZW1wbGF0ZV09XCJkZXRhaWxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RhYkluZGV4XT1cIm5hdmlnYWJsZSA/ICctMScgOiAnMCdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgICAgPC9kaXY+PGRpdiAjaGVhZGVyIGNsYXNzPVwiay1ncmlkLWhlYWRlci13cmFwXCIgcm9sZT1cInByZXNlbnRhdGlvblwiIGRhdGEtc2Nyb2xsYWJsZVxuICAgICAgICAgICAgICAgICAgICBba2VuZG9HcmlkUmVzaXphYmxlQ29udGFpbmVyXT1cImxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aFwiXG4gICAgICAgICAgICAgICAgICAgIFtsb2NrZWRXaWR0aF09XCJsb2NrZWRXaWR0aCArIHNjcm9sbGJhcldpZHRoICsgMlwiPlxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgcm9sZT1cInByZXNlbnRhdGlvblwiIFtzdHlsZS53aWR0aC5weF09XCJub25Mb2NrZWRXaWR0aFwiIFt2aXJ0dWFsQ29sdW1uc109XCJ2aXJ0dWFsQ29sdW1uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvbGdyb3VwIGtlbmRvR3JpZENvbEdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwiaGVhZGVyTGVhZkNvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtncm91cHNdPVwiaXNMb2NrZWQgPyBbXSA6IGdyb3VwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGV0YWlsVGVtcGxhdGVdPVwiZGV0YWlsVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29sZ3JvdXA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQga2VuZG9HcmlkSGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Jlc2l6YWJsZV09XCJyZXNpemFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzY3JvbGxhYmxlXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImhlYWRlckNvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0b3RhbENvbHVtbkxldmVsc109XCJ0b3RhbENvbHVtbkxldmVsc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NvcnRdPVwic29ydFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJhYmxlXT1cImZpbHRlcmFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtncm91cGFibGVdPVwic2hvd0dyb3VwUGFuZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZW9yZGVyYWJsZV09XCJyZW9yZGVyYWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2dyb3Vwc109XCJpc0xvY2tlZCA/IFtdIDogZ3JvdXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzb3J0YWJsZV09XCJzb3J0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbk1lbnVdPVwiY29sdW1uTWVudU9wdGlvbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5NZW51VGVtcGxhdGVdPVwiY29sdW1uTWVudVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbG9ja2VkQ29sdW1uc0NvdW50XT1cImxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RvdGFsQ29sdW1uc0NvdW50XT1cImxlYWZDb2x1bW5zLmxlbmd0aFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RldGFpbFRlbXBsYXRlXT1cImRldGFpbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGFiSW5kZXhdPVwibmF2aWdhYmxlID8gJy0xJyA6ICcwJ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cInZpcnR1YWxDb2x1bW5zXCIgY2xhc3M9XCJrLXdpZHRoLWNvbnRhaW5lclwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgW3N0eWxlLndpZHRoLnB4XT1cImNvbHVtbnNDb250YWluZXIudW5sb2NrZWRXaWR0aFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGtlbmRvLWdyaWQtbGlzdFxuICAgICAgICAgICAgICAgIFtkYXRhXT1cInZpZXdcIlxuICAgICAgICAgICAgICAgIFtyb3dIZWlnaHRdPVwicm93SGVpZ2h0XCJcbiAgICAgICAgICAgICAgICBbZGV0YWlsUm93SGVpZ2h0XT1cImRldGFpbFJvd0hlaWdodFwiXG4gICAgICAgICAgICAgICAgW3RvdGFsXT1cInRvdGFsQ291bnRcIlxuICAgICAgICAgICAgICAgIFt0YWtlXT1cInBhZ2VTaXplXCJcbiAgICAgICAgICAgICAgICBbZ3JvdXBzXT1cImdyb3VwXCJcbiAgICAgICAgICAgICAgICBbZ3JvdXBhYmxlXT1cImdyb3VwYWJsZVwiXG4gICAgICAgICAgICAgICAgW3NraXBdPVwic2tpcFwiXG4gICAgICAgICAgICAgICAgW3RyYWNrQnldPVwidHJhY2tCeVwiXG4gICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwiY29sdW1uc0NvbnRhaW5lclwiXG4gICAgICAgICAgICAgICAgW3NlbGVjdGFibGVdPVwic2VsZWN0YWJsZVwiXG4gICAgICAgICAgICAgICAgW2ZpbHRlcmFibGVdPVwiZmlsdGVyYWJsZVwiXG4gICAgICAgICAgICAgICAgW2RldGFpbFRlbXBsYXRlXT1cImRldGFpbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbbm9SZWNvcmRzVGVtcGxhdGVdPVwibm9SZWNvcmRzVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIChwYWdlQ2hhbmdlKT1cIm5vdGlmeVBhZ2VDaGFuZ2UoJ2xpc3QnLCAkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICBbcm93Q2xhc3NdPVwicm93Q2xhc3NcIlxuICAgICAgICAgICAgICAgIFtyb3dTdGlja3ldPVwicm93U3RpY2t5XCJcbiAgICAgICAgICAgICAgICBbbG9hZGluZ109XCJsb2FkaW5nXCJcbiAgICAgICAgICAgICAgICBbaXNWaXJ0dWFsXT1cImlzVmlydHVhbFwiXG4gICAgICAgICAgICAgICAgW2NlbGxMb2FkaW5nVGVtcGxhdGVdPVwiY2VsbExvYWRpbmdUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgIFtsb2FkaW5nVGVtcGxhdGVdPVwibG9hZGluZ1RlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgW3ZpcnR1YWxDb2x1bW5zXT1cInZpcnR1YWxDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAoc2Nyb2xsQm90dG9tKT1cIm5vdGlmeVNjcm9sbEJvdHRvbSgpXCJcbiAgICAgICAgICAgICAgICAoY29udGVudFNjcm9sbCk9XCJjb250ZW50U2Nyb2xsLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAga2VuZG9EcmFnZ2FibGVcbiAgICAgICAgICAgICAgICBrZW5kb0dyaWRTZWxlY3Rpb25NYXJxdWVlXG4gICAgICAgICAgICAgICAgW2VuYWJsZURyYWddPVwibWFycXVlZVNlbGVjdGlvblwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1ncmlkLWxpc3Q+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgKm5nSWY9XCJzaG93Rm9vdGVyXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstZ3JpZC1mb290ZXJcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5wYWRkaW5nXT1cImhlYWRlclBhZGRpbmdcIj5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwibG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWdyaWQtZm9vdGVyLWxvY2tlZFwiXG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aC5weF09XCJsb2NrZWRXaWR0aFwiPlxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgcm9sZT1cInByZXNlbnRhdGlvblwiIFtsb2NrZWRdPVwidHJ1ZVwiIFtzdHlsZS53aWR0aC5weF09XCJsb2NrZWRXaWR0aFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvbGdyb3VwIGtlbmRvR3JpZENvbEdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwibG9ja2VkTGVhZkNvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtncm91cHNdPVwiZ3JvdXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkZXRhaWxUZW1wbGF0ZV09XCJkZXRhaWxUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2xncm91cD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0Zm9vdCBrZW5kb0dyaWRGb290ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2Nyb2xsYWJsZV09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBzXT1cImdyb3VwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uc109XCJsb2NrZWRMZWFmQ29sdW1uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RldGFpbFRlbXBsYXRlXT1cImRldGFpbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImFyaWFSb3dDb3VudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90Zm9vdD5cbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj48ZGl2ICNmb290ZXJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWdyaWQtZm9vdGVyLXdyYXBcIiBkYXRhLXNjcm9sbGFibGVcbiAgICAgICAgICAgICAgICAgICAgW2tlbmRvR3JpZFJlc2l6YWJsZUNvbnRhaW5lcl09XCJsb2NrZWRMZWFmQ29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgICAgICBbbG9ja2VkV2lkdGhdPVwibG9ja2VkV2lkdGggKyBzY3JvbGxiYXJXaWR0aCArIDNcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIHJvbGU9XCJwcmVzZW50YXRpb25cIiBbc3R5bGUud2lkdGgucHhdPVwibm9uTG9ja2VkV2lkdGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2xncm91cCBrZW5kb0dyaWRDb2xHcm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cIm5vbkxvY2tlZExlYWZDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBzXT1cImlzTG9ja2VkID8gW10gOiBncm91cFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RldGFpbFRlbXBsYXRlXT1cImRldGFpbFRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvbGdyb3VwPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRmb290IGtlbmRvR3JpZEZvb3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwiYXJpYVJvd0NvdW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2Nyb2xsYWJsZV09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBzXT1cImlzTG9ja2VkID8gW10gOiBncm91cFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwibm9uTG9ja2VkTGVhZkNvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtsb2NrZWRDb2x1bW5zQ291bnRdPVwibG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGV0YWlsVGVtcGxhdGVdPVwiZGV0YWlsVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGZvb3Q+XG4gICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFpc1Njcm9sbGFibGVcIj5cbiAgICAgICAgICAgIDx0YWJsZSBbc3R5bGUudGFibGUtbGF5b3V0XT1cInJlc2l6YWJsZSA/ICdmaXhlZCcgOiBudWxsXCI+XG4gICAgICAgICAgICAgICAgPGNvbGdyb3VwIGtlbmRvR3JpZENvbEdyb3VwXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxlYWZDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAgICAgW2dyb3Vwc109XCJncm91cFwiXG4gICAgICAgICAgICAgICAgICAgIFtkZXRhaWxUZW1wbGF0ZV09XCJkZXRhaWxUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgIDwvY29sZ3JvdXA+XG4gICAgICAgICAgICAgICAgPHRoZWFkIGtlbmRvR3JpZEhlYWRlclxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cIiFoaWRlSGVhZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW3Jlc2l6YWJsZV09XCJyZXNpemFibGVcIlxuICAgICAgICAgICAgICAgICAgICBbc2Nyb2xsYWJsZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cInZpc2libGVDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAgICAgW3RvdGFsQ29sdW1uTGV2ZWxzXT1cInRvdGFsQ29sdW1uTGV2ZWxzXCJcbiAgICAgICAgICAgICAgICAgICAgW2dyb3Vwc109XCJncm91cFwiXG4gICAgICAgICAgICAgICAgICAgIFtncm91cGFibGVdPVwic2hvd0dyb3VwUGFuZWxcIlxuICAgICAgICAgICAgICAgICAgICBbcmVvcmRlcmFibGVdPVwicmVvcmRlcmFibGVcIlxuICAgICAgICAgICAgICAgICAgICBbc29ydF09XCJzb3J0XCJcbiAgICAgICAgICAgICAgICAgICAgW3NvcnRhYmxlXT1cInNvcnRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICBbZmlsdGVyYWJsZV09XCJmaWx0ZXJhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbk1lbnVdPVwiY29sdW1uTWVudU9wdGlvbnNcIlxuICAgICAgICAgICAgICAgICAgICBbY29sdW1uTWVudVRlbXBsYXRlXT1cImNvbHVtbk1lbnVUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtkZXRhaWxUZW1wbGF0ZV09XCJkZXRhaWxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFt0YWJJbmRleF09XCJuYXZpZ2FibGUgPyAnLTEnIDogJzAnXCI+XG4gICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICA8dGJvZHkga2VuZG9HcmlkVGFibGVCb2R5XG4gICAgICAgICAgICAgICAgICAgIFtpc0xvYWRpbmddPVwibG9hZGluZ1wiXG4gICAgICAgICAgICAgICAgICAgIFtncm91cHNdPVwiZ3JvdXBcIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YV09XCJ2aWV3XCJcbiAgICAgICAgICAgICAgICAgICAgW3NraXBdPVwic2tpcFwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxlYWZDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGFibGVdPVwic2VsZWN0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJhYmxlXT1cImZpbHRlcmFibGVcIlxuICAgICAgICAgICAgICAgICAgICBbbm9SZWNvcmRzVGVtcGxhdGVdPVwibm9SZWNvcmRzVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbZGV0YWlsVGVtcGxhdGVdPVwiZGV0YWlsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbc2hvd0dyb3VwRm9vdGVyc109XCJzaG93R3JvdXBGb290ZXJzXCJcbiAgICAgICAgICAgICAgICAgICAgW3RyYWNrQnldPVwidHJhY2tCeVwiXG4gICAgICAgICAgICAgICAgICAgIFtyb3dDbGFzc109XCJyb3dDbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvRHJhZ2dhYmxlXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvR3JpZFNlbGVjdGlvbk1hcnF1ZWVcbiAgICAgICAgICAgICAgICAgICAgW2VuYWJsZURyYWddPVwibWFycXVlZVNlbGVjdGlvblwiPlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICAgICAgPHRmb290IGtlbmRvR3JpZEZvb3RlclxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cInNob3dGb290ZXJcIlxuICAgICAgICAgICAgICAgICAgICBbc2Nyb2xsYWJsZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwiYXJpYVJvd0NvdW50XCJcbiAgICAgICAgICAgICAgICAgICAgW2dyb3Vwc109XCJncm91cFwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxlYWZDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbFRlbXBsYXRlXT1cImRldGFpbFRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgPC90Zm9vdD5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxkaXYgW2xvYWRpbmdUZW1wbGF0ZV09XCJsb2FkaW5nVGVtcGxhdGVcIiAqbmdJZj1cImxvYWRpbmdcIiBrZW5kb0dyaWRMb2FkaW5nPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxrZW5kby1wYWdlclxuICAgICAgICAgICAgKm5nSWY9XCJzaG93Qm90dG9tUGFnZXJcIlxuICAgICAgICAgICAgW3RhYmluZGV4XT1cIm5hdmlnYWJsZSA/ICcwJyA6ICctMSdcIlxuICAgICAgICAgICAgW2F0dHIucm9sZV09XCJuYXZpZ2FibGUgPyAnbmF2aWdhdGlvbicgOiB1bmRlZmluZWRcIlxuICAgICAgICAgICAgW3RlbXBsYXRlXT1cInBhZ2VyVGVtcGxhdGVcIlxuICAgICAgICAgICAgW3BhZ2VTaXplXT1cInBhZ2VTaXplXCJcbiAgICAgICAgICAgIFt0b3RhbF09XCJ2aWV3LnRvdGFsXCJcbiAgICAgICAgICAgIFtza2lwXT1cInNraXBcIlxuICAgICAgICAgICAgW29wdGlvbnNdPVwicGFnZWFibGVcIlxuICAgICAgICAgICAgKHBhZ2VDaGFuZ2UpPVwibm90aWZ5UGFnZUNoYW5nZSgncGFnZXInLCAkZXZlbnQpXCI+XG4gICAgICAgIDwva2VuZG8tcGFnZXI+XG4gICAgICAgIDxrZW5kby1ncmlkLXRvb2xiYXIgY2xhc3M9XCJrLXRvb2xiYXIgay1ncmlkLXRvb2xiYXIgay1ncmlkLXRvb2xiYXItYm90dG9tXCIgKm5nSWY9XCJzaG93Qm90dG9tVG9vbGJhclwiIHBvc2l0aW9uPVwiYm90dG9tXCI+PC9rZW5kby1ncmlkLXRvb2xiYXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQnJvd3NlclN1cHBvcnRTZXJ2aWNlLFxuICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBDZWxsU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgR3JvdXBJbmZvU2VydmljZSxcbiAgICAgICAgR3JvdXBzU2VydmljZSxcbiAgICAgICAgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgRGV0YWlsc1NlcnZpY2UsXG4gICAgICAgIEVkaXRTZXJ2aWNlLFxuICAgICAgICBGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICBQREZTZXJ2aWNlLFxuICAgICAgICBSZXNwb25zaXZlU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBFeGNlbFNlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgU2Nyb2xsU3luY1NlcnZpY2UsXG4gICAgICAgIERvbUV2ZW50c1NlcnZpY2UsXG4gICAgICAgIENvbHVtblJlc2l6aW5nU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIENvbHVtblJlb3JkZXJTZXJ2aWNlLFxuICAgICAgICBDb2x1bW5JbmZvU2VydmljZSxcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIFNvcnRTZXJ2aWNlLFxuICAgICAgICBTY3JvbGxSZXF1ZXN0U2VydmljZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBHcmlkQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHVwZGF0ZSA9IChhcnIsIGlkeCwgdmFsdWUpID0+IChbXG4gICAgLi4uYXJyLnNsaWNlKDAsIGlkeCArIDEpLFxuICAgIC4uLihhcnIuc2xpY2UoaWR4ICsgMSkubWFwKHggPT4geCArIHZhbHVlKSlcbl0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFJvd0hlaWdodFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRvdGFsID0gMCwgcm93SGVpZ2h0LCBkZXRhaWxSb3dIZWlnaHQpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnJvd0hlaWdodCA9IHJvd0hlaWdodDtcbiAgICAgICAgdGhpcy5kZXRhaWxSb3dIZWlnaHQgPSBkZXRhaWxSb3dIZWlnaHQ7XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmhlaWdodHMgPSBbXTtcbiAgICAgICAgbGV0IGFnZyA9IDA7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRvdGFsOyBpZHgrKykge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2goYWdnKTtcbiAgICAgICAgICAgIGFnZyArPSByb3dIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmhlaWdodHMucHVzaChyb3dIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhlaWdodChyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHRzW3Jvd0luZGV4XTtcbiAgICB9XG4gICAgZXhwYW5kRGV0YWlsKHJvd0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodChyb3dJbmRleCkgPT09IHRoaXMucm93SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJvd0hlaWdodChyb3dJbmRleCwgdGhpcy5kZXRhaWxSb3dIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxhcHNlRGV0YWlsKHJvd0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodChyb3dJbmRleCkgPiB0aGlzLnJvd0hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSb3dIZWlnaHQocm93SW5kZXgsIHRoaXMuZGV0YWlsUm93SGVpZ2h0ICogLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRXhwYW5kZWQocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0KHJvd0luZGV4KSA+IHRoaXMucm93SGVpZ2h0O1xuICAgIH1cbiAgICBpbmRleChwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMub2Zmc2V0cy5yZWR1Y2UoKHByZXYsIGN1cnJlbnQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA+IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkeCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LCB1bmRlZmluZWQpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmFsaWduXG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMudG90YWwgLSAxIDogcmVzdWx0O1xuICAgIH1cbiAgICBvZmZzZXQocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0c1tyb3dJbmRleF07XG4gICAgfVxuICAgIHRvdGFsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHRzLnJlZHVjZSgocHJldiwgY3VycikgPT4gcHJldiArIGN1cnIsIDApO1xuICAgIH1cbiAgICB1cGRhdGVSb3dIZWlnaHQocm93SW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsID4gMCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRzW3Jvd0luZGV4XSArPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0cyA9IHVwZGF0ZSh0aGlzLm9mZnNldHMsIHJvd0luZGV4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTY3JvbGxBY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUGFnZUFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2tpcCwgdGFrZSQkMSkge1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLnRha2UgPSB0YWtlJCQxO1xuICAgIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTY3JvbGxCb3R0b21BY3Rpb24ge1xufVxuY29uc3QgU0NST0xMX0JPVFRPTV9USFJFU0hPTEQgPSAyO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNjcm9sbGVyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsT2JzZXJ2YWJsZSkge1xuICAgICAgICB0aGlzLnNjcm9sbE9ic2VydmFibGUgPSBzY3JvbGxPYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLmZpcnN0TG9hZGVkID0gMDtcbiAgICB9XG4gICAgY3JlYXRlKHJvd0hlaWdodFNlcnZpY2UsIHNraXAsIHRha2UkJDEsIHRvdGFsKSB7XG4gICAgICAgIHRoaXMucm93SGVpZ2h0U2VydmljZSA9IHJvd0hlaWdodFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSBza2lwO1xuICAgICAgICB0aGlzLmxhc3RMb2FkZWQgPSBza2lwICsgdGFrZSQkMTtcbiAgICAgICAgdGhpcy50YWtlID0gdGFrZSQkMTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSAwO1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChuZXcgU2Nyb2xsQWN0aW9uKHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQoc2tpcCkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBPYnNlcnZhYmxlLmNyZWF0ZShvYnNlcnZlciA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuc2Nyb2xsT2JzZXJ2YWJsZS5zdWJzY3JpYmUoeCA9PiB0aGlzLm9uU2Nyb2xsKHgsIG9ic2VydmVyKSk7XG4gICAgICAgIH0pLnN1YnNjcmliZSh4ID0+IHN1YmplY3QubmV4dCh4KSk7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblNjcm9sbCh7IHNjcm9sbFRvcCwgb2Zmc2V0SGVpZ2h0LCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9LCBvYnNlcnZlcikge1xuICAgICAgICBpZiAodGhpcy5sYXN0U2Nyb2xsVG9wID09PSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cCA9IHRoaXMubGFzdFNjcm9sbFRvcCA+PSBzY3JvbGxUb3A7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgbGV0IGZpcnN0SXRlbUluZGV4ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLmluZGV4KHNjcm9sbFRvcCk7XG4gICAgICAgIGxldCBmaXJzdEl0ZW1PZmZzZXQgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGZpcnN0SXRlbUluZGV4KTtcbiAgICAgICAgY29uc3QgbGFzdEl0ZW1JbmRleCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5pbmRleChzY3JvbGxUb3AgKyBvZmZzZXRIZWlnaHQpO1xuICAgICAgICBpZiAoIXVwKSB7XG4gICAgICAgICAgICBpZiAobGFzdEl0ZW1JbmRleCA+PSB0aGlzLmxhc3RMb2FkZWQgJiYgdGhpcy5sYXN0TG9hZGVkIDwgdGhpcy50b3RhbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gKGZpcnN0SXRlbUluZGV4ICsgdGhpcy50YWtlKSAtIHRoaXMudG90YWw7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEl0ZW1JbmRleCA9IGZpcnN0SXRlbUluZGV4IC0gb3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0SXRlbU9mZnNldCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQoZmlyc3RJdGVtSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0TG9hZGVkID0gZmlyc3RJdGVtSW5kZXg7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgU2Nyb2xsQWN0aW9uKGZpcnN0SXRlbU9mZnNldCkpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0VGFrZSA9IHRoaXMuZmlyc3RMb2FkZWQgKyB0aGlzLnRha2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0TG9hZGVkID0gTWF0aC5taW4obmV4dFRha2UsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgICAgIG5leHRUYWtlID0gbmV4dFRha2UgPiB0aGlzLnRvdGFsID8gdGhpcy50b3RhbCAtIHRoaXMuZmlyc3RMb2FkZWQgOiB0aGlzLnRha2U7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgUGFnZUFjdGlvbih0aGlzLmZpcnN0TG9hZGVkLCB0aGlzLnRha2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0Qm90dG9tID0gc2Nyb2xsSGVpZ2h0IC0gY2xpZW50SGVpZ2h0IC0gc2Nyb2xsVG9wIDwgU0NST0xMX0JPVFRPTV9USFJFU0hPTEQ7XG4gICAgICAgICAgICAgICAgaWYgKGF0Qm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3IFNjcm9sbEJvdHRvbUFjdGlvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwICYmIGZpcnN0SXRlbUluZGV4IDwgdGhpcy5maXJzdExvYWRlZCkge1xuICAgICAgICAgICAgY29uc3Qgbm9uVmlzaWJsZUJ1ZmZlciA9IE1hdGguZmxvb3IodGhpcy50YWtlICogMC4zKTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSBNYXRoLm1heChmaXJzdEl0ZW1JbmRleCAtIG5vblZpc2libGVCdWZmZXIsIDApO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgU2Nyb2xsQWN0aW9uKHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQodGhpcy5maXJzdExvYWRlZCkpKTtcbiAgICAgICAgICAgIHRoaXMubGFzdExvYWRlZCA9IE1hdGgubWluKHRoaXMuZmlyc3RMb2FkZWQgKyB0aGlzLnRha2UsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgUGFnZUFjdGlvbih0aGlzLmZpcnN0TG9hZGVkLCB0aGlzLnRha2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBOT05fREFUQV9DRUxMX0NMQVNTRVMgPSAnay1oaWVyYXJjaHktY2VsbCBrLWRldGFpbC1jZWxsIGstZ3JvdXAtY2VsbCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTk9OX0RBVEFfUk9XX0NMQVNTRVMgPSAnay1ncm91cGluZy1yb3cgay1ncm91cC1mb290ZXIgay1kZXRhaWwtcm93IGstZ3JpZC1ub3JlY29yZHMnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IElHTk9SRV9UQVJHRVRfQ0xBU1NTRVMgPSAnay1pY29uJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBJR05PUkVfQ09OVEFJTkVSX0NMQVNTRVMgPSAnay1ncmlkIGstZ3JpZC1pZ25vcmUtY2xpY2snO1xuXG5jb25zdCBlbGVtZW50QXQgPSAoaW5kZXgsIGVsZW1lbnRzLCBlbGVtZW50T2Zmc2V0KSA9PiB7XG4gICAgZm9yIChsZXQgaWR4ID0gMCwgZWxlbWVudElkeCA9IDA7IGlkeCA8IGVsZW1lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZWxlbWVudE9mZnNldChlbGVtZW50c1tpZHhdKTtcbiAgICAgICAgaWYgKGVsZW1lbnRJZHggPD0gaW5kZXggJiYgaW5kZXggPD0gZWxlbWVudElkeCArIG9mZnNldCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50c1tpZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRJZHggKz0gb2Zmc2V0O1xuICAgIH1cbn07XG5jb25zdCByb3dBdCA9IChpbmRleCwgcm93cykgPT4gZWxlbWVudEF0KGluZGV4LCByb3dzLCByb3cgPT4gcm93Lmhhc0F0dHJpYnV0ZSgnZGF0YS1rZW5kby1ncmlkLWl0ZW0taW5kZXgnKSA/IDEgOiAwKTtcbmNvbnN0IGNlbGxBdCA9IChpbmRleCwgY2VsbHMpID0+IGVsZW1lbnRBdChpbmRleCwgY2VsbHMsIGNlbGwgPT4gIWhhc0NsYXNzZXMoY2VsbCwgTk9OX0RBVEFfQ0VMTF9DTEFTU0VTKSA/IHBhcnNlSW50KGNlbGwuZ2V0QXR0cmlidXRlKCdjb2xTcGFuJyksIDEwKSB8fCAxIDogMCk7XG5jb25zdCBFTVBUWV9PQkpFQ1QgPSB7fTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBTQ1JPTExFUl9GQUNUT1JZX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuKCdncmlkLXNjcm9sbC1zZXJ2aWNlLWZhY3RvcnknKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBERUZBVUxUX1NDUk9MTEVSX0ZBQ1RPUlkob2JzZXJ2YWJsZSkge1xuICAgIHJldHVybiBuZXcgU2Nyb2xsZXJTZXJ2aWNlKG9ic2VydmFibGUpO1xufVxuY29uc3Qgd2hlZWxEZWx0YVkgPSAoZSkgPT4ge1xuICAgIGNvbnN0IGRlbHRhWSA9IGUud2hlZWxEZWx0YVk7XG4gICAgaWYgKGUud2hlZWxEZWx0YSAmJiAoZGVsdGFZID09PSB1bmRlZmluZWQgfHwgZGVsdGFZKSkge1xuICAgICAgICByZXR1cm4gZS53aGVlbERlbHRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChlLmRldGFpbCAmJiBlLmF4aXMgPT09IGUuVkVSVElDQUxfQVhJUykge1xuICAgICAgICByZXR1cm4gKC1lLmRldGFpbCkgKiAxMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuY29uc3QgcHJldmVudExvY2tlZFNjcm9sbCA9IChhcmdzLCBlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgZGVsdGEgPSB3aGVlbERlbHRhWShhcmdzKTtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICBjb25zdCBhbGxvd1Njcm9sbCA9IChzY3JvbGxUb3AgPT09IDAgJiYgMCA8IGRlbHRhKSB8fCAoZWxlbWVudC5zY3JvbGxIZWlnaHQgPD0gZWxlbWVudC5vZmZzZXRIZWlnaHQgKyBzY3JvbGxUb3AgJiYgZGVsdGEgPCAwKTtcbiAgICBpZiAoIWFsbG93U2Nyb2xsKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcbmNvbnN0IHRyYW5zbGF0ZVkgPSAocmVuZGVyZXIsIHZhbHVlKSA9PiBlbCA9PiByZW5kZXJlci5zZXRTdHlsZShlbCwgXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZVkoJHt2YWx1ZX1weClgKTtcbmNvbnN0IG1heWJlTmF0aXZlRWxlbWVudCA9IGVsID0+IGVsID8gZWwubmF0aXZlRWxlbWVudCA6IG51bGw7XG5jb25zdCBoYXNTY3JvbGxiYXIgPSAoZWwsIHBhcmVudCkgPT4gZWwubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCA+IHBhcmVudC5uYXRpdmVFbGVtZW50LmNsaWVudFdpZHRoO1xuY29uc3Qgc2V0SGVpZ2h0JDEgPSByZW5kZXJlciA9PiAoeyBlbCwgaGVpZ2h0IH0pID0+IHJlbmRlcmVyLnNldFN0eWxlKGVsLCBcImhlaWdodFwiLCBgJHtoZWlnaHR9cHhgKTtcbmNvbnN0IGJ1ZmZlclNpemUgPSAxO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBMaXN0Q29tcG9uZW50ID0gY2xhc3MgTGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsZXJGYWN0b3J5LCBkZXRhaWxzU2VydmljZSwgY2hhbmdlTm90aWZpY2F0aW9uLCBzdXNwZW5kU2VydmljZSwgZ3JvdXBzU2VydmljZSwgbmdab25lLCByZW5kZXJlciwgc2Nyb2xsU3luY1NlcnZpY2UsIHJlc2l6ZVNlcnZpY2UsIGVkaXRTZXJ2aWNlLCBzdXBwb3J0U2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UsIHNjcm9sbFJlcXVlc3RTZXJ2aWNlLCBsb2NhbGl6YXRpb24sIGNvbHVtblJlc2l6aW5nU2VydmljZSwgY2hhbmdlRGV0ZWN0b3IsIHBkZlNlcnZpY2UsIGNvbHVtbkluZm8pIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VOb3RpZmljYXRpb24gPSBjaGFuZ2VOb3RpZmljYXRpb247XG4gICAgICAgIHRoaXMuc3VzcGVuZFNlcnZpY2UgPSBzdXNwZW5kU2VydmljZTtcbiAgICAgICAgdGhpcy5ncm91cHNTZXJ2aWNlID0gZ3JvdXBzU2VydmljZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZSA9IHNjcm9sbFN5bmNTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UgPSByZXNpemVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlID0gZWRpdFNlcnZpY2U7XG4gICAgICAgIHRoaXMuc3VwcG9ydFNlcnZpY2UgPSBzdXBwb3J0U2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jb2x1bW5SZXNpemluZ1NlcnZpY2UgPSBjb2x1bW5SZXNpemluZ1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5wZGZTZXJ2aWNlID0gcGRmU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2x1bW5JbmZvID0gY29sdW1uSW5mbztcbiAgICAgICAgdGhpcy5ncm91cHMgPSBbXTtcbiAgICAgICAgdGhpcy5za2lwID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IENvbHVtbnNDb250YWluZXIoKCkgPT4gW10pO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ncm91cGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFja0J5ID0gZGVmYXVsdFRyYWNrQnk7XG4gICAgICAgIHRoaXMuY29udGVudFNjcm9sbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNjcm9sbEJvdHRvbSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zU3RhcnRJZHggPSAwO1xuICAgICAgICB0aGlzLnJlc2l6ZVNlbnNvcnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyU2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5ydGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JvbGxlciA9IHNjcm9sbGVyRmFjdG9yeSh0aGlzLmRpc3BhdGNoZXIpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBkZXRhaWxzU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSh4ID0+IHRoaXMuZGV0YWlsRXhwYW5kKHgpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChzY3JvbGxSZXF1ZXN0U2VydmljZS5yZXF1ZXN0cy5zdWJzY3JpYmUoeCA9PiB0aGlzLnNjcm9sbFRvKHgpKSk7XG4gICAgfVxuICAgIGdldCBob3N0Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgaG9zdFJvbGUoKSB7XG4gICAgICAgIHJldHVybiAncHJlc2VudGF0aW9uJztcbiAgICB9XG4gICAgZ2V0IHNob3dGb290ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwYWJsZSAmJiB0aGlzLmdyb3VwYWJsZS5zaG93Rm9vdGVyO1xuICAgIH1cbiAgICBnZXQgdG90YWxXaWR0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbENvbHVtbnMgJiYgdGhpcy5jb2x1bW5zLnVubG9ja2VkV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMudW5sb2NrZWRXaWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbG9ja2VkTGVhZkNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMubG9ja2VkTGVhZkNvbHVtbnM7XG4gICAgfVxuICAgIGdldCBub25Mb2NrZWRMZWFmQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucy5ub25Mb2NrZWRMZWFmQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IG5vbkxvY2tlZENvbHVtbnNUb1JlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbENvbHVtbnMgJiYgIXRoaXMucGRmU2VydmljZS5leHBvcnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0Q29sdW1ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub25Mb2NrZWRMZWFmQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IGxlYWZDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLmxlYWZDb2x1bW5zVG9SZW5kZXI7XG4gICAgfVxuICAgIGdldCBsb2NrZWRXaWR0aCgpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBDZWxsc1dpZHRoID0gdGhpcy5ncm91cHMubGVuZ3RoICogR1JPVVBfQ0VMTF9XSURUSDtcbiAgICAgICAgcmV0dXJuIGV4cGFuZENvbHVtbnModGhpcy5sb2NrZWRMZWFmQ29sdW1ucy50b0FycmF5KCkpLnJlZHVjZSgocHJldiwgY3VycikgPT4gcHJldiArIChjdXJyLndpZHRoIHx8IDApLCBncm91cENlbGxzV2lkdGgpO1xuICAgIH1cbiAgICBnZXQgbm9uTG9ja2VkV2lkdGgoKSB7XG4gICAgICAgIGlmICgoIXRoaXMucnRsICYmIHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoKSB8fCB0aGlzLnZpcnR1YWxDb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtQ29sdW1uV2lkdGhzKGV4cGFuZENvbHVtbnModGhpcy5ub25Mb2NrZWRDb2x1bW5zVG9SZW5kZXIudG9BcnJheSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrZWRMZWFmQ29sdW1ucy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIodGhpcy5oYW5kbGVSb3dTeW5jLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcih0aGlzLmhhbmRsZVJvd05hdmlnYXRpb25Mb2NrZWQuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKG1lcmdlKHRoaXMuY29sdW1ucy5jaGFuZ2VzLCB0aGlzLnJlc2l6ZVNlcnZpY2UuY2hhbmdlcykuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpcnR1YWxDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydENvbHVtbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB0aGlzLnJ0bCA9IHJ0bCkpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGhhc0luaXRpYWxTa2lwID0gY2hhbmdlcy5za2lwICYmIGNoYW5nZXMuc2tpcC5maXJzdENoYW5nZSAmJiBjaGFuZ2VzLnNraXAuY3VycmVudFZhbHVlID4gMDtcbiAgICAgICAgaWYgKGhhc0luaXRpYWxTa2lwKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUluaXRpYWxTY3JvbGxUb1NraXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKFwic2tpcFwiLCBjaGFuZ2VzKSAmJiAhdGhpcy5yZWJpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcFNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQodGhpcy5za2lwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlZChbXCJ0b3RhbFwiLCBcInRha2VcIl0sIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYmluZCA9IGZhbHNlO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWxDb2x1bW5zICYmICghdGhpcy52aWV3cG9ydENvbHVtbnMgfHwgdGhpcy52aWV3cG9ydFdpZHRoQ2hhbmdlKCkpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0Q29sdW1ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2tpcCAmJiB0aGlzLmlzVmlydHVhbCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KHRoaXMuc2tpcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldE5hdmlnYXRpb25WaWV3cG9ydCgpO1xuICAgICAgICB0aGlzLmF0dGFjaENvbnRhaW5lclNjcm9sbCgpO1xuICAgICAgICB0aGlzLmluaXRSZXNpemVTZXJ2aWNlKCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgY29uc3QgaXNMb2NrZWQgPSB0aGlzLmlzTG9ja2VkO1xuICAgICAgICBpZiAoaXNMb2NrZWQgJiYgIXRoaXMuaGFzTG9ja2VkQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNSb3dzSGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNMb2NrZWRDb250YWluZXIgPSBpc0xvY2tlZDtcbiAgICB9XG4gICAgc3luY1Jvd3NIZWlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZENvbnRhaW5lcikge1xuICAgICAgICAgICAgc3luY1Jvd3NIZWlnaHQodGhpcy5sb2NrZWRUYWJsZS5uYXRpdmVFbGVtZW50LCB0aGlzLnRhYmxlLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNpemVTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYW51cFNjcm9sbGVyKCk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1c3BlbmRTZXJ2aWNlLnNjcm9sbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93SGVpZ2h0U2VydmljZSA9IG5ldyBSb3dIZWlnaHRTZXJ2aWNlKHRoaXMudG90YWwsIHRoaXMucm93SGVpZ2h0LCB0aGlzLmRldGFpbFJvd0hlaWdodCk7XG4gICAgICAgIHRoaXMudG90YWxIZWlnaHQgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2UudG90YWxIZWlnaHQoKTtcbiAgICAgICAgaWYgKCFpc1VuaXZlcnNhbCgpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcih0aGlzLmNyZWF0ZVNjcm9sbGVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2tlZFNjcm9sbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1c3BlbmRTZXJ2aWNlLnNjcm9sbCkge1xuICAgICAgICAgICAgY29uc3QgbG9ja2VkU2Nyb2xsVG9wID0gdGhpcy5sb2NrZWRDb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBpZiAobG9ja2VkU2Nyb2xsVG9wICE9PSB0aGlzLmNvbnRhaW5lclNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gdGhpcy5jb250YWluZXJTY3JvbGxUb3AgPSBsb2NrZWRTY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9ja2VkTW91c2V3aGVlbChhcmdzKSB7XG4gICAgICAgIGlmICghYXJncy5jdHJsS2V5KSB7XG4gICAgICAgICAgICBwcmV2ZW50TG9ja2VkU2Nyb2xsKGFyZ3MsIHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSB3aGVlbERlbHRhWShhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wIC09IHNjcm9sbERlbHRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2tlZEtleWRvd24oYXJncykge1xuICAgICAgICBpZiAoYXJncy5rZXlDb2RlID09PSBLZXlzLlBhZ2VEb3duIHx8IGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5QYWdlVXApIHtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5QYWdlRG93biA/IDEgOiAtMTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgKz0gZWxlbWVudC5vZmZzZXRIZWlnaHQgKiBkaXIgKiAwLjg7XG4gICAgICAgICAgICBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0YWlsRXhwYW5kKHsgaW5kZXgsIGV4cGFuZCB9KSB7XG4gICAgICAgIGlmIChleHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMucm93SGVpZ2h0U2VydmljZS5leHBhbmREZXRhaWwoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLmNvbGxhcHNlRGV0YWlsKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsSGVpZ2h0ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLnRvdGFsSGVpZ2h0KCk7XG4gICAgICAgIHRoaXMucmVzZXROYXZpZ2F0aW9uVmlld3BvcnQoKTtcbiAgICB9XG4gICAgYXR0YWNoQ29udGFpbmVyU2Nyb2xsKCkge1xuICAgICAgICBpZiAoaXNVbml2ZXJzYWwoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoZnJvbUV2ZW50KHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsICdzY3JvbGwnKS5waXBlKG1hcCgoZXZlbnQpID0+IGV2ZW50LnRhcmdldCksIGZpbHRlcigoKSA9PiAhdGhpcy5zdXNwZW5kU2VydmljZS5zY3JvbGwpLCB0YXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Db250YWluZXJTY3JvbGwodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0TmF2aWdhdGlvblZpZXdwb3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlydHVhbENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDb2x1bW5TY3JvbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93Vmlld3BvcnQgPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnZpZXdwb3J0IHx8IEVNUFRZX09CSkVDVDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5WaWV3cG9ydCA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2UuY29sdW1uVmlld3BvcnQgfHwgRU1QVFlfT0JKRUNUO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFNjcm9sbC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogdGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogdGFyZ2V0LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3c6IHJvd1ZpZXdwb3J0LmZpcnN0SXRlbUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmRSb3c6IHJvd1ZpZXdwb3J0Lmxhc3RJdGVtSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBjb2x1bW5WaWV3cG9ydC5maXJzdEl0ZW1JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29sdW1uOiBjb2x1bW5WaWV3cG9ydC5sYXN0SXRlbUluZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSkuc3Vic2NyaWJlKHRoaXMuZGlzcGF0Y2hlcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZS5yZWdpc3RlckVtaXR0ZXIodGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgXCJib2R5XCIpO1xuICAgIH1cbiAgICBjcmVhdGVTY3JvbGxlcigpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwU2Nyb2xsZXIoKTtcbiAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZSA9IHRoaXMuc2Nyb2xsZXJcbiAgICAgICAgICAgIC5jcmVhdGUodGhpcy5yb3dIZWlnaHRTZXJ2aWNlLCB0aGlzLnNraXAsIHRoaXMudGFrZSwgdGhpcy50b3RhbCk7XG4gICAgICAgIHRoaXMuc2tpcFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjcm9sbGVyU3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5waXBlKGZpbHRlcigoeCkgPT4geCBpbnN0YW5jZW9mIFBhZ2VBY3Rpb24pLCBmaWx0ZXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IHRoaXMuc2tpcFNjcm9sbDtcbiAgICAgICAgICAgIHRoaXMuc2tpcFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuICF0ZW1wO1xuICAgICAgICB9KSwgdGFwKCgpID0+IHRoaXMucmViaW5kID0gdHJ1ZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh4KSA9PiB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5wYWdlQ2hhbmdlLmVtaXQoeCkpKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlclN1YnNjcmlwdGlvbi5hZGQob2JzZXJ2YWJsZS5waXBlKGZpbHRlcigoeCkgPT4geCBpbnN0YW5jZW9mIFNjcm9sbEFjdGlvbikpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuc2Nyb2xsLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlclN1YnNjcmlwdGlvbi5hZGQob2JzZXJ2YWJsZS5waXBlKGZpbHRlcigoeCkgPT4geCBpbnN0YW5jZW9mIFNjcm9sbEJvdHRvbUFjdGlvbikpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2Nyb2xsQm90dG9tLmVtaXQoKSkpO1xuICAgIH1cbiAgICBzY3JvbGwoeyBvZmZzZXQgPSAwIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgbWF5YmVOYXRpdmVFbGVtZW50KHRoaXMudGFibGUpLFxuICAgICAgICAgICAgICAgIG1heWJlTmF0aXZlRWxlbWVudCh0aGlzLmxvY2tlZFRhYmxlKVxuICAgICAgICAgICAgXS5maWx0ZXIoaXNQcmVzZW50KS5mb3JFYWNoKHRyYW5zbGF0ZVkodGhpcy5yZW5kZXJlciwgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldE5hdmlnYXRpb25WaWV3cG9ydCgpO1xuICAgIH1cbiAgICBvbkNvbnRhaW5lclNjcm9sbCh7IHNjcm9sbFRvcCB9KSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyU2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICBpZiAodGhpcy5sb2NrZWRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMubG9ja2VkQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUluaXRpYWxTY3JvbGxUb1NraXAoKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9ICgpID0+IHRoaXMuaXNWaXJ0dWFsICYmIHRoaXMuc2tpcCA+IDAgJiYgdGhpcy50b3RhbCA+IDA7XG4gICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuY2hhbmdlTm90aWZpY2F0aW9uLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcihzaG91bGRTY3JvbGwpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShfID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG8oeyByb3c6IHRoaXMuc2tpcCB9KTtcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUm93U3luYygpIHtcbiAgICAgICAgY29uc3QgaXNMb2NrZWQgPSAoKSA9PiBpc1ByZXNlbnQodGhpcy5sb2NrZWRDb250YWluZXIpO1xuICAgICAgICBjb25zdCBvblN0YWJsZSA9ICgpID0+IHRoaXMubmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSk7XG4gICAgICAgIHJldHVybiBtZXJnZSh0aGlzLmNoYW5nZU5vdGlmaWNhdGlvbi5jaGFuZ2VzLCB0aGlzLmdyb3Vwc1NlcnZpY2UuY2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKGlzTG9ja2VkKSwgc3dpdGNoTWFwVG8ob25TdGFibGUoKSkpLCB0aGlzLmVkaXRTZXJ2aWNlLmNoYW5nZWQsIHRoaXMucmVzaXplU2VydmljZS5jaGFuZ2VzLCB0aGlzLmNvbHVtblJlc2l6aW5nU2VydmljZS5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoY2hhbmdlID0+IGNoYW5nZS50eXBlID09PSAnZW5kJykpLCB0aGlzLnN1cHBvcnRTZXJ2aWNlLmNoYW5nZXMpXG4gICAgICAgICAgICAucGlwZSh0YXAoKCkgPT4gdGhpcy5yZXNldE5hdmlnYXRpb25WaWV3cG9ydCgpKSwgZmlsdGVyKGlzTG9ja2VkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdGhpcy5zeW5jUm93c0hlaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5zeW5jQ29udGFpbmVySGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLmxvY2tlZENvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgLy8gZml4ZXMgc2Nyb2xsIGxlZnQgcG9zaXRpb24gaW4gSUUgd2hlbiBlZGl0aW5nXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5hY2NlcHRTaXplKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUm93TmF2aWdhdGlvbkxvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuY2hhbmdlcy5waXBlKGZpbHRlcigoKSA9PiBpc1ByZXNlbnQodGhpcy5sb2NrZWRDb250YWluZXIpKSwgZGVsYXkoMTApKS5zdWJzY3JpYmUoKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCA8PSBhcmdzLnByZXZDb2xJbmRleCAmJiBhcmdzLmNvbEluZGV4IDwgdGhpcy5sb2NrZWRMZWFmQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsICYmIGNlbGwuY29sSW5kZXggKyBjZWxsLmNvbFNwYW4gPCBhcmdzLnByZXZDb2xJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjcm9sbFRvVmlydHVhbFJvdyhpdGVtSW5kZXgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRldGFpbFRlbXBsYXRlKSkge1xuICAgICAgICAgICAgaXRlbUluZGV4ID0gTWF0aC5mbG9vcihpdGVtSW5kZXggLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGl0ZW1JbmRleCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnJlc2V0TmF2aWdhdGlvblZpZXdwb3J0KCk7XG4gICAgfVxuICAgIHNjcm9sbFRvKHsgcm93LCBjb2x1bW4gfSkge1xuICAgICAgICBpZiAoaXNOdW1iZXIocm93KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1ZpcnR1YWxSb3cocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSByb3dBdChyb3csIHRoaXMudGFibGUubmF0aXZlRWxlbWVudC5yb3dzKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoY29sdW1uKSkge1xuICAgICAgICAgICAgY29sdW1uIC09IHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMudmlydHVhbENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5jb2x1bW5zLmxlYWZDb2x1bW5zVG9SZW5kZXI7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgY29sdW1uOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gY29sdW1uc1tpZHhdLndpZHRoIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5sb2NrZWRMZWFmQ29sdW1ucy5sZW5ndGggPyAwIDogdGhpcy5ncm91cHMubGVuZ3RoICogR1JPVVBfQ0VMTF9XSURUSCArICh0aGlzLmRldGFpbFRlbXBsYXRlICYmIGNvbHVtbiA+IDAgPyBHUk9VUF9DRUxMX1dJRFRIIDogMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0ID0gdGhpcy5ub3JtYWxpemVTY3JvbGxMZWZ0KG9mZnNldCArIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbiA9PT0gMCAmJiB0aGlzLmRldGFpbFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0ID0gdGhpcy5ub3JtYWxpemVTY3JvbGxMZWZ0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RSb3cgPSByb3dBdCgwLCB0aGlzLnRhYmxlLm5hdGl2ZUVsZW1lbnQucm93cyk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjZWxsQXQoY29sdW1uLCBmaXJzdFJvdy5jZWxscyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSB0aGlzLmVsZW1lbnRTY3JvbGxMZWZ0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0TmF2aWdhdGlvblZpZXdwb3J0KCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyIHx8ICF0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVuYWJsZWQgfHxcbiAgICAgICAgICAgICF0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLm5lZWRzVmlld3BvcnQoKSB8fCB0aGlzLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIG9mZnNldEhlaWdodCB9ID0gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsQm90dG9tID0gc2Nyb2xsVG9wICsgb2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5pbmRleChzY3JvbGxUb3ApO1xuICAgICAgICBsZXQgbGFzdEl0ZW1JbmRleCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5pbmRleChzY3JvbGxCb3R0b20pO1xuICAgICAgICBjb25zdCBsYXN0SXRlbU9mZnNldCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQobGFzdEl0ZW1JbmRleCk7XG4gICAgICAgIGNvbnN0IGxhc3RJdGVtT3ZlcmZsb3dzID0gbGFzdEl0ZW1PZmZzZXQgKyB0aGlzLnJvd0hlaWdodCA+IHNjcm9sbEJvdHRvbTtcbiAgICAgICAgaWYgKGxhc3RJdGVtSW5kZXggPiAwICYmIGxhc3RJdGVtT3ZlcmZsb3dzKSB7XG4gICAgICAgICAgICBsYXN0SXRlbUluZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0U3RhcnQgPSBmaXJzdEl0ZW1JbmRleDtcbiAgICAgICAgbGV0IHZpZXdwb3J0RW5kID0gbGFzdEl0ZW1JbmRleDtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRldGFpbFRlbXBsYXRlKSkge1xuICAgICAgICAgICAgdmlld3BvcnRTdGFydCAqPSAyO1xuICAgICAgICAgICAgdmlld3BvcnRFbmQgKj0gMjtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0SXRlbUhlaWdodCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQoZmlyc3RJdGVtSW5kZXgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0SXRlbUhlaWdodCArIHRoaXMucm93SGVpZ2h0IDwgc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRTdGFydCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFzdEl0ZW1IZWlnaHQgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2UuaGVpZ2h0KGxhc3RJdGVtSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgbGFzdEl0ZW1FeHBhbmRlZCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5pc0V4cGFuZGVkKGxhc3RJdGVtSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgbGFzdEl0ZW1EZXRhaWxPdmVyZmxvd3MgPSBsYXN0SXRlbU9mZnNldCArIGxhc3RJdGVtSGVpZ2h0ID4gc2Nyb2xsQm90dG9tO1xuICAgICAgICAgICAgaWYgKGxhc3RJdGVtRXhwYW5kZWQgJiYgIWxhc3RJdGVtRGV0YWlsT3ZlcmZsb3dzKSB7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRFbmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNldFZpZXdwb3J0KHZpZXdwb3J0U3RhcnQsIHZpZXdwb3J0RW5kKTtcbiAgICB9XG4gICAgY2xlYW51cFNjcm9sbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxlclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxlclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0UmVzaXplU2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmNvbm5lY3QobWVyZ2UoLi4udGhpcy5yZXNpemVTZW5zb3JzLm1hcChzZW5zb3IgPT4gc2Vuc29yLnJlc2l6ZSkpKTtcbiAgICB9XG4gICAgc3luY0NvbnRhaW5lckhlaWdodCgpIHtcbiAgICAgICAgW21heWJlTmF0aXZlRWxlbWVudCh0aGlzLmxvY2tlZENvbnRhaW5lcildXG4gICAgICAgICAgICAuZmlsdGVyKGlzUHJlc2VudClcbiAgICAgICAgICAgIC5tYXAoZWwgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoaGFzU2Nyb2xsYmFyKHRoaXMudGFibGUsIHRoaXMuY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIGhlaWdodCAtPSB0aGlzLnN1cHBvcnRTZXJ2aWNlLnNjcm9sbGJhcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZWwsIGhlaWdodCB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goc2V0SGVpZ2h0JDEodGhpcy5yZW5kZXJlcikpO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydENvbHVtbnMocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IHRoaXMuY29sdW1ucy5ub25Mb2NrZWRMZWFmQ29sdW1ucy50b0FycmF5KCk7XG4gICAgICAgIGxldCB7IHN0YXJ0SWR4LCBlbmRJZHgsIG9mZnNldCB9ID0gcmFuZ2UgfHwgdGhpcy5jYWxjdWxhdGVWaWV3cG9ydENvbHVtbnMoKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydElkeCAtIGJ1ZmZlclNpemUpO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihlbmRJZHggKyBidWZmZXJTaXplLCBjb2x1bW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoc3RhcnQgPCBzdGFydElkeCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gc3RhcnRJZHggLSAxOyBpZHggPj0gc3RhcnQ7IGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0IC09IGNvbHVtbnNbaWR4XS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudENvbHVtbnMgPSBjb2x1bW5zLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydENvbHVtbnNXaWR0aCA9IGN1cnJlbnRDb2x1bW5zLnJlZHVjZSgodG90YWwsIGNvbHVtbikgPT4gdG90YWwgKyBjb2x1bW4ud2lkdGgsIDApO1xuICAgICAgICBpZiAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRDb2x1bW4gPSBuZXcgQ29sdW1uQmFzZSQxKCk7XG4gICAgICAgICAgICBvZmZzZXRDb2x1bW4ud2lkdGggPSBvZmZzZXQ7XG4gICAgICAgICAgICBjdXJyZW50Q29sdW1ucy51bnNoaWZ0KG9mZnNldENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydENvbHVtbnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMudmlld3BvcnRDb2x1bW5zLnJlc2V0KGN1cnJlbnRDb2x1bW5zKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zU3RhcnRJZHggPSBzdGFydDtcbiAgICAgICAgdGhpcy5jb2x1bW5zRW5kSWR4ID0gZW5kO1xuICAgICAgICB0aGlzLmNvbHVtbkluZm8uY29sdW1uUmFuZ2VDaGFuZ2UuZW1pdCh7IHN0YXJ0LCBlbmQsIG9mZnNldCB9KTtcbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5WaWV3cG9ydChzdGFydElkeCwgZW5kSWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDb2x1bW5TY3JvbGwoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHNjcm9sbExlZnQgPSBjb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsTGVmdCAhPT0gc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jYWxjdWxhdGVWaWV3cG9ydENvbHVtbnMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sdW1uVmlld3BvcnQocmFuZ2Uuc3RhcnRJZHgsIHJhbmdlLmVuZElkeCk7XG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRJZHggPCB0aGlzLmNvbHVtbnNTdGFydElkeCB8fCB0aGlzLmNvbHVtbnNFbmRJZHggPCByYW5nZS5lbmRJZHgpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmNvbHVtblVwZGF0ZUZyYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblVwZGF0ZUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRDb2x1bW5zKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNvbHVtblZpZXdwb3J0KHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICAgICAgY29uc3QgbG9ja2VkQ291bnQgPSB0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbGVhZkNvbHVtbnMkJDEgPSB0aGlzLm5vbkxvY2tlZExlYWZDb2x1bW5zLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRTdGFydCA9IGxvY2tlZENvdW50ICsgc3RhcnRJZHggKyAodGhpcy5kZXRhaWxUZW1wbGF0ZSAmJiBzdGFydElkeCA+IDAgPyAxIDogMCk7XG4gICAgICAgIGxldCB2aWV3cG9ydEVuZCA9IGxvY2tlZENvdW50ICsgZW5kSWR4ICsgKHRoaXMuZGV0YWlsVGVtcGxhdGUgPyAxIDogMCk7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGxlYWZDb2x1bW5zJCQxLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGxlYWZDb2x1bW5zJCQxW2lkeF07XG4gICAgICAgICAgICBpZiAoY29sdW1uLmlzU3BhbkNvbHVtbikge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0RW5kICs9IGNvbHVtbi5jaGlsZENvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2Uuc2V0Q29sdW1uVmlld3BvcnQodmlld3BvcnRTdGFydCwgdmlld3BvcnRFbmQpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVWaWV3cG9ydENvbHVtbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsTGVmdCwgY2xpZW50V2lkdGggfSA9IHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMubm9uTG9ja2VkTGVhZkNvbHVtbnMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkU2Nyb2xsTGVmdCA9IHRoaXMubm9ybWFsaXplU2Nyb2xsTGVmdChzY3JvbGxMZWZ0KTtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbmQgPSBub3JtYWxpemVkU2Nyb2xsTGVmdCArIGNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgc3RhcnRJZHg7XG4gICAgICAgIGxldCBlbmRJZHggPSAwO1xuICAgICAgICBsZXQgY3VycmVudCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgaWR4O1xuICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGNvbHVtbnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tpZHhdO1xuICAgICAgICAgICAgY3VycmVudCArPSBjb2x1bW4ud2lkdGggfHwgMDtcbiAgICAgICAgICAgIGlmIChzdGFydElkeCA9PT0gdW5kZWZpbmVkICYmIGN1cnJlbnQgPiBub3JtYWxpemVkU2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0SWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGN1cnJlbnQgLSAoY29sdW1uLndpZHRoIHx8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPj0gdmlld3BvcnRFbmQpIHtcbiAgICAgICAgICAgICAgICBlbmRJZHggPSBpZHg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbmRJZHggJiYgaWR4ID4gMCkge1xuICAgICAgICAgICAgZW5kSWR4ID0gY29sdW1ucy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0SWR4LCBlbmRJZHgsIG9mZnNldCB9O1xuICAgIH1cbiAgICB2aWV3cG9ydFdpZHRoQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50V2lkdGggPSB0aGlzLnZpZXdwb3J0Q29sdW1ucy50b0FycmF5KCkucmVkdWNlKCh0b3RhbCwgY29sdW1uKSA9PiB0b3RhbCArIGNvbHVtbi53aWR0aCwgMCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50V2lkdGggIT09IHRoaXMudmlld3BvcnRDb2x1bW5zV2lkdGg7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVNjcm9sbExlZnQocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnRsID8gcnRsU2Nyb2xsUG9zaXRpb24ocG9zaXRpb24sIHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIHRoaXMuc3VwcG9ydFNlcnZpY2UucnRsU2Nyb2xsTGVmdCkgOiBwb3NpdGlvbjtcbiAgICB9XG4gICAgZWxlbWVudFNjcm9sbExlZnQoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5ydGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZVNjcm9sbExlZnQodGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQub2Zmc2V0TGVmdCAtIGVsZW1lbnQub2Zmc2V0V2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1ncmlkLWNvbnRhaW5lclwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoXCJhdHRyLnJvbGVcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdFJvbGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b3RhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwicm93SGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGlja3lSb3dIZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImRldGFpbFJvd0hlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwidGFrZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2tpcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sdW1uc0NvbnRhaW5lcilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERldGFpbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGV0YWlsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE5vUmVjb3Jkc1RlbXBsYXRlRGlyZWN0aXZlKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9SZWNvcmRzVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3VwYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3dDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3dTdGlja3lcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsb2FkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInRyYWNrQnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXJ0dWFsQ29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImlzVmlydHVhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsTG9hZGluZ1RlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImxvYWRpbmdUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRlbnRTY3JvbGxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWdlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2Nyb2xsQm90dG9tXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGFpbmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2xvY2tlZENvbnRhaW5lcicsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImxvY2tlZENvbnRhaW5lclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdsb2NrZWRUYWJsZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImxvY2tlZFRhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3RhYmxlJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkcmVuKFJlc2l6ZVNlbnNvckNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6ZVNlbnNvcnNcIiwgdm9pZCAwKTtcbkxpc3RDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBTQ1JPTExFUl9GQUNUT1JZX1RPS0VOLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBERUZBVUxUX1NDUk9MTEVSX0ZBQ1RPUllcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLWxpc3QnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgI2xvY2tlZENvbnRhaW5lciBjbGFzcz1cImstZ3JpZC1jb250ZW50LWxvY2tlZFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAqbmdJZj1cImlzTG9ja2VkXCIgW3N0eWxlLndpZHRoLnB4XT1cImxvY2tlZFdpZHRoXCIgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgIGtleWRvd246IGxvY2tlZEtleWRvd24sXG4gICAgICAgICAgICBzY3JvbGw6IGxvY2tlZFNjcm9sbCxcbiAgICAgICAgICAgIG1vdXNld2hlZWw6IGxvY2tlZE1vdXNld2hlZWwsXG4gICAgICAgICAgICBET01Nb3VzZVNjcm9sbDogbG9ja2VkTW91c2V3aGVlbFxuICAgICAgICB9XCJcbiAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICA+XG4gICAgICAgIDxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiay1ncmlkLXRhYmxlLXdyYXBcIj5cbiAgICAgICAgICAgIDx0YWJsZSBbbG9ja2VkXT1cInRydWVcIiAjbG9ja2VkVGFibGUgY2xhc3M9XCJrLWdyaWQtdGFibGVcIiByb2xlPVwicHJlc2VudGF0aW9uXCIgW3N0eWxlLndpZHRoLnB4XT1cImxvY2tlZFdpZHRoXCI+XG4gICAgICAgICAgICAgICAgPGNvbGdyb3VwIGtlbmRvR3JpZENvbEdyb3VwXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICBbZ3JvdXBzXT1cImdyb3Vwc1wiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxvY2tlZExlYWZDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbFRlbXBsYXRlXT1cImRldGFpbFRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgPC9jb2xncm91cD5cbiAgICAgICAgICAgICAgICA8dGJvZHkga2VuZG9HcmlkVGFibGVCb2R5XG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICBbZ3JvdXBzXT1cImdyb3Vwc1wiXG4gICAgICAgICAgICAgICAgICAgIFtpc0xvY2tlZF09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgW2RhdGFdPVwiZGF0YVwiXG4gICAgICAgICAgICAgICAgICAgIFtub1JlY29yZHNUZXh0XT1cIicnXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwibG9ja2VkTGVhZkNvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICBbdG90YWxDb2x1bW5zQ291bnRdPVwibGVhZkNvbHVtbnMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbFRlbXBsYXRlXT1cImRldGFpbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgW3Nob3dHcm91cEZvb3RlcnNdPVwic2hvd0Zvb3RlclwiXG4gICAgICAgICAgICAgICAgICAgIFtza2lwXT1cInNraXBcIlxuICAgICAgICAgICAgICAgICAgICBbc2VsZWN0YWJsZV09XCJzZWxlY3RhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgW3RyYWNrQnldPVwidHJhY2tCeVwiXG4gICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJhYmxlXT1cImZpbHRlcmFibGVcIlxuICAgICAgICAgICAgICAgICAgICBbcm93Q2xhc3NdPVwicm93Q2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICBbaXNMb2FkaW5nXT1cImxvYWRpbmdcIlxuICAgICAgICAgICAgICAgICAgICBbaXNWaXJ0dWFsXT1cImlzVmlydHVhbFwiXG4gICAgICAgICAgICAgICAgICAgIFtjZWxsTG9hZGluZ1RlbXBsYXRlXT1cImNlbGxMb2FkaW5nVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgIDxrZW5kby1yZXNpemUtc2Vuc29yPjwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWhlaWdodC1jb250YWluZXJcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+XG4gICAgICAgICAgICA8ZGl2IFtzdHlsZS5oZWlnaHQucHhdPVwidG90YWxIZWlnaHRcIj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+PGRpdiAjY29udGFpbmVyXG4gICAgICAgICAgICAgICBjbGFzcz1cImstZ3JpZC1jb250ZW50IGstdmlydHVhbC1jb250ZW50XCJcbiAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIiB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgICAgIFtrZW5kb0dyaWRSZXNpemFibGVDb250YWluZXJdPVwibG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgIFtsb2NrZWRXaWR0aF09XCJsb2NrZWRXaWR0aCArIDFcIj5cbiAgICAgICAgPGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJrLWdyaWQtdGFibGUtd3JhcFwiPlxuICAgICAgICAgICAgPHRhYmxlIFtzdHlsZS53aWR0aC5weF09XCJub25Mb2NrZWRXaWR0aFwiICN0YWJsZSBbdmlydHVhbENvbHVtbnNdPVwidmlydHVhbENvbHVtbnNcIlxuICAgICAgICAgICAgICBjbGFzcz1cImstZ3JpZC10YWJsZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj5cbiAgICAgICAgICAgICAgICA8Y29sZ3JvdXAga2VuZG9HcmlkQ29sR3JvdXBcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIFtncm91cHNdPVwiaXNMb2NrZWQgPyBbXSA6IGdyb3Vwc1wiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cIm5vbkxvY2tlZENvbHVtbnNUb1JlbmRlclwiXG4gICAgICAgICAgICAgICAgICAgIFtkZXRhaWxUZW1wbGF0ZV09XCJkZXRhaWxUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgIDwvY29sZ3JvdXA+XG4gICAgICAgICAgICAgICAgPHRib2R5IGtlbmRvR3JpZFRhYmxlQm9keVxuICAgICAgICAgICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgW3NraXBHcm91cERlY29yYXRpb25dPVwiaXNMb2NrZWRcIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YV09XCJkYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgW2dyb3Vwc109XCJncm91cHNcIlxuICAgICAgICAgICAgICAgICAgICBbc2hvd0dyb3VwRm9vdGVyc109XCJzaG93Rm9vdGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwibm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2FsbENvbHVtbnNdPVwibm9uTG9ja2VkTGVhZkNvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICBbZGV0YWlsVGVtcGxhdGVdPVwiZGV0YWlsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbbm9SZWNvcmRzVGVtcGxhdGVdPVwibm9SZWNvcmRzVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbbG9ja2VkQ29sdW1uc0NvdW50XT1cImxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aFwiXG4gICAgICAgICAgICAgICAgICAgIFt0b3RhbENvbHVtbnNDb3VudF09XCJsZWFmQ29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgICAgICBbc2tpcF09XCJza2lwXCJcbiAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGFibGVdPVwic2VsZWN0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgIFt0cmFja0J5XT1cInRyYWNrQnlcIlxuICAgICAgICAgICAgICAgICAgICBbZmlsdGVyYWJsZV09XCJmaWx0ZXJhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgW3Jvd0NsYXNzXT1cInJvd0NsYXNzXCJcbiAgICAgICAgICAgICAgICAgICAgW3Jvd1N0aWNreV09XCJyb3dTdGlja3lcIlxuICAgICAgICAgICAgICAgICAgICBbdmlydHVhbENvbHVtbnNdPVwidmlydHVhbENvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICBbaXNMb2FkaW5nXT1cImxvYWRpbmdcIlxuICAgICAgICAgICAgICAgICAgICBbaXNWaXJ0dWFsXT1cImlzVmlydHVhbFwiXG4gICAgICAgICAgICAgICAgICAgIFtjZWxsTG9hZGluZ1RlbXBsYXRlXT1cImNlbGxMb2FkaW5nVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgIDxrZW5kby1yZXNpemUtc2Vuc29yICpuZ0lmPVwiaXNMb2NrZWRcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAqbmdJZj1cImlzTG9ja2VkIHx8IHZpcnR1YWxDb2x1bW5zXCI+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1oZWlnaHQtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICAgICAgPGRpdiBbc3R5bGUuaGVpZ2h0LnB4XT1cInRvdGFsSGVpZ2h0XCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2ICpuZ0lmPVwidmlydHVhbENvbHVtbnNcIiBjbGFzcz1cImstd2lkdGgtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICAgICAgPGRpdiBbc3R5bGUud2lkdGgucHhdPVwidG90YWxXaWR0aFwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICBgXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBJbmplY3QoU0NST0xMRVJfRkFDVE9SWV9UT0tFTikpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBEZXRhaWxzU2VydmljZSxcbiAgICAgICAgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgU3VzcGVuZFNlcnZpY2UsXG4gICAgICAgIEdyb3Vwc1NlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBTY3JvbGxTeW5jU2VydmljZSxcbiAgICAgICAgUmVzaXplU2VydmljZSxcbiAgICAgICAgRWRpdFNlcnZpY2UsXG4gICAgICAgIEJyb3dzZXJTdXBwb3J0U2VydmljZSxcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIFNjcm9sbFJlcXVlc3RTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2x1bW5SZXNpemluZ1NlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBQREZTZXJ2aWNlLFxuICAgICAgICBDb2x1bW5JbmZvU2VydmljZV0pXG5dLCBMaXN0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIGluLW1lbW9yeSBoYW5kbGluZyBvZiBkYXRhIG9wZXJhdGlvbnMgc3VjaCBhcyBbcGFnaW5nXSh7JSBzbHVnIHBhZ2luZ19ncmlkICV9KSxcbiAqIFtzb3J0aW5nXSh7JSBzbHVnIHNvcnRpbmdfZ3JpZCAlfSksIGFuZCBbZ3JvdXBpbmddKHslIHNsdWcgZ3JvdXBpbmdiYXNpY3NfZ3JpZCAlfSlcbiAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXNdKHslIHNsdWcgYXV0b21hdGljb3BlcmF0aW9uc19ncmlkICV9KSkuXG4gKi9cbmxldCBEYXRhQmluZGluZ0RpcmVjdGl2ZSA9IGNsYXNzIERhdGFCaW5kaW5nRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihncmlkLCBjaGFuZ2VEZXRlY3RvciwgbG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5ncmlkID0gZ3JpZDtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlID0gbG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBza2lwOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gW107XG4gICAgICAgIGlmIChsb2NhbERhdGFDaGFuZ2VzU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZFN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5yZWJpbmQuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgbnVtYmVyIG9mIHJlY29yZHMgdGhhdCB3aWxsIGJlIHNraXBwZWQgYnkgdGhlIHBhZ2VyLlxuICAgICAqL1xuICAgIHNldCBza2lwKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5za2lwID0gdGhpcy5zdGF0ZS5za2lwID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGRlc2NyaXB0b3JzIGJ5IHdoaWNoIHRoZSBkYXRhIHdpbGwgYmUgc29ydGVkLlxuICAgICAqL1xuICAgIHNldCBzb3J0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5zb3J0ID0gdGhpcy5zdGF0ZS5zb3J0ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGRlc2NyaXB0b3IgYnkgd2hpY2ggdGhlIGRhdGEgd2lsbCBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBzZXQgZmlsdGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5maWx0ZXIgPSB0aGlzLnN0YXRlLmZpbHRlciA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBwYWdlIHNpemUgdXNlZCBieSB0aGUgR3JpZCBwYWdlci5cbiAgICAgKi9cbiAgICBzZXQgcGFnZVNpemUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5ncmlkLnBhZ2VTaXplID0gdGhpcy5zdGF0ZS50YWtlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdG9ycyBieSB3aGljaCB0aGUgZGF0YSB3aWxsIGJlIGdyb3VwZWQuXG4gICAgICovXG4gICAgc2V0IGdyb3VwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5ncm91cCA9IHRoaXMuc3RhdGUuZ3JvdXAgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIGRhdGEgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHBvcHVsYXRlIHRoZSBHcmlkLlxuICAgICAqL1xuICAgIHNldCBkYXRhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgIGlmICh0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmFwcGx5U3RhdGUodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmdyaWRcbiAgICAgICAgICAgIC5kYXRhU3RhdGVDaGFuZ2VcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoYW55Q2hhbmdlZChbXCJwYWdlU2l6ZVwiLCBcInNraXBcIiwgXCJzb3J0XCIsIFwiZ3JvdXBcIiwgXCJmaWx0ZXJcIl0sIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnJlYmluZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR3JpZERhdGEoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25TdGF0ZUNoYW5nZShzdGF0ZSQkMSkge1xuICAgICAgICB0aGlzLmFwcGx5U3RhdGUoc3RhdGUkJDEpO1xuICAgICAgICB0aGlzLnJlYmluZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmViaW5kKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLm9yaWdpbmFsRGF0YTtcbiAgICAgICAgdGhpcy51cGRhdGVHcmlkRGF0YSgpO1xuICAgICAgICB0aGlzLm5vdGlmeURhdGFDaGFuZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhlIEdyaWQgdGhhdCBpdHMgZGF0YSBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBub3RpZnlEYXRhQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmdyaWQub25EYXRhQ2hhbmdlKCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3Moc3RhdGUkJDEpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3ModGhpcy5vcmlnaW5hbERhdGEsIHN0YXRlJCQxKTtcbiAgICB9XG4gICAgYXBwbHlTdGF0ZSh7IHNraXAsIHRha2U6IHRha2UkJDEsIHNvcnQsIGdyb3VwLCBmaWx0ZXI6IGZpbHRlciQkMSB9KSB7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMucGFnZVNpemUgPSB0YWtlJCQxO1xuICAgICAgICB0aGlzLnNvcnQgPSBzb3J0O1xuICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyJCQxO1xuICAgIH1cbiAgICB1cGRhdGVHcmlkRGF0YSgpIHtcbiAgICAgICAgdGhpcy5ncmlkLmRhdGEgPSB0aGlzLnByb2Nlc3ModGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBEYXRhQmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2tpcFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIERhdGFCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzb3J0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEYXRhQmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBEYXRhQmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGFnZVNpemVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBEYXRhQmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZ3JvdXBcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dChcImtlbmRvR3JpZEJpbmRpbmdcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIERhdGFCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkYXRhXCIsIG51bGwpO1xuRGF0YUJpbmRpbmdEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRCaW5kaW5nXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0dyaWRDb21wb25lbnQsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBMb2NhbERhdGFDaGFuZ2VzU2VydmljZV0pXG5dLCBEYXRhQmluZGluZ0RpcmVjdGl2ZSk7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggc3RvcmVzIHRoZSByb3cgc2VsZWN0aW9uIHN0YXRlIG9mIHRoZSBHcmlkIGluIG1lbW9yeVxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZWxlY3Rpb25fZ3JpZCAlfSN0b2MtZHVyaW5nLWRhdGEtb3BlcmF0aW9ucykpLlxuICovXG5sZXQgU2VsZWN0aW9uRGlyZWN0aXZlID0gY2xhc3MgU2VsZWN0aW9uRGlyZWN0aXZlIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihncmlkLCBjZCkge1xuICAgICAgICBzdXBlcihncmlkLCBjZCk7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5zZWxlY3RhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLnNlbGVjdGFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5zZWxlY3Rpb25EaXJlY3RpdmUgPSB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59O1xuU2VsZWN0aW9uRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkU2VsZWN0QnldJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbR3JpZENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgU2VsZWN0aW9uRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBjb250cm9scyB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgdGhlIG1hc3RlciBkZXRhaWwgcm93cy5cbiAqL1xubGV0IEV4cGFuZERldGFpbHNEaXJlY3RpdmUgPSBjbGFzcyBFeHBhbmREZXRhaWxzRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBleHBhbmRlZERldGFpbEtleXMgYXJlIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZGVkRGV0YWlsS2V5c0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGNvbGxlY3Rpb24gdGhhdCB3aWxsIHN0b3JlIHRoZSBleHBhbmRlZCBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZERldGFpbEtleXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgaXRlbXMgc2hvdWxkIGJlIGluaXRpYWxseSBleHBhbmRlZC5cbiAgICAgICAgICogV2hlbiBzZXQgdG8gYHRydWVgIGl0ZW1zIGFkZGVkIHRvIHRoZSBgZXhwYW5kZWREZXRhaWxLZXlzYCBjb2xsZWN0aW9uIHdpbGwgYmUgY29sbGFwc2VkLCBhbmQgaXRlbXMgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gaXQgd2lsbCBiZSBleHBhbmRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbGx5RXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHBhbmRlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZ3JpZC5pc0RldGFpbEV4cGFuZGVkID0gdGhpcy5pc0V4cGFuZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQobWVyZ2UodGhpcy5ncmlkLmRldGFpbEV4cGFuZC5waXBlKG1hcChlID0+IChPYmplY3QuYXNzaWduKHsgZXhwYW5kOiB0cnVlIH0sIGUpKSkpLCB0aGlzLmdyaWQuZGV0YWlsQ29sbGFwc2UucGlwZShtYXAoZSA9PiAoT2JqZWN0LmFzc2lnbih7IGV4cGFuZDogZmFsc2UgfSwgZSkpKSkpLnN1YnNjcmliZSh0aGlzLnRvZ2dsZVN0YXRlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgaXRlbSBrZXkgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgYGV4cGFuZGVkRGV0YWlsS2V5c2AgY29sbGVjdGlvbiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG1hc3Rlcl9kZXRhaWxfZXhwYW5kZWRfc3RhdGVfZ3JpZCAlfSN0b2MtYnVpbHQtaW4tZGlyZWN0aXZlKSkuXG4gICAgICovXG4gICAgZ2V0IGV4cGFuZERldGFpbHNLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmRCeTtcbiAgICB9XG4gICAgc2V0IGV4cGFuZERldGFpbHNLZXkoa2V5KSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLl9leHBhbmRCeSA9IGdldHRlcihrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXhwYW5kQnkgPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQSBkZXByZWNhdGVkIGFsaWFzIGZvciBzZXR0aW5nIHRoZSBgZXhwYW5kRGV0YWlsc0tleWAgcHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0IGV4cGFuZERldGFpbEJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBhbmREZXRhaWxzS2V5O1xuICAgIH1cbiAgICBzZXQgZXhwYW5kRGV0YWlsQnkoa2V5KSB7XG4gICAgICAgIHRoaXMuZXhwYW5kRGV0YWlsc0tleSA9IGtleTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICAvLyBza2lwIHJlaW5pdGlhbGl6YXRpb24gaWYgdGhlIHVzZXIgZGF0YSBpcyB0aGUgc2FtZSBhcyB0aGUgbGFzdCBzdGF0ZSBjaGFuZ2VcbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzLmV4cGFuZGVkRGV0YWlsS2V5cykgJiYgdGhpcy5sYXN0RXhwYW5kZWRTdGF0ZSAhPT0gdGhpcy5leHBhbmRlZERldGFpbEtleXMpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRTdGF0ZSA9IG5ldyBTZXQodGhpcy5leHBhbmRlZERldGFpbEtleXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgZ2V0IGtleUdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuZEJ5IHx8IGdldHRlcih1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaXNFeHBhbmRlZChhcmdzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5R2V0dGVyKGFyZ3MuZGF0YUl0ZW0pO1xuICAgICAgICBjb25zdCBoYXNLZXkgPSB0aGlzLmV4cGFuZGVkU3RhdGUuaGFzKGtleSk7XG4gICAgICAgIC8vIHdoZW4gW2luaXRpYWxseUV4cGFuZGVkXT1cInRydWVcIiBhIHByZXNlbnQga2V5IG1lYW5zIHRoZSBjb3JyZXNwb25kaW5nIGRldGFpbCByb3cgaXMgY29sbGFwc2VkXG4gICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxseUV4cGFuZGVkID8gIWhhc0tleSA6IGhhc0tleTtcbiAgICB9XG4gICAgdG9nZ2xlU3RhdGUoYXJncykge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleUdldHRlcihhcmdzLmRhdGFJdGVtKTtcbiAgICAgICAgaWYgKEJvb2xlYW4odGhpcy5pbml0aWFsbHlFeHBhbmRlZCkgIT09IGFyZ3MuZXhwYW5kKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkU3RhdGUuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkU3RhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2UoKTtcbiAgICB9XG4gICAgbm90aWZ5Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLmxhc3RFeHBhbmRlZFN0YXRlID0gQXJyYXkuZnJvbSh0aGlzLmV4cGFuZGVkU3RhdGUpO1xuICAgICAgICB0aGlzLmV4cGFuZGVkRGV0YWlsS2V5c0NoYW5nZS5lbWl0KHRoaXMubGFzdEV4cGFuZGVkU3RhdGUpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRXhwYW5kRGV0YWlsc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXhwYW5kZWREZXRhaWxLZXlzQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgna2VuZG9HcmlkRXhwYW5kRGV0YWlsc0J5JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgRXhwYW5kRGV0YWlsc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXhwYW5kRGV0YWlsc0tleVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgRXhwYW5kRGV0YWlsc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXhwYW5kRGV0YWlsQnlcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEV4cGFuZERldGFpbHNEaXJlY3RpdmUucHJvdG90eXBlLCBcImV4cGFuZGVkRGV0YWlsS2V5c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEV4cGFuZERldGFpbHNEaXJlY3RpdmUucHJvdG90eXBlLCBcImluaXRpYWxseUV4cGFuZGVkXCIsIHZvaWQgMCk7XG5FeHBhbmREZXRhaWxzRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkRXhwYW5kRGV0YWlsc0J5XScsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9HcmlkRXhwYW5kRGV0YWlsc0J5J1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbR3JpZENvbXBvbmVudF0pXG5dLCBFeHBhbmREZXRhaWxzRGlyZWN0aXZlKTtcblxuY29uc3QgbWFwUGFyZW50R3JvdXAgPSAocGFyZW50R3JvdXApID0+IHtcbiAgICBjb25zdCBwYXJlbnRHcm91cEtleXMgPSBbXTtcbiAgICB3aGlsZSAocGFyZW50R3JvdXApIHtcbiAgICAgICAgcGFyZW50R3JvdXBLZXlzLnB1c2goeyBmaWVsZDogcGFyZW50R3JvdXAuZ3JvdXAuZmllbGQsIHZhbHVlOiBwYXJlbnRHcm91cC5ncm91cC52YWx1ZSB9KTtcbiAgICAgICAgcGFyZW50R3JvdXAgPSBwYXJlbnRHcm91cC5wYXJlbnRHcm91cDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudEdyb3VwS2V5cztcbn07XG5jb25zdCBERUZBVUxUX0tFWV9HRVRURVIgPSAoZ3JvdXBSb3dBcmdzKSA9PiAoe1xuICAgIGZpZWxkOiBncm91cFJvd0FyZ3MuZ3JvdXAuZmllbGQsXG4gICAgdmFsdWU6IGdyb3VwUm93QXJncy5ncm91cC52YWx1ZSxcbiAgICBwYXJlbnRHcm91cEtleXM6IG1hcFBhcmVudEdyb3VwKGdyb3VwUm93QXJncy5wYXJlbnRHcm91cClcbn0pO1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBjb250cm9scyB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgdGhlIGdyb3VwIHJvd3NcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZ3JvdXBzX2V4cGFuZGVkX3N0YXRlX2dyaWQgJX0jdG9jLWJ1aWx0LWluLWRpcmVjdGl2ZSkpLlxuICovXG5sZXQgRXhwYW5kR3JvdXBEaXJlY3RpdmUgPSBjbGFzcyBFeHBhbmRHcm91cERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZ3JpZCkge1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZXhwYW5kZWRHcm91cEtleXMgYXJlIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZGVkR3JvdXBLZXlzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBncm91cCBpdGVtcyBzaG91bGQgYmUgaW5pdGlhbGx5IGV4cGFuZGVkLlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cHNJbml0aWFsbHlFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZ3JpZC5pc0dyb3VwRXhwYW5kZWQgPSB0aGlzLmlzRXhwYW5kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChtZXJnZSh0aGlzLmdyaWQuZ3JvdXBFeHBhbmQucGlwZShtYXAoZSA9PiAoT2JqZWN0LmFzc2lnbih7IGV4cGFuZDogdHJ1ZSB9LCBlKSkpKSwgdGhpcy5ncmlkLmdyb3VwQ29sbGFwc2UucGlwZShtYXAoZSA9PiAoT2JqZWN0LmFzc2lnbih7IGV4cGFuZDogZmFsc2UgfSwgZSkpKSkpLnN1YnNjcmliZSh0aGlzLnRvZ2dsZVN0YXRlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgaXRlbSBmb3JtYXQgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgYGV4cGFuZGVkR3JvdXBLZXlzYFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZ3JvdXBzX2V4cGFuZGVkX3N0YXRlX2dyaWQgJX0jdG9jLWN1c3RvbS1ncm91cC1rZXktZm9ybWF0KSkuXG4gICAgICovXG4gICAgZ2V0IGV4cGFuZEdyb3VwQnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmRHcm91cEJ5O1xuICAgIH1cbiAgICBzZXQgZXhwYW5kR3JvdXBCeShrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4cGFuZEdyb3VwQnkgPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgY29sbGVjdGlvbiB0aGF0IHdpbGwgc3RvcmUgdGhlIGV4cGFuZGVkIGdyb3VwIGtleXMuXG4gICAgICovXG4gICAgZ2V0IGV4cGFuZGVkR3JvdXBLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5kZWRHcm91cEtleXM7XG4gICAgfVxuICAgIHNldCBleHBhbmRlZEdyb3VwS2V5cyhleHBhbmRlZEdyb3Vwcykge1xuICAgICAgICB0aGlzLl9leHBhbmRlZEdyb3VwS2V5cyA9IChleHBhbmRlZEdyb3VwcyB8fCBbXSkuc2xpY2UoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBnZXQga2V5R2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRHcm91cEJ5IHx8IERFRkFVTFRfS0VZX0dFVFRFUjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGlzRXhwYW5kZWQoZ3JvdXBBcmdzKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KGdyb3VwQXJncyk7XG4gICAgICAgIHJldHVybiBpdGVtSW5kZXggPiAtMSA/ICF0aGlzLmdyb3Vwc0luaXRpYWxseUV4cGFuZGVkIDogdGhpcy5ncm91cHNJbml0aWFsbHlFeHBhbmRlZDtcbiAgICB9XG4gICAgZ2V0SXRlbUluZGV4KGdyb3VwQXJncykge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRHcm91cEJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRlZEdyb3VwS2V5cy5pbmRleE9mKHRoaXMua2V5R2V0dGVyKGdyb3VwQXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZGVkR3JvdXBLZXlzLmZpbmRJbmRleChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgcGFyZW50R3JvdXAgPSBncm91cEFyZ3MucGFyZW50R3JvdXA7XG4gICAgICAgICAgICB3aGlsZSAoaXNQcmVzZW50KHBhcmVudEdyb3VwKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGl0ZW0ucGFyZW50R3JvdXBLZXlzKSB8fCAhaXNQcmVzZW50KGl0ZW0ucGFyZW50R3JvdXBLZXlzW2luZGV4XSkgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50R3JvdXAuZ3JvdXAudmFsdWUgIT09IGl0ZW0ucGFyZW50R3JvdXBLZXlzW2luZGV4XS52YWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRHcm91cC5ncm91cC5maWVsZCAhPT0gaXRlbS5wYXJlbnRHcm91cEtleXNbaW5kZXhdLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50R3JvdXAgPSBwYXJlbnRHcm91cC5wYXJlbnRHcm91cDtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWUgPT09IGdyb3VwQXJncy5ncm91cC52YWx1ZSAmJiBpdGVtLmZpZWxkID09PSBncm91cEFyZ3MuZ3JvdXAuZmllbGQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b2dnbGVTdGF0ZShncm91cEFyZ3MpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlHZXR0ZXIoZ3JvdXBBcmdzKTtcbiAgICAgICAgaWYgKEJvb2xlYW4odGhpcy5ncm91cHNJbml0aWFsbHlFeHBhbmRlZCkgIT09IGdyb3VwQXJncy5leHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRHcm91cEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmV4cGFuZGVkR3JvdXBLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRHcm91cEtleXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGFuZGVkR3JvdXBLZXlzQ2hhbmdlLmVtaXQodGhpcy5leHBhbmRlZEdyb3VwS2V5cy5zbGljZSgpKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEV4cGFuZEdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJleHBhbmRlZEdyb3VwS2V5c0NoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2tlbmRvR3JpZEV4cGFuZEdyb3VwQnknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBFeHBhbmRHcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXhwYW5kR3JvdXBCeVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIEV4cGFuZEdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJleHBhbmRlZEdyb3VwS2V5c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBFeHBhbmRHcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZ3JvdXBzSW5pdGlhbGx5RXhwYW5kZWRcIiwgdm9pZCAwKTtcbkV4cGFuZEdyb3VwRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkRXhwYW5kR3JvdXBCeV0nLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvR3JpZEV4cGFuZEdyb3VwQnknXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtHcmlkQ29tcG9uZW50XSlcbl0sIEV4cGFuZEdyb3VwRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImdyb3VwUGFuZWxFbXB0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcIm5vUmVjb3Jkc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInBhZ2VyTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJwYWdlckZpcnN0UGFnZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInBhZ2VyTGFzdFBhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJwYWdlclByZXZpb3VzUGFnZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInBhZ2VyTmV4dFBhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJwYWdlclBhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJwYWdlckl0ZW1zUGVyUGFnZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInBhZ2VyT2ZcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJwYWdlckl0ZW1zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwicGFnZXJQYWdlTnVtYmVySW5wdXRUaXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlcklucHV0TGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJNZW51VGl0bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJNZW51T3BlcmF0b3JzRHJvcERvd25MYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlck1lbnVMb2dpY0Ryb3BEb3duTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJFcU9wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmlsdGVyTm90RXFPcGVyYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlcklzTnVsbE9wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmlsdGVySXNOb3ROdWxsT3BlcmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJJc0VtcHR5T3BlcmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJJc05vdEVtcHR5T3BlcmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJTdGFydHNXaXRoT3BlcmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJDb250YWluc09wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmlsdGVyTm90Q29udGFpbnNPcGVyYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlckVuZHNXaXRoT3BlcmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJHdGVPcGVyYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlckd0T3BlcmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJMdGVPcGVyYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlckx0T3BlcmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJJc1RydWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJJc0ZhbHNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmlsdGVyQm9vbGVhbkFsbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlckFmdGVyT3JFcXVhbE9wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmlsdGVyQWZ0ZXJPcGVyYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlckJlZm9yZU9wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmlsdGVyQmVmb3JlT3JFcXVhbE9wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmlsdGVyRmlsdGVyQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmlsdGVyQ2xlYXJCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJBbmRMb2dpY1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlck9yTG9naWNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJsb2FkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZ3JpZExhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiY29sdW1uTWVudVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInNldENvbHVtblBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImxvY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJ1bmxvY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJzdGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInVuc3RpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJzb3J0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInNvcnRBc2NlbmRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJzb3J0RGVzY2VuZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInNvcnRlZEFzY2VuZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcInNvcnRlZERlc2NlbmRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJzb3J0ZWREZWZhdWx0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiY29sdW1uc0FwcGx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiY29sdW1uc1Jlc2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZGV0YWlsRXhwYW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZGV0YWlsQ29sbGFwc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJEYXRlVG9kYXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJmaWx0ZXJEYXRlVG9nZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmlsdGVyTnVtZXJpY0RlY3JlbWVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImZpbHRlck51bWVyaWNJbmNyZW1lbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25DaGVja2JveExhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwic2VsZWN0QWxsQ2hlY2tib3hMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImdyb3VwQ29sbGFwc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJncm91cEV4cGFuZFwiLCB2b2lkIDApO1xuXG52YXIgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xID0gY2xhc3MgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5Mb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRMb2NhbGl6ZWRNZXNzYWdlc10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlKTtcblxudmFyIEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzE7XG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXNcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZ2xvYmFsaXphdGlvbl9ncmlkICV9I3RvYy1sb2NhbGl6YXRpb24pKS5cbiAqL1xubGV0IEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50IGV4dGVuZHMgTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBGaWx0ZXJSb3dDb21wb25lbnQgPSBjbGFzcyBGaWx0ZXJSb3dDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgY29sdW1uSW5mb1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UgPSBjb2x1bW5JbmZvU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gW107XG4gICAgICAgIHRoaXMuZmlsdGVyUm93Q2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgICBhZGRTdGlja3lTdHlsZXMoY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IHN0aWNreSA9IGNvbHVtbi5zdGlja3kgPyB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLnN0aWNreUNvbHVtbnNTdHlsZXMoY29sdW1uKSA6IG51bGw7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGlja3ksIGNvbHVtbi5maWx0ZXJTdHlsZSk7XG4gICAgfVxuICAgIGZpbHRlckxhYmVsKGNvbHVtbikge1xuICAgICAgICBjb25zdCBsb2NhbGl6YXRpb25Nc2cgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2ZpbHRlcklucHV0TGFiZWwnKSB8fCAnJztcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IGNvbHVtbi50aXRsZSB8fCBjb2x1bW4uZmllbGQ7XG4gICAgICAgIHJldHVybiByZXBsYWNlTWVzc2FnZVBsYWNlaG9sZGVyKGxvY2FsaXphdGlvbk1zZywgJ2NvbHVtbk5hbWUnLCBjb2x1bW5OYW1lKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBGaWx0ZXJSb3dDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEZpbHRlclJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEZpbHRlclJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEZXRhaWxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIEZpbHRlclJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGV0YWlsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEZpbHRlclJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwibG9naWNhbFJvd0luZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBGaWx0ZXJSb3dDb21wb25lbnQucHJvdG90eXBlLCBcImxvY2tlZENvbHVtbnNDb3VudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZmlsdGVyLXJvdycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmlsdGVyUm93Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJSb3dDbGFzc1wiLCB2b2lkIDApO1xuRmlsdGVyUm93Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkRmlsdGVyUm93XScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDx0ZFxuICAgICAgICAgICAgW2NsYXNzLmstZ3JvdXAtY2VsbF09XCJ0cnVlXCJcbiAgICAgICAgICAgICpuZ0Zvcj1cImxldCBnIG9mIGdyb3Vwc1wiXG4gICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCI+XG4gICAgICAgIDwvdGQ+XG4gICAgICAgIDx0ZFxuICAgICAgICAgICAgW2NsYXNzLmstaGllcmFyY2h5LWNlbGxdPVwidHJ1ZVwiXG4gICAgICAgICAgICAqbmdJZj1cImRldGFpbFRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCI+XG4gICAgICAgIDwvdGQ+XG4gICAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbnM7IGxldCBjb2x1bW5JbmRleCA9IGluZGV4XCJcbiAgICAgICAgICAgIFtjbGFzcy5rLWdyaWQtaGVhZGVyLXN0aWNreV09XCJjb2x1bW4uc3RpY2t5XCJcbiAgICAgICAgICAgIFtuZ1N0eWxlXT1cImFkZFN0aWNreVN0eWxlcyhjb2x1bW4pXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cImNvbHVtbi5maWx0ZXJDbGFzc1wiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImZpbHRlckxhYmVsKGNvbHVtbilcIlxuICAgICAgICAgICAga2VuZG9HcmlkRmlsdGVyQ2VsbFxuICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICBrZW5kb0dyaWRMb2dpY2FsQ2VsbFxuICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibG9naWNhbFJvd0luZGV4XCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbENvbEluZGV4XT1cImxvY2tlZENvbHVtbnNDb3VudCArIGNvbHVtbkluZGV4XCJcbiAgICAgID48L3RkPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIENvbHVtbkluZm9TZXJ2aWNlXSlcbl0sIEZpbHRlclJvd0NvbXBvbmVudCk7XG5cbmNvbnN0IGFyZURpZmZlcmVudCA9IChhLCBiKSA9PiBhLmZpZWxkICE9PSBiLmZpZWxkIHx8IGEub3BlcmF0b3IgIT09IGIub3BlcmF0b3IgfHwgYS52YWx1ZSAhPT0gYi52YWx1ZTtcbmNvbnN0IGlzQ2hhbmdlZCQxID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpZHggPSAwLCBsZW4gPSBhLmxlbmd0aDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgICBjb25zdCBwcmV2ID0gYVtpZHhdO1xuICAgICAgICBjb25zdCBjdXJyID0gYltpZHhdO1xuICAgICAgICBpZiAoaXNDb21wb3NpdGVGaWx0ZXJEZXNjcmlwdG9yKHByZXYpKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlXG4gICAgICAgICAgICBpZiAoZGlmZkZpbHRlcnMocHJldiwgY3VycltpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZURpZmZlcmVudChwcmV2LCBjdXJyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGNvcHlPYmplY3QgPSAob2JqKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIG9iaik7XG4gICAgaWYgKG9iai5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkgIT09ICdjb25zdHJ1Y3RvcicgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IG9ialtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGNsb25lRmlsdGVyID0gKGZpbHRlciQkMSkgPT4gY29weU9iamVjdChmaWx0ZXIkJDEpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb25lRmlsdGVycyA9IChmaWx0ZXIkJDEpID0+IHtcbiAgICBpZiAoIWZpbHRlciQkMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3IoZmlsdGVyJCQxKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsdGVyczogY2xvbmVGaWx0ZXJzKGZpbHRlciQkMS5maWx0ZXJzKSxcbiAgICAgICAgICAgIGxvZ2ljOiBmaWx0ZXIkJDEubG9naWNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIkJDEpKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIkJDEubWFwKGNsb25lRmlsdGVycyk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZUZpbHRlcihmaWx0ZXIkJDEpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkaWZmRmlsdGVycyA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGlzUHJlc2VudChhKSAmJiAhaXNQcmVzZW50KGIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWlzUHJlc2VudChhKSAmJiBpc1ByZXNlbnQoYikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1ByZXNlbnQoYSkgJiYgaXNQcmVzZW50KGIpICYmIGlzQ2hhbmdlZCQxKGEuZmlsdGVycywgYi5maWx0ZXJzKTtcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRmlsdGVyQ2VsbENvbXBvbmVudCA9IGNsYXNzIEZpbHRlckNlbGxDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVDb250ZXh0ID0ge307XG4gICAgfVxuICAgIGdldCBmaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXI7XG4gICAgfVxuICAgIHNldCBmaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyID0gY2xvbmVGaWx0ZXJzKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVDb250ZXh0LmNvbHVtbiA9IHRoaXMuY29sdW1uO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbnRleHQuZmlsdGVyID0gdGhpcy5maWx0ZXI7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zdHJpbmctbGl0ZXJhbFxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbnRleHRbXCIkaW1wbGljaXRcIl0gPSB0aGlzLmZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlQ29udGV4dDtcbiAgICB9XG4gICAgZ2V0IGhhc1RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29sdW1uLmZpbHRlckNlbGxUZW1wbGF0ZVJlZik7XG4gICAgfVxuICAgIGdldCBpc0ZpbHRlcmFibGUoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb2x1bW4pICYmICFpc051bGxPckVtcHR5U3RyaW5nKHRoaXMuY29sdW1uLmZpZWxkKSAmJiB0aGlzLmNvbHVtbi5maWx0ZXJhYmxlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5Db21wb25lbnQpXG5dLCBGaWx0ZXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgRmlsdGVyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIG51bGwpO1xuRmlsdGVyQ2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZEZpbHRlckNlbGxdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzRmlsdGVyYWJsZVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwiaGFzVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XCJmYWxzZVwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvRmlsdGVyQ2VsbEhvc3QgW2NvbHVtbl09XCJjb2x1bW5cIiBbZmlsdGVyXT1cImZpbHRlclwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cInRydWVcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImNvbHVtbi5maWx0ZXJDZWxsVGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sdW1uLmZpbHRlckNlbGxUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwidGVtcGxhdGVDb250ZXh0XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgfSlcbl0sIEZpbHRlckNlbGxDb21wb25lbnQpO1xuXG5jb25zdCBsb2NhbGl6ZU9wZXJhdG9ycyA9IG9wZXJhdG9ycyA9PiBsb2NhbGl6YXRpb24gPT4gT2JqZWN0LmtleXMob3BlcmF0b3JzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW29wZXJhdG9yc1trZXldXSA9IGxvY2FsaXphdGlvbi5nZXQoa2V5KTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmFsaWduXG5jb25zdCBvcGVyYXRvclRleHRzID0gbG9jYWxpemVPcGVyYXRvcnMoe1xuICAgIFwiZmlsdGVyRXFPcGVyYXRvclwiOiBcImVxXCIsXG4gICAgXCJmaWx0ZXJOb3RFcU9wZXJhdG9yXCI6IFwibmVxXCIsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9iamVjdC1saXRlcmFsLXNvcnQta2V5c1xuICAgIFwiZmlsdGVyR3RlT3BlcmF0b3JcIjogXCJndGVcIixcbiAgICBcImZpbHRlckd0T3BlcmF0b3JcIjogXCJndFwiLFxuICAgIFwiZmlsdGVyTHRlT3BlcmF0b3JcIjogXCJsdGVcIixcbiAgICBcImZpbHRlckx0T3BlcmF0b3JcIjogXCJsdFwiLFxuICAgIFwiZmlsdGVySXNOdWxsT3BlcmF0b3JcIjogXCJpc251bGxcIixcbiAgICBcImZpbHRlcklzTm90TnVsbE9wZXJhdG9yXCI6IFwiaXNub3RudWxsXCIsXG4gICAgXCJmaWx0ZXJJc0VtcHR5T3BlcmF0b3JcIjogXCJpc2VtcHR5XCIsXG4gICAgXCJmaWx0ZXJJc05vdEVtcHR5T3BlcmF0b3JcIjogXCJpc25vdGVtcHR5XCIsXG4gICAgXCJmaWx0ZXJDb250YWluc09wZXJhdG9yXCI6IFwiY29udGFpbnNcIixcbiAgICBcImZpbHRlck5vdENvbnRhaW5zT3BlcmF0b3JcIjogXCJkb2Vzbm90Y29udGFpblwiLFxuICAgIFwiZmlsdGVyU3RhcnRzV2l0aE9wZXJhdG9yXCI6IFwic3RhcnRzd2l0aFwiLFxuICAgIFwiZmlsdGVyRW5kc1dpdGhPcGVyYXRvclwiOiBcImVuZHN3aXRoXCIsXG4gICAgXCJmaWx0ZXJBZnRlck9yRXF1YWxPcGVyYXRvclwiOiBcImFmdGVyLWVxXCIsXG4gICAgXCJmaWx0ZXJBZnRlck9wZXJhdG9yXCI6IFwiYWZ0ZXJcIixcbiAgICBcImZpbHRlckJlZm9yZU9yRXF1YWxPcGVyYXRvclwiOiBcImJlZm9yZS1lcVwiLFxuICAgIFwiZmlsdGVyQmVmb3JlT3BlcmF0b3JcIjogXCJiZWZvcmVcIlxufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG9KU09OID0gKHhzKSA9PiB4cy5tYXAoeCA9PiB4LnRvSlNPTigpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG9wZXJhdG9yLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG9wZXJhdG9yVGV4dHModGhpcy5sb2NhbGl6YXRpb24pO1xuICAgICAgICB0aGlzLl90ZXh0ID0gdGhpcy5tZXNzYWdlc1t0aGlzLm9wZXJhdG9yXTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5yZWZyZXNoVGV4dC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgZHJvcC1kb3duIGxpc3QuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyT3BlcmF0b3JCYXNlXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHNldCB0ZXh0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3RleHQgPSBpc051bGxPckVtcHR5U3RyaW5nKHZhbHVlKSA/IHRoaXMubWVzc2FnZXNbdGhpcy5vcGVyYXRvcl0gOiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLm9wZXJhdG9yXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZnJlc2hUZXh0KCkge1xuICAgICAgICBjb25zdCB1cGRhdGUgPSB0aGlzLl90ZXh0ID09PSB0aGlzLm1lc3NhZ2VzW3RoaXMub3BlcmF0b3JdO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gb3BlcmF0b3JUZXh0cyh0aGlzLmxvY2FsaXphdGlvbik7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB0aGlzLm1lc3NhZ2VzW3RoaXMub3BlcmF0b3JdO1xuICAgICAgICB9XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBGaWx0ZXJPcGVyYXRvckJhc2UucHJvdG90eXBlLCBcInRleHRcIiwgbnVsbCk7XG5cbmNvbnN0IGluc2VydERlZmF1bHRGaWx0ZXIgPSAoaW5kZXgsIHJvb3RGaWx0ZXIsIGZpbHRlciQkMSkgPT4ge1xuICAgIHJvb3RGaWx0ZXIgPSAocm9vdEZpbHRlciB8fCB7IGZpbHRlcnM6IFtdLCBsb2dpYzogXCJhbmRcIiB9KTtcbiAgICByb290RmlsdGVyLmZpbHRlcnNbaW5kZXhdID0gZmlsdGVyJCQxO1xuICAgIHJldHVybiBmaWx0ZXIkJDE7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldEZpbHRlciA9IChpbmRleCwgZmlsdGVyJCQxLCBmaWVsZCwgZGVmYXVsdE9wZXJhdG9yKSA9PiB7XG4gICAgaWYgKGlzUHJlc2VudChmaWx0ZXIkJDEpICYmIGlzUHJlc2VudChmaWx0ZXIkJDEuZmlsdGVycykgJiYgZmlsdGVyJCQxLmZpbHRlcnMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlciQkMS5maWx0ZXJzW2luZGV4XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnNlcnREZWZhdWx0RmlsdGVyKGluZGV4LCBmaWx0ZXIkJDEsIHtcbiAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgb3BlcmF0b3I6IGRlZmF1bHRPcGVyYXRvclxuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxvZ2ljT3BlcmF0b3JzID0gKGxvY2FsaXphdGlvbikgPT4gW1xuICAgIHsgdGV4dDogbG9jYWxpemF0aW9uLmdldChcImZpbHRlckFuZExvZ2ljXCIpLCB2YWx1ZTogXCJhbmRcIiB9LFxuICAgIHsgdGV4dDogbG9jYWxpemF0aW9uLmdldChcImZpbHRlck9yTG9naWNcIiksIHZhbHVlOiBcIm9yXCIgfVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmbGF0dGVuID0gKGZpbHRlciQkMSkgPT4ge1xuICAgIGlmIChpc1ByZXNlbnQoZmlsdGVyJCQxLmZpbHRlcnMpKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIkJDEuZmlsdGVycy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLmNvbmNhdChpc0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3IoY3VycikgPyBmbGF0dGVuKGN1cnIpIDogW2N1cnJdKSwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuY29uc3QgdHJpbUZpbHRlckJ5RmllbGQgPSAoZmlsdGVyJCQxLCBmaWVsZCkgPT4ge1xuICAgIGlmIChpc1ByZXNlbnQoZmlsdGVyJCQxKSAmJiBpc1ByZXNlbnQoZmlsdGVyJCQxLmZpbHRlcnMpKSB7XG4gICAgICAgIGZpbHRlciQkMS5maWx0ZXJzID0gZmlsdGVyJCQxLmZpbHRlcnMuZmlsdGVyKHggPT4ge1xuICAgICAgICAgICAgaWYgKGlzQ29tcG9zaXRlRmlsdGVyRGVzY3JpcHRvcih4KSkge1xuICAgICAgICAgICAgICAgIHRyaW1GaWx0ZXJCeUZpZWxkKHgsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5maWx0ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LmZpZWxkICE9PSBmaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmaWx0ZXJzQnlGaWVsZCA9IChmaWx0ZXIkJDEsIGZpZWxkKSA9PiBmbGF0dGVuKGZpbHRlciQkMSB8fCB7fSkuZmlsdGVyKHggPT4geC5maWVsZCA9PT0gZmllbGQpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpbHRlckJ5RmllbGQgPSAoZmlsdGVyJCQxLCBmaWVsZCkgPT4ge1xuICAgIGxldCBbY3VycmVudEZpbHRlcl0gPSBmaWx0ZXJzQnlGaWVsZChmaWx0ZXIkJDEsIGZpZWxkKTtcbiAgICByZXR1cm4gY3VycmVudEZpbHRlcjtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmVtb3ZlRmlsdGVyID0gKGZpbHRlciQkMSwgZmllbGQpID0+IHtcbiAgICB0cmltRmlsdGVyQnlGaWVsZChmaWx0ZXIkJDEsIGZpZWxkKTtcbiAgICByZXR1cm4gZmlsdGVyJCQxO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsb2NhbGl6ZU9wZXJhdG9ycyQxID0gb3BlcmF0b3JzID0+IGxvY2FsaXphdGlvbiA9PiBPYmplY3Qua2V5cyhvcGVyYXRvcnMpLm1hcChrZXkgPT4gKHtcbiAgICB0ZXh0OiBsb2NhbGl6YXRpb24uZ2V0KGtleSksXG4gICAgdmFsdWU6IG9wZXJhdG9yc1trZXldXG59KSk7XG4vKipcbiAqIEFuIGFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRoZSBmaWx0ZXItY2VsbCBjb21wb25lbnQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZXVzYWJsZWN1c3RvbWZpbHRlcnNfZ3JpZCAlfSN0b2MtZmlsdGVyLXJvdykpLlxuICovXG5jbGFzcyBCYXNlRmlsdGVyQ2VsbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSkge1xuICAgICAgICB0aGlzLmZpbHRlclNlcnZpY2UgPSBmaWx0ZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBvcGVyYXRvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVyYXRvcnMubGVuZ3RoID8gdGhpcy5fb3BlcmF0b3JzIDogdGhpcy5kZWZhdWx0T3BlcmF0b3JzO1xuICAgIH1cbiAgICBzZXQgb3BlcmF0b3JzKHZhbHVlcykge1xuICAgICAgICB0aGlzLl9vcGVyYXRvcnMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uTGlzdFN1YnNjcmlwdGlvbiA9IG9ic2VydmUodGhpcy5vcGVyYXRvckxpc3QpXG4gICAgICAgICAgICAucGlwZShtYXAocSA9PiBxLnRvQXJyYXkoKSksIG1hcCh0b0pTT04pKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh4ID0+IHtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3JzID0geDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRpb25MaXN0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkxpc3RTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaWx0ZXJCeUZpZWxkKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJCeUZpZWxkKHRoaXMuZmlsdGVyLCBmaWVsZCk7XG4gICAgfVxuICAgIGZpbHRlcnNCeUZpZWxkKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzQnlGaWVsZCh0aGlzLmZpbHRlciwgZmllbGQpO1xuICAgIH1cbiAgICByZW1vdmVGaWx0ZXIoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUZpbHRlcih0aGlzLmZpbHRlciwgZmllbGQpO1xuICAgIH1cbiAgICB1cGRhdGVGaWx0ZXIoZmlsdGVyJCQxKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmZpbHRlciB8fCB7XG4gICAgICAgICAgICBmaWx0ZXJzOiBbXSxcbiAgICAgICAgICAgIGxvZ2ljOiBcImFuZFwiXG4gICAgICAgIH07XG4gICAgICAgIGxldCBbY3VycmVudEZpbHRlcl0gPSBmbGF0dGVuKHJvb3QpLmZpbHRlcih4ID0+IHguZmllbGQgPT09IGZpbHRlciQkMS5maWVsZCk7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGN1cnJlbnRGaWx0ZXIpKSB7XG4gICAgICAgICAgICByb290LmZpbHRlcnMucHVzaChmaWx0ZXIkJDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjdXJyZW50RmlsdGVyLCBmaWx0ZXIkJDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBhcHBseUZpbHRlcihmaWx0ZXIkJDEpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlLmZpbHRlcihmaWx0ZXIkJDEpO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZpbHRlcmNlbGwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQmFzZUZpbHRlckNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKEZpbHRlck9wZXJhdG9yQmFzZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIEJhc2VGaWx0ZXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGVyYXRvckxpc3RcIiwgdm9pZCAwKTtcblxuY29uc3QgbnVtZXJpY09wZXJhdG9ycyA9IGxvY2FsaXplT3BlcmF0b3JzJDEoe1xuICAgIFwiZmlsdGVyRXFPcGVyYXRvclwiOiBcImVxXCIsXG4gICAgXCJmaWx0ZXJOb3RFcU9wZXJhdG9yXCI6IFwibmVxXCIsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9iamVjdC1saXRlcmFsLXNvcnQta2V5c1xuICAgIFwiZmlsdGVyR3RlT3BlcmF0b3JcIjogXCJndGVcIixcbiAgICBcImZpbHRlckd0T3BlcmF0b3JcIjogXCJndFwiLFxuICAgIFwiZmlsdGVyTHRlT3BlcmF0b3JcIjogXCJsdGVcIixcbiAgICBcImZpbHRlckx0T3BlcmF0b3JcIjogXCJsdFwiLFxuICAgIFwiZmlsdGVySXNOdWxsT3BlcmF0b3JcIjogXCJpc251bGxcIixcbiAgICBcImZpbHRlcklzTm90TnVsbE9wZXJhdG9yXCI6IFwiaXNub3RudWxsXCJcbn0pO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgYmFzZSBudW1lcmljIGZpbHRlciBjb21wb25lbnQuXG4gKi9cbmNsYXNzIE51bWVyaWNGaWx0ZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlRmlsdGVyQ2VsbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvci4gRGVmYXVsdHMgdG8gYGVxYC5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBcImVxXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHZhbHVlIHRoYXQgaXMgdXNlZCB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRoZSBjb21wb25lbnQgdmFsdWUuXG4gICAgICAgICAqIEB0eXBlIHtudW1lcmljfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSAqKlVwKiogYW5kICoqRG93bioqIHNwaW4gYnV0dG9ucyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Bpbm5lcnMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmF1bHRPcGVyYXRvcnMgPSBudW1lcmljT3BlcmF0b3JzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgZm9ybWF0IHVzZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG5vdCBmb2N1c2VkLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBgY29sdW1uLmZvcm1hdGAgdmFsdWUgaXMgdXNlZCAoaWYgc2V0KS5cbiAgICAgKi9cbiAgICBzZXQgZm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiAhaXNOdWxsT3JFbXB0eVN0cmluZyh0aGlzLl9mb3JtYXQpID8gdGhpcy5fZm9ybWF0IDogdGhpcy5jb2x1bW5Gb3JtYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGZpbHRlciBmb3IgdGhlIGFzc29jaWF0ZWQgY29sdW1uIGZpZWxkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtGaWx0ZXJEZXNjcmlwdG9yfVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeUZpZWxkKHRoaXMuY29sdW1uLmZpZWxkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZmlsdGVyIG9wZXJhdG9yIGZvciB0aGUgYXNzb2NpYXRlZCBjb2x1bW4gZmllbGQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudE9wZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RmlsdGVyID8gdGhpcy5jdXJyZW50RmlsdGVyLm9wZXJhdG9yIDogdGhpcy5vcGVyYXRvcjtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbkZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uICYmICFpc051bGxPckVtcHR5U3RyaW5nKHRoaXMuY29sdW1uLmZvcm1hdCkgP1xuICAgICAgICAgICAgZXh0cmFjdEZvcm1hdCh0aGlzLmNvbHVtbi5mb3JtYXQpIDogXCJuMlwiO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmxvY2FsaXphdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgIH1cbiAgICBsb2NhbGl6YXRpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wZXJhdG9ycyA9IG51bWVyaWNPcGVyYXRvcnModGhpcy5sb2NhbGl6YXRpb24pO1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRvckxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9ycyA9IHRvSlNPTih0aGlzLm9wZXJhdG9yTGlzdC50b0FycmF5KCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sdW1uQ29tcG9uZW50KVxuXSwgTnVtZXJpY0ZpbHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOdW1lcmljRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE51bWVyaWNGaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE51bWVyaWNGaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE51bWVyaWNGaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNwaW5uZXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWNpbWFsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOdW1lcmljRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgbnVsbCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG51bWVyaWMgZmlsdGVyIGNlbGwuXG4gKlxuICogQGV4YW1wbGVcbiAqICBgYGBodG1sLW5vLXJ1blxuICogICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkRmlsdGVyQ2VsbFRlbXBsYXRlIGxldC1maWx0ZXIgbGV0LWNvbHVtbj1cImNvbHVtblwiPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtbnVtZXJpYy1maWx0ZXItY2VsbFxuICogICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAqICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLW51bWVyaWMtZmlsdGVyLWNlbGw+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICBgYGBcbiAqL1xubGV0IE51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50ID0gY2xhc3MgTnVtZXJpY0ZpbHRlckNlbGxDb21wb25lbnQgZXh0ZW5kcyBOdW1lcmljRmlsdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJTZXJ2aWNlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBkZWxheSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGJlZm9yZSB0aGUgZmlsdGVyIHZhbHVlIGlzIHN1Ym1pdHRlZC5cbiAgICAgICAgICogQSB2YWx1ZSBvZiBgMGAgaW5kaWNhdGVzIG5vIGRlbGF5LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgNTAwYC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckRlbGF5ID0gNTAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZHJvcC1kb3duIGZpbHRlciBvcGVyYXRvcnMgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dPcGVyYXRvcnMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbWVzc2FnZUZvcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkxhYmVsKCkge1xuICAgICAgICBjb25zdCBsb2NhbGl6YXRpb25Nc2cgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2ZpbHRlcklucHV0TGFiZWwnKSB8fCAnJztcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uLnRpdGxlIHx8IHRoaXMuY29sdW1uLmZpZWxkO1xuICAgICAgICByZXR1cm4gcmVwbGFjZU1lc3NhZ2VQbGFjZWhvbGRlcihsb2NhbGl6YXRpb25Nc2csICdjb2x1bW5OYW1lJywgY29sdW1uTmFtZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJEZWxheVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93T3BlcmF0b3JzXCIsIHZvaWQgMCk7XG5OdW1lcmljRmlsdGVyQ2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1udW1lcmljLWZpbHRlci1jZWxsJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWdyaWQtZmlsdGVyLXdyYXBwZXItY2VsbFxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgW2RlZmF1bHRPcGVyYXRvcl09XCJvcGVyYXRvclwiXG4gICAgICAgICAgICBbc2hvd09wZXJhdG9yc109XCJzaG93T3BlcmF0b3JzXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGtlbmRvLW51bWVyaWN0ZXh0Ym94XG4gICAgICAgICAgICAgICAga2VuZG9HcmlkRm9jdXNhYmxlXG4gICAgICAgICAgICAgICAga2VuZG9GaWx0ZXJJbnB1dFxuICAgICAgICAgICAgICAgIFtjb2x1bW5MYWJlbF09XCJjb2x1bW5MYWJlbFwiXG4gICAgICAgICAgICAgICAgW2ZpbHRlckRlbGF5XT1cImZpbHRlckRlbGF5XCJcbiAgICAgICAgICAgICAgICBbYXV0b0NvcnJlY3RdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cImN1cnJlbnRGaWx0ZXI/LnZhbHVlXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICAgICAgW2RlY2ltYWxzXT1cImRlY2ltYWxzXCJcbiAgICAgICAgICAgICAgICBbc3Bpbm5lcnNdPVwic3Bpbm5lcnNcIlxuICAgICAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgW3N0ZXBdPVwic3RlcFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGtlbmRvLW51bWVyaWN0ZXh0Ym94LW1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgIFtpbmNyZW1lbnRdPVwibWVzc2FnZUZvcignZmlsdGVyTnVtZXJpY0luY3JlbWVudCcpXCJcbiAgICAgICAgICAgICAgICAgICAgW2RlY3JlbWVudF09XCJtZXNzYWdlRm9yKCdmaWx0ZXJOdW1lcmljRGVjcmVtZW50JylcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLW51bWVyaWN0ZXh0Ym94LW1lc3NhZ2VzPlxuICAgICAgICAgICAgPC9rZW5kby1udW1lcmljdGV4dGJveD5cbiAgICAgICAgPC9rZW5kby1ncmlkLWZpbHRlci13cmFwcGVyLWNlbGw+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRmlsdGVyU2VydmljZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBOdW1lcmljRmlsdGVyQ2VsbENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRmlsdGVySW5wdXREaXJlY3RpdmUgPSBjbGFzcyBGaWx0ZXJJbnB1dERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWVBY2Nlc3NvcnMsIG5nWm9uZSwgZWxlbWVudCwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maWx0ZXJEZWxheSA9IDUwMDtcbiAgICAgICAgdGhpcy5jaGFuZ2VSZXF1ZXN0cyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuYWNjZXNzb3IgPSB2YWx1ZUFjY2Vzc29yc1swXTtcbiAgICAgICAgbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlU3RhcnQgPSByZW5kZXJlci5saXN0ZW4oZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnY29tcG9zaXRpb25zdGFydCcsICgpID0+IHRoaXMuY29tcG9zaW5nID0gdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZUVuZCA9IHJlbmRlcmVyLmxpc3RlbihlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdjb21wb3NpdGlvbmVuZCcsICgpID0+IHRoaXMuY29tcG9zaW5nID0gZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZUV2ZW50cyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVFbmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hY2Nlc3Nvci53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5hZGRBcmlhQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoeCA9PiB0aGlzLmZpbHRlckRlbGF5ID4gMCA/XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVJlcXVlc3RzLm5leHQoeCkgOlxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdCh4KSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlQ2hhbmdlcygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ2ZpbHRlckRlbGF5JywgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVDaGFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUNoYW5nZXMoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUV2ZW50cygpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmNoYW5nZVJlcXVlc3RzU3Vic2NyaXB0aW9uID0gdGhpcy5jaGFuZ2VSZXF1ZXN0c1xuICAgICAgICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKHRoaXMuZmlsdGVyRGVsYXkpLCBmaWx0ZXIoKCkgPT4gIXRoaXMuY29tcG9zaW5nKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoeCA9PiB0aGlzLmNoYW5nZS5lbWl0KHgpKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFuZ2VSZXF1ZXN0c1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VSZXF1ZXN0c1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEFyaWFBdHRyaWJ1dGVzKCkge1xuICAgICAgICBjb25zdCBhcmlhVmFsdWUgPSB0aGlzLmNvbHVtbkxhYmVsO1xuICAgICAgICBpZiAodGhpcy5rZW5kb0lucHV0ICYmIHRoaXMua2VuZG9JbnB1dC5mb2N1c2FibGVJZCAmJiBpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKGAjJHt0aGlzLmtlbmRvSW5wdXQuZm9jdXNhYmxlSWR9YCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKGZvY3VzYWJsZUVsZW1lbnQsICdhcmlhLWxhYmVsJywgYXJpYVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnYXJpYS1sYWJlbCcsIGFyaWFWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEtlbmRvSW5wdXQsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBGaWx0ZXJJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwia2VuZG9JbnB1dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRmlsdGVySW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImZpbHRlckRlbGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGaWx0ZXJJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29sdW1uTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgRmlsdGVySW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuRmlsdGVySW5wdXREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0ZpbHRlcklucHV0XSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIFNlbGYoKSksIF9fcGFyYW0oMCwgSW5qZWN0KE5HX1ZBTFVFX0FDQ0VTU09SKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheSwgTmdab25lLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjJdKVxuXSwgRmlsdGVySW5wdXREaXJlY3RpdmUpO1xuXG5jb25zdCBFTVBUWV9WQUxVRV9PUEVSQVRPUlMgPSBuZXcgU2V0KFsnaXNudWxsJywgJ2lzbm90bnVsbCcsICdpc2VtcHR5JywgJ2lzbm90ZW1wdHknXSk7XG5jb25zdCBpc0VtcHR5VmFsdWVPcGVyYXRvciA9IChvcGVyYXRvcikgPT4gRU1QVFlfVkFMVUVfT1BFUkFUT1JTLmhhcyhvcGVyYXRvcik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmlsdGVySW5wdXRXcmFwcGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZpbHRlckNlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlclNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoZmlsdGVyU2VydmljZSk7XG4gICAgICAgIHRoaXMub3BlcmF0b3JzID0gW107XG4gICAgfVxuICAgIGdldCBjdXJyZW50RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeUZpZWxkKHRoaXMuY29sdW1uLmZpZWxkKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRPcGVyYXRvcigpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyJCQxID0gdGhpcy5jdXJyZW50RmlsdGVyO1xuICAgICAgICBpZiAoIXRoaXMuX29wZXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVyYXRvciA9IGZpbHRlciQkMSA/IGZpbHRlciQkMS5vcGVyYXRvciA6IHRoaXMuZGVmYXVsdE9wZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVyYXRvcjtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRPcGVyYXRvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vcGVyYXRvciA9IHZhbHVlO1xuICAgICAgICBjb25zdCBlbXB0eVZhbHVlT3BlcmF0b3IgPSBpc0VtcHR5VmFsdWVPcGVyYXRvcih2YWx1ZSk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5wdXREaXNhYmxlZCA9IGVtcHR5VmFsdWVPcGVyYXRvcjtcbiAgICAgICAgaWYgKGVtcHR5VmFsdWVPcGVyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5hcHBseU5vVmFsdWVGaWx0ZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0JsYW5rKHZhbHVlKSAmJiBpc1ByZXNlbnQodGhpcy5jdXJyZW50RmlsdGVyKSkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLmN1cnJlbnRGaWx0ZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkZWZhdWx0T3BlcmF0b3IoKSB7XG4gICAgICAgIGlmICghaXNOdWxsT3JFbXB0eVN0cmluZyh0aGlzLl9kZWZhdWx0T3BlcmF0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdE9wZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3BlcmF0b3JzICYmIHRoaXMub3BlcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3JzWzBdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcImVxXCI7XG4gICAgfVxuICAgIHNldCBkZWZhdWx0T3BlcmF0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdE9wZXJhdG9yID0gdmFsdWU7XG4gICAgfVxuICAgIHNldCBmaWx0ZXJJbnB1dERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaW5wdXQpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMuaW5wdXQuY2hhbmdlLnN1YnNjcmliZSh0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJJbnB1dERpc2FibGVkID0gaXNFbXB0eVZhbHVlT3BlcmF0b3IodGhpcy5jdXJyZW50T3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5jaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc051bGxPckVtcHR5U3RyaW5nKHZhbHVlKSB8fCB0aGlzLmZpbHRlckJ5RmllbGQodGhpcy5jb2x1bW4uZmllbGQpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckNoYW5nZShpc051bGxPckVtcHR5U3RyaW5nKHZhbHVlKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGaWx0ZXIodGhpcy5jb2x1bW4uZmllbGQpIDpcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlcih7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0aGlzLmNvbHVtbi5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHRoaXMuY3VycmVudE9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DbGVhcigpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZShudWxsKTtcbiAgICAgICAgdGhpcy5maWx0ZXJJbnB1dERpc2FibGVkID0gaXNFbXB0eVZhbHVlT3BlcmF0b3IodGhpcy5kZWZhdWx0T3BlcmF0b3IpO1xuICAgIH1cbiAgICBhcHBseU5vVmFsdWVGaWx0ZXIob3BlcmF0b3IpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJDaGFuZ2UodGhpcy51cGRhdGVGaWx0ZXIoe1xuICAgICAgICAgICAgZmllbGQ6IHRoaXMuY29sdW1uLmZpZWxkLFxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoXCJmaWx0ZXJcIiwgY2hhbmdlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVyYXRvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcklucHV0RGlzYWJsZWQgPSBpc0VtcHR5VmFsdWVPcGVyYXRvcih0aGlzLmN1cnJlbnRPcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEZpbHRlcklucHV0V3JhcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3BlcmF0b3JzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5Db21wb25lbnQpXG5dLCBGaWx0ZXJJbnB1dFdyYXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRmlsdGVySW5wdXRXcmFwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChGaWx0ZXJJbnB1dERpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGaWx0ZXJJbnB1dERpcmVjdGl2ZSlcbl0sIEZpbHRlcklucHV0V3JhcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5wdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgRmlsdGVySW5wdXRXcmFwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWZhdWx0T3BlcmF0b3JcIiwgbnVsbCk7XG5cbmNvbnN0IEVNUFRZX0ZJTFRFUl9PUEVSQVRPUlMgPSBbJ2lzbnVsbCcsICdpc25vdG51bGwnLCAnaXNlbXB0eScsICdpc25vdGVtcHR5J107XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEZpbHRlckNlbGxXcmFwcGVyQ29tcG9uZW50ID0gY2xhc3MgRmlsdGVyQ2VsbFdyYXBwZXJDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJJbnB1dFdyYXBwZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlclNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoZmlsdGVyU2VydmljZSk7XG4gICAgICAgIHRoaXMuc2hvd09wZXJhdG9ycyA9IHRydWU7XG4gICAgfVxuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZUJhc2VDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBzaG93QnV0dG9uKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXIkJDEgPSB0aGlzLmN1cnJlbnRGaWx0ZXI7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoZmlsdGVyJCQxKSAmJiAoIWlzTnVsbE9yRW1wdHlTdHJpbmcoZmlsdGVyJCQxLnZhbHVlKSB8fFxuICAgICAgICAgICAgRU1QVFlfRklMVEVSX09QRVJBVE9SUy5pbmRleE9mKFN0cmluZyhmaWx0ZXIkJDEub3BlcmF0b3IpKSA+PSAwKTtcbiAgICB9XG4gICAgZmlsdGVyQ2hhbmdlKGZpbHRlciQkMSkge1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVyKGZpbHRlciQkMSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZpbHRlcmNlbGwtd3JhcHBlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBGaWx0ZXJDZWxsV3JhcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1maWx0ZXJjZWxsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEZpbHRlckNlbGxXcmFwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvdmVycmlkZUJhc2VDbGFzc2VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZpbHRlckNlbGxXcmFwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93T3BlcmF0b3JzXCIsIHZvaWQgMCk7XG5GaWx0ZXJDZWxsV3JhcHBlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1maWx0ZXItd3JhcHBlci1jZWxsJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8a2VuZG8tZ3JpZC1maWx0ZXItY2VsbC1vcGVyYXRvcnNcbiAgICAgICAgICAgIFtzaG93T3BlcmF0b3JzXT1cInNob3dPcGVyYXRvcnNcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgKGNsZWFyKT1cIm9uQ2xlYXIoKVwiXG4gICAgICAgICAgICBbc2hvd0J1dHRvbl09XCJzaG93QnV0dG9uXCJcbiAgICAgICAgICAgIFsodmFsdWUpXT1cImN1cnJlbnRPcGVyYXRvclwiPlxuICAgICAgICA8L2tlbmRvLWdyaWQtZmlsdGVyLWNlbGwtb3BlcmF0b3JzPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ZpbHRlclNlcnZpY2VdKVxuXSwgRmlsdGVyQ2VsbFdyYXBwZXJDb21wb25lbnQpO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1hY2Nlc3MtbWlzc2luZy1tZW1iZXJcbmNvbnN0IHN0cmluZ09wZXJhdG9ycyA9IGxvY2FsaXplT3BlcmF0b3JzJDEoe1xuICAgIFwiZmlsdGVyRXFPcGVyYXRvclwiOiBcImVxXCIsXG4gICAgXCJmaWx0ZXJOb3RFcU9wZXJhdG9yXCI6IFwibmVxXCIsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9iamVjdC1saXRlcmFsLXNvcnQta2V5c1xuICAgIFwiZmlsdGVyQ29udGFpbnNPcGVyYXRvclwiOiBcImNvbnRhaW5zXCIsXG4gICAgXCJmaWx0ZXJOb3RDb250YWluc09wZXJhdG9yXCI6IFwiZG9lc25vdGNvbnRhaW5cIixcbiAgICBcImZpbHRlclN0YXJ0c1dpdGhPcGVyYXRvclwiOiBcInN0YXJ0c3dpdGhcIixcbiAgICBcImZpbHRlckVuZHNXaXRoT3BlcmF0b3JcIjogXCJlbmRzd2l0aFwiLFxuICAgIFwiZmlsdGVySXNOdWxsT3BlcmF0b3JcIjogXCJpc251bGxcIixcbiAgICBcImZpbHRlcklzTm90TnVsbE9wZXJhdG9yXCI6IFwiaXNub3RudWxsXCIsXG4gICAgXCJmaWx0ZXJJc0VtcHR5T3BlcmF0b3JcIjogXCJpc2VtcHR5XCIsXG4gICAgXCJmaWx0ZXJJc05vdEVtcHR5T3BlcmF0b3JcIjogXCJpc25vdGVtcHR5XCJcbn0pO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgYmFzZSBzdHJpbmcgZmlsdGVyIGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgU3RyaW5nRmlsdGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZpbHRlckNlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlclNlcnZpY2UsIGxvY2FsaXphdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3IuIERlZmF1bHRzIHRvIGBjb250YWluc2AuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gXCJjb250YWluc1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWx0ZXIgZm9yIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmaWVsZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7RmlsdGVyRGVzY3JpcHRvcn1cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQnlGaWVsZCgodGhpcy5jb2x1bW4gfHwge30pLmZpZWxkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZmlsdGVyIG9wZXJhdG9yIGZvciB0aGUgYXNzb2NpYXRlZCBjb2x1bW4gZmllbGQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudE9wZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RmlsdGVyID8gdGhpcy5jdXJyZW50RmlsdGVyLm9wZXJhdG9yIDogdGhpcy5vcGVyYXRvcjtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5sb2NhbGl6YXRpb25DaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcbiAgICB9XG4gICAgbG9jYWxpemF0aW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRPcGVyYXRvcnMgPSBzdHJpbmdPcGVyYXRvcnModGhpcy5sb2NhbGl6YXRpb24pO1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRvckxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9ycyA9IHRvSlNPTih0aGlzLm9wZXJhdG9yTGlzdC50b0FycmF5KCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sdW1uQ29tcG9uZW50KVxuXSwgU3RyaW5nRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFN0cmluZ0ZpbHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTdHJpbmdGaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9wZXJhdG9yXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN0cmluZy1maWx0ZXIgY2VsbCBjb21wb25lbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX2dyaWQgJX0jdG9jLWNvbmZpZ3VyYXRpb24tY29tcG9uZW50cy1mb3ItZmlsdGVyLXRlbXBsYXRlcykpLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogIGBgYGh0bWwtbm8tcnVuXG4gKiAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRGaWx0ZXJDZWxsVGVtcGxhdGUgbGV0LWZpbHRlciBsZXQtY29sdW1uPVwiY29sdW1uXCI+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1zdHJpbmctZmlsdGVyLWNlbGxcbiAqICAgICAgICAgICAgICBbc2hvd09wZXJhdG9yc109XCJmYWxzZVwiXG4gKiAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICogICAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCI+XG4gKiAgICAgICAgICA8L2tlbmRvLWdyaWQtc3RyaW5nLWZpbHRlci1jZWxsPlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgYGBgXG4gKi9cbmxldCBTdHJpbmdGaWx0ZXJDZWxsQ29tcG9uZW50ID0gY2xhc3MgU3RyaW5nRmlsdGVyQ2VsbENvbXBvbmVudCBleHRlbmRzIFN0cmluZ0ZpbHRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UsIGxvY2FsaXphdGlvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBkZWxheSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGJlZm9yZSB0aGUgZmlsdGVyIHZhbHVlIGlzIHN1Ym1pdHRlZC5cbiAgICAgICAgICogQSB2YWx1ZSBvZiBgMGAgaW5kaWNhdGVzIG5vIGRlbGF5LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgNTAwYC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckRlbGF5ID0gNTAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZHJvcC1kb3duIGZpbHRlciBvcGVyYXRvcnMgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dPcGVyYXRvcnMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkxhYmVsKCkge1xuICAgICAgICBjb25zdCBsb2NhbGl6YXRpb25Nc2cgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2ZpbHRlcklucHV0TGFiZWwnKSB8fCAnJztcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uLnRpdGxlIHx8IHRoaXMuY29sdW1uLmZpZWxkO1xuICAgICAgICByZXR1cm4gcmVwbGFjZU1lc3NhZ2VQbGFjZWhvbGRlcihsb2NhbGl6YXRpb25Nc2csICdjb2x1bW5OYW1lJywgY29sdW1uTmFtZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFN0cmluZ0ZpbHRlckNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlckRlbGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU3RyaW5nRmlsdGVyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd09wZXJhdG9yc1wiLCB2b2lkIDApO1xuU3RyaW5nRmlsdGVyQ2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1zdHJpbmctZmlsdGVyLWNlbGwnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tZ3JpZC1maWx0ZXItd3JhcHBlci1jZWxsXG4gICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbZGVmYXVsdE9wZXJhdG9yXT1cIm9wZXJhdG9yXCJcbiAgICAgICAgICAgIFtzaG93T3BlcmF0b3JzXT1cInNob3dPcGVyYXRvcnNcIj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGtlbmRvVGV4dEJveFxuICAgICAgICAgICAgICAgIGtlbmRvR3JpZEZvY3VzYWJsZVxuICAgICAgICAgICAgICAgIGtlbmRvRmlsdGVySW5wdXRcbiAgICAgICAgICAgICAgICBbY29sdW1uTGFiZWxdPVwiY29sdW1uTGFiZWxcIlxuICAgICAgICAgICAgICAgIFtmaWx0ZXJEZWxheV09XCJmaWx0ZXJEZWxheVwiXG4gICAgICAgICAgICAgICAgW25nTW9kZWxdPVwiY3VycmVudEZpbHRlcj8udmFsdWVcIiAvPlxuICAgICAgICA8L2tlbmRvLWdyaWQtZmlsdGVyLXdyYXBwZXItY2VsbD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFN0cmluZ0ZpbHRlckNlbGxDb21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb21wb25lbnQgd2hpY2ggYWNjb21tb2RhdGVzIHRoZSBmaWx0ZXIgb3BlcmF0b3JzLlxuICovXG5sZXQgRmlsdGVyQ2VsbE9wZXJhdG9yc0NvbXBvbmVudCA9IGNsYXNzIEZpbHRlckNlbGxPcGVyYXRvcnNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jbGVhclRleHQgPSAnQ2xlYXInO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpbHRlciBvcGVyYXRvcnMgdGhhdCB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlcmF0b3JzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBsaXN0IG9mIG9wZXJhdG9ycyB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dPcGVyYXRvcnMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgb3BlcmF0b3IgaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSAqKkNsZWFyKiogYnV0dG9uIGlzIGNsaWNrZWQuXG4gICAgICAgICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8e30+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNoYW5nZShkYXRhSXRlbSkge1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoZGF0YUl0ZW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2xlYXJDbGljaygpIHtcbiAgICAgICAgdGhpcy5jbGVhci5lbWl0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNsZWFyS2V5ZG93bihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuRW50ZXIgfHwgYXJncy5rZXlDb2RlID09PSBLZXlzLlNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZHJvcGRvd25LZXlkb3duKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuRW50ZXIgJiYgIXRoaXMuZHJvcGRvd24uaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLnRvZ2dsZSh0cnVlKTtcbiAgICAgICAgICAgIGFyZ3MucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbGVhclRleHQgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoXCJmaWx0ZXJDbGVhckJ1dHRvblwiKSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZpbHRlcmNlbGwtb3BlcmF0b3InKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRmlsdGVyQ2VsbE9wZXJhdG9yc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2Ryb3Bkb3duJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEcm9wRG93bkxpc3RDb21wb25lbnQpXG5dLCBGaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkcm9wZG93blwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBGaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGVyYXRvcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBGaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93QnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmlsdGVyQ2VsbE9wZXJhdG9yc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd09wZXJhdG9yc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmlsdGVyQ2VsbE9wZXJhdG9yc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBGaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEZpbHRlckNlbGxPcGVyYXRvcnNDb21wb25lbnQucHJvdG90eXBlLCBcImNsZWFyXCIsIHZvaWQgMCk7XG5GaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLWZpbHRlci1jZWxsLW9wZXJhdG9ycycsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby1kcm9wZG93bmxpc3RcbiAgICAgICAgICAgICNkcm9wZG93blxuICAgICAgICAgICAgKm5nSWY9XCJzaG93T3BlcmF0b3JzXCJcbiAgICAgICAgICAgIGtlbmRvR3JpZEZvY3VzYWJsZVxuICAgICAgICAgICAgW2RhdGFdPVwib3BlcmF0b3JzXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay1kcm9wZG93bi1vcGVyYXRvclwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgaWNvbkNsYXNzPVwiay1pLWZpbHRlclwiXG4gICAgICAgICAgICBbdmFsdWVQcmltaXRpdmVdPVwidHJ1ZVwiXG4gICAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAgICAgICAgICAgIFtwb3B1cFNldHRpbmdzXT1cInsgd2lkdGg6ICdhdXRvJyB9XCJcbiAgICAgICAgICAgIHZhbHVlRmllbGQ9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAoa2V5ZG93bik9XCJkcm9wZG93bktleWRvd24oJGV2ZW50KVwiPlxuICAgICAgICA8L2tlbmRvLWRyb3Bkb3dubGlzdD5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGtlbmRvR3JpZEZvY3VzYWJsZVxuICAgICAgICAgICAgKm5nSWY9XCJzaG93QnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay1idXR0b24gay1idXR0b24tc29saWQtYmFzZSBrLWJ1dHRvbi1zb2xpZCBrLWJ1dHRvbi1tZCBrLXJvdW5kZWQtbWQgay1idXR0b24tcmVjdGFuZ2xlIGstaWNvbi1idXR0b25cIlxuICAgICAgICAgICAgW3RpdGxlXT1cImNsZWFyVGV4dFwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY2xlYXJDbGljaygpXCJcbiAgICAgICAgICAgIChrZXlkb3duKT1cImNsZWFyS2V5ZG93bigkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1idXR0b24taWNvbiBrLWktZmlsdGVyLWNsZWFyXCI+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIEZpbHRlckNlbGxPcGVyYXRvcnNDb21wb25lbnQpO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1hY2Nlc3MtbWlzc2luZy1tZW1iZXJcbmNvbnN0IHN0cmluZ09wZXJhdG9ycyQxID0gbG9jYWxpemVPcGVyYXRvcnMkMSh7XG4gICAgXCJmaWx0ZXJDb250YWluc09wZXJhdG9yXCI6IFwiY29udGFpbnNcIixcbiAgICBcImZpbHRlck5vdENvbnRhaW5zT3BlcmF0b3JcIjogXCJkb2Vzbm90Y29udGFpblwiLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXNcbiAgICBcImZpbHRlckVxT3BlcmF0b3JcIjogXCJlcVwiLFxuICAgIFwiZmlsdGVyTm90RXFPcGVyYXRvclwiOiBcIm5lcVwiLFxuICAgIFwiZmlsdGVyU3RhcnRzV2l0aE9wZXJhdG9yXCI6IFwic3RhcnRzd2l0aFwiLFxuICAgIFwiZmlsdGVyRW5kc1dpdGhPcGVyYXRvclwiOiBcImVuZHN3aXRoXCIsXG4gICAgXCJmaWx0ZXJJc051bGxPcGVyYXRvclwiOiBcImlzbnVsbFwiLFxuICAgIFwiZmlsdGVySXNOb3ROdWxsT3BlcmF0b3JcIjogXCJpc25vdG51bGxcIixcbiAgICBcImZpbHRlcklzRW1wdHlPcGVyYXRvclwiOiBcImlzZW1wdHlcIixcbiAgICBcImZpbHRlcklzTm90RW1wdHlPcGVyYXRvclwiOiBcImlzbm90ZW1wdHlcIlxufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEF1dG9Db21wbGV0ZUZpbHRlckNlbGxDb21wb25lbnQgPSBjbGFzcyBBdXRvQ29tcGxldGVGaWx0ZXJDZWxsQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZpbHRlckNlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlclNlcnZpY2UsIGNvbHVtbiwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5zaG93T3BlcmF0b3JzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0T3BlcmF0b3JzID0gc3RyaW5nT3BlcmF0b3JzJDEodGhpcy5sb2NhbGl6YXRpb24pO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB9XG4gICAgc2V0IHZhbHVlRmllbGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVGaWVsZCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVGaWVsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlRmllbGQgPyB0aGlzLl92YWx1ZUZpZWxkIDogdGhpcy5jb2x1bW4uZmllbGQ7XG4gICAgfVxuICAgIGdldCBjdXJyZW50RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeUZpZWxkKHRoaXMuY29sdW1uLmZpZWxkKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRPcGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEZpbHRlciA/IHRoaXMuY3VycmVudEZpbHRlci5vcGVyYXRvciA6IFwiY29udGFpbnNcIjtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF1dG9Db21wbGV0ZUZpbHRlckNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dPcGVyYXRvcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENvbHVtbkNvbXBvbmVudClcbl0sIEF1dG9Db21wbGV0ZUZpbHRlckNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXV0b0NvbXBsZXRlRmlsdGVyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEF1dG9Db21wbGV0ZUZpbHRlckNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQXV0b0NvbXBsZXRlRmlsdGVyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGaWVsZFwiLCBudWxsKTtcbkF1dG9Db21wbGV0ZUZpbHRlckNlbGxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWdyaWQtYXV0b2NvbXBsZXRlLWZpbHRlci1jZWxsJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWdyaWQtZmlsdGVyLXdyYXBwZXItY2VsbFxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgW3Nob3dPcGVyYXRvcnNdPVwic2hvd09wZXJhdG9yc1wiPlxuICAgICAgICAgICAgPGtlbmRvLWF1dG9jb21wbGV0ZVxuICAgICAgICAgICAgICAgIGtlbmRvRmlsdGVySW5wdXRcbiAgICAgICAgICAgICAgICBbZGF0YV09XCJkYXRhXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVGaWVsZF09XCJ2YWx1ZUZpZWxkXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVdPVwiY3VycmVudEZpbHRlcj8udmFsdWVcIj5cbiAgICAgICAgICAgIDwva2VuZG8tYXV0b2NvbXBsZXRlPlxuICAgICAgICA8L2tlbmRvLWdyaWQtZmlsdGVyLXdyYXBwZXItY2VsbD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICBDb2x1bW5Db21wb25lbnQsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgQXV0b0NvbXBsZXRlRmlsdGVyQ2VsbENvbXBvbmVudCk7XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLWFjY2Vzcy1taXNzaW5nLW1lbWJlclxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEJvb2xlYW5GaWx0ZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlRmlsdGVyQ2VsbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBcImVxXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1zID0gW1xuICAgICAgICAgICAgeyB0ZXh0OiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoXCJmaWx0ZXJJc1RydWVcIiksIHZhbHVlOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHRleHQ6IHRoaXMubG9jYWxpemF0aW9uLmdldChcImZpbHRlcklzRmFsc2VcIiksIHZhbHVlOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRJdGVtID0geyB0ZXh0OiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoXCJmaWx0ZXJCb29sZWFuQWxsXCIpLCB2YWx1ZTogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhvc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZmlsdGVyIGZvciB0aGUgYXNzb2NpYXRlZCBjb2x1bW4gZmllbGQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge0ZpbHRlckRlc2NyaXB0b3J9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJ5RmllbGQodGhpcy5jb2x1bW4uZmllbGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWx0ZXIgb3BlcmF0b3IgZm9yIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmaWVsZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50T3BlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaWx0ZXIgPyB0aGlzLmN1cnJlbnRGaWx0ZXIub3BlcmF0b3IgOiB0aGlzLm9wZXJhdG9yO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmxvY2FsaXphdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgIH1cbiAgICBsb2NhbGl6YXRpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXG4gICAgICAgICAgICB7IHRleHQ6IHRoaXMubG9jYWxpemF0aW9uLmdldChcImZpbHRlcklzVHJ1ZVwiKSwgdmFsdWU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdGV4dDogdGhpcy5sb2NhbGl6YXRpb24uZ2V0KFwiZmlsdGVySXNGYWxzZVwiKSwgdmFsdWU6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5kZWZhdWx0SXRlbSA9IHsgdGV4dDogdGhpcy5sb2NhbGl6YXRpb24uZ2V0KFwiZmlsdGVyQm9vbGVhbkFsbFwiKSwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1maWx0ZXJjZWxsLWJvb2xlYW4nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQm9vbGVhbkZpbHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5Db21wb25lbnQpXG5dLCBCb29sZWFuRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEJvb2xlYW5GaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBCb29sZWFuIGZpbHRlci1jZWxsIGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICBgYGBodG1sLW5vLXJ1blxuICogICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkRmlsdGVyQ2VsbFRlbXBsYXRlIGxldC1maWx0ZXIgbGV0LWNvbHVtbj1cImNvbHVtblwiPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtYm9vbGVhbi1maWx0ZXItY2VsbFxuICogICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAqICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLWJvb2xlYW4tZmlsdGVyLWNlbGw+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICBgYGBcbiAqL1xubGV0IEJvb2xlYW5GaWx0ZXJDZWxsQ29tcG9uZW50ID0gY2xhc3MgQm9vbGVhbkZpbHRlckNlbGxDb21wb25lbnQgZXh0ZW5kcyBCb29sZWFuRmlsdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJTZXJ2aWNlLCBsb2NhbGl6YXRpb24sIGNkKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UsIGxvY2FsaXphdGlvbik7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICB9XG4gICAgbG9jYWxpemF0aW9uQ2hhbmdlKCkge1xuICAgICAgICBzdXBlci5sb2NhbGl6YXRpb25DaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb2x1bW5MYWJlbCgpIHtcbiAgICAgICAgY29uc3QgbG9jYWxpemF0aW9uTXNnID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdmaWx0ZXJJbnB1dExhYmVsJykgfHwgJyc7XG4gICAgICAgIGNvbnN0IGNvbHVtbk5hbWUgPSB0aGlzLmNvbHVtbi50aXRsZSB8fCB0aGlzLmNvbHVtbi5maWVsZDtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VNZXNzYWdlUGxhY2Vob2xkZXIobG9jYWxpemF0aW9uTXNnLCAnY29sdW1uTmFtZScsIGNvbHVtbk5hbWUpO1xuICAgIH1cbn07XG5Cb29sZWFuRmlsdGVyQ2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1ib29sZWFuLWZpbHRlci1jZWxsJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWdyaWQtZmlsdGVyLXdyYXBwZXItY2VsbFxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW3Nob3dPcGVyYXRvcnNdPVwiZmFsc2VcIlxuICAgICAgICAgICAgW2RlZmF1bHRPcGVyYXRvcl09XCJvcGVyYXRvclwiPlxuICAgICAgICAgICAgPGtlbmRvLWRyb3Bkb3dubGlzdFxuICAgICAgICAgICAgICAgIGtlbmRvRmlsdGVySW5wdXRcbiAgICAgICAgICAgICAgICBrZW5kb0dyaWRGb2N1c2FibGVcbiAgICAgICAgICAgICAgICBbY29sdW1uTGFiZWxdPVwiY29sdW1uTGFiZWxcIlxuICAgICAgICAgICAgICAgIFtkZWZhdWx0SXRlbV09XCJkZWZhdWx0SXRlbVwiXG4gICAgICAgICAgICAgICAgW2RhdGFdPVwiaXRlbXNcIlxuICAgICAgICAgICAgICAgIHRleHRGaWVsZD1cInRleHRcIlxuICAgICAgICAgICAgICAgIHZhbHVlRmllbGQ9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgW3BvcHVwU2V0dGluZ3NdPVwieyB3aWR0aDogJ2F1dG8nIH1cIlxuICAgICAgICAgICAgICAgIFt2YWx1ZVByaW1pdGl2ZV09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVdPVwiY3VycmVudEZpbHRlcj8udmFsdWVcIj5cbiAgICAgICAgICAgIDwva2VuZG8tZHJvcGRvd25saXN0PlxuICAgICAgICA8L2tlbmRvLWdyaWQtZmlsdGVyLXdyYXBwZXItY2VsbD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBCb29sZWFuRmlsdGVyQ2VsbENvbXBvbmVudCk7XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLWFjY2Vzcy1taXNzaW5nLW1lbWJlclxuY29uc3QgZGF0ZU9wZXJhdG9ycyA9IGxvY2FsaXplT3BlcmF0b3JzJDEoe1xuICAgIFwiZmlsdGVyRXFPcGVyYXRvclwiOiBcImVxXCIsXG4gICAgXCJmaWx0ZXJOb3RFcU9wZXJhdG9yXCI6IFwibmVxXCIsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9iamVjdC1saXRlcmFsLXNvcnQta2V5c1xuICAgIFwiZmlsdGVyQWZ0ZXJPckVxdWFsT3BlcmF0b3JcIjogXCJndGVcIixcbiAgICBcImZpbHRlckFmdGVyT3BlcmF0b3JcIjogXCJndFwiLFxuICAgIFwiZmlsdGVyQmVmb3JlT3JFcXVhbE9wZXJhdG9yXCI6IFwibHRlXCIsXG4gICAgXCJmaWx0ZXJCZWZvcmVPcGVyYXRvclwiOiBcImx0XCIsXG4gICAgXCJmaWx0ZXJJc051bGxPcGVyYXRvclwiOiBcImlzbnVsbFwiLFxuICAgIFwiZmlsdGVySXNOb3ROdWxsT3BlcmF0b3JcIjogXCJpc25vdG51bGxcIlxufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRGF0ZUZpbHRlckNvbXBvbmVudCBleHRlbmRzIEJhc2VGaWx0ZXJDZWxsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJTZXJ2aWNlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIoZmlsdGVyU2VydmljZSk7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yLiBEZWZhdWx0cyB0byBgY29udGFpbnNgLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IFwiZ3RlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBhY3RpdmUgdmlldyB0aGF0IHRoZSBjYWxlbmRhciBpbml0aWFsbHkgcmVuZGVycy5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGFjdGl2ZSB2aWV3IGlzIGBtb250aGAuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gWW91IGhhdmUgdG8gc2V0IGBhY3RpdmVWaWV3YCB3aXRoaW4gdGhlIGB0b3BWaWV3YC1gYm90dG9tVmlld2AgcmFuZ2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXcgPSBcIm1vbnRoXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBib3R0b21tb3N0IGNhbGVuZGFyIHZpZXcsIHRvIHdoaWNoIHRoZSB1c2VyIGNhbiBuYXZpZ2F0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm90dG9tVmlldyA9IFwibW9udGhcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHRvcG1vc3QgY2FsZW5kYXIgdmlldywgdG8gd2hpY2ggdGhlIHVzZXIgY2FuIG5hdmlnYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b3BWaWV3ID0gXCJjZW50dXJ5XCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSBhIHdlZWsgbnVtYmVyIGNvbHVtbiBpbiB0aGUgYG1vbnRoYCB2aWV3IG9mIHRoZSBDYWxlbmRhci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2Vla051bWJlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRPcGVyYXRvcnMgPSBkYXRlT3BlcmF0b3JzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZmlsdGVyIGZvciB0aGUgYXNzb2NpYXRlZCBjb2x1bW4gZmllbGQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge0ZpbHRlckRlc2NyaXB0b3J9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJ5RmllbGQodGhpcy5jb2x1bW4uZmllbGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGRhdGUgZm9ybWF0IHRoYXQgaXMgdXNlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGZvY3VzZWQuXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGBjb2x1bW4uZm9ybWF0YCB2YWx1ZSBpcyB1c2VkIChpZiBzZXQpLlxuICAgICAqL1xuICAgIHNldCBmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZm9ybWF0ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgZGF0ZSBmb3JtYXQgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgZm9jdXNlZC5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYGNvbHVtbi5mb3JtYXRgIHZhbHVlIGlzIHVzZWQgKGlmIHNldCkuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiAhaXNOdWxsT3JFbXB0eVN0cmluZyh0aGlzLl9mb3JtYXQpID8gdGhpcy5fZm9ybWF0IDogdGhpcy5jb2x1bW5Gb3JtYXQ7XG4gICAgfVxuICAgIGdldCBjb2x1bW5Gb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbiAmJiAhaXNOdWxsT3JFbXB0eVN0cmluZyh0aGlzLmNvbHVtbi5mb3JtYXQpID9cbiAgICAgICAgICAgIGV4dHJhY3RGb3JtYXQodGhpcy5jb2x1bW4uZm9ybWF0KSA6IFwiZFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWx0ZXIgb3BlcmF0b3IgZm9yIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmaWVsZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50T3BlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaWx0ZXIgPyB0aGlzLmN1cnJlbnRGaWx0ZXIub3BlcmF0b3IgOiB0aGlzLm9wZXJhdG9yO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmxvY2FsaXphdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgIH1cbiAgICBsb2NhbGl6YXRpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wZXJhdG9ycyA9IGRhdGVPcGVyYXRvcnModGhpcy5sb2NhbGl6YXRpb24pO1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRvckxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9ycyA9IHRvSlNPTih0aGlzLm9wZXJhdG9yTGlzdC50b0FycmF5KCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sdW1uQ29tcG9uZW50KVxuXSwgRGF0ZUZpbHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRlRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVGaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIERhdGVGaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVGaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlRmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZUZpbHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZUZpbHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm90dG9tVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZUZpbHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidG9wVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVGaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGF0ZS1maWx0ZXIgY2VsbCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgYGBgaHRtbC1uby1ydW5cbiAqICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiT3JkZXJEYXRlXCIgdGl0bGU9XCJPcmRlciBEYXRlXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkRmlsdGVyQ2VsbFRlbXBsYXRlIGxldC1maWx0ZXIgbGV0LWNvbHVtbj1cImNvbHVtblwiPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtZGF0ZS1maWx0ZXItY2VsbFxuICogICAgICAgICAgICAgIFtzaG93T3BlcmF0b3JzXT1cImZhbHNlXCJcbiAqICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gKiAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIj5cbiAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1kYXRlLWZpbHRlci1jZWxsPlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgYGBgXG4gKi9cbmxldCBEYXRlRmlsdGVyQ2VsbENvbXBvbmVudCA9IGNsYXNzIERhdGVGaWx0ZXJDZWxsQ29tcG9uZW50IGV4dGVuZHMgRGF0ZUZpbHRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UsIGxvY2FsaXphdGlvbik7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZHJvcC1kb3duIGZpbHRlciBvcGVyYXRvcnMgd2lsbCBiZSBkaXNwbGF5ZWQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dPcGVyYXRvcnMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbWVzc2FnZUZvcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkxhYmVsKCkge1xuICAgICAgICBjb25zdCBsb2NhbGl6YXRpb25Nc2cgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2ZpbHRlcklucHV0TGFiZWwnKSB8fCAnJztcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uLnRpdGxlIHx8IHRoaXMuY29sdW1uLmZpZWxkO1xuICAgICAgICByZXR1cm4gcmVwbGFjZU1lc3NhZ2VQbGFjZWhvbGRlcihsb2NhbGl6YXRpb25Nc2csICdjb2x1bW5OYW1lJywgY29sdW1uTmFtZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlRmlsdGVyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd09wZXJhdG9yc1wiLCB2b2lkIDApO1xuRGF0ZUZpbHRlckNlbGxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWdyaWQtZGF0ZS1maWx0ZXItY2VsbCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby1ncmlkLWZpbHRlci13cmFwcGVyLWNlbGxcbiAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgIFtvcGVyYXRvcnNdPVwib3BlcmF0b3JzXCJcbiAgICAgICAgICAgIFtkZWZhdWx0T3BlcmF0b3JdPVwib3BlcmF0b3JcIlxuICAgICAgICAgICAgW3Nob3dPcGVyYXRvcnNdPVwic2hvd09wZXJhdG9yc1wiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxrZW5kby1kYXRlcGlja2VyXG4gICAgICAgICAgICAgICAga2VuZG9GaWx0ZXJJbnB1dFxuICAgICAgICAgICAgICAgIGtlbmRvR3JpZEZvY3VzYWJsZVxuICAgICAgICAgICAgICAgIFtjb2x1bW5MYWJlbF09XCJjb2x1bW5MYWJlbFwiXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cImN1cnJlbnRGaWx0ZXI/LnZhbHVlXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdFBsYWNlaG9sZGVyXT1cImZvcm1hdFBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIlxuICAgICAgICAgICAgICAgIFtib3R0b21WaWV3XT1cImJvdHRvbVZpZXdcIlxuICAgICAgICAgICAgICAgIFt0b3BWaWV3XT1cInRvcFZpZXdcIlxuICAgICAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJdPVwid2Vla051bWJlclwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGtlbmRvLWRhdGVwaWNrZXItbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgW3RvZ2dsZV09XCJtZXNzYWdlRm9yKCdmaWx0ZXJEYXRlVG9nZ2xlJylcIlxuICAgICAgICAgICAgICAgICAgICBbdG9kYXldPVwibWVzc2FnZUZvcignZmlsdGVyRGF0ZVRvZGF5JylcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLWRhdGVwaWNrZXItbWVzc2FnZXM+XG4gICAgICAgICAgICA8L2tlbmRvLWRhdGVwaWNrZXI+XG4gICAgICAgIDwva2VuZG8tZ3JpZC1maWx0ZXItd3JhcHBlci1jZWxsPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ZpbHRlclNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgRGF0ZUZpbHRlckNlbGxDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENvbEdyb3VwQ29tcG9uZW50ID0gY2xhc3MgQ29sR3JvdXBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gW107XG4gICAgfVxuICAgIGdldCBjb2x1bW5zVG9SZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zVG9SZW5kZXIodGhpcy5jb2x1bW5zKTtcbiAgICB9XG4gICAgdHJhY2tCeShpbmRleCwgX2l0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIENvbEdyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIENvbEdyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERldGFpbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ29sR3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImRldGFpbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5Db2xHcm91cENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZENvbEdyb3VwXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cInRydWVcIj5cbiAgICAgICAgPGNvbCBbY2xhc3Muay1ncm91cC1jb2xdPVwidHJ1ZVwiICpuZ0Zvcj1cImxldCBnIG9mIGdyb3Vwc1wiIC8+XG4gICAgICAgIDxjb2wgW2NsYXNzLmstaGllcmFyY2h5LWNvbF09XCJ0cnVlXCIgKm5nSWY9XCJkZXRhaWxUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIi8+XG4gICAgICAgIDxjb2wgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBjb2x1bW5zVG9SZW5kZXI7IHRyYWNrQnk6IHRyYWNrQnk7XCIgW3N0eWxlLndpZHRoLnB4XT1cImNvbHVtbi53aWR0aFwiLz5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICB9KVxuXSwgQ29sR3JvdXBDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IExvYWRpbmdDb21wb25lbnQgPSBjbGFzcyBMb2FkaW5nQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGxvYWRpbmdUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdsb2FkaW5nJyk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWxvYWRpbmctbWFzaycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTG9hZGluZ0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBMb2FkaW5nVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBMb2FkaW5nQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsb2FkaW5nVGVtcGxhdGVcIiwgdm9pZCAwKTtcbkxvYWRpbmdDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRMb2FkaW5nXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhbG9hZGluZ1RlbXBsYXRlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstbG9hZGluZy10ZXh0XCI+e3sgbG9hZGluZ1RleHQgfX08L3NwYW4+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1sb2FkaW5nLWltYWdlXCI+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1sb2FkaW5nLWNvbG9yXCI+PC9kaXY+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJsb2FkaW5nVGVtcGxhdGVcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJsb2FkaW5nVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBMb2FkaW5nQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBSZXNpemFibGVDb250YWluZXJEaXJlY3RpdmUgPSBjbGFzcyBSZXNpemFibGVDb250YWluZXJEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsLCByZW5kZXJlciwgcmVzaXplU2VydmljZSwgZ3JpZCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlID0gcmVzaXplU2VydmljZTtcbiAgICAgICAgdGhpcy5ncmlkID0gZ3JpZDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHNldCBsb2NrZWRXaWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9sb2NrZWRXaWR0aCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFJlc2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQga2VuZG9HcmlkUmVzaXphYmxlQ29udGFpbmVyKGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgcmVmcmVzaCA9IGVuYWJsZWQgIT09IHRoaXMuZW5hYmxlZDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoUmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVTdWJzY3JpcHRpb24gJiYgIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVzaXplU3Vic2NyaXB0aW9uICYmIHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTdWJzY3JpcHRpb24gPSB0aGlzLnJlc2l6ZVNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkICYmIHRoaXMuZ3JpZC53cmFwcGVyKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJFbGVtZW50ID0gdGhpcy5ncmlkLndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoY29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aCAtIHRoaXMuX2xvY2tlZFdpZHRoLCAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFwid2lkdGhcIiwgd2lkdGggKyBcInB4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFwid2lkdGhcIiwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2xvY2tlZFdpZHRoJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgUmVzaXphYmxlQ29udGFpbmVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2NrZWRXaWR0aFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBSZXNpemFibGVDb250YWluZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcImtlbmRvR3JpZFJlc2l6YWJsZUNvbnRhaW5lclwiLCBudWxsKTtcblJlc2l6YWJsZUNvbnRhaW5lckRpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZFJlc2l6YWJsZUNvbnRhaW5lcl0nXG4gICAgfSksXG4gICAgX19wYXJhbSgzLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgUmVzaXplU2VydmljZSxcbiAgICAgICAgR3JpZENvbXBvbmVudF0pXG5dLCBSZXNpemFibGVDb250YWluZXJEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRlbXBsYXRlQ29udGV4dERpcmVjdGl2ZSA9IGNsYXNzIFRlbXBsYXRlQ29udGV4dERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3Iodmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuICAgIH1cbiAgICBzZXQgdGVtcGxhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVWaWV3KCk7XG4gICAgICAgIGlmIChjb250ZXh0LnRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydGVkVmlld1JlZiA9IHRoaXMudmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcoY29udGV4dC50ZW1wbGF0ZVJlZiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVmlldygpO1xuICAgIH1cbiAgICByZW1vdmVWaWV3KCkge1xuICAgICAgICBpZiAodGhpcy5pbnNlcnRlZFZpZXdSZWYpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZi5yZW1vdmUodGhpcy52aWV3Q29udGFpbmVyUmVmLmluZGV4T2YodGhpcy5pbnNlcnRlZFZpZXdSZWYpKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0ZWRWaWV3UmVmID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgVGVtcGxhdGVDb250ZXh0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZUNvbnRleHRcIiwgbnVsbCk7XG5UZW1wbGF0ZUNvbnRleHREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1t0ZW1wbGF0ZUNvbnRleHRdJyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVmlld0NvbnRhaW5lclJlZl0pXG5dLCBUZW1wbGF0ZUNvbnRleHREaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEZvY3VzR3JvdXAgPSBjbGFzcyBGb2N1c0dyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnJvb3QucmVnaXN0ZXJHcm91cCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGZvY3VzYWJsZUNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maWx0ZXIoZWwgPT4gZWwuY2FuRm9jdXMoKSk7XG4gICAgfVxuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yb290LnVucmVnaXN0ZXJHcm91cCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcihmID0+IGYgIT09IGVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiB2YWx1ZSB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIGdyb3VwIHdpbGwgcmVjZWl2ZSBmb2N1cyB3aGVuIHRoZSBjZWxsIGlzIGZvY3VzZWQuXG4gICAgICogUmVxdWlyZXMgYSBzaW5nbGUgXCJzaW1wbGVcIiBmb2N1c2FibGUgZWxlbWVudCBzdWNoIGFzIGEgYnV0dG9uIG9yIGEgY2hlY2tib3guXG4gICAgICovXG4gICAgaXNOYXZpZ2FibGUoKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlQ2hpbGRyZW47XG4gICAgICAgIHJldHVybiBmb2N1c2FibGUubGVuZ3RoID09PSAxICYmIGZvY3VzYWJsZVswXS5pc05hdmlnYWJsZSgpO1xuICAgIH1cbiAgICBjYW5Gb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNhYmxlQ2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkZvY3VzKCkgJiYgIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2FibGVDaGlsZHJlblswXS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVN0YXRlKHRydWUpO1xuICAgIH1cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVN0YXRlKGZhbHNlKTtcbiAgICB9XG4gICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZSgoZm9jdXNlZCwgZWxlbWVudCkgPT4gZm9jdXNlZCB8fCBlbGVtZW50Lmhhc0ZvY3VzKCksIGZhbHNlKTtcbiAgICB9XG4gICAgdG9nZ2xlU3RhdGUoYWN0aXZlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSAhPT0gYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmID0+IGYudG9nZ2xlKGFjdGl2ZSkpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkZvY3VzR3JvdXAgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGb2N1c1Jvb3RdKVxuXSwgRm9jdXNHcm91cCk7XG5cbmxldCBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gICAgcmV0dXJuIGlkKys7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IExvZ2ljYWxDZWxsRGlyZWN0aXZlID0gY2xhc3MgTG9naWNhbENlbGxEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGZvY3VzR3JvdXAsIGVsZW1lbnQsIGNvbHVtbkluZm9TZXJ2aWNlLCBpZFNlcnZpY2UsIG5hdmlnYXRpb25TZXJ2aWNlLCByZW5kZXJlciwgem9uZSwgY2VsbENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5mb2N1c0dyb3VwID0gZm9jdXNHcm91cDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZSA9IGNvbHVtbkluZm9TZXJ2aWNlO1xuICAgICAgICB0aGlzLmlkU2VydmljZSA9IGlkU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuY2VsbENvbnRleHQgPSBjZWxsQ29udGV4dDtcbiAgICAgICAgdGhpcy5sb2dpY2FsU2xhdmVDZWxsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29sU3BhbiA9IDE7XG4gICAgICAgIHRoaXMucm93U3BhbiA9IDE7XG4gICAgICAgIHRoaXMuZGF0YVJvd0luZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuZGV0YWlsRXhwYW5kQ2VsbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVpZCA9IG5leHRJZCgpO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2dpY2FsU2xhdmVDZWxsICYmIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkU2VydmljZS5jZWxsSWQodGhpcy5sb2dpY2FsUm93SW5kZXgsIHRoaXMubG9naWNhbENvbEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYXJpYUNvbEluZGV4KCkge1xuICAgICAgICBpZiAodGhpcy5sb2dpY2FsU2xhdmVDZWxsIHx8IHRoaXMubG9naWNhbENvbEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2dpY2FsQ29sSW5kZXggKyAxO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25DaGFuZ2UgPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKChlKSA9PiB0aGlzLm9uTmF2aWdhdGlvbkNoYW5nZShlKSk7XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVuYWJsZWQgfHwgdGhpcy5sb2dpY2FsQ29sSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2VsbENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbENvbnRleHQuZm9jdXNHcm91cCA9IHRoaXMuZm9jdXNHcm91cDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyTm9DaGFuZ2VzKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG4gICAgICAgIGlmICgoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ2dyb3VwSXRlbScpIHx8IHRoaXMubG9naWNhbENvbEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGdyb3VwSXRlbSBjaGFuZ2VzIGFzIHRoZSByZWZlcmVuY2UgaXMgbm90IHN0YWJsZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4Q2hhbmdlID0gY2hhbmdlcy5sb2dpY2FsQ29sSW5kZXg7XG4gICAgICAgIGNvbnN0IHJvd0luZGV4Q2hhbmdlID0gY2hhbmdlcy5sb2dpY2FsUm93SW5kZXg7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhDaGFuZ2UgJiYgIWluZGV4Q2hhbmdlLmlzRmlyc3RDaGFuZ2UoKSA/IGluZGV4Q2hhbmdlLnByZXZpb3VzVmFsdWUgOiB0aGlzLmxvZ2ljYWxDb2xJbmRleDtcbiAgICAgICAgY29uc3Qgcm93SW5kZXggPSByb3dJbmRleENoYW5nZSAmJiAhcm93SW5kZXhDaGFuZ2UuaXNGaXJzdENoYW5nZSgpID8gcm93SW5kZXhDaGFuZ2UucHJldmlvdXNWYWx1ZSA6IHRoaXMubG9naWNhbFJvd0luZGV4O1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnVucmVnaXN0ZXJDZWxsKGluZGV4LCByb3dJbmRleCwgdGhpcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uQ2hhbmdlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS51bnJlZ2lzdGVyQ2VsbCh0aGlzLmxvZ2ljYWxDb2xJbmRleCwgdGhpcy5sb2dpY2FsUm93SW5kZXgsIHRoaXMpO1xuICAgIH1cbiAgICBvbk5hdmlnYXRpb25DaGFuZ2UoZSkge1xuICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmxvZ2ljYWxDb2xJbmRleCA9PT0gZS5jb2xJbmRleCAmJiB0aGlzLmxvZ2ljYWxSb3dJbmRleCA9PT0gZS5yb3dJbmRleDtcbiAgICAgICAgY29uc3Qgd2FzQWN0aXZlID0gdGhpcy5sb2dpY2FsQ29sSW5kZXggPT09IGUucHJldkNvbEluZGV4ICYmIHRoaXMubG9naWNhbFJvd0luZGV4ID09PSBlLnByZXZSb3dJbmRleDtcbiAgICAgICAgaWYgKGFjdGl2ZSB8fCB3YXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKGVsLCAndGFiSW5kZXgnLCB0aGlzLmlzRm9jdXNhYmxlKCkgJiYgIXRoaXMubG9naWNhbFNsYXZlQ2VsbCA/ICcwJyA6ICctMScpO1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXNHcm91cC5pc05hdmlnYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0dyb3VwLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubG9naWNhbFNsYXZlQ2VsbCAmJiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmF1dG9Gb2N1c0NlbGwodGhpcy5sb2dpY2FsQ29sSW5kZXgsIHRoaXMubG9naWNhbENvbEluZGV4ICsgdGhpcy5jb2xTcGFuIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taWNyb3Rhc2soKCkgPT4gdGhpcy5pc0ZvY3VzZWQoKSAmJiBlbC5mb2N1cygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbCwgJ2stc3RhdGUtZm9jdXNlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyTGFiZWxUZXh0KSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbCwgJ2stc3RhdGUtZm9jdXNlZCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyTGFiZWxUZXh0KSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGhpcy5oZWFkZXJMYWJlbFRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1pY3JvdGFzayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oY2FsbGJhY2spKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDaGFuZ2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9naWNhbFNsYXZlQ2VsbCkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5yZWdpc3RlckNlbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJOb0NoYW5nZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2dpY2FsU2xhdmVDZWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnJlZ2lzdGVyQ2VsbE9uQ3VycmVudFJvdyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0ZvY3VzYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuaXNDZWxsRm9jdXNhYmxlKHRoaXMpO1xuICAgIH1cbiAgICBpc0ZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmlzQ2VsbEZvY3VzZWQodGhpcyk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIExvZ2ljYWxDZWxsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2dpY2FsQ29sSW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIExvZ2ljYWxDZWxsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2dpY2FsUm93SW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMb2dpY2FsQ2VsbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibG9naWNhbFNsYXZlQ2VsbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTG9naWNhbENlbGxEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbEluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMb2dpY2FsQ2VsbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29sU3BhblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTG9naWNhbENlbGxEaXJlY3RpdmUucHJvdG90eXBlLCBcInJvd1NwYW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExvZ2ljYWxDZWxsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJncm91cEl0ZW1cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIExvZ2ljYWxDZWxsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkYXRhUm93SW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExvZ2ljYWxDZWxsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkYXRhSXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExvZ2ljYWxDZWxsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkZXRhaWxFeHBhbmRDZWxsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMb2dpY2FsQ2VsbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaGVhZGVyTGFiZWxUZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5pZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIExvZ2ljYWxDZWxsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtY29saW5kZXgnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBMb2dpY2FsQ2VsbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXJpYUNvbEluZGV4XCIsIG51bGwpO1xuTG9naWNhbENlbGxEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRm9jdXNHcm91cCxcbiAgICAgICAgICAgICAgICBkZXBzOiBbRm9jdXNSb290XSxcbiAgICAgICAgICAgICAgICB1c2VDbGFzczogRm9jdXNHcm91cFxuICAgICAgICAgICAgfV0sXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZExvZ2ljYWxDZWxsXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDcsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDcsIEluamVjdChDRUxMX0NPTlRFWFQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ZvY3VzR3JvdXAsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIENvbHVtbkluZm9TZXJ2aWNlLFxuICAgICAgICBJZFNlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZSwgT2JqZWN0XSlcbl0sIExvZ2ljYWxDZWxsRGlyZWN0aXZlKTtcblxubGV0IGlkJDEgPSAwO1xuZnVuY3Rpb24gbmV4dElkJDEoKSB7XG4gICAgcmV0dXJuIGlkJDErKztcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTG9naWNhbFJvd0RpcmVjdGl2ZSA9IGNsYXNzIExvZ2ljYWxSb3dEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGlkU2VydmljZSwgbmF2aWdhdGlvbikge1xuICAgICAgICB0aGlzLmlkU2VydmljZSA9IGlkU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gbmF2aWdhdGlvbjtcbiAgICAgICAgdGhpcy5sb2dpY2FsU2xhdmVSb3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dpY2FsU2xhdmVDZWxsc0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5kYXRhUm93SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy51aWQgPSBuZXh0SWQkMSgpO1xuICAgIH1cbiAgICBnZXQgaG9zdFJvbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ2ljYWxTbGF2ZVJvdyA/ICdwcmVzZW50YXRpb24nIDogJ3Jvdyc7XG4gICAgfVxuICAgIGdldCBhcmlhUm93SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ2ljYWxSb3dJbmRleCArIDE7XG4gICAgfVxuICAgIGdldCBhcmlhT3ducygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hdmlnYXRpb24uZW5hYmxlZCB8fCB0aGlzLmxvZ2ljYWxTbGF2ZVJvdyB8fCB0aGlzLmxvZ2ljYWxTbGF2ZUNlbGxzQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRzID0gW107XG4gICAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy5sb2dpY2FsQ2VsbHNDb3VudCArIHRoaXMubG9naWNhbFNsYXZlQ2VsbHNDb3VudDtcbiAgICAgICAgZm9yIChsZXQgY2VsbEluZGV4ID0gdGhpcy5sb2dpY2FsQ2VsbHNDb3VudDsgY2VsbEluZGV4IDwgdG90YWw7IGNlbGxJbmRleCsrKSB7XG4gICAgICAgICAgICBpZHMucHVzaCh0aGlzLmlkU2VydmljZS5jZWxsSWQodGhpcy5sb2dpY2FsUm93SW5kZXgsIGNlbGxJbmRleCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHMuam9pbignICcpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXZpZ2F0aW9uLmVuYWJsZWQgfHwgdGhpcy5sb2dpY2FsU2xhdmVSb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleENoYW5nZSA9IGNoYW5nZXMubG9naWNhbFJvd0luZGV4O1xuICAgICAgICBjb25zdCBsb2dpY2FsU2xhdmVSb3dDaGFuZ2UgPSBjaGFuZ2VzLmxvZ2ljYWxTbGF2ZVJvdztcbiAgICAgICAgaWYgKGluZGV4Q2hhbmdlIHx8IGxvZ2ljYWxTbGF2ZVJvd0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpbmRleENoYW5nZSAmJiAhaW5kZXhDaGFuZ2UuaXNGaXJzdENoYW5nZSgpID8gaW5kZXhDaGFuZ2UucHJldmlvdXNWYWx1ZSA6IHRoaXMubG9naWNhbFJvd0luZGV4O1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLnVucmVnaXN0ZXJSb3coaW5kZXgsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLnJlZ2lzdGVyUm93KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFueUNoYW5nZWQoWydkYXRhUm93SW5kZXgnLCAnZGF0YUl0ZW0nXSwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi51cGRhdGVSb3codGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi51bnJlZ2lzdGVyUm93KHRoaXMubG9naWNhbFJvd0luZGV4LCB0aGlzKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTG9naWNhbFJvd0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwibG9naWNhbFJvd0luZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTG9naWNhbFJvd0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwibG9naWNhbFNsYXZlUm93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMb2dpY2FsUm93RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2dpY2FsQ2VsbHNDb3VudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTG9naWNhbFJvd0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwibG9naWNhbFNsYXZlQ2VsbHNDb3VudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTG9naWNhbFJvd0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGF0YVJvd0luZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMb2dpY2FsUm93RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkYXRhSXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIExvZ2ljYWxSb3dEaXJlY3RpdmUucHJvdG90eXBlLCBcImhvc3RSb2xlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1yb3dpbmRleCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIExvZ2ljYWxSb3dEaXJlY3RpdmUucHJvdG90eXBlLCBcImFyaWFSb3dJbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtb3ducycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIExvZ2ljYWxSb3dEaXJlY3RpdmUucHJvdG90eXBlLCBcImFyaWFPd25zXCIsIG51bGwpO1xuTG9naWNhbFJvd0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZExvZ2ljYWxSb3ddJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSWRTZXJ2aWNlLFxuICAgICAgICBOYXZpZ2F0aW9uU2VydmljZV0pXG5dLCBMb2dpY2FsUm93RGlyZWN0aXZlKTtcblxuY29uc3QgRk9STUFUX1JFR0VYID0gL1xce1xcZCs6Py87XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEZpZWxkQWNjZXNzb3JQaXBlID0gY2xhc3MgRmllbGRBY2Nlc3NvclBpcGUge1xuICAgIGNvbnN0cnVjdG9yKGludGxTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaW50bFNlcnZpY2UgPSBpbnRsU2VydmljZTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKGRhdGFJdGVtLCBmaWVsZE5hbWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoIWlzTnVsbE9yRW1wdHlTdHJpbmcoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIoZmllbGROYW1lKShkYXRhSXRlbSk7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yRW1wdHlTdHJpbmcoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFZhbHVlKGZvcm1hdCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhSXRlbTtcbiAgICB9XG4gICAgZm9ybWF0VmFsdWUoZm9ybWF0LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpbnRsID0gdGhpcy5pbnRsU2VydmljZTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGZvcm1hdCkgJiYgZm9ybWF0Lm1hdGNoKEZPUk1BVF9SRUdFWCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRsLmZvcm1hdChmb3JtYXQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50bC50b1N0cmluZyh2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG59O1xuRmllbGRBY2Nlc3NvclBpcGUgPSBfX2RlY29yYXRlKFtcbiAgICBQaXBlKHtcbiAgICAgICAgbmFtZTogJ3ZhbHVlT2YnLFxuICAgICAgICBwdXJlOiBmYWxzZVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgRmllbGRBY2Nlc3NvclBpcGUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY29sdW1uc1RvUmVzaXplID0gKHsgY29sdW1ucyB9KSA9PiBNYXRoLm1heCgxLCByZXNpemFibGVDb2x1bW5zKGNvbHVtbnMpLmxlbmd0aCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgcm93ID0gc2VsZWN0b3IgPT4gZWxlbWVudCA9PiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhlYWRlclJvdyA9IGluZGV4ID0+IGVsZW1lbnQgPT4gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCd0aGVhZD50cicpW2luZGV4XTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjZWxsID0gKGluZGV4LCBzZWxlY3RvciA9ICd0ZCcpID0+IGVsZW1lbnQgPT4gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAke3NlbGVjdG9yfTpub3QoLmstZ3JvdXAtY2VsbCk6bm90KC5rLWhpZXJhcmNoeS1jZWxsKWApW2luZGV4XTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBvZmZzZXRXaWR0aCA9IGVsZW1lbnQgPT4gZWxlbWVudC5vZmZzZXRXaWR0aDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwaXBlID0gKC4uLmZucykgPT4gZGF0YSA9PiBmbnMucmVkdWNlKChzdGF0ZSQkMSwgZm4pID0+IHN0YXRlJCQxID8gZm4oc3RhdGUkJDEpIDogMCwgZGF0YSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRhYmxlRGlyZWN0aXZlID0gY2xhc3MgVGFibGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHJlbmRlcmVyLCBzZXJ2aWNlLCB6b25lLCBjZHIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maXJzdFJlc2l6ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbWluV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0UmVzaXplID8gMCA6IG51bGw7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBjb25zdCBvYnMgPSB0aGlzLnNlcnZpY2VcbiAgICAgICAgICAgIC5jaGFuZ2VzLnBpcGUoZmlsdGVyKGUgPT4gdGhpcy5sb2NrZWQgPT09IGUubG9ja2VkKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gb2JzLnBpcGUoZmlsdGVyKGUgPT4gZS50eXBlID09PSAnc3RhcnQnKSwgdGFwKHRoaXMuaW5pdFN0YXRlLmJpbmQodGhpcykpLCBtYXAoY29sdW1uc1RvUmVzaXplKSwgc3dpdGNoTWFwKCh0YWtlJCQxKSA9PiBvYnMucGlwZShmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICdyZXNpemVUYWJsZScpLCBtYXAoZSA9PiBlLmRlbHRhKSwgYnVmZmVyQ291bnQodGFrZSQkMSkpKSkuc3Vic2NyaWJlKHRoaXMucmVzaXplLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmF1dG9GaXRTdWJzY3JpcHRpb24gPSB0aGlzLnNlcnZpY2VcbiAgICAgICAgICAgIC5yZWdpc3RlclRhYmxlKHtcbiAgICAgICAgICAgIGF1dG9GaXQ6IHRoaXMuYXV0b0ZpdE9ic2VydmFibGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGxvY2tlZDogdGhpcy5sb2NrZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0ZpdFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hdXRvRml0U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmF1dG9GaXRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5maXJzdFJlc2l6ZSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy52aXJ0dWFsQ29sdW1ucyB8fCB0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbFdpZHRoID0gb2Zmc2V0V2lkdGgodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZShkZWx0YXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpcnR1YWxDb2x1bW5zIHx8IHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGRlbHRhcy5yZWR1Y2UoKHN1bSwgaXRlbSkgPT4gc3VtICsgaXRlbSwgMCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMub3JpZ2luYWxXaWR0aCArIGRlbHRhO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3dpZHRoJywgd2lkdGggKyAncHgnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIGF1dG9GaXRPYnNlcnZhYmxlKGNvbHVtbkluZm8pIHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+IHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2stYXV0b2ZpdHRpbmcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGhzID0gY29sdW1uSW5mby5tYXAodGhpcy5tZWFzdXJlQ29sdW1uLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrLWF1dG9maXR0aW5nJyk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh3aWR0aHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtZWFzdXJlQ29sdW1uKGluZm8pIHtcbiAgICAgICAgY29uc3QgZG9tID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHBpcGUoaGVhZGVyUm93KGluZm8ubGV2ZWwpLCBjZWxsKGluZm8uaGVhZGVySW5kZXgsICd0aCcpLCBvZmZzZXRXaWR0aCkoZG9tKTtcbiAgICAgICAgbGV0IGRhdGEgPSAwO1xuICAgICAgICBpZiAoIWluZm8uaXNQYXJlbnRTcGFuIHx8IChpbmZvLmlzUGFyZW50U3BhbiAmJiBpbmZvLmlzTGFzdEluU3BhbikpIHtcbiAgICAgICAgICAgIGRhdGEgPSBwaXBlKHJvdygndGJvZHk+dHI6bm90KC5rLWdyb3VwaW5nLXJvdyk6bm90KC5rLWdyaWQtbm9yZWNvcmRzKScpLCBjZWxsKGluZm8uaW5kZXgpLCBvZmZzZXRXaWR0aCkoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb290ZXIgPSBwaXBlKHJvdygndGZvb3Q+dHInKSwgY2VsbChpbmZvLmluZGV4KSwgb2Zmc2V0V2lkdGgpKGRvbSk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChoZWFkZXIsIGRhdGEsIGZvb3Rlcik7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwibG9ja2VkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGFibGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInZpcnR1YWxDb2x1bW5zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUubWluLXdpZHRoJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGFibGVEaXJlY3RpdmUucHJvdG90eXBlLCBcIm1pbldpZHRoXCIsIG51bGwpO1xuVGFibGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ3RhYmxlJyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBDb2x1bW5SZXNpemluZ1NlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgVGFibGVEaXJlY3RpdmUpO1xuXG5jb25zdCBleHBvcnRlZE1vZHVsZXMgPSBbXG4gICAgQ29sdW1uQ29tcG9uZW50LFxuICAgIENvbHVtbkdyb3VwQ29tcG9uZW50LFxuICAgIExvZ2ljYWxDZWxsRGlyZWN0aXZlLFxuICAgIExvZ2ljYWxSb3dEaXJlY3RpdmUsXG4gICAgRm9jdXNhYmxlRGlyZWN0aXZlLFxuICAgIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIENvbEdyb3VwQ29tcG9uZW50LFxuICAgIFJlc2l6YWJsZUNvbnRhaW5lckRpcmVjdGl2ZSxcbiAgICBUZW1wbGF0ZUNvbnRleHREaXJlY3RpdmUsXG4gICAgRmllbGRBY2Nlc3NvclBpcGUsXG4gICAgRGV0YWlsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgU3BhbkNvbHVtbkNvbXBvbmVudCxcbiAgICBUYWJsZURpcmVjdGl2ZSxcbiAgICBMb2FkaW5nQ29tcG9uZW50XG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTaGFyZWRNb2R1bGUgPSBjbGFzcyBTaGFyZWRNb2R1bGUge1xuICAgIHN0YXRpYyBleHBvcnRzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgQ29sdW1uQ29tcG9uZW50LFxuICAgICAgICAgICAgU3BhbkNvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgICAgIENvbHVtbkdyb3VwQ29tcG9uZW50LFxuICAgICAgICAgICAgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBEZXRhaWxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIEZvY3VzYWJsZURpcmVjdGl2ZVxuICAgICAgICBdO1xuICAgIH1cbn07XG5TaGFyZWRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2V4cG9ydGVkTW9kdWxlc10sXG4gICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXMsIERyYWdnYWJsZU1vZHVsZSwgRXZlbnRzTW9kdWxlXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgU2hhcmVkTW9kdWxlKTtcblxudmFyIENvbnRhaW5zRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYENvbnRhaW5zYCAoKipDb250YWlucyoqKSBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmxldCBDb250YWluc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gQ29udGFpbnNGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xID0gY2xhc3MgQ29udGFpbnNGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiY29udGFpbnNcIiwgbG9jYWxpemF0aW9uKTsgfVxufTtcbkNvbnRhaW5zRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBDb250YWluc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29udGFpbnNGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1jb250YWlucy1vcGVyYXRvcicsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBDb250YWluc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50KTtcblxudmFyIERvZXNOb3RDb250YWluRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYERvZXNOb3RDb250YWluYCAoKipEb2VzIG5vdCBjb250YWluKiopIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xubGV0IERvZXNOb3RDb250YWluRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBEb2VzTm90Q29udGFpbkZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEgPSBjbGFzcyBEb2VzTm90Q29udGFpbkZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJkb2Vzbm90Y29udGFpblwiLCBsb2NhbGl6YXRpb24pOyB9XG59O1xuRG9lc05vdENvbnRhaW5GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCA9IERvZXNOb3RDb250YWluRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEb2VzTm90Q29udGFpbkZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmlsdGVyLW5vdC1jb250YWlucy1vcGVyYXRvcicsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBEb2VzTm90Q29udGFpbkZpbHRlck9wZXJhdG9yQ29tcG9uZW50KTtcblxudmFyIEVuZHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYEVuZHNXaXRoYCAoKipFbmRzIHdpdGgqKikgc3RyaW5nIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xubGV0IEVuZHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBFbmRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEgPSBjbGFzcyBFbmRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJlbmRzd2l0aFwiLCBsb2NhbGl6YXRpb24pOyB9XG59O1xuRW5kc1dpdGhGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCA9IEVuZHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBFbmRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmlsdGVyLWVuZHN3aXRoLW9wZXJhdG9yJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIEVuZHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnQpO1xuXG52YXIgRXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgRXF1YWxgICgqKklzIGVxdWFsIHRvKiopIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xubGV0IEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEgPSBjbGFzcyBFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJlcVwiLCBsb2NhbGl6YXRpb24pOyB9XG59O1xuRXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCA9IEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmlsdGVyLWVxLW9wZXJhdG9yJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQpO1xuXG52YXIgSXNFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzE7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGBJc0VtcHR5YCAoKipJcyBlbXB0eSoqKSBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmxldCBJc0VtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBJc0VtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIElzRW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiaXNlbXB0eVwiLCBsb2NhbGl6YXRpb24pOyB9XG59O1xuSXNFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gSXNFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSXNFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmlsdGVyLWlzZW1wdHktb3BlcmF0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgSXNFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50KTtcblxudmFyIElzTm90RW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgSXNOb3RFbXB0eWAgKCoqSXMgbm90IGVtcHR5KiopIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xubGV0IElzTm90RW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCA9IElzTm90RW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xID0gY2xhc3MgSXNOb3RFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJpc25vdGVtcHR5XCIsIGxvY2FsaXphdGlvbik7IH1cbn07XG5Jc05vdEVtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBJc05vdEVtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJc05vdEVtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItaXNub3RlbXB0eS1vcGVyYXRvcicsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBJc05vdEVtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnQpO1xuXG52YXIgSXNOb3ROdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYElzTm90TnVsbGAgKCoqSXMgbm90IG51bGwqKikgZmlsdGVyIG9wZXJhdG9yLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcywgcmVmZXIgdG86XG4gKiAqIFtTZXR0aW5nIHRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX2dyaWQgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX2dyaWQgJX0jdG9jLXNldHRpbmctdGhlLW9yZGVyLW9mLXRoZS1maWx0ZXItb3BlcmF0b3JzKVxuICovXG5sZXQgSXNOb3ROdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBJc05vdE51bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xID0gY2xhc3MgSXNOb3ROdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImlzbm90bnVsbFwiLCBsb2NhbGl6YXRpb24pOyB9XG59O1xuSXNOb3ROdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBJc05vdE51bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyT3BlcmF0b3JCYXNlLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElzTm90TnVsbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmlsdGVyLWlzbm90bnVsbC1vcGVyYXRvcicsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBJc05vdE51bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCk7XG5cbnZhciBJc051bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgSXNOdWxsYCAoKipJcyBudWxsKiopIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xubGV0IElzTnVsbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gSXNOdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIElzTnVsbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJpc251bGxcIiwgbG9jYWxpemF0aW9uKTsgfVxufTtcbklzTnVsbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gSXNOdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJc051bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1pc251bGwtb3BlcmF0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgSXNOdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQpO1xuXG52YXIgTm90RXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgTm90RXF1YWxgICgqKklzIG5vdCBlcXVhbCB0byoqKSBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmxldCBOb3RFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gTm90RXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xID0gY2xhc3MgTm90RXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwibmVxXCIsIGxvY2FsaXphdGlvbik7IH1cbn07XG5Ob3RFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gTm90RXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyT3BlcmF0b3JCYXNlLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5vdEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItbmVxLW9wZXJhdG9yJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIE5vdEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQpO1xuXG52YXIgU3RhcnRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzE7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGBTdGFydHNXaXRoYCAoKipTdGFydHMgd2l0aCoqKSBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmxldCBTdGFydHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBTdGFydHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIFN0YXJ0c1dpdGhGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwic3RhcnRzd2l0aFwiLCBsb2NhbGl6YXRpb24pOyB9XG59O1xuU3RhcnRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gU3RhcnRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU3RhcnRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmlsdGVyLXN0YXJ0c3dpdGgtb3BlcmF0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgU3RhcnRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50KTtcblxudmFyIEdyZWF0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xO1xuLypcbiAqIFJlcHJlc2VudHMgdGhlIGBHcmVhdGVyYCAoKipJcyBncmVhdGVyIHRoYW4qKikgbnVtZXJpYyBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmxldCBHcmVhdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBHcmVhdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIEdyZWF0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiZ3RcIiwgbG9jYWxpemF0aW9uKTsgfVxufTtcbkdyZWF0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCA9IEdyZWF0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyT3BlcmF0b3JCYXNlLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEdyZWF0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1ndC1vcGVyYXRvcicsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBHcmVhdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnQpO1xuXG52YXIgR3JlYXRlck9yRXF1YWxUb0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzE7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGBHcmVhdGVyT3JFcXVhbFRvYCAoKipJcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8qKikgbnVtZXJpYyBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmxldCBHcmVhdGVyT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBHcmVhdGVyT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIEdyZWF0ZXJPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiZ3RlXCIsIGxvY2FsaXphdGlvbik7IH1cbn07XG5HcmVhdGVyT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBHcmVhdGVyT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBHcmVhdGVyT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItZ3RlLW9wZXJhdG9yJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIEdyZWF0ZXJPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCk7XG5cbnZhciBMZXNzRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMTtcbi8qXG4gKiBSZXByZXNlbnRzIHRoZSBgTGVzc2AgKCoqSXMgbGVzcyB0aGFuKiopIG51bWVyaWMgZmlsdGVyIG9wZXJhdG9yLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcywgcmVmZXIgdG86XG4gKiAqIFtTZXR0aW5nIHRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX2dyaWQgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX2dyaWQgJX0jdG9jLXNldHRpbmctdGhlLW9yZGVyLW9mLXRoZS1maWx0ZXItb3BlcmF0b3JzKVxuICovXG5sZXQgTGVzc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gTGVzc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEgPSBjbGFzcyBMZXNzRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImx0XCIsIGxvY2FsaXphdGlvbik7IH1cbn07XG5MZXNzRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBMZXNzRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMZXNzRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItbHQtb3BlcmF0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgTGVzc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50KTtcblxudmFyIExlc3NPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xO1xuLypcbiAqIFJlcHJlc2VudHMgdGhlIGBMZXNzT3JFcXVhbFRvYCAoKipJcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8qKikgbnVtZXJpYyBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmxldCBMZXNzT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBMZXNzT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIExlc3NPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwibHRlXCIsIGxvY2FsaXphdGlvbik7IH1cbn07XG5MZXNzT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBMZXNzT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMZXNzT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItbHRlLW9wZXJhdG9yJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIExlc3NPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCk7XG5cbnZhciBBZnRlckZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzE7XG4vKlxuICogUmVwcmVzZW50cyB0aGUgYEdyZWF0ZXJgICgqKklzIGFmdGVyKiopIGRhdGUgZmlsdGVyIG9wZXJhdG9yLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcywgcmVmZXIgdG86XG4gKiAqIFtTZXR0aW5nIHRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX2dyaWQgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX2dyaWQgJX0jdG9jLXNldHRpbmctdGhlLW9yZGVyLW9mLXRoZS1maWx0ZXItb3BlcmF0b3JzKVxuICovXG5sZXQgQWZ0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCA9IEFmdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIEFmdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImFmdGVyXCIsIGxvY2FsaXphdGlvbik7IH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IFwiZ3RcIlxuICAgICAgICB9O1xuICAgIH1cbn07XG5BZnRlckZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gQWZ0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyT3BlcmF0b3JCYXNlLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEFmdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItYWZ0ZXItb3BlcmF0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgQWZ0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCk7XG5cbnZhciBBZnRlckVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMTtcbi8qXG4gKiBSZXByZXNlbnRzIHRoZSBgR3JlYXRlck9yRXF1YWxUb2AgKCoqSXMgYWZ0ZXIgb3IgZXF1YWwgdG8qKikgZGF0ZSBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfZ3JpZCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmxldCBBZnRlckVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBBZnRlckVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIEFmdGVyRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiYWZ0ZXItZXFcIiwgbG9jYWxpemF0aW9uKTsgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogXCJndGVcIlxuICAgICAgICB9O1xuICAgIH1cbn07XG5BZnRlckVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBBZnRlckVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBBZnRlckVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItYWZ0ZXItZXEtb3BlcmF0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgQWZ0ZXJFcUZpbHRlck9wZXJhdG9yQ29tcG9uZW50KTtcblxudmFyIEJlZm9yZUVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMTtcbi8qXG4gKiBSZXByZXNlbnRzIHRoZSBgTGVzc09yRXF1YWxUb2AgKCoqSXMgYmVmb3JlIG9yIGVxdWFsIHRvKiopIGRhdGUgZmlsdGVyIG9wZXJhdG9yLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcywgcmVmZXIgdG86XG4gKiAqIFtTZXR0aW5nIHRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX2dyaWQgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX2dyaWQgJX0jdG9jLXNldHRpbmctdGhlLW9yZGVyLW9mLXRoZS1maWx0ZXItb3BlcmF0b3JzKVxuICovXG5sZXQgQmVmb3JlRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCA9IEJlZm9yZUVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIEJlZm9yZUVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImJlZm9yZS1lcVwiLCBsb2NhbGl6YXRpb24pOyB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiBcImx0ZVwiXG4gICAgICAgIH07XG4gICAgfVxufTtcbkJlZm9yZUVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgPSBCZWZvcmVFcUZpbHRlck9wZXJhdG9yQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQmVmb3JlRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1iZWZvcmUtZXEtb3BlcmF0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgQmVmb3JlRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCk7XG5cbnZhciBCZWZvcmVGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xO1xuLypcbiAqIFJlcHJlc2VudHMgdGhlIGBMZXNzIHRoZW5gICgqKklzIGJlZm9yZSoqKSBkYXRlIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xubGV0IEJlZm9yZUZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gQmVmb3JlRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IGNsYXNzIEJlZm9yZUZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJiZWZvcmVcIiwgbG9jYWxpemF0aW9uKTsgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogXCJsdFwiXG4gICAgICAgIH07XG4gICAgfVxufTtcbkJlZm9yZUZpbHRlck9wZXJhdG9yQ29tcG9uZW50ID0gQmVmb3JlRmlsdGVyT3BlcmF0b3JDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBCZWZvcmVGaWx0ZXJPcGVyYXRvckNvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1iZWZvcmUtb3BlcmF0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgQmVmb3JlRmlsdGVyT3BlcmF0b3JDb21wb25lbnQpO1xuXG5jb25zdCBGSUxURVJfT1BFUkFUT1JTID0gW1xuICAgIEZpbHRlckNlbGxPcGVyYXRvcnNDb21wb25lbnQsXG4gICAgQ29udGFpbnNGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBEb2VzTm90Q29udGFpbkZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIEVuZHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsXG4gICAgRXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBJc0VtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnQsXG4gICAgSXNOb3RFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIElzTm90TnVsbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIElzTnVsbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIE5vdEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsXG4gICAgU3RhcnRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIEdyZWF0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBHcmVhdGVyT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsXG4gICAgTGVzc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIExlc3NPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBBZnRlckZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIEFmdGVyRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBCZWZvcmVFcUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIEJlZm9yZUZpbHRlck9wZXJhdG9yQ29tcG9uZW50XG5dO1xuY29uc3QgaW1wb3J0ZWRNb2R1bGVzID0gW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgIEZvcm1zTW9kdWxlLFxuICAgIERyb3BEb3duTGlzdE1vZHVsZSxcbiAgICBBdXRvQ29tcGxldGVNb2R1bGUsXG4gICAgSW5wdXRzTW9kdWxlLFxuICAgIERhdGVQaWNrZXJNb2R1bGUsXG4gICAgUG9wdXBNb2R1bGUsXG4gICAgU2hhcmVkTW9kdWxlXG5dO1xuY29uc3QgQ09NUE9ORU5UUyA9IFtcbiAgICBGaWx0ZXJJbnB1dERpcmVjdGl2ZVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2hhcmVkRmlsdGVyTW9kdWxlID0gY2xhc3MgU2hhcmVkRmlsdGVyTW9kdWxlIHtcbiAgICBzdGF0aWMgZXhwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLkZJTFRFUl9PUEVSQVRPUlNcbiAgICAgICAgXTtcbiAgICB9XG59O1xuU2hhcmVkRmlsdGVyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtGSUxURVJfT1BFUkFUT1JTLCBDT01QT05FTlRTXSxcbiAgICAgICAgZXhwb3J0czogW0ZJTFRFUl9PUEVSQVRPUlMsIGltcG9ydGVkTW9kdWxlcywgQ09NUE9ORU5UU10sXG4gICAgICAgIGltcG9ydHM6IFsuLi5pbXBvcnRlZE1vZHVsZXNdXG4gICAgfSlcbl0sIFNoYXJlZEZpbHRlck1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBGaWx0ZXJIb3N0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0LCByZXNvbHZlcikge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IHRoaXMuaG9zdC5jcmVhdGVDb21wb25lbnQodGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSh0aGlzLmNvbXBvbmVudFR5cGUoKSkpO1xuICAgICAgICB0aGlzLmluaXRDb21wb25lbnQoe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFtcImNvbHVtblwiLCBcImZpbHRlclwiXSwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0Q29tcG9uZW50KHsgY29sdW1uLCBmaWx0ZXI6IGZpbHRlciQkMSB9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5jb21wb25lbnQuaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgaW5zdGFuY2UuZmlsdGVyID0gZmlsdGVyJCQxO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENvbHVtbkNvbXBvbmVudClcbl0sIEZpbHRlckhvc3REaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbHVtblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRmlsdGVySG9zdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqID4gTGlzdCB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHMgaW4gdGhlIEdyaWRNb2R1bGUgYXMgYGVudHJ5Q29tcG9uZW50c2AuXG4gKi9cbmNvbnN0IGZpbHRlckNvbXBvbmVudEZhY3RvcnkgPSAodHlwZSkgPT4gKHtcbiAgICBcImJvb2xlYW5cIjogQm9vbGVhbkZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgXCJkYXRlXCI6IERhdGVGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgIFwibnVtZXJpY1wiOiBOdW1lcmljRmlsdGVyQ2VsbENvbXBvbmVudCxcbiAgICBcInRleHRcIjogU3RyaW5nRmlsdGVyQ2VsbENvbXBvbmVudFxufVt0eXBlXSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRmlsdGVyQ2VsbEhvc3REaXJlY3RpdmUgPSBjbGFzcyBGaWx0ZXJDZWxsSG9zdERpcmVjdGl2ZSBleHRlbmRzIEZpbHRlckhvc3REaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIHJlc29sdmVyKSB7XG4gICAgICAgIHN1cGVyKGhvc3QsIHJlc29sdmVyKTtcbiAgICB9XG4gICAgY29tcG9uZW50VHlwZSgpIHtcbiAgICAgICAgaWYgKCFpc051bGxPckVtcHR5U3RyaW5nKHRoaXMuY29sdW1uLmZpbHRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJDb21wb25lbnRGYWN0b3J5KHRoaXMuY29sdW1uLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZ0ZpbHRlckNlbGxDb21wb25lbnQ7XG4gICAgfVxufTtcbkZpbHRlckNlbGxIb3N0RGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9GaWx0ZXJDZWxsSG9zdF0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJdKVxuXSwgRmlsdGVyQ2VsbEhvc3REaXJlY3RpdmUpO1xuXG5jb25zdCBJTlRFUk5BTF9DT01QT05FTlRTID0gW1xuICAgIEZpbHRlclJvd0NvbXBvbmVudCxcbiAgICBGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgIEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBTdHJpbmdGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgIE51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgIEF1dG9Db21wbGV0ZUZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgQm9vbGVhbkZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgRmlsdGVyQ2VsbEhvc3REaXJlY3RpdmUsXG4gICAgRmlsdGVyQ2VsbFdyYXBwZXJDb21wb25lbnQsXG4gICAgRGF0ZUZpbHRlckNlbGxDb21wb25lbnRcbl07XG5jb25zdCBFTlRSWV9DT01QT05FTlRTID0gW1xuICAgIFN0cmluZ0ZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgTnVtZXJpY0ZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgQm9vbGVhbkZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgRGF0ZUZpbHRlckNlbGxDb21wb25lbnRcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFJvd0ZpbHRlck1vZHVsZSA9IGNsYXNzIFJvd0ZpbHRlck1vZHVsZSB7XG4gICAgc3RhdGljIGV4cG9ydHMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBGaWx0ZXJSb3dDb21wb25lbnQsXG4gICAgICAgICAgICBGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgICAgICAgICAgRmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgRmlsdGVyQ2VsbE9wZXJhdG9yc0NvbXBvbmVudCxcbiAgICAgICAgICAgIFN0cmluZ0ZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgICAgICAgICBOdW1lcmljRmlsdGVyQ2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgIEF1dG9Db21wbGV0ZUZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgICAgICAgICBCb29sZWFuRmlsdGVyQ2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgIERhdGVGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgICAgICAgICAgU2hhcmVkRmlsdGVyTW9kdWxlLmV4cG9ydHMoKVxuICAgICAgICBdO1xuICAgIH1cbn07XG5Sb3dGaWx0ZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0lOVEVSTkFMX0NPTVBPTkVOVFNdLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IEVOVFJZX0NPTVBPTkVOVFMsXG4gICAgICAgIGV4cG9ydHM6IFtJTlRFUk5BTF9DT01QT05FTlRTLCBTaGFyZWRGaWx0ZXJNb2R1bGVdLFxuICAgICAgICBpbXBvcnRzOiBbU2hhcmVkRmlsdGVyTW9kdWxlXVxuICAgIH0pXG5dLCBSb3dGaWx0ZXJNb2R1bGUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFBhZ2VySW5wdXREaXJlY3RpdmUgPSBjbGFzcyBQYWdlcklucHV0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0LCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgY29uc3QgaW5wdXRFbGVtZW50ID0gdGhpcy5ob3N0Lm51bWVyaWNJbnB1dC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGlucHV0RWxlbWVudCwgJ2stcGFnZXItbmF2Jyk7XG4gICAgfVxufTtcblBhZ2VySW5wdXREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1trZW5kb0dyaWRQYWdlcklucHV0XScgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1lcmljVGV4dEJveENvbXBvbmVudCxcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIFBhZ2VySW5wdXREaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFBhZ2VyRHJvcERvd25MaXN0RGlyZWN0aXZlID0gY2xhc3MgUGFnZXJEcm9wRG93bkxpc3REaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5rZXlkb3duSGFuZGxlciA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLZXlzLkVzY2FwZSAmJiB0aGlzLmhvc3QuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3QudG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyRWxlbWVudCA9IHRoaXMuaG9zdC53cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyLCB0cnVlKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaG9zdC53cmFwcGVyLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIpO1xuICAgIH1cbn07XG5QYWdlckRyb3BEb3duTGlzdERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2tlbmRvR3JpZFBhZ2VyRHJvcERvd25dJyB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Ryb3BEb3duTGlzdENvbXBvbmVudF0pXG5dLCBQYWdlckRyb3BEb3duTGlzdERpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3JtYWxpemVTZXR0aW5ncyA9ICh7IGJ1dHRvbkNvdW50ID0gMTAsIGluZm8gPSB0cnVlLCB0eXBlID0gJ251bWVyaWMnLCBwYWdlU2l6ZXMgPSBmYWxzZSwgcHJldmlvdXNOZXh0ID0gdHJ1ZSwgcmVzcG9uc2l2ZSA9IHRydWUsIHBvc2l0aW9uID0gJ2JvdHRvbScgfSkgPT4gKHtcbiAgICBidXR0b25Db3VudCxcbiAgICBpbmZvLFxuICAgIHBhZ2VTaXplczogcGFnZVNpemVzID09PSB0cnVlID8gWzUsIDEwLCAyMF0gOiBwYWdlU2l6ZXMsXG4gICAgcHJldmlvdXNOZXh0LFxuICAgIHR5cGUsXG4gICAgcmVzcG9uc2l2ZSxcbiAgICBwb3NpdGlvblxufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9ybWFsaXplID0gKHNldHRpbmdzKSA9PiBub3JtYWxpemVTZXR0aW5ncyhzZXR0aW5ncyA9PT0gdHJ1ZSA/IHt9IDogc2V0dGluZ3MpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFBhZ2VyQ29tcG9uZW50ID0gY2xhc3MgUGFnZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHBhZ2VyQ29udGV4dCwgbmF2aWdhdGlvblNlcnZpY2UsIGVsZW1lbnQsIHJlbmRlcmVyLCB6b25lLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBjZWxsQ29udGV4dCwgZm9jdXNSb290LCBmb2N1c0dyb3VwKSB7XG4gICAgICAgIHRoaXMucGFnZXJDb250ZXh0ID0gcGFnZXJDb250ZXh0O1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlID0gbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jZWxsQ29udGV4dCA9IGNlbGxDb250ZXh0O1xuICAgICAgICB0aGlzLmZvY3VzUm9vdCA9IGZvY3VzUm9vdDtcbiAgICAgICAgdGhpcy5mb2N1c0dyb3VwID0gZm9jdXNHcm91cDtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgICAgIHRoaXMuc2tpcCA9IDE7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5wYWdlcldyYXBDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuZ3JpZFBhZ2VyQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gbm9ybWFsaXplKHt9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbnRleHQgPSB7fTtcbiAgICAgICAgdGhpcy5faXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLnRlbXBsYXRlIHx8ICFlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgUkVTUE9OU0lWRV9CUkVBS1BPSU5UX01FRElVTSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2stcGFnZXItbWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLXBhZ2VyLXNtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3aWR0aCA+PSBSRVNQT05TSVZFX0JSRUFLUE9JTlRfTUVESVVNICYmIHdpZHRoIDwgUkVTUE9OU0lWRV9CUkVBS1BPSU5UX0xBUkdFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50LCAnay1wYWdlci1tZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2stcGFnZXItc20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSZXNwb25zaXZlQ2xhc3NlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXQgb3B0aW9ucyh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gbm9ybWFsaXplKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRm9jdXNlZDtcbiAgICB9XG4gICAgZ2V0IHBhZ2VyQXJpYUxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5lbmFibGVkID8gdGhpcy5wYWdlckxhYmVsIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHBhZ2VyTGFiZWwoKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsaXphdGlvbk1zZyA9IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ3BhZ2VyTGFiZWwnKSB8fCAnJztcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VNZXNzYWdlUGxhY2Vob2xkZXIocmVwbGFjZU1lc3NhZ2VQbGFjZWhvbGRlcihsb2NhbGl6YXRpb25Nc2csICdjdXJyZW50UGFnZScsIHRoaXMuY3VycmVudFBhZ2UudG9TdHJpbmcoKSksICd0b3RhbFBhZ2VzJywgdGhpcy50b3RhbFBhZ2VzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBnZXQgZm9jdXNUcmFwVGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzR3JvdXAuaXNBY3RpdmUgPyAnMCcgOiAnLTEnO1xuICAgIH1cbiAgICBvbkZvY3VzSW4oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkRm9jdXNQYWdlciA9IGV2ZW50LnRhcmdldCA9PT0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRm9jdXNQYWdlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c1Jvb3QuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c1Jvb3QuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkZvY3VzT3V0KCkge1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkVzY2FwZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1Jvb3QuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkVudGVyKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVuYWJsZWQgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1Jvb3QuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNGaXJzdEVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuYXZpZ2F0ZVRvUHJldmlvdXNQYWdlKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkVHJpZ2dlclBhZ2VDaGFuZ2UoZS50YXJnZXQsIHRoaXMuY3VycmVudFBhZ2UgPiAxKSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlckNvbnRleHQucHJldlBhZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuYXZpZ2F0ZVRvTmV4dFBhZ2UoZSkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRUcmlnZ2VyUGFnZUNoYW5nZShlLnRhcmdldCwgdGhpcy5jdXJyZW50UGFnZSA8IHRoaXMudG90YWxQYWdlcykpIHtcbiAgICAgICAgICAgIHRoaXMucGFnZXJDb250ZXh0Lm5leHRQYWdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmF2aWdhdGVUb0ZpcnN0UGFnZShlKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFRyaWdnZXJQYWdlQ2hhbmdlKGUudGFyZ2V0LCB0aGlzLmN1cnJlbnRQYWdlID4gMSkpIHtcbiAgICAgICAgICAgIHRoaXMucGFnZXJDb250ZXh0LmNoYW5nZVBhZ2UoMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmF2aWdhdGVUb0xhc3RQYWdlKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkVHJpZ2dlclBhZ2VDaGFuZ2UoZS50YXJnZXQsIHRoaXMuY3VycmVudFBhZ2UgPCB0aGlzLnRvdGFsUGFnZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2VyQ29udGV4dC5jaGFuZ2VQYWdlKHRoaXMudG90YWxQYWdlcyAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0b3RhbFBhZ2VzKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKCh0aGlzLnRvdGFsIHx8IDApIC8gdGhpcy5wYWdlU2l6ZSk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50UGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHRoaXMuc2tpcCB8fCAwKSAvIHRoaXMucGFnZVNpemUpICsgMTtcbiAgICB9XG4gICAgZ2V0IHRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX3RlbXBsYXRlQ29udGV4dDtcbiAgICAgICAgY29udGV4dC50b3RhbFBhZ2VzID0gdGhpcy50b3RhbFBhZ2VzO1xuICAgICAgICBjb250ZXh0LnRvdGFsID0gdGhpcy50b3RhbDtcbiAgICAgICAgY29udGV4dC5za2lwID0gdGhpcy5za2lwO1xuICAgICAgICBjb250ZXh0LnBhZ2VTaXplID0gdGhpcy5wYWdlU2l6ZTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnBhZ2VyQ29udGV4dC5wYWdlQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmNoYW5nZVBhZ2UuYmluZCh0aGlzKSkpO1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzUm9vdC5kZWFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNlbGxDb250ZXh0KCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWydwYWdlU2l6ZScsICdza2lwJywgJ3RvdGFsJ10sIGNoYW5nZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlckNvbnRleHQubm90aWZ5Q2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgICAgICAgc2tpcDogdGhpcy5za2lwLFxuICAgICAgICAgICAgICAgIHRvdGFsOiB0aGlzLnRvdGFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgY2hhbmdlcy50ZW1wbGF0ZS5jdXJyZW50VmFsdWUgPyB0aGlzLmNsZWFyUmVzcG9uc2l2ZUNsYXNzZXMoKSA6IHRoaXMucmVzaXplSGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZSA/IHRoaXMucmVzaXplSGFuZGxlcigpIDogdGhpcy5jbGVhclJlc3BvbnNpdmVDbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVBhZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH1cbiAgICBvbklubmVyRm9jdXNJbihldmVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy56b25lLm9uU3RhYmxlLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ID09PSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzRmlyc3RFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzTGFzdEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzRmlyc3RFbGVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhclJlc3BvbnNpdmVDbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2stcGFnZXItc20nKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCAnay1wYWdlci1tZCcpO1xuICAgIH1cbiAgICBzaG91bGRUcmlnZ2VyUGFnZUNoYW5nZSh0YXJnZXQsIGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5lbmFibGVkICYmXG4gICAgICAgICAgICB0YXJnZXQgPT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50ICYmXG4gICAgICAgICAgICBjb25kaXRpb247XG4gICAgfVxuICAgIGZvY3VzRmlyc3RFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBmaXJzdCA9IGZpbmRGb2N1c2FibGVDaGlsZCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgZmlyc3QuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c0xhc3RFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gZmluZExhc3RGb2N1c2FibGVDaGlsZCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBsYXN0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ2VsbENvbnRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxDb250ZXh0LmZvY3VzR3JvdXAgPSB0aGlzLmZvY3VzR3JvdXA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUGFnZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRvdGFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBQYWdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2tpcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUGFnZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBhZ2VTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIFBhZ2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUGFnZXJUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIFBhZ2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFBhZ2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWdlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1wYWdlci13cmFwJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQYWdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicGFnZXJXcmFwQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWdyaWQtcGFnZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFBhZ2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmlkUGFnZXJDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc3RhdGUtZm9jdXNlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQYWdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNGb2N1c2VkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1sYWJlbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFBhZ2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWdlckFyaWFMYWJlbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcignZm9jdXNpbicsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgUGFnZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRm9jdXNJblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcignZm9jdXNvdXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFBhZ2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkZvY3VzT3V0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdrZXlkb3duLmVzY2FwZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgUGFnZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRXNjYXBlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdrZXlkb3duLmVudGVyJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBQYWdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib25FbnRlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcigna2V5ZG93bi5hcnJvd2xlZnQnLCBbJyRldmVudCddKSxcbiAgICBIb3N0TGlzdGVuZXIoJ2tleWRvd24ucGFnZXVwJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBQYWdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibmF2aWdhdGVUb1ByZXZpb3VzUGFnZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcigna2V5ZG93bi5hcnJvd3JpZ2h0JywgWyckZXZlbnQnXSksXG4gICAgSG9zdExpc3RlbmVyKCdrZXlkb3duLnBhZ2Vkb3duJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBQYWdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibmF2aWdhdGVUb05leHRQYWdlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdrZXlkb3duLmhvbWUnLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFBhZ2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0ZVRvRmlyc3RQYWdlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdrZXlkb3duLmVuZCcsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgUGFnZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYXRlVG9MYXN0UGFnZVwiLCBudWxsKTtcblBhZ2VyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1wYWdlcicsXG4gICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBGT0NVU19ST09UX0FDVElWRSxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZvY3VzUm9vdCxcbiAgICAgICAgICAgICAgICBkZXBzOiBbRk9DVVNfUk9PVF9BQ1RJVkVdLFxuICAgICAgICAgICAgICAgIHVzZUNsYXNzOiBGb2N1c1Jvb3RcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBGb2N1c0dyb3VwLFxuICAgICAgICAgICAgICAgIGRlcHM6IFtGb2N1c1Jvb3RdLFxuICAgICAgICAgICAgICAgIHVzZUNsYXNzOiBGb2N1c0dyb3VwXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgKm5nSWY9XCJuYXZpZ2F0aW9uU2VydmljZS5lbmFibGVkXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay1zci1vbmx5XCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCJmb2N1c1RyYXBUYWJJbmRleFwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWhpZGRlbl09XCJ0cnVlXCJcbiAgICAgICAgICAgIChmb2N1c2luKT1cIm9uSW5uZXJGb2N1c0luKCRldmVudCwgJ3N0YXJ0JylcIj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ0lmPVwidGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlLnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ0ZW1wbGF0ZUNvbnRleHRcIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhdGVtcGxhdGU/LnRlbXBsYXRlUmVmXCI+XG4gICAgICAgICAgICA8a2VuZG8tcGFnZXItcHJldi1idXR0b25zICpuZ0lmPVwic2V0dGluZ3MucHJldmlvdXNOZXh0XCI+PC9rZW5kby1wYWdlci1wcmV2LWJ1dHRvbnM+XG4gICAgICAgICAgICA8a2VuZG8tcGFnZXItbnVtZXJpYy1idXR0b25zXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJzZXR0aW5ncy50eXBlID09PSAnbnVtZXJpYydcIlxuICAgICAgICAgICAgICAgIFtidXR0b25Db3VudF09XCJzZXR0aW5ncy5idXR0b25Db3VudFwiPlxuICAgICAgICAgICAgPC9rZW5kby1wYWdlci1udW1lcmljLWJ1dHRvbnM+XG4gICAgICAgICAgICA8a2VuZG8tcGFnZXItaW5wdXQgKm5nSWY9XCJzZXR0aW5ncy50eXBlID09PSAnaW5wdXQnXCI+PC9rZW5kby1wYWdlci1pbnB1dD5cbiAgICAgICAgICAgIDxrZW5kby1wYWdlci1uZXh0LWJ1dHRvbnMgKm5nSWY9XCJzZXR0aW5ncy5wcmV2aW91c05leHRcIj48L2tlbmRvLXBhZ2VyLW5leHQtYnV0dG9ucz5cbiAgICAgICAgICAgIDxrZW5kby1wYWdlci1pbmZvICpuZ0lmPSdzZXR0aW5ncy5pbmZvJz48L2tlbmRvLXBhZ2VyLWluZm8+XG4gICAgICAgICAgICA8a2VuZG8tcGFnZXItcGFnZS1zaXplc1xuICAgICAgICAgICAgICAgICpuZ0lmPVwic2V0dGluZ3MucGFnZVNpemVzXCJcbiAgICAgICAgICAgICAgICBbcGFnZVNpemVzXT1cInNldHRpbmdzLnBhZ2VTaXplc1wiXG4gICAgICAgICAgICAgICAgI3BhZ2VTaXplc1xuICAgICAgICAgICAgPjwva2VuZG8tcGFnZXItcGFnZS1zaXplcz5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgICpuZ0lmPVwibmF2aWdhdGlvblNlcnZpY2UuZW5hYmxlZFwiXG4gICAgICAgICAgICBjbGFzcz1cImstc3Itb25seVwiXG4gICAgICAgICAgICBbdGFiaW5kZXhdPVwiZm9jdXNUcmFwVGFiSW5kZXhcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwidHJ1ZVwiXG4gICAgICAgICAgICAoZm9jdXNpbik9XCJvbklubmVyRm9jdXNJbigkZXZlbnQsICdlbmQnKVwiPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKm5nSWY9XCJzZXR0aW5ncy5yZXNwb25zaXZlXCIgKHJlc2l6ZSk9XCJyZXNpemVIYW5kbGVyKClcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gIGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDYsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDYsIEluamVjdChDRUxMX0NPTlRFWFQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BhZ2VyQ29udGV4dFNlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSwgT2JqZWN0LCBGb2N1c1Jvb3QsXG4gICAgICAgIEZvY3VzR3JvdXBdKVxuXSwgUGFnZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUGFnZXJFbGVtZW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIHBhZ2VyQ29udGV4dCwgY2QpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMucGFnZXJDb250ZXh0ID0gcGFnZXJDb250ZXh0O1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMudG90YWwgPSB0aGlzLnBhZ2VyQ29udGV4dC50b3RhbDtcbiAgICAgICAgdGhpcy5za2lwID0gdGhpcy5wYWdlckNvbnRleHQuc2tpcDtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHRoaXMucGFnZXJDb250ZXh0LnBhZ2VTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBQYWdlckVsZW1lbnRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFBhZ2UoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCh0aGlzLnNraXAgfHwgMCkgLyB0aGlzLnBhZ2VTaXplKSArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIFBhZ2VyRWxlbWVudENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCB0b3RhbFBhZ2VzKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKCh0aGlzLnRvdGFsIHx8IDApIC8gdGhpcy5wYWdlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIFBhZ2VyRWxlbWVudENvbXBvbmVudFxuICAgICAqL1xuICAgIHRleHRGb3Ioa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZ2VcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBQYWdlckVsZW1lbnRDb21wb25lbnRcbiAgICAgKi9cbiAgICBjaGFuZ2VQYWdlKHBhZ2UpIHtcbiAgICAgICAgdGhpcy5wYWdlckNvbnRleHQuY2hhbmdlUGFnZShwYWdlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJFbGVtZW50Q29tcG9uZW50XG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMucGFnZXJDb250ZXh0LmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMub25DaGFuZ2VzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2QubWFya0ZvckNoZWNrKCkpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIERpc3BsYXlzIGJ1dHRvbnMgZm9yIG5hdmlnYXRpbmcgdG8gdGhlIGZpcnN0IGFuZCB0byB0aGUgcHJldmlvdXMgcGFnZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHBhZ2luZ19ncmlkICV9I3RvYy1wYWdlci10ZW1wbGF0ZXMpKS5cbiAqL1xubGV0IFBhZ2VyUHJldkJ1dHRvbnNDb21wb25lbnQgPSBjbGFzcyBQYWdlclByZXZCdXR0b25zQ29tcG9uZW50IGV4dGVuZHMgUGFnZXJFbGVtZW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIHBhZ2VyQ29udGV4dCwgY2QsIG5hdmlnYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGxvY2FsaXphdGlvbiwgcGFnZXJDb250ZXh0LCBjZCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIFBhZ2VyUHJldkJ1dHRvbnNDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYWdlID09PSAxIHx8ICF0aGlzLnRvdGFsO1xuICAgIH1cbiAgICBvbkNoYW5nZXMoeyB0b3RhbCwgc2tpcCwgcGFnZVNpemUgfSkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMucGFnZVNpemUgPSBwYWdlU2l6ZTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG59O1xuUGFnZXJQcmV2QnV0dG9uc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXBhZ2VyLXByZXYtYnV0dG9ucycsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgICBba2VuZG9HcmlkRm9jdXNhYmxlXT1cIiFkaXNhYmxlZFwiXG4gICAgICAgICAgICBbdGl0bGVdPVwidGV4dEZvcigncGFnZXJGaXJzdFBhZ2UnKVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY3VycmVudFBhZ2UgIT09IDEgPyBjaGFuZ2VQYWdlKDApIDogZmFsc2VcIlxuICAgICAgICAgICAgKGtleWRvd24uZW50ZXIpPVwiY3VycmVudFBhZ2UgIT09IDEgPyBjaGFuZ2VQYWdlKDApIDogZmFsc2VcIlxuICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7XG4gICAgICAgICAgICAgICAgJ2stbGluayc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2stcGFnZXItbmF2JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnay1zdGF0ZS1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICdrLXBhZ2VyLWZpcnN0JzogdHJ1ZVxuICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgPHNwYW4gcm9sZT1cIm5vdGVcIlxuICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJ0ZXh0Rm9yKCdwYWdlckZpcnN0UGFnZScpXCJcbiAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAgICAgJ2staWNvbic6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdrLWktc2Vlay13JzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgICBba2VuZG9HcmlkRm9jdXNhYmxlXT1cIiFkaXNhYmxlZFwiXG4gICAgICAgICAgICBbdGl0bGVdPVwidGV4dEZvcigncGFnZXJQcmV2aW91c1BhZ2UnKVwiXG4gICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjdXJyZW50UGFnZSAhPT0gMSA/IGNoYW5nZVBhZ2UoY3VycmVudFBhZ2UtMikgOiBmYWxzZVwiXG4gICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJjdXJyZW50UGFnZSAhPT0gMSA/IGNoYW5nZVBhZ2UoY3VycmVudFBhZ2UtMikgOiBmYWxzZVwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7XG4gICAgICAgICAgICAgICAgJ2stbGluayc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2stcGFnZXItbmF2JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnay1zdGF0ZS1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICcnOiB0cnVlXG4gICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICA8c3BhbiByb2xlPVwibm90ZVwiXG4gICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cInRleHRGb3IoJ3BhZ2VyUHJldmlvdXNQYWdlJylcIlxuICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAgICAgICAnay1pY29uJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2staS1hcnJvdy13JzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgUGFnZXJDb250ZXh0U2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlXSlcbl0sIFBhZ2VyUHJldkJ1dHRvbnNDb21wb25lbnQpO1xuXG4vKipcbiAqIERpc3BsYXlzIGJ1dHRvbnMgZm9yIG5hdmlnYXRpbmcgdG8gdGhlIG5leHQgYW5kIHRvIHRoZSBsYXN0IHBhZ2UgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwYWdpbmdfZ3JpZCAlfSN0b2MtcGFnZXItdGVtcGxhdGUpKS5cbiAqL1xubGV0IFBhZ2VyTmV4dEJ1dHRvbnNDb21wb25lbnQgPSBjbGFzcyBQYWdlck5leHRCdXR0b25zQ29tcG9uZW50IGV4dGVuZHMgUGFnZXJFbGVtZW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIHBhZ2VyQ29udGV4dCwgY2QsIG5hdmlnYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGxvY2FsaXphdGlvbiwgcGFnZXJDb250ZXh0LCBjZCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIFBhZ2VyTmV4dEJ1dHRvbnNDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYWdlID09PSB0aGlzLnRvdGFsUGFnZXMgfHwgIXRoaXMudG90YWw7XG4gICAgfVxuICAgIG9uQ2hhbmdlcyh7IHRvdGFsLCBza2lwLCBwYWdlU2l6ZSB9KSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHBhZ2VTaXplO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbn07XG5QYWdlck5leHRCdXR0b25zQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcGFnZXItbmV4dC1idXR0b25zJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIFtrZW5kb0dyaWRGb2N1c2FibGVdPVwiIWRpc2FibGVkXCJcbiAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICBbdGl0bGVdPVwidGV4dEZvcigncGFnZXJOZXh0UGFnZScpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjdXJyZW50UGFnZSAhPT0gdG90YWxQYWdlcyA/IGNoYW5nZVBhZ2UoY3VycmVudFBhZ2UpIDogZmFsc2VcIlxuICAgICAgICAgICAgKGtleWRvd24uZW50ZXIpPVwiY3VycmVudFBhZ2UgIT09IHRvdGFsUGFnZXMgPyBjaGFuZ2VQYWdlKGN1cnJlbnRQYWdlKSA6IGZhbHNlXCJcbiAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAgICdrLWxpbmsnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdrLXBhZ2VyLW5hdic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2stc3RhdGUtZGlzYWJsZWQnOiBkaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAnJzogdHJ1ZVxuICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgPHNwYW4gcm9sZT1cIm5vdGVcIiBbYXR0ci5hcmlhLWxhYmVsXT1cInRleHRGb3IoJ3BhZ2VyTmV4dFBhZ2UnKVwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAgICAgICAnay1pY29uJzp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnay1pLWFycm93LWUnOiB0cnVlXG4gICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgICBba2VuZG9HcmlkRm9jdXNhYmxlXT1cIiFkaXNhYmxlZFwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInRleHRGb3IoJ3BhZ2VyTGFzdFBhZ2UnKVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY3VycmVudFBhZ2UgIT09IHRvdGFsUGFnZXMgPyBjaGFuZ2VQYWdlKHRvdGFsUGFnZXMtMSkgOiBmYWxzZVwiXG4gICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJjdXJyZW50UGFnZSAhPT0gdG90YWxQYWdlcyA/IGNoYW5nZVBhZ2UodG90YWxQYWdlcy0xKSA6IGZhbHNlXCJcbiAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAgICdrLWxpbmsnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdrLXBhZ2VyLW5hdic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2stc3RhdGUtZGlzYWJsZWQnOiBkaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAnay1wYWdlci1sYXN0JzogdHJ1ZVxuICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgPHNwYW4gcm9sZT1cIm5vdGVcIiBbYXR0ci5hcmlhLWxhYmVsXT1cInRleHRGb3IoJ3BhZ2VyTGFzdFBhZ2UnKVwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAgICAgICAnay1pY29uJzp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnay1pLXNlZWstZSc6IHRydWVcbiAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBQYWdlckNvbnRleHRTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2VdKVxuXSwgUGFnZXJOZXh0QnV0dG9uc0NvbXBvbmVudCk7XG5cbi8qKlxuICogRGlzcGxheXMgbnVtZXJpYyBidXR0b25zIHRvIGVuYWJsZSBuYXZpZ2F0aW9uIGJldHdlZW4gdGhlIHBhZ2VzLlxuICovXG5sZXQgUGFnZXJOdW1lcmljQnV0dG9uc0NvbXBvbmVudCA9IGNsYXNzIFBhZ2VyTnVtZXJpY0J1dHRvbnNDb21wb25lbnQgZXh0ZW5kcyBQYWdlckVsZW1lbnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgY2QsIHBhZ2VyQ29udGV4dCkge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb24sIHBhZ2VyQ29udGV4dCwgY2QpO1xuICAgICAgICB0aGlzLnBhZ2VyQ29udGV4dCA9IHBhZ2VyQ29udGV4dDtcbiAgICAgICAgdGhpcy5udW1iZXJzV3JhcENsYXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAqIEBtZW1iZXJPZiBQYWdlck51bWVyaWNCdXR0b25zQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGJ1dHRvbnMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gdGhpcy5zdGFydDsgaWR4IDw9IHRoaXMuZW5kOyBpZHgrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaWR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGVuZCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKCh0aGlzLnN0YXJ0ICsgdGhpcy5idXR0b25Db3VudCkgLSAxLCB0aGlzLnRvdGFsUGFnZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN0YXJ0KCkge1xuICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICAgICAgY29uc3QgYnV0dG9uQ291bnQgPSB0aGlzLmJ1dHRvbkNvdW50O1xuICAgICAgICBpZiAocGFnZSA+IGJ1dHRvbkNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCByZW1pbmRlciA9IChwYWdlICUgYnV0dG9uQ291bnQpO1xuICAgICAgICAgICAgcmV0dXJuIChyZW1pbmRlciA9PT0gMCkgPyAocGFnZSAtIGJ1dHRvbkNvdW50KSArIDEgOiAocGFnZSAtIHJlbWluZGVyKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwYWdlTGFiZWwobnVtKSB7XG4gICAgICAgIGNvbnN0IHBhZ2VUZXh0ID0gdGhpcy50ZXh0Rm9yKCdwYWdlclBhZ2UnKTtcbiAgICAgICAgaWYgKHBhZ2VUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFnZVRleHQgKyAnICcgKyBudW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25TZWxlY3RDaGFuZ2UoZSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgY29uc3QgdmFsdWVBc051bWJlciA9IE51bWJlcih0YXJnZXQudmFsdWUpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTih2YWx1ZUFzTnVtYmVyKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VQYWdlKHZhbHVlQXNOdW1iZXIgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQudmFsdWUgPT09ICdwcmV2aW91c0J1dHRvbnMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VQYWdlKHRoaXMuc3RhcnQgLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlUGFnZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DaGFuZ2VzKHsgdG90YWwsIHNraXAsIHBhZ2VTaXplIH0pIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gcGFnZVNpemU7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXBhZ2VyLW51bWJlcnMtd3JhcCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGFnZXJOdW1lcmljQnV0dG9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibnVtYmVyc1dyYXBDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUGFnZXJOdW1lcmljQnV0dG9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYnV0dG9uQ291bnRcIiwgdm9pZCAwKTtcblBhZ2VyTnVtZXJpY0J1dHRvbnNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1wYWdlci1udW1lcmljLWJ1dHRvbnMnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICBjbGFzcz1cImstZHJvcGRvd25saXN0IGstcGFnZXItbmF2XCJcbiAgICAgICAgICAgIGtlbmRvR3JpZEZvY3VzYWJsZVxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCIoY3VycmVudFBhZ2UpLnRvU3RyaW5nKClcIlxuICAgICAgICAgICAgKGNoYW5nZSk9XCJvblNlbGVjdENoYW5nZSgkZXZlbnQpXCI+XG4gICAgICAgICAgICA8b3B0aW9uICpuZ0lmPVwic3RhcnQgPiAxXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstbGlua1wiXG4gICAgICAgICAgICAgICAgdmFsdWU9XCJwcmV2aW91c0J1dHRvbnNcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwicGFnZUxhYmVsKHN0YXJ0IC0gMSlcIj4uLi5cbiAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgbnVtIG9mIGJ1dHRvbnNcIlxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJudW0udG9TdHJpbmcoKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJwYWdlTGFiZWwobnVtKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1jdXJyZW50XT1cImN1cnJlbnRQYWdlID09IG51bSA/ICdwYWdlJyA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieydrLWxpbmsnOiB0cnVlLCAnay1zdGF0ZS1zZWxlY3RlZCc6Y3VycmVudFBhZ2UgPT0gbnVtfVwiPlxuICAgICAgICAgICAgICAgIHt7bnVtfX1cbiAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiAqbmdJZj1cImVuZCA8IHRvdGFsUGFnZXNcIlxuICAgICAgICAgICAgICAgIHZhbHVlPVwibmV4dEJ1dHRvbnNcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1saW5rXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cInBhZ2VMYWJlbChlbmQgKyAxKVwiPi4uLlxuICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8dWwgW25nQ2xhc3NdPVwieydrLXBhZ2VyLW51bWJlcnMnOiB0cnVlLCAnay1yZXNldCc6IHRydWV9XCI+XG4gICAgICAgICAgICA8bGkgKm5nSWY9XCJzdGFydCA+IDFcIj5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICBrZW5kb0dyaWRGb2N1c2FibGVcbiAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWxpbmsgay1wYWdlci1uYXZcIlxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJwYWdlTGFiZWwoc3RhcnQgLSAxKVwiXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJjaGFuZ2VQYWdlKHN0YXJ0IC0gMilcIlxuICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJjaGFuZ2VQYWdlKHN0YXJ0IC0gMilcIj4uLi48L3NwYW4+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBudW0gb2YgYnV0dG9uc1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvR3JpZEZvY3VzYWJsZVxuICAgICAgICAgICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJwYWdlTGFiZWwobnVtKVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnay1saW5rJzogdHJ1ZSwgJ2stc3RhdGUtc2VsZWN0ZWQnOmN1cnJlbnRQYWdlID09IG51bSwgJ2stcGFnZXItbmF2JzogdHJ1ZX1cIlxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiY2hhbmdlUGFnZShudW0gLSAxKVwiXG4gICAgICAgICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cImNoYW5nZVBhZ2UobnVtIC0gMSlcIj5cbiAgICAgICAgICAgICAgICAgICAge3tudW19fVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8bGkgKm5nSWY9XCJlbmQgPCB0b3RhbFBhZ2VzXCI+XG4gICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAga2VuZG9HcmlkRm9jdXNhYmxlXG4gICAgICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1saW5rIGstcGFnZXItbmF2XCJcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwicGFnZUxhYmVsKGVuZCArIDEpXCJcbiAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNoYW5nZVBhZ2UoZW5kKVwiXG4gICAgICAgICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cImNoYW5nZVBhZ2UoZW5kKVwiPi4uLjwvc3Bhbj5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvdWw+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIFBhZ2VyQ29udGV4dFNlcnZpY2VdKVxuXSwgUGFnZXJOdW1lcmljQnV0dG9uc0NvbXBvbmVudCk7XG5cbi8qKlxuICogRGlzcGxheXMgYW4gaW5wdXQgZWxlbWVudCB3aGljaCBhbGxvd3MgdGhlIHR5cGluZyBhbmQgcmVuZGVyaW5nIG9mIHBhZ2UgbnVtYmVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgPGtlbmRvLWdyaWRcbiAqICAgICAgICBba2VuZG9HcmlkQmluZGluZ109XCJncmlkRGF0YVwiXG4gKiAgICAgICAgW3BhZ2VTaXplXT1cIjFcIlxuICogICAgICAgIFtwYWdlYWJsZV09XCJ0cnVlXCJcbiAqICAgICAgPlxuICogICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiUHJvZHVjdElEXCIgdGl0bGU9XCJJRFwiIHdpZHRoPVwiNDBcIj5cbiAqICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiIHRpdGxlPVwiTmFtZVwiIHdpZHRoPVwiMjUwXCI+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiVW5pdFByaWNlXCIgdGl0bGU9XCJQcmljZVwiIHdpZHRoPVwiODBcIiBmb3JtYXQ9XCJ7MDpjfVwiPlxuICogICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqXG4gKiAgICAgICA8bmctdGVtcGxhdGUga2VuZG9QYWdlclRlbXBsYXRlIGxldC10b3RhbFBhZ2VzPVwidG90YWxQYWdlc1wiIGxldC1jdXJyZW50UGFnZT1cImN1cnJlbnRQYWdlXCI+XG4gKiAgICAgICAgICA8a2VuZG8tcGFnZXItcHJldi1idXR0b25zPjwva2VuZG8tcGFnZXItcHJldi1idXR0b25zPlxuICogICAgICAgICAgPGtlbmRvLXBhZ2VyLW51bWVyaWMtYnV0dG9ucyBbYnV0dG9uQ291bnRdPVwiMTBcIj48L2tlbmRvLXBhZ2VyLW51bWVyaWMtYnV0dG9ucz5cbiAqICAgICAgICAgIDxrZW5kby1wYWdlci1uZXh0LWJ1dHRvbnM+PC9rZW5kby1wYWdlci1uZXh0LWJ1dHRvbnM+XG4gKiAgICAgICAgICA8a2VuZG8tcGFnZXItaW5wdXQ+PC9rZW5kby1wYWdlci1pbnB1dD5cbiAqICAgICAgICAgIDxrZW5kby1wYWdlci1pbmZvPjwva2VuZG8tcGFnZXItaW5mbz5cbiAqICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICogICAgPC9rZW5kby1ncmlkPlxuICogICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgZ3JpZERhdGEgPSBbe1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAxLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICogICAgICAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICogICAgICAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICogICAgICAgfSwge1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAqICAgICAgICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAqICAgICAgICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICogICAgICAgfVxuICogICAgIF07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBQYWdlcklucHV0Q29tcG9uZW50ID0gY2xhc3MgUGFnZXJJbnB1dENvbXBvbmVudCBleHRlbmRzIFBhZ2VyRWxlbWVudENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCBwYWdlckNvbnRleHQsIHpvbmUsIG5hdmlnYXRpb25TZXJ2aWNlLCBjZCkge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb24sIHBhZ2VyQ29udGV4dCwgY2QpO1xuICAgICAgICB0aGlzLnBhZ2VyQ29udGV4dCA9IHBhZ2VyQ29udGV4dDtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIFBhZ2VySW5wdXRDb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGluY29taW5nVmFsdWUgPSB0aGlzLm51bWVyaWNJbnB1dC52YWx1ZSB8fCB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5FbnRlcikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGluY29taW5nVmFsdWUgIT09IHRoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlUGFnZShpbmNvbWluZ1ZhbHVlIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBQYWdlcklucHV0Q29tcG9uZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUJsdXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gdGhpcy5udW1lcmljSW5wdXQudmFsdWU7XG4gICAgICAgICAgICBpZiAoIWlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm51bWVyaWNJbnB1dC53cml0ZVZhbHVlKHRoaXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgIT09IHRoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVBhZ2UoaW5wdXRWYWx1ZSAtIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1BhZ2VzID8gdGhpcy5jdXJyZW50UGFnZSA6IDA7XG4gICAgfVxuICAgIGdldCBoYXNQYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWxQYWdlcyAhPT0gMDtcbiAgICB9XG4gICAgb25DaGFuZ2VzKHsgdG90YWwsIHNraXAsIHBhZ2VTaXplIH0pIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gcGFnZVNpemU7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZChOdW1lcmljVGV4dEJveENvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1lcmljVGV4dEJveENvbXBvbmVudClcbl0sIFBhZ2VySW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm51bWVyaWNJbnB1dFwiLCB2b2lkIDApO1xuUGFnZXJJbnB1dENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcGFnZXItaW5wdXQnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICA8c3BhbiBbbmdDbGFzc109XCJ7J2stcGFnZXItaW5wdXQnOiB0cnVlLCAnay1sYWJlbCc6IHRydWV9XCI+XG4gICAgICAgIHt7dGV4dEZvcigncGFnZXJQYWdlJyl9fVxuICAgICAgICA8a2VuZG8tbnVtZXJpY3RleHRib3hcbiAgICAgICAgICAgIGtlbmRvR3JpZFBhZ2VySW5wdXRcbiAgICAgICAgICAgIFtrZW5kb0dyaWRGb2N1c2FibGVdPVwiaGFzUGFnZXNcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIFtzcGlubmVyc109XCJmYWxzZVwiXG4gICAgICAgICAgICBbZGVjaW1hbHNdPVwiMFwiXG4gICAgICAgICAgICBmb3JtYXQ9XCJuMFwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiIWhhc1BhZ2VzXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJjdXJyZW50XCJcbiAgICAgICAgICAgIFttaW5dPVwiaGFzUGFnZXMgPyAxIDogMFwiXG4gICAgICAgICAgICBbbWF4XT1cInRvdGFsUGFnZXNcIlxuICAgICAgICAgICAgW2F1dG9Db3JyZWN0XT1cInRydWVcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInRleHRGb3IoJ3BhZ2VyUGFnZU51bWJlcklucHV0VGl0bGUnKVwiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAga2V5ZG93bjogaGFuZGxlS2V5RG93bixcbiAgICAgICAgICAgICAgICBmb2N1c291dDogaGFuZGxlQmx1clxuICAgICAgICAgICAgfVwiXG4gICAgICAgID5cbiAgICAgICAgPC9rZW5kby1udW1lcmljdGV4dGJveD5cbiAgICAgICAge3t0ZXh0Rm9yKCdwYWdlck9mJyl9fSB7e3RvdGFsUGFnZXN9fVxuICAgICA8L3NwYW4+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgUGFnZXJDb250ZXh0U2VydmljZSxcbiAgICAgICAgTmdab25lLFxuICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgUGFnZXJJbnB1dENvbXBvbmVudCk7XG5cbi8qKlxuICogRGlzcGxheXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgcGFnZSBhbmQgdGhlIHRvdGFsIG51bWJlciBvZiByZWNvcmRzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGFnaW5nX2dyaWQgJX0jdG9jLXBhZ2VyLXRlbXBsYXRlcykpLlxuICovXG5sZXQgUGFnZXJJbmZvQ29tcG9uZW50ID0gY2xhc3MgUGFnZXJJbmZvQ29tcG9uZW50IGV4dGVuZHMgUGFnZXJFbGVtZW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGNkLCBwYWdlckNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIobG9jYWxpemF0aW9uLCBwYWdlckNvbnRleHQsIGNkKTtcbiAgICAgICAgdGhpcy5wYWdlckNvbnRleHQgPSBwYWdlckNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIFBhZ2VySW5mb0NvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBtYXhJdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuY3VycmVudFBhZ2UgKiB0aGlzLnBhZ2VTaXplLCB0aGlzLnRvdGFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJJbmZvQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRQYWdlVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWwgP1xuICAgICAgICAgICAgKHRoaXMuY3VycmVudFBhZ2UgLSAxKSAqIHRoaXMucGFnZVNpemUgKyAxIDpcbiAgICAgICAgICAgIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBQYWdlckluZm9Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgY2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG9uQ2hhbmdlcyh7IHRvdGFsLCBza2lwLCBwYWdlU2l6ZSB9KSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHBhZ2VTaXplO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstcGFnZXItaW5mb1wiKSxcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstbGFiZWxcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFBhZ2VySW5mb0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xhc3Nlc1wiLCBudWxsKTtcblBhZ2VySW5mb0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXBhZ2VyLWluZm8nLFxuICAgICAgICB0ZW1wbGF0ZTogYHt7Y3VycmVudFBhZ2VUZXh0fX0gLSB7e21heEl0ZW1zfX0ge3t0ZXh0Rm9yKCdwYWdlck9mJyl9fSB7e3RvdGFsfX0ge3t0ZXh0Rm9yKCdwYWdlckl0ZW1zJyl9fWBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBQYWdlckNvbnRleHRTZXJ2aWNlXSlcbl0sIFBhZ2VySW5mb0NvbXBvbmVudCk7XG5cbi8qKlxuICogRGlzcGxheXMgYSBkcm9wLWRvd24gbGlzdCBmb3IgdGhlIHBhZ2Ugc2l6ZSBzZWxlY3Rpb24gKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwYWdpbmdfZ3JpZCAlfSN0b2MtcGFnZXItdGVtcGxhdGVzKSkuXG4gKi9cbmxldCBQYWdlclBhZ2VTaXplc0NvbXBvbmVudCA9IGNsYXNzIFBhZ2VyUGFnZVNpemVzQ29tcG9uZW50IGV4dGVuZHMgUGFnZXJFbGVtZW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGNkLCBwYWdlckNvbnRleHQsIG5hdmlnYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGxvY2FsaXphdGlvbiwgcGFnZXJDb250ZXh0LCBjZCk7XG4gICAgICAgIHRoaXMucGFnZXJDb250ZXh0ID0gcGFnZXJDb250ZXh0O1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlID0gbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuX3BhZ2VTaXplcyA9IFtdO1xuICAgIH1cbiAgICBnZXQgcGFnZVNpemVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFnZVNpemVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcGFnZSBzaXplcyBjb2xsZWN0aW9uLiBDYW4gYmUgYW4gQXJyYXkgb2YgbnVtYmVycyBhbmQvb3IgUGFnZVNpemVJdGVtIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzLXByZXZpZXdcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqICAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgICAgIDxrZW5kby1ncmlkIFtrZW5kb0dyaWRCaW5kaW5nXT1cImdyaWREYXRhXCIgW2hlaWdodF09XCIyMDBcIlxuICAgICAqICAgICAgICAgICBbcGFnZWFibGVdPVwidHJ1ZVwiXG4gICAgICogICAgICAgICAgICBbcGFnZVNpemVdPVwicGFnZVNpemVcIj5cbiAgICAgKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1BhZ2VyVGVtcGxhdGUgbGV0LXRvdGFsUGFnZXM9XCJ0b3RhbFBhZ2VzXCIgbGV0LWN1cnJlbnRQYWdlPVwiY3VycmVudFBhZ2VcIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8a2VuZG8tcGFnZXItcGFnZS1zaXplcyBbcGFnZVNpemVzXT1cInBhZ2VzaXplc1wiPjwva2VuZG8tcGFnZXItcGFnZS1zaXplcz5cbiAgICAgKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICogICAgICAgIDwva2VuZG8tZ3JpZD5cbiAgICAgKiAgICBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgIHB1YmxpYyBncmlkRGF0YTogYW55W10gPSBwcm9kdWN0cztcbiAgICAgKiAgICBwdWJsaWMgcGFnZVNpemUgPSAyO1xuICAgICAqICAgIHB1YmxpYyBwYWdlc2l6ZXMgPSBbe3RleHQ6ICdPbmUnLCB2YWx1ZTogMX0sIHt0ZXh0OiAnVHdvJywgdmFsdWU6IDJ9LCB7dGV4dDogJ0FsbCcsIHZhbHVlIDogJ2FsbCd9XTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zdCBwcm9kdWN0cyA9IFt7XG4gICAgICogICAnUHJvZHVjdElEJyA6IDEsXG4gICAgICogICAnUHJvZHVjdE5hbWUnIDogXCJDaGFpXCIsXG4gICAgICogICAnU3VwcGxpZXJJRCcgOiAxLFxuICAgICAqICAgJ0NhdGVnb3J5SUQnIDogMSxcbiAgICAgKiAgICdRdWFudGl0eVBlclVuaXQnIDogXCIxMCBib3hlcyB4IDIwIGJhZ3NcIixcbiAgICAgKiAgICdVbml0UHJpY2UnIDogMTguMDAwMCxcbiAgICAgKiAgICdVbml0c0luU3RvY2snIDogMzksXG4gICAgICogICAnVW5pdHNPbk9yZGVyJyA6IDAsXG4gICAgICogICAnUmVvcmRlckxldmVsJyA6IDEwLFxuICAgICAqICAgJ0Rpc2NvbnRpbnVlZCcgOiBmYWxzZVxuICAgICAqXG4gICAgICogfSwge1xuICAgICAqICAgJ1Byb2R1Y3RJRCcgOiAyLFxuICAgICAqICAgJ1Byb2R1Y3ROYW1lJyA6IFwiQ2hhbmdcIixcbiAgICAgKiAgICdTdXBwbGllcklEJyA6IDEsXG4gICAgICogICAnQ2F0ZWdvcnlJRCcgOiAxLFxuICAgICAqICAgJ1F1YW50aXR5UGVyVW5pdCcgOiBcIjI0IC0gMTIgb3ogYm90dGxlc1wiLFxuICAgICAqICAgJ1VuaXRQcmljZScgOiAxOS4wMDAwLFxuICAgICAqICAgJ1VuaXRzSW5TdG9jaycgOiAxNyxcbiAgICAgKiAgICdVbml0c09uT3JkZXInIDogNDAsXG4gICAgICogICAnUmVvcmRlckxldmVsJyA6IDI1LFxuICAgICAqICAgJ0Rpc2NvbnRpbnVlZCcgOiBmYWxzZVxuICAgICAqIH0sIHtcbiAgICAgKiAgICdQcm9kdWN0SUQnIDogMyxcbiAgICAgKiAgICdQcm9kdWN0TmFtZScgOiBcIkFuaXNlZWQgU3lydXBcIixcbiAgICAgKiAgICdTdXBwbGllcklEJyA6IDEsXG4gICAgICogICAnQ2F0ZWdvcnlJRCcgOiAyLFxuICAgICAqICAgJ1F1YW50aXR5UGVyVW5pdCcgOiBcIjEyIC0gNTUwIG1sIGJvdHRsZXNcIixcbiAgICAgKiAgICdVbml0UHJpY2UnIDogMTAuMDAwMCxcbiAgICAgKiAgICdVbml0c0luU3RvY2snIDogMTMsXG4gICAgICogICAnVW5pdHNPbk9yZGVyJyA6IDcwLFxuICAgICAqICAgJ1Jlb3JkZXJMZXZlbCcgOiAyNSxcbiAgICAgKiAgICdEaXNjb250aW51ZWQnIDogZmFsc2VcbiAgICAgKiB9LCB7XG4gICAgICogICAnUHJvZHVjdElEJyA6IDQsXG4gICAgICogICAnUHJvZHVjdE5hbWUnIDogXCJDaGVmIEFudG9uXFwncyBDYWp1biBTZWFzb25pbmdcIixcbiAgICAgKiAgICdTdXBwbGllcklEJyA6IDIsXG4gICAgICogICdDYXRlZ29yeUlEJyA6IDIsXG4gICAgICogICAnUXVhbnRpdHlQZXJVbml0JyA6IFwiNDggLSA2IG96IGphcnNcIixcbiAgICAgKiAgICdVbml0UHJpY2UnIDogMjIuMDAwMCxcbiAgICAgKiAgICdVbml0c0luU3RvY2snIDogNTMsXG4gICAgICogICAnVW5pdHNPbk9yZGVyJyA6IDAsXG4gICAgICogICAnUmVvcmRlckxldmVsJyA6IDAsXG4gICAgICogICAnRGlzY29udGludWVkJyA6IGZhbHNlXG4gICAgICogfSwge1xuICAgICAqICAgJ1Byb2R1Y3RJRCcgOiA1LFxuICAgICAqICAgJ1Byb2R1Y3ROYW1lJyA6IFwiQ2hlZiBBbnRvblxcJ3MgR3VtYm8gTWl4XCIsXG4gICAgICogICAnU3VwcGxpZXJJRCcgOiAyLFxuICAgICAqICAgJ0NhdGVnb3J5SUQnIDogMixcbiAgICAgKiAgICdRdWFudGl0eVBlclVuaXQnIDogXCIzNiBib3hlc1wiLFxuICAgICAqICAgJ1VuaXRQcmljZScgOiAyMS4zNTAwLFxuICAgICAqICAgJ1VuaXRzSW5TdG9jaycgOiAwLFxuICAgICAqICAgJ1VuaXRzT25PcmRlcicgOiAwLFxuICAgICAqICAgJ1Jlb3JkZXJMZXZlbCcgOiAwLFxuICAgICAqICAgJ0Rpc2NvbnRpbnVlZCcgOiB0cnVlXG4gICAgICogfSwge1xuICAgICAqICAgJ1Byb2R1Y3RJRCcgOiA2LFxuICAgICAqICAgJ1Byb2R1Y3ROYW1lJyA6IFwiR3JhbmRtYVxcJ3MgQm95c2VuYmVycnkgU3ByZWFkXCIsXG4gICAgICogICAnU3VwcGxpZXJJRCcgOiAzLFxuICAgICAqICAgJ0NhdGVnb3J5SUQnIDogMixcbiAgICAgKiAgICdRdWFudGl0eVBlclVuaXQnIDogXCIxMiAtIDggb3ogamFyc1wiLFxuICAgICAqICAgJ1VuaXRQcmljZScgOiAyNS4wMDAwLFxuICAgICAqICAgJ1VuaXRzSW5TdG9jaycgOiAxMjAsXG4gICAgICogICAnVW5pdHNPbk9yZGVyJyA6IDAsXG4gICAgICogICAnUmVvcmRlckxldmVsJyA6IDI1LFxuICAgICAqICAgJ0Rpc2NvbnRpbnVlZCcgOiBmYWxzZVxuICAgICAqIH1dO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBwYWdlU2l6ZXMocGFnZVNpemVzKSB7XG4gICAgICAgIGxldCBub3JtYWxpemVkSXRlbXMgPSBbXTtcbiAgICAgICAgcGFnZVNpemVzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBpdGVtLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnBhZ2VTaXplICYmICFub3JtYWxpemVkSXRlbXMuc29tZShpdGVtID0+IGl0ZW0udmFsdWUgPT09IHRoaXMucGFnZVNpemUpKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkSXRlbXMgPSBbeyB0ZXh0OiB0aGlzLnBhZ2VTaXplLnRvU3RyaW5nKCksIHZhbHVlOiB0aGlzLnBhZ2VTaXplIH0sIC4uLm5vcm1hbGl6ZWRJdGVtc107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFnZVNpemVzID0gbm9ybWFsaXplZEl0ZW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgY2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBzaG93SW5pdGlhbFBhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlU2l6ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0udmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWUgPT09IE51bWJlcih0aGlzLnBhZ2VTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsID09PSBOdW1iZXIodGhpcy5wYWdlU2l6ZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcGFnZVNpemVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IHRoaXMudG90YWw7XG4gICAgICAgIHRoaXMucGFnZXJDb250ZXh0LmNoYW5nZVBhZ2VTaXplKHRoaXMucGFnZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0VmFsdWUocGFnZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhZ2UudmFsdWUgPT09ICdudW1iZXInID8gcGFnZS52YWx1ZSA6IHRoaXMudG90YWw7XG4gICAgfVxuICAgIG9uQ2hhbmdlcyh7IHRvdGFsLCBza2lwLCBwYWdlU2l6ZSB9KSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHR5cGVvZiBwYWdlU2l6ZSA9PT0gJ251bWJlcicgPyBwYWdlU2l6ZSA6IHRoaXMudG90YWw7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIFBhZ2VyUGFnZVNpemVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWdlU2l6ZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1wYWdlci1zaXplcycpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWxhYmVsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFBhZ2VyUGFnZVNpemVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGFzc2VzXCIsIG51bGwpO1xuUGFnZXJQYWdlU2l6ZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1wYWdlci1wYWdlLXNpemVzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWRyb3Bkb3dubGlzdFxuICAgICAgICAgICAgI2Ryb3Bkb3dubGlzdFxuICAgICAgICAgICAga2VuZG9HcmlkUGFnZXJEcm9wRG93blxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIGtlbmRvR3JpZEZvY3VzYWJsZVxuICAgICAgICAgICAgW2RhdGFdPVwicGFnZVNpemVzXCJcbiAgICAgICAgICAgIHRleHRGaWVsZD1cInRleHRcIlxuICAgICAgICAgICAgdmFsdWVGaWVsZD1cInZhbHVlXCJcbiAgICAgICAgICAgIFt2YWx1ZVByaW1pdGl2ZV09XCJ0cnVlXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJwYWdlU2l6ZVwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwicGFnZVNpemVDaGFuZ2UoJGV2ZW50KVwiPjwva2VuZG8tZHJvcGRvd25saXN0PlxuICAgICAgICA8a2VuZG8tbGFiZWwgW2Zvcl09XCJkcm9wZG93bmxpc3RcIiBbdGV4dF09XCJ0ZXh0Rm9yKCdwYWdlckl0ZW1zUGVyUGFnZScpXCI+PC9rZW5kby1sYWJlbD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgUGFnZXJDb250ZXh0U2VydmljZSxcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2VdKVxuXSwgUGFnZXJQYWdlU2l6ZXNDb21wb25lbnQpO1xuXG5jb25zdCBpbXBvcnRlZE1vZHVsZXMkMSA9IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgSW5wdXRzTW9kdWxlLFxuICAgIExhYmVsTW9kdWxlLFxuICAgIERyb3BEb3duc01vZHVsZSxcbiAgICBSZXNpemVTZW5zb3JNb2R1bGUsXG4gICAgU2hhcmVkTW9kdWxlXG5dO1xuY29uc3QgSU5URVJOQUxfQ09NUE9ORU5UUyQxID0gW1xuICAgIFBhZ2VyQ29tcG9uZW50LFxuICAgIFBhZ2VyUHJldkJ1dHRvbnNDb21wb25lbnQsXG4gICAgUGFnZXJOZXh0QnV0dG9uc0NvbXBvbmVudCxcbiAgICBQYWdlck51bWVyaWNCdXR0b25zQ29tcG9uZW50LFxuICAgIFBhZ2VySW5wdXRDb21wb25lbnQsXG4gICAgUGFnZXJJbmZvQ29tcG9uZW50LFxuICAgIFBhZ2VyUGFnZVNpemVzQ29tcG9uZW50LFxuICAgIFBhZ2VyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgUGFnZXJEcm9wRG93bkxpc3REaXJlY3RpdmUsXG4gICAgUGFnZXJJbnB1dERpcmVjdGl2ZVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgUGFnZXJNb2R1bGUgPSBjbGFzcyBQYWdlck1vZHVsZSB7XG4gICAgc3RhdGljIGV4cG9ydHMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBQYWdlckNvbXBvbmVudCxcbiAgICAgICAgICAgIFBhZ2VyUHJldkJ1dHRvbnNDb21wb25lbnQsXG4gICAgICAgICAgICBQYWdlck5leHRCdXR0b25zQ29tcG9uZW50LFxuICAgICAgICAgICAgUGFnZXJOdW1lcmljQnV0dG9uc0NvbXBvbmVudCxcbiAgICAgICAgICAgIFBhZ2VySW5wdXRDb21wb25lbnQsXG4gICAgICAgICAgICBQYWdlckluZm9Db21wb25lbnQsXG4gICAgICAgICAgICBQYWdlclBhZ2VTaXplc0NvbXBvbmVudCxcbiAgICAgICAgICAgIFBhZ2VyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBQYWdlckRyb3BEb3duTGlzdERpcmVjdGl2ZSxcbiAgICAgICAgICAgIFBhZ2VySW5wdXREaXJlY3RpdmVcbiAgICAgICAgXTtcbiAgICB9XG59O1xuUGFnZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0lOVEVSTkFMX0NPTVBPTkVOVFMkMV0sXG4gICAgICAgIGV4cG9ydHM6IFtJTlRFUk5BTF9DT01QT05FTlRTJDFdLFxuICAgICAgICBpbXBvcnRzOiBbLi4uaW1wb3J0ZWRNb2R1bGVzJDFdXG4gICAgfSlcbl0sIFBhZ2VyTW9kdWxlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBHcm91cEhlYWRlckNvbXBvbmVudCA9IGNsYXNzIEdyb3VwSGVhZGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihncm91cHNTZXJ2aWNlLCBncm91cEluZm9TZXJ2aWNlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5ncm91cHNTZXJ2aWNlID0gZ3JvdXBzU2VydmljZTtcbiAgICAgICAgdGhpcy5ncm91cEluZm9TZXJ2aWNlID0gZ3JvdXBJbmZvU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuc2tpcEdyb3VwRGVjb3JhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0RldGFpbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3RhbENvbHVtbnNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gW107XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZ3JvdXBJdGVtQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwQXJncyA9IHtcbiAgICAgICAgICAgIGdyb3VwOiB0aGlzLml0ZW0uZGF0YSxcbiAgICAgICAgICAgIGdyb3VwSW5kZXg6IHRoaXMuaXRlbS5pbmRleCxcbiAgICAgICAgICAgIHBhcmVudEdyb3VwOiBnZXRHcm91cFJvd0FyZ3ModGhpcy5pdGVtLnBhcmVudEdyb3VwKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSB0aGlzLmdyb3Vwc1NlcnZpY2UuaXNFeHBhbmRlZChncm91cEFyZ3MpO1xuICAgIH1cbiAgICBwcmVmaXhHcm91cENlbGwoaXRlbSkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KGl0ZW0ubGV2ZWwpO1xuICAgIH1cbiAgICB0b2dnbGVHcm91cChpdGVtKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzU2VydmljZS50b2dnbGVSb3coaXRlbSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ3JvdXBTcGFuKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgZ3JvdXBDb3VudCA9ICh0aGlzLmdyb3VwcyB8fCBbXSkubGVuZ3RoO1xuICAgICAgICBjb25zdCBkZXRhaWxPZmZzZXQgPSB0aGlzLmhhc0RldGFpbHMgPyAxIDogMDtcbiAgICAgICAgaWYgKHRoaXMuaGFzR3JvdXBIZWFkZXJDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cENvdW50ICsgMSArIGRldGFpbE9mZnNldCAtIGl0ZW0ubGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbHVtbkNvdW50ID0gY29sdW1uc1NwYW4odGhpcy5jb2x1bW5zKTtcbiAgICAgICAgaWYgKHRoaXMuc2tpcEdyb3VwRGVjb3JhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbkNvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cENvdW50ICsgY29sdW1uQ291bnQgKyBkZXRhaWxPZmZzZXQgLSBpdGVtLmxldmVsO1xuICAgIH1cbiAgICBsb2dpY2FsQ29sU3BhbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpcEdyb3VwRGVjb3JhdGlvbiA/IDEgOiB0aGlzLnRvdGFsQ29sdW1uc0NvdW50O1xuICAgIH1cbiAgICBhcmlhUm9sZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2tpcEdyb3VwRGVjb3JhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICdwcmVzZW50YXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZ3JpZGNlbGwnO1xuICAgIH1cbiAgICBmb3JtYXRGb3JHcm91cChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwSW5mb1NlcnZpY2UuZm9ybWF0Rm9yR3JvdXAoaXRlbSk7XG4gICAgfVxuICAgIGdyb3VwVGl0bGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cEluZm9TZXJ2aWNlLmdyb3VwVGl0bGUoaXRlbSk7XG4gICAgfVxuICAgIGdyb3VwSGVhZGVyVGVtcGxhdGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cEluZm9TZXJ2aWNlLmdyb3VwSGVhZGVyVGVtcGxhdGUoaXRlbSk7XG4gICAgfVxuICAgIGdldCBncm91cEJ1dHRvblRpdGxlKCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlS2V5ID0gdGhpcy5pc0V4cGFuZGVkID8gJ2dyb3VwQ29sbGFwc2UnIDogJ2dyb3VwRXhwYW5kJztcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChtZXNzYWdlS2V5KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgR3JvdXBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJvd0luZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBHcm91cEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibG9naWNhbFJvd0luZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHcm91cEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdyb3VwSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJza2lwR3JvdXBEZWNvcmF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgR3JvdXBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhhc0RldGFpbHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEdyb3VwSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b3RhbENvbHVtbnNDb3VudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdyb3VwSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYXNHcm91cEhlYWRlckNvbHVtblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBHcm91cEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBIZWFkZXJDb2x1bW5zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHcm91cEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBHcm91cEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1ncm91cGluZy1yb3cnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgR3JvdXBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3VwSXRlbUNsYXNzXCIsIG51bGwpO1xuR3JvdXBIZWFkZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRHcm91cEhlYWRlcl0nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIXNraXBHcm91cERlY29yYXRpb25cIj5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImstZ3JvdXAtY2VsbFwiXG4gICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IGcgb2YgcHJlZml4R3JvdXBDZWxsKGl0ZW0pXCI+PC90ZD5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPHRkIFthdHRyLmNvbHNwYW5dPVwiZ3JvdXBTcGFuKGl0ZW0pXCIgKm5nSWY9XCIhKHNraXBHcm91cERlY29yYXRpb24gJiYgaGFzR3JvdXBIZWFkZXJDb2x1bW4pXCJcbiAgICAgICAgICAgIFthdHRyLnJvbGVdPVwiYXJpYVJvbGUoKVwiXG4gICAgICAgICAgICBhcmlhLXNlbGVjdGVkPVwiZmFsc2VcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJpc0V4cGFuZGVkXCJcbiAgICAgICAgICAgIGtlbmRvR3JpZExvZ2ljYWxDZWxsXG4gICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImxvZ2ljYWxSb3dJbmRleFwiXG4gICAgICAgICAgICBbbG9naWNhbENvbEluZGV4XT1cIjBcIlxuICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZUNlbGxdPVwic2tpcEdyb3VwRGVjb3JhdGlvblwiXG4gICAgICAgICAgICBbZ3JvdXBJdGVtXT1cIml0ZW1cIlxuICAgICAgICAgICAgW2NvbFNwYW5dPVwibG9naWNhbENvbFNwYW4oKVwiPlxuICAgICAgICAgICAgPHAgY2xhc3M9XCJrLXJlc2V0XCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFza2lwR3JvdXBEZWNvcmF0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIjXCIgdGFiaW5kZXg9XCItMVwiIChjbGljayk9XCJ0b2dnbGVHcm91cChpdGVtKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaWNvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7ICdrLWktY29sbGFwc2UnOiBpc0V4cGFuZGVkLCAnay1pLWV4cGFuZCc6ICFpc0V4cGFuZGVkIH1cIiByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImdyb3VwQnV0dG9uVGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJncm91cEJ1dHRvblRpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFncm91cEhlYWRlclRlbXBsYXRlKGl0ZW0pXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7Z3JvdXBUaXRsZShpdGVtKX19OiB7e2l0ZW0uZGF0YSB8IHZhbHVlT2Y6XCJ2YWx1ZVwiOiBmb3JtYXRGb3JHcm91cChpdGVtKX19XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGdyb3VwSGVhZGVyVGVtcGxhdGUoaXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGl0ZW0uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVzOiBpdGVtLmRhdGE/LmFnZ3JlZ2F0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0uZGF0YT8udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGl0ZW0uZGF0YT8uZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGl0ZW0uaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6IGlzRXhwYW5kZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiBpdGVtLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgPC90ZD5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImhhc0dyb3VwSGVhZGVyQ29sdW1uXCI+XG4gICAgICAgICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBncm91cEhlYWRlckNvbHVtbnM7IGxldCBpbmRleCA9IGluZGV4XCJcbiAgICAgICAgICAgICAgICByb2xlPVwiZ3JpZGNlbGxcIlxuICAgICAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAga2VuZG9HcmlkTG9naWNhbENlbGxcbiAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImxvZ2ljYWxSb3dJbmRleFwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxDb2xJbmRleF09XCJpbmRleCArIDFcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVDZWxsXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICBbZ3JvdXBJdGVtXT1cIml0ZW1cIlxuICAgICAgICAgICAgICAgIFtjb2xTcGFuXT1cIjFcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb2x1bW4uZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZVJlZlwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBpdGVtLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVzOiBpdGVtLmRhdGE/LmFnZ3JlZ2F0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbS5kYXRhPy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBpdGVtLmRhdGE/LmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGl0ZW0uaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGl0ZW0uZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbR3JvdXBzU2VydmljZSxcbiAgICAgICAgR3JvdXBJbmZvU2VydmljZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBHcm91cEhlYWRlckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRHJvcFRhcmdldERpcmVjdGl2ZSA9IGNsYXNzIERyb3BUYXJnZXREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge307XG4gICAgICAgIHRoaXMuZW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZHJvcCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmFkZCh0aGlzKTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuc2VydmljZS5jaGFuZ2VzLnBpcGUoZmlsdGVyKCh7IHRhcmdldCB9KSA9PiB0YXJnZXQgPT09IHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChjaGFuZ2VzLnBpcGUoZmlsdGVyKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gJ2xlYXZlJykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5sZWF2ZS5uZXh0KHRoaXMuZXZlbnRBcmdzKGUpKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGNoYW5nZXMucGlwZShmaWx0ZXIoKHsgdHlwZSB9KSA9PiB0eXBlID09PSAnZW50ZXInKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVudGVyLm5leHQodGhpcy5ldmVudEFyZ3MoZSkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoY2hhbmdlcy5waXBlKGZpbHRlcigoeyB0eXBlIH0pID0+IHR5cGUgPT09ICdkcm9wJykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcm9wLm5leHQodGhpcy5ldmVudEFyZ3MoZSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBldmVudEFyZ3MoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgbW91c2VFdmVudDogZS5tb3VzZUV2ZW50LFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBlLmRyYWdnYWJsZVxuICAgICAgICB9O1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEcm9wVGFyZ2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRHJvcFRhcmdldERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZW50ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEcm9wVGFyZ2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsZWF2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyb3BUYXJnZXREaXJlY3RpdmUucHJvdG90eXBlLCBcImRyb3BcIiwgdm9pZCAwKTtcbkRyb3BUYXJnZXREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0Ryb3BUYXJnZXRdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgRHJhZ0FuZERyb3BTZXJ2aWNlXSlcbl0sIERyb3BUYXJnZXREaXJlY3RpdmUpO1xuXG5jb25zdCB3aXRob3V0RmllbGQgPSAoeyBmaWVsZCB9KSA9PiBpc051bGxPckVtcHR5U3RyaW5nKGZpZWxkKTtcbmNvbnN0IGFscmVhZHlHcm91cGVkID0gKHsgZ3JvdXBzLCBmaWVsZCB9KSA9PiBncm91cHMuc29tZShncm91cCA9PiBncm91cC5maWVsZCA9PT0gZmllbGQpO1xuY29uc3Qgb3ZlclNhbWVUYXJnZXQgPSAoeyB0YXJnZXQsIGZpZWxkIH0pID0+IHRhcmdldC5maWVsZCA9PT0gZmllbGQ7XG5jb25zdCBvdmVyTGFzdFRhcmdldCA9ICh7IHRhcmdldCB9KSA9PiB0YXJnZXQubGFzdFRhcmdldDtcbmNvbnN0IGlzTGFzdEdyb3VwID0gKHsgZ3JvdXBzLCBmaWVsZCB9KSA9PiBncm91cHMubWFwKGdyb3VwID0+IGdyb3VwLmZpZWxkKS5pbmRleE9mKGZpZWxkKSA9PT0gZ3JvdXBzLmxlbmd0aCAtIDE7XG5jb25zdCBpc05vdEdyb3VwYWJsZSA9IChncm91cHNTZXJ2aWNlKSA9PiAoeyBmaWVsZCB9KSA9PiAhZ3JvdXBzU2VydmljZS5pc0dyb3VwYWJsZShmaWVsZCk7XG5jb25zdCBjb2x1bW5SdWxlcyA9IChncm91cFNlcnZpY2UpID0+IG9yKHdpdGhvdXRGaWVsZCwgYWxyZWFkeUdyb3VwZWQsIGlzTm90R3JvdXBhYmxlKGdyb3VwU2VydmljZSkpO1xuY29uc3QgaW5kaWNhdG9yUnVsZXMgPSBvcihvdmVyU2FtZVRhcmdldCwgYW5kKG92ZXJMYXN0VGFyZ2V0LCBpc0xhc3RHcm91cCkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBHcm91cFBhbmVsQ29tcG9uZW50ID0gY2xhc3MgR3JvdXBQYW5lbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoaGludCwgY3VlLCBncm91cEluZm9TZXJ2aWNlLCBsb2NhbGl6YXRpb24sIGNkKSB7XG4gICAgICAgIHRoaXMuaGludCA9IGhpbnQ7XG4gICAgICAgIHRoaXMuY3VlID0gY3VlO1xuICAgICAgICB0aGlzLmdyb3VwSW5mb1NlcnZpY2UgPSBncm91cEluZm9TZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBbXTtcbiAgICAgICAgdGhpcy5kcm9wVGFyZ2V0cyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5ncm91cFRpdGxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgZ2V0IGdyb3VwSGVhZGVyQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXQgdGV4dCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVtcHR5VGV4dCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlUZXh0ID8gdGhpcy5lbXB0eVRleHQgOiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2dyb3VwUGFuZWxFbXB0eScpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChvYnNlcnZlKHRoaXMuZHJvcFRhcmdldHMpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuYXR0YWNoVGFyZ2V0cy5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi5hZGQodGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZC5tYXJrRm9yQ2hlY2soKSkpO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaXRsZXMgPSB0aGlzLmdyb3Vwcy5tYXAoZ3JvdXAgPT4gdGhpcy5ncm91cEluZm9TZXJ2aWNlLmdyb3VwVGl0bGUoZ3JvdXApKTtcbiAgICAgICAgaWYgKGN1cnJlbnRUaXRsZXMubGVuZ3RoICE9PSB0aGlzLmdyb3VwVGl0bGVzLmxlbmd0aCB8fCBjdXJyZW50VGl0bGVzLnNvbWUoKGN1cnJlbnQsIGlkeCkgPT4gY3VycmVudCAhPT0gdGhpcy5ncm91cFRpdGxlc1tpZHhdKSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cFRpdGxlcyA9IGN1cnJlbnRUaXRsZXM7XG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpcmVjdGlvbkNoYW5nZShncm91cCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ3JvdXBzLmZpbmRJbmRleCh4ID0+IHguZmllbGQgPT09IGdyb3VwLmZpZWxkKTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gWy4uLnRoaXMuZ3JvdXBzLnNsaWNlKDAsIGluZGV4KSwgZ3JvdXAsIC4uLnRoaXMuZ3JvdXBzLnNsaWNlKGluZGV4ICsgMSldO1xuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KGdyb3Vwcyk7XG4gICAgfVxuICAgIGluc2VydChmaWVsZCwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cHMuZmlsdGVyKHggPT4geC5maWVsZCAhPT0gZmllbGQpO1xuICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCB8fCB0aGlzLmdyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoWy4uLmdyb3Vwcy5zbGljZSgwLCBpbmRleCksIHsgZmllbGQ6IGZpZWxkIH0sIC4uLmdyb3Vwcy5zbGljZShpbmRleCldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUoZ3JvdXApIHtcbiAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdCh0aGlzLmdyb3Vwcy5maWx0ZXIoeCA9PiB4LmZpZWxkICE9PSBncm91cC5maWVsZCkpO1xuICAgIH1cbiAgICBjYW5Ecm9wKGRyYWdnYWJsZSwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGlzSW5kaWNhdG9yID0gZHJhZ2dhYmxlLnR5cGUgPT09ICdncm91cEluZGljYXRvcic7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gaXNJbmRpY2F0b3JcbiAgICAgICAgICAgID8gaW5kaWNhdG9yUnVsZXNcbiAgICAgICAgICAgIDogY29sdW1uUnVsZXModGhpcy5ncm91cEluZm9TZXJ2aWNlKTtcbiAgICAgICAgcmV0dXJuICFydWxlcyh7XG4gICAgICAgICAgICBmaWVsZDogZHJhZ2dhYmxlLmZpZWxkLFxuICAgICAgICAgICAgZ3JvdXBzOiB0aGlzLmdyb3VwcyxcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXR0YWNoVGFyZ2V0cygpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFyZ2V0U3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICBjb25zdCBlbnRlclN0cmVhbSA9IHRoaXMuZHJvcFRhcmdldHNcbiAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdGFyZ2V0KSA9PiBtZXJnZShhY2MsIHRhcmdldC5lbnRlciksIGZyb20oW10pKTtcbiAgICAgICAgY29uc3QgbGVhdmVTdHJlYW0gPSB0aGlzLmRyb3BUYXJnZXRzXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIHRhcmdldCkgPT4gbWVyZ2UoYWNjLCB0YXJnZXQubGVhdmUpLCBmcm9tKFtdKSk7XG4gICAgICAgIGNvbnN0IGRyb3BTdHJlYW0gPSB0aGlzLmRyb3BUYXJnZXRzXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIHRhcmdldCkgPT4gbWVyZ2UoYWNjLCB0YXJnZXQuZHJvcCksIGZyb20oW10pKTtcbiAgICAgICAgdGhpcy50YXJnZXRTdWJzY3JpcHRpb24uYWRkKGVudGVyU3RyZWFtLnBpcGUodGFwKF8gPT4gdGhpcy5oaW50LnJlbW92ZUxvY2soKSksIGZpbHRlcigoeyBkcmFnZ2FibGUsIHRhcmdldCB9KSA9PiB0aGlzLmNhbkRyb3AoZHJhZ2dhYmxlLmNvbnRleHQsIHRhcmdldC5jb250ZXh0KSksIHRhcCh0aGlzLmVudGVyLmJpbmQodGhpcykpLCBzd2l0Y2hNYXBUbyhkcm9wU3RyZWFtLnBpcGUodGFrZVVudGlsKGxlYXZlU3RyZWFtLnBpcGUodGFwKHRoaXMubGVhdmUuYmluZCh0aGlzKSkpKSkpKS5zdWJzY3JpYmUodGhpcy5kcm9wLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgZW50ZXIoeyBkcmFnZ2FibGUsIHRhcmdldCB9KSB7XG4gICAgICAgIHRoaXMuaGludC5lbmFibGUoKTtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHRhcmdldC5jb250ZXh0Lmxhc3RUYXJnZXQgfHwgaXNUYXJnZXRCZWZvcmUoZHJhZ2dhYmxlLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgdGFyZ2V0LmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsaXphdGlvbi5ydGwpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICFiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdWUucG9zaXRpb24ocG9zaXRpb24odGFyZ2V0LmVsZW1lbnQubmF0aXZlRWxlbWVudCwgYmVmb3JlKSk7XG4gICAgfVxuICAgIGxlYXZlKCkge1xuICAgICAgICB0aGlzLmhpbnQuZGlzYWJsZSgpO1xuICAgICAgICB0aGlzLmN1ZS5oaWRlKCk7XG4gICAgfVxuICAgIGRyb3AoeyB0YXJnZXQsIGRyYWdnYWJsZSB9KSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZHJhZ2dhYmxlLmNvbnRleHQuZmllbGQ7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kcm9wVGFyZ2V0cy50b0FycmF5KCkuaW5kZXhPZih0YXJnZXQpO1xuICAgICAgICB0aGlzLmluc2VydChmaWVsZCwgaW5kZXgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgR3JvdXBQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstZ3JvdXBpbmctaGVhZGVyXCIpLFxuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1ncm91cGluZy1oZWFkZXItZmxleFwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgR3JvdXBQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBIZWFkZXJDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgR3JvdXBQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgR3JvdXBQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGRyZW4oRHJvcFRhcmdldERpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIEdyb3VwUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcImRyb3BUYXJnZXRzXCIsIHZvaWQgMCk7XG5Hcm91cFBhbmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1ncm91cC1wYW5lbCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJncm91cHMubGVuZ3RoID09PSAwXCI+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWluZGljYXRvci1jb250YWluZXJcIlxuICAgICAgICAgICAgICAgIFtjb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRhcmdldDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgIGtlbmRvRHJvcFRhcmdldD5cbiAgICAgICAgICAgICAgICB7eyB0ZXh0IH19XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPGRpdiAqbmdGb3I9XCJsZXQgZ3JvdXAgb2YgZ3JvdXBzOyBsZXQgaW5kZXggPSBpbmRleDtcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWluZGljYXRvci1jb250YWluZXJcIlxuICAgICAgICAgICAgW2NvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgIGZpZWxkOiBncm91cC5maWVsZFxuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICBrZW5kb0Ryb3BUYXJnZXQ+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2VuZG9EcmFnZ2FibGVDb2x1bW5cbiAgICAgICAgICAgICAgICBbZW5hYmxlRHJhZ109XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBbY29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBncm91cC5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2dyb3VwSW5kaWNhdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgaGludDogIGdyb3VwVGl0bGVzW2luZGV4XVxuICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgIGtlbmRvR3JvdXBJbmRpY2F0b3JcbiAgICAgICAgICAgICAgICBrZW5kb0RyYWdnYWJsZVxuICAgICAgICAgICAgICAgIFtncm91cF09XCJncm91cFwiXG4gICAgICAgICAgICAgICAgW2dyb3VwVGl0bGVdPVwiZ3JvdXBUaXRsZXNbaW5kZXhdXCJcbiAgICAgICAgICAgICAgICAoZGlyZWN0aW9uQ2hhbmdlKT1cImRpcmVjdGlvbkNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAocmVtb3ZlKT1cInJlbW92ZSgkZXZlbnQpXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWluZGljYXRvci1jb250YWluZXJcIlxuICAgICAgICAgICAgKm5nSWY9XCJncm91cHMubGVuZ3RoICE9PSAwXCJcbiAgICAgICAgICAgIFtjb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICBsYXN0VGFyZ2V0OiB0cnVlXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgICAgIGtlbmRvRHJvcFRhcmdldD4mbmJzcDs8L2Rpdj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEcmFnSGludFNlcnZpY2UsXG4gICAgICAgIERyb3BDdWVTZXJ2aWNlLFxuICAgICAgICBHcm91cEluZm9TZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBHcm91cFBhbmVsQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBHcm91cEluZGljYXRvckNvbXBvbmVudCA9IGNsYXNzIEdyb3VwSW5kaWNhdG9yQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnJlbW92ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IGdyb3VwSW5kaWNhdG9yQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgZGlyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cC5kaXIgPyB0aGlzLmdyb3VwLmRpciA6IFwiYXNjXCI7XG4gICAgfVxuICAgIHRvZ2dsZURpcmVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBkaXI6IHRoaXMuZGlyID09PSBcImFzY1wiID8gXCJkZXNjXCIgOiBcImFzY1wiLFxuICAgICAgICAgICAgZmllbGQ6IHRoaXMuZ3JvdXAuZmllbGRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmVtb3ZlRGVzY3JpcHRvcigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUuZW1pdCh7XG4gICAgICAgICAgICBkaXI6IHRoaXMuZ3JvdXAuZGlyLFxuICAgICAgICAgICAgZmllbGQ6IHRoaXMuZ3JvdXAuZmllbGRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEdyb3VwSW5kaWNhdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25DaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBHcm91cEluZGljYXRvckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVtb3ZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHcm91cEluZGljYXRvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEdyb3VwSW5kaWNhdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cFRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstZ3JvdXAtaW5kaWNhdG9yXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBHcm91cEluZGljYXRvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBJbmRpY2F0b3JDbGFzc1wiLCBudWxsKTtcbkdyb3VwSW5kaWNhdG9yQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JvdXBJbmRpY2F0b3JdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzcz1cImstbGlua1wiIHRhYmluZGV4PVwiLTFcIiAoY2xpY2spPVwidG9nZ2xlRGlyZWN0aW9uKClcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1pLXNvcnQtYXNjLXNtXT1cImRpciA9PT0gJ2FzYydcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLWktc29ydC1kZXNjLXNtXT1cImRpciA9PT0gJ2Rlc2MnXCI+PC9zcGFuPlxuICAgICAgICAgICAge3tncm91cFRpdGxlfX08L2E+XG4gICAgICAgIDxhIGNsYXNzPVwiay1idXR0b24gay1idXR0b24tZmxhdC1iYXNlIGstYnV0dG9uLWZsYXQgay1pY29uLWJ1dHRvbiBrLWJ1dHRvbi1tZCBrLXJvdW5kZWQtbWQgay1idXR0b24tcmVjdGFuZ2xlIGstaWNvbi1idXR0b25cIiB0YWJpbmRleD1cIi0xXCIgKGNsaWNrKT1cInJlbW92ZURlc2NyaXB0b3IoKVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWJ1dHRvbi1pY29uIGstaWNvbiBrLWktZ3JvdXAtZGVsZXRlXCI+PC9zcGFuPlxuICAgICAgICA8L2E+XG4gICAgYFxuICAgIH0pXG5dLCBHcm91cEluZGljYXRvckNvbXBvbmVudCk7XG5cbi8vIFRPRE9cbi8vIHRzbGludDpkaXNhYmxlOnJ4anMtbm8tdW5zYWZlLXRha2V1bnRpbFxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHByZXZlbnRPbkRibENsaWNrID0gcmVsZWFzZSA9PiBtb3VzZURvd24gPT4gb2YobW91c2VEb3duKS5waXBlKGRlbGF5KDE1MCksIHRha2VVbnRpbChyZWxlYXNlKSk7XG5jb25zdCBoYXNDbGFzcyA9IGNsYXNzTmFtZSA9PiBlbCA9PiBuZXcgUmVnRXhwKGAoXnwgKSR7Y2xhc3NOYW1lfSggfCQpYCkudGVzdChlbC5jbGFzc05hbWUpO1xuY29uc3QgaXNEZWxldGVCdXR0b24gPSBvcihoYXNDbGFzcygnay1pLWdyb3VwLWRlbGV0ZScpLCBoYXNDbGFzcygnay1pY29uLWJ1dHRvbicpKTtcbmNvbnN0IGlzU29ydEljb24gPSBvcihoYXNDbGFzcygnay1pLXNvcnQtYXNjLXNtJyksIGhhc0NsYXNzKCdrLWktc29ydC1kZXNjLXNtJykpO1xuY29uc3Qgc2tpcEJ1dHRvbnMgPSBhbmQobm90KGlzRGVsZXRlQnV0dG9uKSwgbm90KGlzU29ydEljb24pLCBub3QoaXNGb2N1c2FibGVXaXRoVGFiS2V5KSwgbm90KG1hdGNoZXNOb2RlTmFtZSgnbGFiZWwnKSkpO1xuY29uc3QgZWxlbWVudFVuZGVyQ3Vyc29yID0gKHsgY2xpZW50WCwgY2xpZW50WSB9KSA9PiBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGNsaWVudFgsIGNsaWVudFkpO1xuY29uc3QgaGlkZVRoZW5TaG93ID0gKGVsZW1lbnQsIGNvbnQpID0+IHtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgY29uc3QgcmVzdWx0ID0gY29udCgpO1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERyYWdnYWJsZUNvbHVtbkRpcmVjdGl2ZSA9IGNsYXNzIERyYWdnYWJsZUNvbHVtbkRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZHJhZ2dhYmxlLCBlbGVtZW50LCB6b25lLCBzZXJ2aWNlLCBoaW50LCBjdWUsIG5hdiwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuaGludCA9IGhpbnQ7XG4gICAgICAgIHRoaXMuY3VlID0gY3VlO1xuICAgICAgICB0aGlzLm5hdiA9IG5hdjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7fTtcbiAgICAgICAgdGhpcy5kcmFnID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuICAgIHNldCBlbmFibGVEcmFnKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgdGhpcy51cGRhdGVUb3VjaEFjdGlvbigpO1xuICAgIH1cbiAgICBnZXQgaG9zdENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGVkO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5kcmFnZ2FibGUua2VuZG9QcmVzcy5waXBlKGZpbHRlcihfID0+IHRoaXMuZW5hYmxlZCksIGZpbHRlcigoeyBvcmlnaW5hbEV2ZW50OiB7IHRhcmdldCB9IH0pID0+IHRhcmdldCA9PT0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgfHwgc2tpcEJ1dHRvbnModGFyZ2V0KSksIHRhcCgoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IGUub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgIGlmICghZS5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uYXYubmF2aWdhdGVUbyhvcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgIH0pLCBzd2l0Y2hNYXAocHJldmVudE9uRGJsQ2xpY2sodGhpcy5kcmFnZ2FibGUua2VuZG9SZWxlYXNlKSksIHRhcCgoXykgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaW50LmNyZWF0ZSh0aGlzLmNvbnRleHQuaGludCk7XG4gICAgICAgICAgICB0aGlzLmN1ZS5jcmVhdGUoKTtcbiAgICAgICAgfSksIHN3aXRjaE1hcChkb3duID0+IHRoaXMuZHJhZ2dhYmxlLmtlbmRvRHJhZy5waXBlKHRhcCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdGFwKHRoaXMuaGludC5hdHRhY2goKSksIHRhcCh0aGlzLmN1ZS5hdHRhY2goKSksIHRha2VVbnRpbCh0aGlzLmRyYWdnYWJsZS5rZW5kb1JlbGVhc2UpLCBtYXAobW92ZSA9PiAoeyBtb3ZlLCBkb3duIH0pKSkpLCB0YXAodGhpcy5wZXJmb3JtRHJhZy5iaW5kKHRoaXMpKSwgc3dpdGNoTWFwVG8odGhpcy5kcmFnZ2FibGUua2VuZG9SZWxlYXNlKSkuc3Vic2NyaWJlKHRoaXMuZHJvcC5iaW5kKHRoaXMpKSkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJvcCh1cEV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGludC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jdWUucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2VydmljZS5ub3RpZnlEcm9wKHRoaXMsIHVwRXZlbnQpO1xuICAgIH1cbiAgICBwZXJmb3JtRHJhZyh7IG1vdmUgfSkge1xuICAgICAgICB0aGlzLmhpbnQubW92ZShtb3ZlKTtcbiAgICAgICAgY29uc3QgY3Vyc29yRWxlbWVudCA9IHRoaXMuZWxlbWVudFVuZGVyQ3Vyc29yKG1vdmUpO1xuICAgICAgICBpZiAoY3Vyc29yRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLm5vdGlmeURyYWcodGhpcywgY3Vyc29yRWxlbWVudCwgbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnLmVtaXQoe1xuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0aGlzLFxuICAgICAgICAgICAgbW91c2VFdmVudDogbW92ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxlbWVudFVuZGVyQ3Vyc29yKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5oaW50LmhpZGUoKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGVsZW1lbnRVbmRlckN1cnNvcihtb3VzZUV2ZW50KTtcbiAgICAgICAgaWYgKHRhcmdldCAmJiAvay1ncm91cGluZy1kcm9wY2x1ZS8udGVzdCh0YXJnZXQuY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gaGlkZVRoZW5TaG93KHRhcmdldCwgZWxlbWVudFVuZGVyQ3Vyc29yLmJpbmQodGhpcywgbW91c2VFdmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGludC5zaG93KCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHVwZGF0ZVRvdWNoQWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5hYmxlZCA/IHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrLXRvdWNoLWFjdGlvbi1ub25lJykgOlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2stdG91Y2gtYWN0aW9uLW5vbmUnKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRHJhZ2dhYmxlQ29sdW1uRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgRHJhZ2dhYmxlQ29sdW1uRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbmFibGVEcmFnXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYWdnYWJsZUNvbHVtbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZHJhZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZ3JpZC1kcmFnZ2FibGUtaGVhZGVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIERyYWdnYWJsZUNvbHVtbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIG51bGwpO1xuRHJhZ2dhYmxlQ29sdW1uRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9EcmFnZ2FibGVDb2x1bW5dJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgSG9zdCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RyYWdnYWJsZURpcmVjdGl2ZSxcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgTmdab25lLFxuICAgICAgICBEcmFnQW5kRHJvcFNlcnZpY2UsXG4gICAgICAgIERyYWdIaW50U2VydmljZSxcbiAgICAgICAgRHJvcEN1ZVNlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjJdKVxuXSwgRHJhZ2dhYmxlQ29sdW1uRGlyZWN0aXZlKTtcblxuY29uc3QgZXhwb3J0ZWQgPSBbXG4gICAgRHJhZ2dhYmxlQ29sdW1uRGlyZWN0aXZlLFxuICAgIERyb3BUYXJnZXREaXJlY3RpdmVcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERyYWdBbmREcm9wTW9kdWxlID0gY2xhc3MgRHJhZ0FuZERyb3BNb2R1bGUge1xufTtcbkRyYWdBbmREcm9wTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtleHBvcnRlZF0sXG4gICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZF1cbiAgICB9KVxuXSwgRHJhZ0FuZERyb3BNb2R1bGUpO1xuXG5jb25zdCBleHBvcnRlZE1vZHVsZXMkMSA9IFtcbiAgICBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBHcm91cEhlYWRlckNvbXBvbmVudCxcbiAgICBHcm91cFBhbmVsQ29tcG9uZW50LFxuICAgIEdyb3VwSW5kaWNhdG9yQ29tcG9uZW50XG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBHcm91cE1vZHVsZSA9IGNsYXNzIEdyb3VwTW9kdWxlIHtcbiAgICBzdGF0aWMgZXhwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZVxuICAgICAgICBdO1xuICAgIH1cbn07XG5Hcm91cE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbZXhwb3J0ZWRNb2R1bGVzJDFdLFxuICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDFdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBTaGFyZWRNb2R1bGUsIERyYWdBbmREcm9wTW9kdWxlXVxuICAgIH0pXG5dLCBHcm91cE1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBERUZBVUxUUyA9IHtcbiAgICBhbGxvd1Vuc29ydDogdHJ1ZSxcbiAgICBtb2RlOiAnc2luZ2xlJyxcbiAgICBzaG93SW5kZXhlczogdHJ1ZSxcbiAgICBpbml0aWFsRGlyZWN0aW9uOiAnYXNjJyxcbiAgICBtdWx0aVNvcnRLZXk6ICdub25lJ1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3JtYWxpemUkMSA9ICguLi5zZXR0aW5ncykgPT4gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFMsIC4uLnNldHRpbmdzKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc0ZpbHRlciA9IChzZXR0aW5ncywgY29sdW1uKSA9PiBzZXR0aW5ncy5maWx0ZXIgIT09IGZhbHNlICYmIGNvbHVtbi5maWVsZCAmJiBjb2x1bW4uZmlsdGVyYWJsZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNTb3J0ID0gKHNldHRpbmdzLCBjb2x1bW4pID0+IHNldHRpbmdzLnNvcnQgIT09IGZhbHNlICYmIGNvbHVtbi5maWVsZCAmJiBjb2x1bW4uc29ydGFibGU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzTG9jayA9IChzZXR0aW5ncywgY29sdW1uKSA9PiBzZXR0aW5ncy5sb2NrICYmIGNvbHVtbi5sb2NrYWJsZSAmJiAhKGNvbHVtbi5wYXJlbnQgJiYgIWNvbHVtbi5wYXJlbnQuaXNTcGFuQ29sdW1uKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNTdGljayA9IChzZXR0aW5ncywgY29sdW1uKSA9PiBzZXR0aW5ncy5zdGljayAmJiBjb2x1bW4uc3RpY2thYmxlICYmICEoY29sdW1uLnBhcmVudCAmJiAhY29sdW1uLnBhcmVudC5pc1NwYW5Db2x1bW4pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc1Bvc2l0aW9uID0gKHNldHRpbmdzLCBjb2x1bW4pID0+IHNldHRpbmdzLnNldENvbHVtblBvc2l0aW9uICYmIChjb2x1bW4uc3RpY2thYmxlIHx8IGNvbHVtbi5sb2NrYWJsZSkgJiYgIShjb2x1bW4ucGFyZW50ICYmICFjb2x1bW4ucGFyZW50LmlzU3BhbkNvbHVtbik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzQ29sdW1uQ2hvb3NlciA9IChzZXR0aW5ncykgPT4gc2V0dGluZ3MuY29sdW1uQ2hvb3NlciAhPT0gZmFsc2U7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzSXRlbXMgPSAoc2V0dGluZ3MsIGNvbHVtbikgPT4gaGFzQ29sdW1uQ2hvb3NlcihzZXR0aW5ncykgfHwgaGFzTG9jayhzZXR0aW5ncywgY29sdW1uKSB8fCBoYXNTb3J0KHNldHRpbmdzLCBjb2x1bW4pIHx8IGhhc0ZpbHRlcihzZXR0aW5ncywgY29sdW1uKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBGaWx0ZXJNZW51Q29tcG9uZW50ID0gY2xhc3MgRmlsdGVyTWVudUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgcG9wdXBTZXJ2aWNlLCBsb2NhbGl6YXRpb24sIG5hdmlnYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyU2VydmljZSA9IGZpbHRlclNlcnZpY2U7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gJy0xJztcbiAgICB9XG4gICAgZ2V0IGhhc0ZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzQnlGaWVsZCh0aGlzLmZpbHRlciwgKHRoaXMuY29sdW1uIHx8IHt9KS5maWVsZCkubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBmaWx0ZXJMYWJlbCgpIHtcbiAgICAgICAgY29uc3QgbG9jYWxpemF0aW9uTXNnID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdmaWx0ZXJNZW51VGl0bGUnKSB8fCAnJztcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uLnRpdGxlIHx8IHRoaXMuY29sdW1uLmZpZWxkO1xuICAgICAgICByZXR1cm4gcmVwbGFjZU1lc3NhZ2VQbGFjZWhvbGRlcihsb2NhbGl6YXRpb25Nc2csICdjb2x1bW5OYW1lJywgY29sdW1uTmFtZSk7XG4gICAgfVxuICAgIHRvZ2dsZShhbmNob3IsIHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKGFuY2hvciwgdGVtcGxhdGUsIHRoaXMucG9wdXBSZWYpO1xuICAgICAgICBpZiAoIXRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzQ2VsbCgwLCB0aGlzLmNvbHVtbi5sZWFmSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmNob3IubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5mb2N1c0NlbGwoMCwgdGhpcy5jb2x1bW4ubGVhZkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5Db21wb25lbnQpXG5dLCBGaWx0ZXJNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdhbmNob3InLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIEZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImFuY2hvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCd0ZW1wbGF0ZScsIHsgc3RhdGljOiB0cnVlLCByZWFkOiBUZW1wbGF0ZVJlZiB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBGaWx0ZXJNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmlsdGVyTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgdm9pZCAwKTtcbkZpbHRlck1lbnVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWdyaWQtZmlsdGVyLW1lbnUnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YSAjYW5jaG9yXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7J2stZ3JpZC1maWx0ZXInOnRydWUsICdrLXN0YXRlLWFjdGl2ZSc6IGhhc0ZpbHRlcnN9XCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJJbmRleFwiXG4gICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlKGFuY2hvciwgdGVtcGxhdGUpXCJcbiAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cIiRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgICBocmVmPVwiI1wiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJmaWx0ZXJMYWJlbFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLWZpbHRlclwiPjwvc3Bhbj5cbiAgICAgICAgPC9hPlxuICAgICAgICA8bmctdGVtcGxhdGUgI3RlbXBsYXRlPlxuICAgICAgICAgICAgPGtlbmRvLWdyaWQtZmlsdGVyLW1lbnUtY29udGFpbmVyXG4gICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgICAgICAoY2xvc2UpPVwiY2xvc2UoKVwiXG4gICAgICAgICAgICAgICAgKGtleWRvd24uZXNjYXBlKT1cImNsb3NlKClcIlxuICAgICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cIiRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1ncmlkLWZpbHRlci1tZW51LWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICBTaW5nbGVQb3B1cFNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlXSlcbl0sIEZpbHRlck1lbnVDb21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHNlcnZpY2UgdGhhdCBpcyBwYXNzZWQgdG8gdGhlXG4gKiBbQ29sdW1uTWVudVRlbXBsYXRlXSh7JSBzbHVnIGFwaV9ncmlkX2NvbHVtbm1lbnV0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgPGtlbmRvLWdyaWQgW2RhdGFdPVwiZGF0YVwiIFtjb2x1bW5NZW51XT1cInRydWVcIj5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDb2x1bW5NZW51VGVtcGxhdGUgbGV0LXNlcnZpY2U9XCJzZXJ2aWNlXCI+XG4gKiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLWNsb3NlXCIgKGNsaWNrKT1cInNlcnZpY2UuY2xvc2UoKVwiXG4gKiAgICAgICAgICAgICAgICAgIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyByaWdodDogNXB4OyB0b3A6IDVweDtjdXJzb3I6IHBvaW50ZXI7XCI+PC9zcGFuPlxuICogICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbm1lbnUtc29ydCBbc2VydmljZV09XCJzZXJ2aWNlXCI+XG4gKiAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbm1lbnUtc29ydD5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJGaWVsZDFcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiRmllbGQyXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFt7IEZpZWxkMTogJ0ZvbycsIEZpZWxkMjogJ0JhcicgfV07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBDb2x1bW5NZW51U2VydmljZSA9IGNsYXNzIENvbHVtbk1lbnVTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVudVRhYmJpbmdTZXJ2aWNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlTWVudSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5tZW51VGFiYmluZ1NlcnZpY2UgPSBtZW51VGFiYmluZ1NlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY29sdW1uIG1lbnUuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VNZW51LmVtaXQoKTtcbiAgICB9XG59O1xuQ29sdW1uTWVudVNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtNZW51VGFiYmluZ1NlcnZpY2VdKVxuXSwgQ29sdW1uTWVudVNlcnZpY2UpO1xuXG5jb25zdCBQT1BVUF9DTEFTUyA9ICdrLWdyaWQtY29sdW1ubWVudS1wb3B1cCc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtjb2x1bW4gbWVudV0oeyUgc2x1ZyBjb2x1bW5tZW51X2dyaWQgJX0pIGNvbXBvbmVudC5cbiAqL1xubGV0IENvbHVtbk1lbnVDb21wb25lbnQgPSBjbGFzcyBDb2x1bW5NZW51Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UsIGxvY2FsaXphdGlvbiwgc2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlID0gbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW5kYWxvbmUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNldHRpbmdzIGZvciB0aGUgQ29sdW1uIE1lbnUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldHRpbmdzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFiSW5kZXggPSAnLTEnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZEZpbHRlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZENvbHVtbnMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWRQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsb3NlU3Vic2NyaXB0aW9uID0gc2VydmljZS5jbG9zZU1lbnUuc3Vic2NyaWJlKHRoaXMuY2xvc2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5oYXNGaWx0ZXIgJiYgZmlsdGVyc0J5RmllbGQodGhpcy5maWx0ZXIsIHRoaXMuY29sdW1uLmZpZWxkKS5sZW5ndGggPiAwKSB8fFxuICAgICAgICAgICAgKCF0aGlzLnNvcnRhYmxlICYmIHRoaXMuaGFzU29ydCAmJiB0aGlzLnNvcnQuZmluZChkZXNjcmlwdG9yID0+IGRlc2NyaXB0b3IuZmllbGQgPT09IHRoaXMuY29sdW1uLmZpZWxkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaGFzRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gaGFzRmlsdGVyKHRoaXMuc2V0dGluZ3MsIHRoaXMuY29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBoYXNTb3J0KCkge1xuICAgICAgICByZXR1cm4gaGFzU29ydCh0aGlzLnNldHRpbmdzLCB0aGlzLmNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaGFzQ29sdW1uQ2hvb3NlcigpIHtcbiAgICAgICAgcmV0dXJuIGhhc0NvbHVtbkNob29zZXIodGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaGFzTG9jaygpIHtcbiAgICAgICAgcmV0dXJuIGhhc0xvY2sodGhpcy5zZXR0aW5ncywgdGhpcy5jb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhhc1N0aWNrKCkge1xuICAgICAgICByZXR1cm4gaGFzU3RpY2sodGhpcy5zZXR0aW5ncywgdGhpcy5jb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhhc1Bvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGFzUG9zaXRpb24odGhpcy5zZXR0aW5ncywgdGhpcy5jb2x1bW4pO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmNvbHVtbiA9IHRoaXMuY29sdW1uO1xuICAgICAgICB0aGlzLnNlcnZpY2Uuc29ydCA9IHRoaXMuc29ydDtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmZpbHRlciA9IHRoaXMuZmlsdGVyO1xuICAgICAgICB0aGlzLnNlcnZpY2Uuc29ydGFibGUgPSB0aGlzLnNvcnRhYmxlO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0b2dnbGUoZSwgYW5jaG9yLCB0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGFuZGVkRmlsdGVyID0gdGhpcy5nZXRFeHBhbmRlZFN0YXRlKHRoaXMuc2V0dGluZ3MuZmlsdGVyKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZENvbHVtbnMgPSB0aGlzLmdldEV4cGFuZGVkU3RhdGUodGhpcy5zZXR0aW5ncy5jb2x1bW5DaG9vc2VyKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZFBvc2l0aW9uID0gdGhpcy5nZXRFeHBhbmRlZFN0YXRlKHRoaXMuc2V0dGluZ3Muc2V0Q29sdW1uUG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3BlbihhbmNob3IsIHRlbXBsYXRlLCB0aGlzLnBvcHVwUmVmLCBQT1BVUF9DTEFTUyk7XG4gICAgICAgIGlmICghdGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZm9jdXNDZWxsKDAsIHRoaXMuY29sdW1uLmxlYWZJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvci5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzQ2VsbCgwLCB0aGlzLmNvbHVtbi5sZWFmSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbmNob3IubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY29sdW1uTWVudVRpdGxlKCkge1xuICAgICAgICBjb25zdCBsb2NhbGl6YXRpb25Nc2cgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2NvbHVtbk1lbnUnKSB8fCAnJztcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uLnRpdGxlIHx8IHRoaXMuY29sdW1uLmZpZWxkO1xuICAgICAgICByZXR1cm4gcmVwbGFjZU1lc3NhZ2VQbGFjZWhvbGRlcihsb2NhbGl6YXRpb25Nc2csICdjb2x1bW5OYW1lJywgY29sdW1uTmFtZSk7XG4gICAgfVxuICAgIGdldEV4cGFuZGVkU3RhdGUobWVudUl0ZW1TZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIChtZW51SXRlbVNldHRpbmdzKSA9PT0gJ29iamVjdCcgPyBtZW51SXRlbVNldHRpbmdzLmV4cGFuZGVkIDogZmFsc2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWdyaWQtY29sdW1uLW1lbnUtc3RhbmRhbG9uZScpLFxuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5NZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFuZGFsb25lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5NZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbk1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcInNldHRpbmdzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5NZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzb3J0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5NZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbk1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcInNvcnRhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIENvbHVtbk1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbk1lbnVUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sdW1uTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnYW5jaG9yJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBDb2x1bW5NZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmNob3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgndGVtcGxhdGUnLCB7IHN0YXRpYzogdHJ1ZSwgcmVhZDogVGVtcGxhdGVSZWYgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgQ29sdW1uTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwidGVtcGxhdGVcIiwgdm9pZCAwKTtcbkNvbHVtbk1lbnVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIENvbHVtbk1lbnVTZXJ2aWNlLFxuICAgICAgICAgICAgTWVudVRhYmJpbmdTZXJ2aWNlXG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1jb2x1bW4tbWVudScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxhICNhbmNob3JcbiAgICAgICAgICAgIGNsYXNzPVwiay1ncmlkLWNvbHVtbi1tZW51IGstZ3JpZC1maWx0ZXJcIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwieyAnay1zdGF0ZS1hY3RpdmUnOiBpc0FjdGl2ZSB9XCJcbiAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGUoJGV2ZW50LCBhbmNob3IsIHRlbXBsYXRlKVwiXG4gICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCIkZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgICAgaHJlZj1cIiNcIlxuICAgICAgICAgICAgW3RhYmluZGV4XT1cInRhYkluZGV4XCJcbiAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImNvbHVtbk1lbnVUaXRsZVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLW1vcmUtdmVydGljYWxcIj48L3NwYW4+XG4gICAgICAgIDwvYT5cbiAgICAgICAgPG5nLXRlbXBsYXRlICN0ZW1wbGF0ZT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4uY29sdW1uTWVudVRlbXBsYXRlUmVmIHx8IGNvbHVtbk1lbnVUZW1wbGF0ZSB8fCBkZWZhdWx0VGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7IHNlcnZpY2U6IHNlcnZpY2UsIGNvbHVtbjogY29sdW1uIH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRUZW1wbGF0ZT5cbiAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbm1lbnUtY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKGtleWRvd24uZXNjYXBlKT1cImNsb3NlKClcIlxuICAgICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cIiRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVwiPlxuICAgICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbm1lbnUtc29ydCAjc29ydEl0ZW0gW2tlbmRvR3JpZENvbHVtbk1lbnVJdGVtXT1cInNvcnRJdGVtXCIgKm5nSWY9XCJoYXNTb3J0XCIgW3NlcnZpY2VdPVwic2VydmljZVwiPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LXNvcnQ+XG4gICAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubWVudS1sb2NrICNsb2NrSXRlbSAqbmdJZj1cImhhc0xvY2sgJiYgIWhhc1Bvc2l0aW9uXCIgW2tlbmRvR3JpZENvbHVtbk1lbnVJdGVtXT1cImxvY2tJdGVtXCIgW3NlcnZpY2VdPVwic2VydmljZVwiPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LWxvY2s+XG4gICAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubWVudS1zdGljayAjc3RpY2tJdGVtICpuZ0lmPVwiaGFzU3RpY2sgJiYgIWhhc1Bvc2l0aW9uXCIgW2tlbmRvR3JpZENvbHVtbk1lbnVJdGVtXT1cInN0aWNrSXRlbVwiIFtzZXJ2aWNlXT1cInNlcnZpY2VcIj5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1zdGljaz5cbiAgICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICNwb3NpdGlvbkl0ZW1cbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNQb3NpdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIFtzaG93TG9ja109XCJoYXNMb2NrXCJcbiAgICAgICAgICAgICAgICAgICAgW3Nob3dTdGlja109XCJoYXNTdGlja1wiXG4gICAgICAgICAgICAgICAgICAgIFtrZW5kb0dyaWRDb2x1bW5NZW51SXRlbV09XCJwb3NpdGlvbkl0ZW1cIlxuICAgICAgICAgICAgICAgICAgICBbc2VydmljZV09XCJzZXJ2aWNlXCJcbiAgICAgICAgICAgICAgICAgICAgW2V4cGFuZGVkXT1cImV4cGFuZGVkUG9zaXRpb25cIj5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1wb3NpdGlvbj5cbiAgICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LWNob29zZXJcbiAgICAgICAgICAgICAgICAgICAgI2Nob29zZXJJdGVtXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzQ29sdW1uQ2hvb3NlclwiXG4gICAgICAgICAgICAgICAgICAgIFtrZW5kb0dyaWRDb2x1bW5NZW51SXRlbV09XCJjaG9vc2VySXRlbVwiXG4gICAgICAgICAgICAgICAgICAgIFtzZXJ2aWNlXT1cInNlcnZpY2VcIlxuICAgICAgICAgICAgICAgICAgICBbZXhwYW5kZWRdPVwiZXhwYW5kZWRDb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbm1lbnUtY2hvb3Nlcj5cbiAgICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LWZpbHRlclxuICAgICAgICAgICAgICAgICAgICAjZmlsdGVySXRlbVxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0ZpbHRlclwiXG4gICAgICAgICAgICAgICAgICAgIFtrZW5kb0dyaWRDb2x1bW5NZW51SXRlbV09XCJmaWx0ZXJJdGVtXCJcbiAgICAgICAgICAgICAgICAgICAgW3NlcnZpY2VdPVwic2VydmljZVwiXG4gICAgICAgICAgICAgICAgICAgIFtleHBhbmRlZF09XCJleHBhbmRlZEZpbHRlclwiPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LWZpbHRlcj5cbiAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTaW5nbGVQb3B1cFNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIENvbHVtbk1lbnVTZXJ2aWNlLFxuICAgICAgICBOYXZpZ2F0aW9uU2VydmljZV0pXG5dLCBDb2x1bW5NZW51Q29tcG9uZW50KTtcblxuY29uc3QgbWVyZ2VPYmplY3RzID0gKC4uLmFyZ3MpID0+IE9iamVjdC5hc3NpZ24uYXBwbHkobnVsbCwgW3t9XS5jb25jYXQoYXJncykpO1xuY29uc3QgZGlyZWN0aW9ucyA9IGluaXRpYWxEaXJlY3Rpb24gPT4gaW5pdGlhbERpcmVjdGlvbiA9PT0gXCJhc2NcIiA/IFtcImFzY1wiLCBcImRlc2NcIl0gOiBbXCJkZXNjXCIsIFwiYXNjXCJdO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzUm9vdExldmVsID0gKHsgcGFyZW50IH0pID0+ICFpc1RydXRoeShwYXJlbnQpO1xuY29uc3Qgb2ZDb2x1bW5UeXBlID0gKHsgZHJhZ2dhYmxlIH0pID0+IFsnY29sdW1uJywgJ2NvbHVtbkdyb3VwJ11cbiAgICAuaW5kZXhPZihkcmFnZ2FibGUuY29udGV4dC50eXBlKSA+PSAwO1xuY29uc3Qgbm90U2FtZUVsZW1lbnQgPSAoeyBkcmFnZ2FibGUsIHRhcmdldCB9KSA9PiBkcmFnZ2FibGUuZWxlbWVudC5uYXRpdmVFbGVtZW50ICE9PSB0YXJnZXQuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuY29uc3QgaW5TYW1lUGFyZW50ID0gKHgsIHkpID0+IHgucGFyZW50ID09PSB5LnBhcmVudCB8fFxuICAgIChpc0luU3BhbkNvbHVtbih5KSAmJiBpblNhbWVQYXJlbnQoeCwgeS5wYXJlbnQpKTtcbmNvbnN0IHNhbWVQYXJlbnQgPSAoeyBkcmFnZ2FibGUsIHRhcmdldCB9KSA9PiBpblNhbWVQYXJlbnQoZHJhZ2dhYmxlLmNvbnRleHQuY29sdW1uLCB0YXJnZXQuY29udGV4dC5jb2x1bW4pO1xuY29uc3QgbGFzdE5vbkxvY2tlZCA9ICh7IGRyYWdnYWJsZSB9KSA9PiAhaXNUcnV0aHkoZHJhZ2dhYmxlLmNvbnRleHQuY29sdW1uLmxvY2tlZCkgJiZcbiAgICBpc1Jvb3RMZXZlbChkcmFnZ2FibGUuY29udGV4dC5jb2x1bW4pICYmXG4gICAgZHJhZ2dhYmxlLmNvbnRleHQubGFzdENvbHVtbjtcbmNvbnN0IG5vdEluU3BhbkNvbHVtbiA9ICh7IGRyYWdnYWJsZSB9KSA9PiAhaXNJblNwYW5Db2x1bW4oZHJhZ2dhYmxlLmNvbnRleHQuY29sdW1uKTtcbmNvbnN0IHJlb3JkZXJhYmxlID0gKHsgZHJhZ2dhYmxlIH0pID0+IGRyYWdnYWJsZS5jb250ZXh0LmNvbHVtbi5yZW9yZGVyYWJsZTtcbmNvbnN0IGxvY2thYmxlID0gKHsgZHJhZ2dhYmxlLCB0YXJnZXQgfSkgPT4gZHJhZ2dhYmxlLmNvbnRleHQuY29sdW1uLmxvY2thYmxlICE9PSBmYWxzZSB8fFxuICAgIGRyYWdnYWJsZS5jb250ZXh0LmNvbHVtbi5pc0xvY2tlZCA9PT0gdGFyZ2V0LmNvbnRleHQuY29sdW1uLmlzTG9ja2VkO1xuY29uc3QgcnVsZXMgPSBhbmQob2ZDb2x1bW5UeXBlLCByZW9yZGVyYWJsZSwgbm90SW5TcGFuQ29sdW1uLCBub3RTYW1lRWxlbWVudCwgc2FtZVBhcmVudCwgbm90KGxhc3ROb25Mb2NrZWQpLCBsb2NrYWJsZSk7XG5jb25zdCBtb2RpZmllcktleXMgPSBbJ2FsdCcsICdjdHJsJywgJ3NoaWZ0JywgJ21ldGEnXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgSGVhZGVyQ29tcG9uZW50ID0gY2xhc3MgSGVhZGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UsIGhpbnQsIGN1ZSwgcmVvcmRlclNlcnZpY2UsIGlkU2VydmljZSwgc29ydFNlcnZpY2UsIGxvY2FsaXphdGlvbiwgY29sdW1uSW5mb1NlcnZpY2UsIGNkKSB7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLmhpbnQgPSBoaW50O1xuICAgICAgICB0aGlzLmN1ZSA9IGN1ZTtcbiAgICAgICAgdGhpcy5yZW9yZGVyU2VydmljZSA9IHJlb3JkZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLmlkU2VydmljZSA9IGlkU2VydmljZTtcbiAgICAgICAgdGhpcy5zb3J0U2VydmljZSA9IHNvcnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZSA9IGNvbHVtbkluZm9TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IFtdO1xuICAgICAgICB0aGlzLnNvcnQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zb3J0YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdyb3VwYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvY2tlZENvbHVtbnNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVzaXphYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVvcmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2x1bW5NZW51ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG90YWxDb2x1bW5zQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnNvcnRlZEZpZWxkcyA9IHt9O1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXRzID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgZ2V0IGhlYWRlckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc2Nyb2xsYWJsZTtcbiAgICB9XG4gICAgZ2V0IHNvcnRhYmxlTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ3NvcnRhYmxlJyk7XG4gICAgfVxuICAgIC8vIE51bWJlciBvZiB1bmxvY2tlZCBjb2x1bW5zIGluIHRoZSBuZXh0IHRhYmxlLCBpZiBhbnlcbiAgICBnZXQgdW5sb2NrZWRDb2x1bW5zQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29sdW1uc0NvdW50IC0gdGhpcy5sb2NrZWRDb2x1bW5zQ291bnQgLSB0aGlzLmNvbHVtbnMubGVuZ3RoO1xuICAgIH1cbiAgICBzb3J0Q29sdW1uKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgdGhpcy5zb3J0U2VydmljZS5zb3J0KGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgICBvblNvcnRDbGljayhjb2x1bW4sIGV2ZW50LCBsaW5rKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKGNvbHVtbi5oZWFkZXJUZW1wbGF0ZVJlZiAmJiB0YXJnZXQgIT09IGxpbmspIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc0ZvY3VzYWJsZVBhcmVudCA9IEJvb2xlYW4oY2xvc2VzdEluU2NvcGUodGFyZ2V0LCBpc0ZvY3VzYWJsZSwgbGluaykpO1xuICAgICAgICAgICAgaWYgKGhhc0ZvY3VzYWJsZVBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzb3J0IHdoZW4gY2xpY2tpbmcgZm9jdXNhYmxlIHRlbXBsYXRlIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RpZmllciA9IHRoaXMubWF0Y2hNb2RpZmllcihldmVudCk7XG4gICAgICAgIGNvbnN0IHRvZ2dsZWRDb2x1bW4gPSB0aGlzLnRvZ2dsZVNvcnQoY29sdW1uLCBtb2RpZmllcik7XG4gICAgICAgIHRoaXMuc29ydENvbHVtbih0b2dnbGVkQ29sdW1uKTtcbiAgICB9XG4gICAgb25IZWFkZXJLZXlkb3duKGNvbHVtbiwgYXJncykge1xuICAgICAgICBpZiAoYXJncy5rZXlDb2RlID09PSBLZXlzLkFycm93RG93biAmJiBhcmdzLmFsdEtleSAmJiB0aGlzLnNob3dGaWx0ZXJNZW51KSB7XG4gICAgICAgICAgICBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBhcmdzLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyTWVudSA9IHRoaXMuZmlsdGVyTWVudXMuZmluZChmbSA9PiBmbS5jb2x1bW4gPT09IGNvbHVtbik7XG4gICAgICAgICAgICBmaWx0ZXJNZW51LnRvZ2dsZShmaWx0ZXJNZW51LmFuY2hvci5uYXRpdmVFbGVtZW50LCBmaWx0ZXJNZW51LnRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5rZXlDb2RlID09PSBLZXlzLkFycm93RG93biAmJiBhcmdzLmFsdEtleSAmJiB0aGlzLnNob3dDb2x1bW5NZW51KGNvbHVtbikpIHtcbiAgICAgICAgICAgIGFyZ3MucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGFyZ3Muc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5NZW51ID0gdGhpcy5jb2x1bW5NZW51cy5maW5kKGNtID0+IGNtLmNvbHVtbiA9PT0gY29sdW1uKTtcbiAgICAgICAgICAgIGNvbHVtbk1lbnUudG9nZ2xlKG51bGwsIGNvbHVtbk1lbnUuYW5jaG9yLm5hdGl2ZUVsZW1lbnQsIGNvbHVtbk1lbnUudGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zb3J0YWJsZSB8fCBhcmdzLmRlZmF1bHRQcmV2ZW50ZWQgfHwgY29sdW1uLnNvcnRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuRW50ZXIgJiYgaXNQcmVzZW50KGNvbHVtbi5maWVsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyID0gdGhpcy5tYXRjaE1vZGlmaWVyKGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5zb3J0U2VydmljZS5zb3J0KHRoaXMudG9nZ2xlU29ydChjb2x1bW4sIG1vZGlmaWVyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvd1NvcnROdW1iZXJpbmcoY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IHsgc2hvd0luZGV4ZXMgfSA9IG5vcm1hbGl6ZSQxKHRoaXMuc29ydGFibGUpO1xuICAgICAgICByZXR1cm4gc2hvd0luZGV4ZXNcbiAgICAgICAgICAgICYmIHRoaXMuc29ydFxuICAgICAgICAgICAgJiYgdGhpcy5zb3J0LmZpbHRlcigoeyBkaXIgfSkgPT4gaXNQcmVzZW50KGRpcikpLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICYmIHRoaXMuc29ydE9yZGVyKGNvbHVtbi5maWVsZCkgPiAwO1xuICAgIH1cbiAgICBzb3J0T3JkZXIoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydFxuICAgICAgICAgICAgLmZpbHRlcigoeyBkaXIgfSkgPT4gaXNQcmVzZW50KGRpcikpXG4gICAgICAgICAgICAuZmluZEluZGV4KHggPT4geC5maWVsZCA9PT0gZmllbGQpXG4gICAgICAgICAgICArIDE7XG4gICAgfVxuICAgIHNvcnRJY29uKGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlJCQxID0gdGhpcy5zb3J0RGVzY3JpcHRvcihmaWVsZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnay1pY29uJzogaXNQcmVzZW50KHN0YXRlJCQxLmRpciksXG4gICAgICAgICAgICAnay1pLXNvcnQtZGVzYy1zbSc6IHN0YXRlJCQxLmRpciA9PT0gXCJkZXNjXCIsXG4gICAgICAgICAgICAnay1pLXNvcnQtYXNjLXNtJzogc3RhdGUkJDEuZGlyID09PSBcImFzY1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNvcnRTdGF0ZShjb2x1bW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU29ydGFibGUoY29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlJCQxID0gdGhpcy5zb3J0RGVzY3JpcHRvcihjb2x1bW4uZmllbGQpO1xuICAgICAgICBpZiAoc3RhdGUkJDEuZGlyID09PSAnYXNjJykge1xuICAgICAgICAgICAgcmV0dXJuICdhc2NlbmRpbmcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSQkMS5kaXIgPT09ICdkZXNjJykge1xuICAgICAgICAgICAgcmV0dXJuICdkZXNjZW5kaW5nJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzb3J0U3RhdHVzKGNvbHVtbikge1xuICAgICAgICBpZiAoIXRoaXMuc29ydGVkRmllbGRzW2NvbHVtbi5maWVsZF0gfHwgIXRoaXMuaXNTb3J0YWJsZShjb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1zZyA9ICdzb3J0ZWREZWZhdWx0JztcbiAgICAgICAgY29uc3Qgc3RhdGUkJDEgPSB0aGlzLnNvcnREZXNjcmlwdG9yKGNvbHVtbi5maWVsZCk7XG4gICAgICAgIGlmIChzdGF0ZSQkMS5kaXIgPT09ICdhc2MnKSB7XG4gICAgICAgICAgICBtc2cgPSAnc29ydGVkQXNjZW5kaW5nJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSQkMS5kaXIgPT09ICdkZXNjJykge1xuICAgICAgICAgICAgbXNnID0gJ3NvcnRlZERlc2NlbmRpbmcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQobXNnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uXG4gICAgICogQHBhcmFtIG1vZGlmaWVyIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNsaWVudC1kZWZpbmVkIGBtdWx0aVNvcnRLZXlgIG1vZGlmaWVyIGlzIG1ldC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgICAqIEByZXR1cm5zIC0gU29ydERlc2NyaXB0b3JbXVxuICAgICAqL1xuICAgIHRvZ2dsZVNvcnQoY29sdW1uLCBtb2RpZmllciA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd1Vuc29ydCwgbW9kZSwgaW5pdGlhbERpcmVjdGlvbiB9ID0gbm9ybWFsaXplJDEodGhpcy5zb3J0YWJsZSwgY29sdW1uLnNvcnRhYmxlKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMudG9nZ2xlRGlyZWN0aW9uKGNvbHVtbi5maWVsZCwgYWxsb3dVbnNvcnQsIGluaXRpYWxEaXJlY3Rpb24pO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ3NpbmdsZScgfHwgIW1vZGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Rlc2NyaXB0b3JdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5zb3J0LmZpbHRlcihkZXNjID0+IGRlc2MuZmllbGQgIT09IGNvbHVtbi5maWVsZCksIGRlc2NyaXB0b3JdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgbW9kaWZpZXIga2V5IChpZiBhbnkpIHBhc3NlZFxuICAgICAqIHdpdGggYSBjbGljay9rZXlib2FyZCBldmVudCBtYXRjaGVzIHRoZSB1c2VyLWRlZmluZWQgbXVsdGlTb3J0S2V5LlxuICAgICAqL1xuICAgIG1hdGNoTW9kaWZpZXIoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBtdWx0aVNvcnRLZXkgfSA9IG5vcm1hbGl6ZSQxKHRoaXMuc29ydGFibGUpO1xuICAgICAgICBpZiAobXVsdGlTb3J0S2V5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RpZmllcktleXMuZXZlcnkoa2V5ID0+ICFldmVudFtgJHtrZXl9S2V5YF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtdWx0aVNvcnRLZXkgPT09ICdjdHJsJ1xuICAgICAgICAgICAgPyBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXlcbiAgICAgICAgICAgIDogZXZlbnRbYCR7bXVsdGlTb3J0S2V5fUtleWBdO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChvYnNlcnZlKHRoaXMuZHJvcFRhcmdldHMpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuYXR0YWNoVGFyZ2V0cy5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgdGhpcy5fbGVhZkNvbHVtbnMgPSBjb2x1bW5zVG9SZW5kZXIodGhpcy5jb2x1bW5zIHx8IFtdKS5maWx0ZXIoeCA9PiAhaXNDb2x1bW5Hcm91cENvbXBvbmVudCh4KSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgc29ydENoYW5nZSA9IGNoYW5nZXMuc29ydDtcbiAgICAgICAgaWYgKHNvcnRDaGFuZ2UgJiYgIXNvcnRDaGFuZ2UuaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICAgICAgICBzb3J0Q2hhbmdlLmN1cnJlbnRWYWx1ZS5mb3JFYWNoKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0ZWRGaWVsZHNbY2hhbmdlLmZpZWxkXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24uYWRkKHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZC5tYXJrRm9yQ2hlY2soKSkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcHVwU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHNlbGVjdEFsbENoZWNrYm94SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkU2VydmljZS5zZWxlY3RBbGxDaGVja2JveElkKCk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RBbGxDaGVja2JveExhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdzZWxlY3RBbGxDaGVja2JveExhYmVsJyk7XG4gICAgfVxuICAgIGlzRmlyc3RPblJvdyhjb2x1bW4sIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGlzVGFpbGluZyA9IChjKSA9PiBjICYmXG4gICAgICAgICAgICAodGhpcy5jb2x1bW5zRm9yTGV2ZWwoYy5sZXZlbCkuaW5kZXhPZihjKSA+IDAgfHwgaXNUYWlsaW5nKGMucGFyZW50KSk7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gMCAmJiAhdGhpcy5ncm91cHMubGVuZ3RoICYmICF0aGlzLmRldGFpbFRlbXBsYXRlICYmIGlzVGFpbGluZyhjb2x1bW4ucGFyZW50KTtcbiAgICB9XG4gICAgbG9naWNhbENvbHVtbkluZGV4KGNvbHVtbikge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNvbHVtbi5sZWFmSW5kZXg7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggKyAoaXNQcmVzZW50KHRoaXMuZGV0YWlsVGVtcGxhdGUpID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZ2V0IHNob3dGaWx0ZXJNZW51KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sdW1uTWVudSAmJiBoYXNGaWx0ZXJNZW51KHRoaXMuZmlsdGVyYWJsZSk7XG4gICAgfVxuICAgIGdldCBzaG93RmlsdGVyUm93KCkge1xuICAgICAgICByZXR1cm4gaGFzRmlsdGVyUm93KHRoaXMuZmlsdGVyYWJsZSk7XG4gICAgfVxuICAgIHNob3dDb2x1bW5NZW51KGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5NZW51ICYmIGNvbHVtbi5jb2x1bW5NZW51ICYmXG4gICAgICAgICAgICAodGhpcy5jb2x1bW5NZW51VGVtcGxhdGUgfHwgY29sdW1uLmNvbHVtbk1lbnVUZW1wbGF0ZXMubGVuZ3RoIHx8IGhhc0l0ZW1zKHRoaXMuY29sdW1uTWVudSwgY29sdW1uKSk7XG4gICAgfVxuICAgIGlzRmlsdGVyYWJsZShjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuICFpc051bGxPckVtcHR5U3RyaW5nKGNvbHVtbi5maWVsZCkgJiYgY29sdW1uLmZpbHRlcmFibGUgPT09IHRydWU7XG4gICAgfVxuICAgIGNhbkRyb3AoZHJhZ2dhYmxlLCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVvcmRlcmFibGUgJiYgcnVsZXMoeyBkcmFnZ2FibGUsIHRhcmdldCB9KTtcbiAgICB9XG4gICAgc2hvdWxkQWN0aXZhdGUoY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IGNhblJlb3JkZXIgPSB0aGlzLnJlb3JkZXJhYmxlICYmIGNvbHVtbi5yZW9yZGVyYWJsZTtcbiAgICAgICAgaWYgKCFjYW5SZW9yZGVyICYmICFpc0NvbHVtbkNvbXBvbmVudChjb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JvdXBhYmxlID0gdGhpcy5ncm91cGFibGUgJiYgaXNDb2x1bW5Db21wb25lbnQoY29sdW1uKSAmJiBjb2x1bW4uZ3JvdXBhYmxlICE9PSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGdyb3VwYWJsZSB8fCBjYW5SZW9yZGVyO1xuICAgIH1cbiAgICBpc1NvcnRhYmxlKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gIWlzTnVsbE9yRW1wdHlTdHJpbmcoY29sdW1uLmZpZWxkKVxuICAgICAgICAgICAgJiYgaXNUcnV0aHkodGhpcy5zb3J0YWJsZSkgJiYgaXNUcnV0aHkoY29sdW1uLnNvcnRhYmxlKTtcbiAgICB9XG4gICAgaXNDaGVja2JveENvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGlzQ2hlY2tib3hDb2x1bW4oY29sdW1uKSAmJiAhY29sdW1uLnRlbXBsYXRlUmVmO1xuICAgIH1cbiAgICB0cmFja0J5SW5kZXgoaW5kZXgsIF9pdGVtKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkU3RpY2t5U3R5bGVzKGNvbHVtbikge1xuICAgICAgICBjb25zdCBzdGlja3lTdHlsZXMgPSB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLnN0aWNreUNvbHVtbnNTdHlsZXMoY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbHVtbi5zdHlsZSwgc3RpY2t5U3R5bGVzKTtcbiAgICB9XG4gICAgdG9nZ2xlRGlyZWN0aW9uKGZpZWxkLCBhbGxvd1Vuc29ydCwgaW5pdGlhbERpcmVjdGlvbikge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5zb3J0RGVzY3JpcHRvcihmaWVsZCk7XG4gICAgICAgIGNvbnN0IFtmaXJzdCwgc2Vjb25kXSA9IGRpcmVjdGlvbnMoaW5pdGlhbERpcmVjdGlvbik7XG4gICAgICAgIGxldCBkaXIgPSBmaXJzdDtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZGlyID09PSBmaXJzdCkge1xuICAgICAgICAgICAgZGlyID0gc2Vjb25kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3IuZGlyID09PSBzZWNvbmQgJiYgYWxsb3dVbnNvcnQpIHtcbiAgICAgICAgICAgIGRpciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkaXIsIGZpZWxkIH07XG4gICAgfVxuICAgIGNvbHVtbnNGb3JMZXZlbChsZXZlbCkge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5jb2x1bW5zID8gdGhpcy5jb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmxldmVsID09PSBsZXZlbCkgOiBbXTtcbiAgICAgICAgcmV0dXJuIHNvcnRDb2x1bW5zKGNvbHVtbnNUb1JlbmRlcihjb2x1bW5zKSk7XG4gICAgfVxuICAgIGlzQ29sdW1uR3JvdXBDb21wb25lbnQoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBpc0NvbHVtbkdyb3VwQ29tcG9uZW50KGNvbHVtbik7XG4gICAgfVxuICAgIGdldCBjb2x1bW5MZXZlbHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkoKHRoaXMudG90YWxDb2x1bW5MZXZlbHMgfHwgMCkgKyAxKTtcbiAgICB9XG4gICAgc29ydERlc2NyaXB0b3IoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydC5maW5kKGl0ZW0gPT4gaXRlbS5maWVsZCA9PT0gZmllbGQpIHx8IHsgZmllbGQgfTtcbiAgICB9XG4gICAgZ2V0IGxlYWZDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZkNvbHVtbnM7XG4gICAgfVxuICAgIGF0dGFjaFRhcmdldHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhcmdldFN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgY29uc3QgZW50ZXJTdHJlYW0gPSBtZXJnZSguLi50aGlzLmRyb3BUYXJnZXRzLm1hcCh0YXJnZXQgPT4gdGFyZ2V0LmVudGVyKSk7XG4gICAgICAgIGNvbnN0IGxlYXZlU3RyZWFtID0gbWVyZ2UoLi4udGhpcy5kcm9wVGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHRhcmdldC5sZWF2ZSkpO1xuICAgICAgICBjb25zdCBkcm9wU3RyZWFtID0gbWVyZ2UoLi4udGhpcy5kcm9wVGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHRhcmdldC5kcm9wKSk7XG4gICAgICAgIHRoaXMudGFyZ2V0U3Vic2NyaXB0aW9uLmFkZChlbnRlclN0cmVhbS5waXBlKHRhcCgoeyB0YXJnZXQsIGRyYWdnYWJsZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoZHJhZ2dhYmxlLmNvbnRleHQudHlwZSA9PT0gJ2dyb3VwSW5kaWNhdG9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExvY2tlZCA9IGlzVHJ1dGh5KHRhcmdldC5jb250ZXh0LmNvbHVtbi5pc0xvY2tlZCk7XG4gICAgICAgICAgICBjb25zdCBkcmFnZ2FibGVMb2NrZWQgPSBpc1RydXRoeShkcmFnZ2FibGUuY29udGV4dC5jb2x1bW4uaXNMb2NrZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9ja2VkQ29sdW1uc0NvdW50ID4gMCB8fCB0YXJnZXRMb2NrZWQgfHwgZHJhZ2dhYmxlTG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaW50LnRvZ2dsZUxvY2sodGFyZ2V0TG9ja2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIGZpbHRlcigoeyBkcmFnZ2FibGUsIHRhcmdldCB9KSA9PiB0aGlzLmNhbkRyb3AoZHJhZ2dhYmxlLCB0YXJnZXQpKSwgc3dpdGNoTWFwKHRoaXMudHJhY2tNb3ZlLmJpbmQodGhpcywgbGVhdmVTdHJlYW0sIGRyb3BTdHJlYW0pKSwgbWFwKChlKSA9PiBtZXJnZU9iamVjdHMoZSwgeyBiZWZvcmU6IHRoaXMuY2FsY3VsYXRlQmVmb3JlKGUpLCBjaGFuZ2VDb250YWluZXI6IGUuY2hhbmdlQ29udGFpbmVyIH0pKSwgbWFwKHRoaXMubm9ybWFsaXplVGFyZ2V0LmJpbmQodGhpcykpLCB0YXAodGhpcy5lbnRlci5iaW5kKHRoaXMpKSwgc3dpdGNoTWFwKChhcmdzKSA9PiBkcm9wU3RyZWFtLnBpcGUobWFwKCgpID0+IGFyZ3MpLCB0YWtlVW50aWwobGVhdmVTdHJlYW0ucGlwZSh0YXAodGhpcy5sZWF2ZS5iaW5kKHRoaXMpKSkpKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuZHJvcC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVRhcmdldChlKSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGFyZ2V0LmNvbnRleHQuY29sdW1uLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuaXNTcGFuQ29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSB0aGlzLmRyb3BUYXJnZXRzLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U3BhbiA9IGFyci5maW5kKHQgPT4gdC5jb250ZXh0LmNvbHVtbi5wYXJlbnQgPT09IHBhcmVudCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGZpcnN0U3Bhbik7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3QgPSBlLmJlZm9yZSA/IDAgOiBwYXJlbnQuY2hpbGRDb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB0YXJnZXQgPSBhcnJbaW5kZXggKyBhZGp1c3RdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZU9iamVjdHMoZSwgeyB0YXJnZXQgfSk7XG4gICAgfVxuICAgIHRyYWNrTW92ZShsZWF2ZVN0cmVhbSwgZHJvcFN0cmVhbSwgZSkge1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBlLnRhcmdldC5jb250ZXh0LmNvbHVtbjtcbiAgICAgICAgY29uc3QgbGV2ZWxDb2x1bW5zID0gdGhpcy5jb2x1bW5zRm9yTGV2ZWwoY29sdW1uLmxldmVsKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsZXZlbENvbHVtbnMuaW5kZXhPZihjb2x1bW4pO1xuICAgICAgICBjb25zdCBpc0ZpcnN0ID0gKGNvbHVtbi5sb2NrZWQgPyBpbmRleCA9PT0gbGV2ZWxDb2x1bW5zLmxlbmd0aCAtIDEgOiBpbmRleCA9PT0gMCk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSBlLmRyYWdnYWJsZS5jb250ZXh0LmNvbHVtbi5pc0xvY2tlZCAhPT0gY29sdW1uLmlzTG9ja2VkO1xuICAgICAgICBpZiAoY2hhbmdlZCAmJiBpc0ZpcnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZS5kcmFnZ2FibGUuZHJhZ1xuICAgICAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbChsZWF2ZVN0cmVhbSksIHRha2VVbnRpbChkcm9wU3RyZWFtKSwgbWFwKCh7IG1vdXNlRXZlbnQgfSkgPT4gbWVyZ2VPYmplY3RzKHsgY2hhbmdlQ29udGFpbmVyOiB0cnVlIH0sIGUsIHsgbW91c2VFdmVudCB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZihtZXJnZU9iamVjdHMoeyBjaGFuZ2VDb250YWluZXI6IGNoYW5nZWQgfSwgZSkpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVCZWZvcmUoeyBkcmFnZ2FibGUsIHRhcmdldCwgbW91c2VFdmVudCwgY2hhbmdlQ29udGFpbmVyID0gZmFsc2UgfSkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0LmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IGJlZm9yZSA9IGZhbHNlO1xuICAgICAgICBpZiAoY2hhbmdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGxlZnQgfSA9IG9mZnNldCh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IHRhcmdldEVsZW1lbnQub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlID0gbGVmdCArIGhhbGZXaWR0aDtcbiAgICAgICAgICAgIGJlZm9yZSA9IG1pZGRsZSA+IG1vdXNlRXZlbnQucGFnZVg7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb24ucnRsKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlID0gIWJlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSA9IGlzVGFyZ2V0QmVmb3JlKGRyYWdnYWJsZS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRhcmdldEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZWZvcmU7XG4gICAgfVxuICAgIGVudGVyKHsgdGFyZ2V0LCBiZWZvcmUgfSkge1xuICAgICAgICB0aGlzLmhpbnQuZW5hYmxlKCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsaXphdGlvbi5ydGwpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICFiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdWUucG9zaXRpb24ocG9zaXRpb24odGFyZ2V0LmVsZW1lbnQubmF0aXZlRWxlbWVudCwgYmVmb3JlKSk7XG4gICAgfVxuICAgIGxlYXZlKCkge1xuICAgICAgICB0aGlzLmhpbnQuZGlzYWJsZSgpO1xuICAgICAgICB0aGlzLmN1ZS5oaWRlKCk7XG4gICAgfVxuICAgIGRyb3AoeyBkcmFnZ2FibGUsIHRhcmdldCwgYmVmb3JlLCBjaGFuZ2VDb250YWluZXIgfSkge1xuICAgICAgICB0aGlzLnJlb3JkZXJTZXJ2aWNlLnJlb3JkZXIoe1xuICAgICAgICAgICAgYmVmb3JlLFxuICAgICAgICAgICAgY2hhbmdlQ29udGFpbmVyLFxuICAgICAgICAgICAgc291cmNlOiBkcmFnZ2FibGUuY29udGV4dC5jb2x1bW4sXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldC5jb250ZXh0LmNvbHVtblxuICAgICAgICB9KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b3RhbENvbHVtbkxldmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERldGFpbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZXRhaWxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2Nyb2xsYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic29ydFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic29ydGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3VwYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsb2NrZWRDb2x1bW5zQ291bnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVvcmRlcmFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbk1lbnVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5NZW51VGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidG90YWxDb2x1bW5zQ291bnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWdyaWQtaGVhZGVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVhZGVyQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGRyZW4oRHJvcFRhcmdldERpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZHJvcFRhcmdldHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZHJlbihGaWx0ZXJNZW51Q29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJNZW51c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkcmVuKENvbHVtbk1lbnVDb21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbk1lbnVzXCIsIHZvaWQgMCk7XG5IZWFkZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRIZWFkZXJdJyxcbiAgICAgICAgc3R5bGVzOiBbYFxuICAgICAgICAuay1jb2x1bW4tcmVzaXplciB7XG4gICAgICAgICAgICBjdXJzb3I6IGNvbC1yZXNpemU7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGhlaWdodDogMTAwMCU7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICB3aWR0aDogLjVlbTtcbiAgICAgICAgfVxuICAgIGBdLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJ0cnVlXCI+XG4gICAgICAgIDx0ciAqbmdGb3I9XCJsZXQgaSBvZiBjb2x1bW5MZXZlbHM7IGxldCBsZXZlbEluZGV4ID0gaW5kZXhcIlxuICAgICAgICAgICAga2VuZG9HcmlkTG9naWNhbFJvd1xuICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibGV2ZWxJbmRleFwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZVJvd109XCJsb2NrZWRDb2x1bW5zQ291bnQgPiAwXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbENlbGxzQ291bnRdPVwiY29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVDZWxsc0NvdW50XT1cInVubG9ja2VkQ29sdW1uc0NvdW50XCI+XG4gICAgICAgICAgICA8dGhcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstZ3JvdXAtY2VsbCBrLWhlYWRlclwiXG4gICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IGcgb2YgZ3JvdXBzXCI+XG4gICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgPHRoIGNsYXNzPVwiay1oaWVyYXJjaHktY2VsbCBrLWhlYWRlclwiXG4gICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJkZXRhaWxUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgIGtlbmRvR3JpZExvZ2ljYWxDZWxsXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibGV2ZWxJbmRleFwiXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsQ29sSW5kZXhdPVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9XCJmYWxzZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jb2x1bW4gW25nRm9yT2ZdPVwiY29sdW1uc0ZvckxldmVsKGxldmVsSW5kZXgpXCIgW25nRm9yVHJhY2tCeV09XCJ0cmFja0J5SW5kZXhcIiBsZXQtY29sdW1uSW5kZXg9XCJpbmRleFwiIGxldC1sYXN0PVwibGFzdFwiPlxuICAgICAgICAgICAgICAgIDx0aCAqbmdJZj1cIiFpc0NvbHVtbkdyb3VwQ29tcG9uZW50KGNvbHVtbilcIlxuICAgICAgICAgICAgICAgICAgICBrZW5kb0dyaWRMb2dpY2FsQ2VsbFxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImxldmVsSW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbENvbEluZGV4XT1cImxvZ2ljYWxDb2x1bW5JbmRleChjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgW2hlYWRlckxhYmVsVGV4dF09XCJjb2x1bW4udGl0bGUgfHwgY29sdW1uLmZpZWxkXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbFNwYW5dPVwiY29sdW1uLmNvbHNwYW5cIlxuICAgICAgICAgICAgICAgICAgICBbcm93U3Bhbl09XCJjb2x1bW4ucm93c3Bhbih0b3RhbENvbHVtbkxldmVscylcIlxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiY29sdW1uaGVhZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zb3J0XT1cInNvcnRTdGF0ZShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgKGtleWRvd24pPVwib25IZWFkZXJLZXlkb3duKGNvbHVtbiwgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvRHJvcFRhcmdldFxuICAgICAgICAgICAgICAgICAgICBrZW5kb0RyYWdnYWJsZVxuICAgICAgICAgICAgICAgICAgICBrZW5kb0RyYWdnYWJsZUNvbHVtblxuICAgICAgICAgICAgICAgICAgICBbZW5hYmxlRHJhZ109XCJzaG91bGRBY3RpdmF0ZShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGNvbHVtbi5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaW50OiBjb2x1bW4udGl0bGUgfHwgY29sdW1uLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENvbHVtbjogbGFzdCAmJiBjb2x1bW5JbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWhlYWRlclwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLWZpbHRlcmFibGVdPVwiKHNob3dGaWx0ZXJNZW51ICYmIGlzRmlsdGVyYWJsZShjb2x1bW4pKSB8fCBzaG93Q29sdW1uTWVudShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstZmlyc3RdPVwiaXNGaXJzdE9uUm93KGNvbHVtbiwgY29sdW1uSW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstZ3JpZC1oZWFkZXItc3RpY2t5XT1cImNvbHVtbi5zdGlja3lcIlxuICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJjb2x1bW4uaGVhZGVyQ2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJjb2x1bW4uc3RpY2t5ID8gYWRkU3RpY2t5U3R5bGVzKGNvbHVtbikgOiBjb2x1bW4uaGVhZGVyU3R5bGVcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5yb3dzcGFuXT1cImNvbHVtbi5yb3dzcGFuKHRvdGFsQ29sdW1uTGV2ZWxzKVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmNvbHNwYW5dPVwiY29sdW1uLmNvbHNwYW5cIj5cblxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzU29ydGFibGUoY29sdW1uKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtZmlsdGVyLW1lbnVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cInNob3dGaWx0ZXJNZW51ICYmIGlzRmlsdGVyYWJsZShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0YWJJbmRleF09XCJ0YWJJbmRleFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWZpbHRlci1tZW51PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uLW1lbnUgKm5nSWY9XCJzaG93Q29sdW1uTWVudShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NldHRpbmdzXT1cImNvbHVtbk1lbnVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uTWVudVRlbXBsYXRlXT1cImNvbHVtbk1lbnVUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NvcnRdPVwic29ydFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzb3J0YWJsZV09XCJzb3J0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RhYkluZGV4XT1cInRhYkluZGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uLW1lbnU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGVDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGNvbHVtbi5oZWFkZXJUZW1wbGF0ZVJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbi5sZWFmSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWNvbHVtbi5oZWFkZXJUZW1wbGF0ZVJlZlwiPnt7Y29sdW1uLmRpc3BsYXlUaXRsZX19PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXNTb3J0YWJsZShjb2x1bW4pXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstY2VsbC1pbm5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICNsaW5rIGNsYXNzPVwiay1saW5rXCIgKGNsaWNrKT1cIm9uU29ydENsaWNrKGNvbHVtbiwgJGV2ZW50LCBsaW5rKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiBjb2x1bW4uaGVhZGVyVGVtcGxhdGVSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbi5sZWFmSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFjb2x1bW4uaGVhZGVyVGVtcGxhdGVSZWZcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1jb2x1bW4tdGl0bGVcIj57e2NvbHVtbi5kaXNwbGF5VGl0bGV9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gcm9sZT1cIm5vdGVcIiBbYXR0ci5hcmlhLWxhYmVsXT1cInNvcnRhYmxlTGFiZWxcIiBbbmdDbGFzc109XCJzb3J0SWNvbihjb2x1bW4uZmllbGQpXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cInNob3dTb3J0TnVtYmVyaW5nKGNvbHVtbilcIiBjbGFzcz1cImstc29ydC1vcmRlclwiPnt7c29ydE9yZGVyKGNvbHVtbi5maWVsZCl9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gcm9sZT1cInN0YXR1c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1zb3J0LXN0YXR1c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAtMTAwMDBweDtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaW5uZXJIdG1sXT1cInNvcnRTdGF0dXMoY29sdW1uKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1maWx0ZXItbWVudVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cInNob3dGaWx0ZXJNZW51ICYmIGlzRmlsdGVyYWJsZShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0YWJJbmRleF09XCJ0YWJJbmRleFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1maWx0ZXItbWVudT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4tbWVudSAqbmdJZj1cInNob3dDb2x1bW5NZW51KGNvbHVtbilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZXR0aW5nc109XCJjb2x1bW5NZW51XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uTWVudVRlbXBsYXRlXT1cImNvbHVtbk1lbnVUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzb3J0XT1cInNvcnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzb3J0YWJsZV09XCJzb3J0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0YWJJbmRleF09XCJ0YWJJbmRleFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4tbWVudT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXNDaGVja2JveENvbHVtbihjb2x1bW4pICYmICFjb2x1bW4uaGVhZGVyVGVtcGxhdGVSZWYgJiYgY29sdW1uLnNob3dTZWxlY3RBbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1jaGVja2JveCBrLWNoZWNrYm94LW1kIGstcm91bmRlZC1tZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuaWRdPVwic2VsZWN0QWxsQ2hlY2tib3hJZCgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cInNlbGVjdEFsbENoZWNrYm94TGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlbmRvR3JpZFNlbGVjdEFsbENoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2VuZG9HcmlkRm9jdXNhYmxlPlxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBrZW5kb0dyaWRDb2x1bW5IYW5kbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlbmRvRHJhZ2dhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstY29sdW1uLXJlc2l6ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJyZXNpemFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwiY29sdW1uc1wiPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICA8dGggKm5nSWY9XCJpc0NvbHVtbkdyb3VwQ29tcG9uZW50KGNvbHVtbilcIlxuICAgICAgICAgICAgICAgICAgICBrZW5kb0dyaWRMb2dpY2FsQ2VsbFxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImxldmVsSW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbENvbEluZGV4XT1cImxvZ2ljYWxDb2x1bW5JbmRleChjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgW3Jvd1NwYW5dPVwiY29sdW1uLnJvd3NwYW4odG90YWxDb2x1bW5MZXZlbHMpXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbFNwYW5dPVwiY29sdW1uLmNvbHNwYW5cIlxuICAgICAgICAgICAgICAgICAgICBbaGVhZGVyTGFiZWxUZXh0XT1cImNvbHVtbi50aXRsZSB8fCBjb2x1bW4uZmllbGRcIlxuICAgICAgICAgICAgICAgICAgICBrZW5kb0Ryb3BUYXJnZXRcbiAgICAgICAgICAgICAgICAgICAga2VuZG9EcmFnZ2FibGVcbiAgICAgICAgICAgICAgICAgICAga2VuZG9EcmFnZ2FibGVDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgW2VuYWJsZURyYWddPVwic2hvdWxkQWN0aXZhdGUoY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgICAgIFtjb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW5Hcm91cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6IGNvbHVtbi50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDb2x1bW46IGxhc3QgJiYgY29sdW1uSW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1oZWFkZXJcIlxuICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1maXJzdF09XCJpc0ZpcnN0T25Sb3coY29sdW1uLCBjb2x1bW5JbmRleClcIlxuICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1maWx0ZXJhYmxlXT1cInNob3dDb2x1bW5NZW51KGNvbHVtbilcIlxuICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1ncmlkLWNvbnRlbnQtc3RpY2t5XT1cImNvbHVtbi5zdGlja3lcIlxuICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJjb2x1bW4uaGVhZGVyQ2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJjb2x1bW4uaGVhZGVyU3R5bGVcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5yb3dzcGFuXT1cImNvbHVtbi5yb3dzcGFuKHRvdGFsQ29sdW1uTGV2ZWxzKVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmNvbHNwYW5dPVwiY29sdW1uLmNvbHNwYW5cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbi1tZW51ICpuZ0lmPVwic2hvd0NvbHVtbk1lbnUoY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0YW5kYWxvbmVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZXR0aW5nc109XCJjb2x1bW5NZW51XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbk1lbnVUZW1wbGF0ZV09XCJjb2x1bW5NZW51VGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4tbWVudT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVJlZjogY29sdW1uLmhlYWRlclRlbXBsYXRlUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogbG9ja2VkQ29sdW1uc0NvdW50ICsgY29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWNvbHVtbi5oZWFkZXJUZW1wbGF0ZVJlZlwiPnt7Y29sdW1uLmRpc3BsYXlUaXRsZX19PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGtlbmRvR3JpZENvbHVtbkhhbmRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlbmRvRHJhZ2dhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWNvbHVtbi1yZXNpemVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cInJlc2l6YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImNvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC90cj5cbiAgICAgICAgPHRyICpuZ0lmPVwic2hvd0ZpbHRlclJvd1wiXG4gICAgICAgICAgICBrZW5kb0dyaWRGaWx0ZXJSb3dcbiAgICAgICAgICAgICAgICBbY29sdW1uc109XCJsZWFmQ29sdW1uc1wiXG4gICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgIFtncm91cHNdPVwiZ3JvdXBzXCJcbiAgICAgICAgICAgICAgICBbZGV0YWlsVGVtcGxhdGVdPVwiZGV0YWlsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtsb2NrZWRDb2x1bW5zQ291bnRdPVwibG9ja2VkQ29sdW1uc0NvdW50XCJcbiAgICAgICAgICAgIGtlbmRvR3JpZExvZ2ljYWxSb3dcbiAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cInRvdGFsQ29sdW1uTGV2ZWxzICsgMVwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZVJvd109XCJsb2NrZWRDb2x1bW5zQ291bnQgPiAwXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbENlbGxzQ291bnRdPVwiY29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVDZWxsc0NvdW50XT1cInVubG9ja2VkQ29sdW1uc0NvdW50XCJcbiAgICAgICAgPjwvdHI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTaW5nbGVQb3B1cFNlcnZpY2UsXG4gICAgICAgIERyYWdIaW50U2VydmljZSxcbiAgICAgICAgRHJvcEN1ZVNlcnZpY2UsXG4gICAgICAgIENvbHVtblJlb3JkZXJTZXJ2aWNlLFxuICAgICAgICBJZFNlcnZpY2UsXG4gICAgICAgIFNvcnRTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2x1bW5JbmZvU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgSGVhZGVyQ29tcG9uZW50KTtcblxuLy8gVE9ET1xuLy8gdHNsaW50OmRpc2FibGU6cnhqcy1uby11bnNhZmUtdGFrZXVudGlsXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZnJvbVBlcmNlbnRhZ2UgPSAodmFsdWUsIHBlcmNlbnQpID0+IHtcbiAgICBjb25zdCBzaWduID0gcGVyY2VudCA8IDAgPyAtMSA6IDE7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgoTWF0aC5hYnMocGVyY2VudCkgLyAxMDApICogdmFsdWUpICogc2lnbjtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlLCB3aG9sZSkgPT4gKHZhbHVlIC8gd2hvbGUpICogMTAwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhlYWRlcldpZHRoID0gKGhhbmRsZSkgPT4gaGFuZGxlLm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBhbGxMZWFmQ29sdW1ucyA9IGNvbHVtbnMgPT4gZXhwYW5kQ29sdW1ucyhjb2x1bW5zKVxuICAgIC5maWx0ZXIoYyA9PiAhYy5pc0NvbHVtbkdyb3VwKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzdG9wUHJvcGFnYXRpb24gPSAoeyBvcmlnaW5hbEV2ZW50OiBldmVudCB9KSA9PiB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY3JlYXRlTW92ZVN0cmVhbSA9IChzZXJ2aWNlLCBkcmFnZ2FibGUpID0+IG1vdXNlRG93biA9PiBkcmFnZ2FibGUua2VuZG9EcmFnLnBpcGUodGFrZVVudGlsKGRyYWdnYWJsZS5rZW5kb1JlbGVhc2UucGlwZSh0YXAoKCkgPT4gc2VydmljZS5lbmQoKSkpKSwgbWFwKCh7IHBhZ2VYIH0pID0+ICh7XG4gICAgb3JpZ2luYWxYOiBtb3VzZURvd24ucGFnZVgsXG4gICAgcGFnZVhcbn0pKSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcHJldmVudE9uRGJsQ2xpY2skMSA9IHJlbGVhc2UgPT4gbW91c2VEb3duID0+IG9mKG1vdXNlRG93bikucGlwZShkZWxheSgxNTApLCB0YWtlVW50aWwocmVsZWFzZSkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzSW5TcGFuQ29sdW1uJDEgPSBjb2x1bW4gPT4gISEoY29sdW1uLnBhcmVudCAmJiBjb2x1bW4ucGFyZW50LmlzU3BhbkNvbHVtbik7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb2x1bW4gaW5kZXguIElmIHRoZSBjb2x1bW4gaXMgc3RhdGVkIGluIGBTcGFuQ29sdW1uYCxcbiAqIHRoZSBpbmRleCBmb3IgYWxsIGNoaWxkIGNvbHVtbnMgZXF1YWxzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hpbGQuXG4gKi9cbmNvbnN0IGluZGV4T2YgPSAodGFyZ2V0LCBsaXN0KSA9PiB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgaWdub3JlID0gMDtcbiAgICBsZXQgc2tpcCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGxpc3RbaW5kZXhdO1xuICAgICAgICBjb25zdCBpc1BhcmVudFNwYW5Db2x1bW4gPSBpc0luU3BhbkNvbHVtbiQxKGN1cnJlbnQpO1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGlnbm9yZS0tIDw9IDApICYmIGlzUGFyZW50U3BhbkNvbHVtbikge1xuICAgICAgICAgICAgaWdub3JlID0gY3VycmVudC5wYXJlbnQuY2hpbGRDb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBza2lwICs9IGlnbm9yZTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXggLSBza2lwO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ29sdW1uSGFuZGxlRGlyZWN0aXZlID0gY2xhc3MgQ29sdW1uSGFuZGxlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUsIGVsZW1lbnQsIHNlcnZpY2UsIHpvbmUsIGNkciwgbG9jYWxpemF0aW9uLCBjb2x1bW5JbmZvU2VydmljZSkge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlID0gY29sdW1uSW5mb1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMucnRsID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW4ucmVzaXphYmxlID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICB9XG4gICAgZ2V0IGxlZnRTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJ1dGh5KHRoaXMucnRsKSA/IDAgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcmlnaHRTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJ1dGh5KHRoaXMucnRsKSA/IG51bGwgOiAwO1xuICAgIH1cbiAgICBhdXRvRml0KCkge1xuICAgICAgICBjb25zdCBhbGxMZWFmcyA9IGFsbExlYWZDb2x1bW5zKHRoaXMuY29sdW1ucyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMZWFmcyA9IGxlYWZDb2x1bW5zKFt0aGlzLmNvbHVtbl0pLmZpbHRlcihjb2x1bW4gPT4gaXNUcnV0aHkoY29sdW1uLnJlc2l6YWJsZSkpO1xuICAgICAgICBjb25zdCBjb2x1bW5JbmZvID0gY3VycmVudExlYWZzLm1hcChjb2x1bW4gPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNQYXJlbnRTcGFuID0gaXNJblNwYW5Db2x1bW4kMShjb2x1bW4pO1xuICAgICAgICAgICAgY29uc3QgaXNMYXN0SW5TcGFuID0gaXNQYXJlbnRTcGFuID8gY29sdW1uLnBhcmVudC5jaGlsZENvbHVtbnMubGFzdCA9PT0gY29sdW1uIDogZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGluZGV4T2YoY29sdW1uLCBhbGxMZWFmcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgICAgICBoZWFkZXJJbmRleDogdGhpcy5jb2x1bW5zRm9yTGV2ZWwoY29sdW1uLmxldmVsKS5pbmRleE9mKGNvbHVtbiksXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgaXNMYXN0SW5TcGFuLFxuICAgICAgICAgICAgICAgIGlzUGFyZW50U3BhbixcbiAgICAgICAgICAgICAgICBsZXZlbDogY29sdW1uLmxldmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudExlYWZzLmZvckVhY2goY29sdW1uID0+IGNvbHVtbi53aWR0aCA9IDApO1xuICAgICAgICB0aGlzLnNlcnZpY2UubWVhc3VyZUNvbHVtbnMoY29sdW1uSW5mbyk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmNvbHVtbi53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLmltcGxpY2l0V2lkdGggPSBoZWFkZXJXaWR0aCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzLnNlcnZpY2UuY2hhbmdlcy5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmNvbHVtbi5yZXNpemFibGUpLCBmaWx0ZXIoZSA9PiBpc1ByZXNlbnQoZS5jb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbiA9PT0gdGhpcy5jb2x1bW4pKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHNlcnZpY2UucGlwZShmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICdzdGFydCcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmluaXRTdGF0ZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoc2VydmljZS5waXBlKGZpbHRlcihlID0+IGUudHlwZSA9PT0gJ3Jlc2l6ZUNvbHVtbicpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLnJlc2l6ZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5zZXJ2aWNlLmNoYW5nZXMucGlwZShmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICdzdGFydCcpLCBmaWx0ZXIodGhpcy5zaG91bGRVcGRhdGUuYmluZCh0aGlzKSksIHRha2UoMSkgLy9vbiBmaXJzdCByZXNpemUgb25seVxuICAgICAgICApLnN1YnNjcmliZSh0aGlzLmluaXRDb2x1bW5XaWR0aC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuZHJhZ2dhYmxlLmtlbmRvUHJlc3MucGlwZSh0YXAoc3RvcFByb3BhZ2F0aW9uKSwgdGFwKCgpID0+IHRoaXMuc2VydmljZS5zdGFydCh0aGlzLmNvbHVtbikpLCBzd2l0Y2hNYXAocHJldmVudE9uRGJsQ2xpY2skMSh0aGlzLmRyYWdnYWJsZS5rZW5kb1JlbGVhc2UpKSwgc3dpdGNoTWFwKGNyZWF0ZU1vdmVTdHJlYW0odGhpcy5zZXJ2aWNlLCB0aGlzLmRyYWdnYWJsZSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoeyBwYWdlWCwgb3JpZ2luYWxYIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gcGFnZVggLSBvcmlnaW5hbFg7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50ID0gdG9QZXJjZW50YWdlKGRlbHRhLCB0aGlzLmNvbHVtbi5yZXNpemVTdGFydFdpZHRoIHx8IHRoaXMuY29sdW1uLndpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5yZXNpemVDb2x1bW5zKHBlcmNlbnQpO1xuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHNlcnZpY2UucGlwZShmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICdhdXRvRml0Q29tcGxldGUnKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5zaXplVG9GaXQuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHNlcnZpY2UucGlwZShmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICd0cmlnZ2VyQXV0b0ZpdCcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmF1dG9GaXQuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB0aGlzLnJ0bCA9IHJ0bCkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gIWFsbExlYWZDb2x1bW5zKHRoaXMuY29sdW1ucylcbiAgICAgICAgICAgIC5tYXAoY29sdW1uID0+IGNvbHVtbi53aWR0aClcbiAgICAgICAgICAgIC5zb21lKGlzQmxhbmspO1xuICAgIH1cbiAgICBpbml0Q29sdW1uV2lkdGgoKSB7XG4gICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gaGVhZGVyV2lkdGgodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gICAgaW5pdFN0YXRlKCkge1xuICAgICAgICB0aGlzLmNvbHVtbi5yZXNpemVTdGFydFdpZHRoID0gaGVhZGVyV2lkdGgodGhpcy5lbGVtZW50KTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLnJlc2l6ZWRDb2x1bW4oe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIG9sZFdpZHRoOiB0aGlzLmNvbHVtbi5yZXNpemVTdGFydFdpZHRoXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNpemUoeyBkZWx0YVBlcmNlbnQgfSkge1xuICAgICAgICBsZXQgZGVsdGEgPSBmcm9tUGVyY2VudGFnZSh0aGlzLmNvbHVtbi5yZXNpemVTdGFydFdpZHRoLCBkZWx0YVBlcmNlbnQpO1xuICAgICAgICBpZiAoaXNUcnV0aHkodGhpcy5ydGwpKSB7XG4gICAgICAgICAgICBkZWx0YSAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KHRoaXMuY29sdW1uLnJlc2l6ZVN0YXJ0V2lkdGggKyBkZWx0YSwgdGhpcy5jb2x1bW4ubWluUmVzaXphYmxlV2lkdGgpO1xuICAgICAgICBjb25zdCB0YWJsZURlbHRhID0gbmV3V2lkdGggPiB0aGlzLmNvbHVtbi5taW5SZXNpemFibGVXaWR0aCA/XG4gICAgICAgICAgICBkZWx0YSA6IHRoaXMuY29sdW1uLm1pblJlc2l6YWJsZVdpZHRoIC0gdGhpcy5jb2x1bW4ucmVzaXplU3RhcnRXaWR0aDtcbiAgICAgICAgdGhpcy51cGRhdGVXaWR0aCh0aGlzLmNvbHVtbiwgbmV3V2lkdGgpO1xuICAgICAgICB0aGlzLnNlcnZpY2UucmVzaXplVGFibGUodGhpcy5jb2x1bW4sIHRhYmxlRGVsdGEpO1xuICAgIH1cbiAgICBzaXplVG9GaXQoeyBjb2x1bW5zLCB3aWR0aHMgfSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNvbHVtbnMuaW5kZXhPZih0aGlzLmNvbHVtbik7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoLi4ud2lkdGhzLm1hcCh3ID0+IHdbaW5kZXhdKSkgKyAxOyAvL2FkZCAxcHggZm9yIElFXG4gICAgICAgIGNvbnN0IHRhYmxlRGVsdGEgPSB3aWR0aCAtIHRoaXMuY29sdW1uLnJlc2l6ZVN0YXJ0V2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlV2lkdGgodGhpcy5jb2x1bW4sIHdpZHRoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLnJlc2l6ZVRhYmxlKHRoaXMuY29sdW1uLCB0YWJsZURlbHRhKTtcbiAgICB9XG4gICAgdXBkYXRlV2lkdGgoY29sdW1uLCB3aWR0aCkge1xuICAgICAgICBjb2x1bW4ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZS5oaWRkZW5Db2x1bW5zLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsoY29sLndpZHRoKSAmJiBpc1ByZXNlbnQoY29sLmltcGxpY2l0V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzaXplIGhpZGRlbiBjb2x1bW5zIHRvIHRoZWlyIGltcGxpY2l0IHdpZHRoIHNvIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBjYW4gYmUgZGlzcGxheWVkIHdpdGggdGhlIHNhbWUgd2lkdGggaWYgbWFkZSB2aXNpYmxlLlxuICAgICAgICAgICAgICAgIGNvbC53aWR0aCA9IGNvbC5pbXBsaWNpdFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7IC8vZm9yY2UgQ0QgY3ljbGVcbiAgICB9XG4gICAgY29sdW1uc0ZvckxldmVsKGxldmVsKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zVG9SZW5kZXIodGhpcy5jb2x1bW5zID8gdGhpcy5jb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmxldmVsID09PSBsZXZlbCkgOiBbXSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgQ29sdW1uSGFuZGxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb2x1bW5zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5CYXNlJDEpXG5dLCBDb2x1bW5IYW5kbGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbHVtblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLmRpc3BsYXknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDb2x1bW5IYW5kbGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInZpc2libGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUubGVmdCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENvbHVtbkhhbmRsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGVmdFN0eWxlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLnJpZ2h0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ29sdW1uSGFuZGxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJyaWdodFN0eWxlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdkYmxjbGljaycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgQ29sdW1uSGFuZGxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhdXRvRml0XCIsIG51bGwpO1xuQ29sdW1uSGFuZGxlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkQ29sdW1uSGFuZGxlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIEhvc3QoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEcmFnZ2FibGVEaXJlY3RpdmUsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIENvbHVtblJlc2l6aW5nU2VydmljZSxcbiAgICAgICAgTmdab25lLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sdW1uSW5mb1NlcnZpY2VdKVxuXSwgQ29sdW1uSGFuZGxlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBzZWxlY3QtYWxsIGNoZWNrYm94IGZlYXR1cmUgb2YgdGhlIEdyaWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZWxlY3Rpb25fZ3JpZCAlfSN0b2Mtc2VsZWN0LWFsbC1mZWF0dXJlKSkuXG4gKi9cbmxldCBTZWxlY3RBbGxDaGVja2JveERpcmVjdGl2ZSA9IGNsYXNzIFNlbGVjdEFsbENoZWNrYm94RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3Rpb25TZXJ2aWNlLCBlbCwgcmVuZGVyZXIsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYGtlbmRvR3JpZFNlbGVjdEFsbENoZWNrYm94YCBzZWxlY3QtYWxsIGNoZWNrYm94XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2VsZWN0aW9uX2dyaWQgJX0jdG9jLXNlbGVjdC1hbGwtZmVhdHVyZSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RBbGxDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgIHRoaXMuc3RhdGVTZXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95Q2xpY2sgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdjbGljaycsIHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5zdGF0ZVNldCA9IHRydWU7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95Q2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIC8vIHlpZWxkcyBjb25zaXN0ZW50IGNyb3NzLWJyb3dzZXIgYmVoYXZpb3Igd2hlbiBjbGlja2luZyBhbiBpbmRldGVybWluYXRlIGNoZWNrYm94XG4gICAgICAgIGNvbnN0IHVuZGVmaW5lZENoZWNrZWRTdGF0ZUluSUUgPSBkZXRlY3RJRSgpICYmIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3RBbGxTdGF0ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpc0NoZWNrZWQgPSB1bmRlZmluZWRDaGVja2VkU3RhdGVJbklFID8gdHJ1ZSA6IHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGVja2VkO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGVuYWJsZWRBbmRNdWx0aXBsZSA9IG9wdGlvbnMuZW5hYmxlZCAmJiBvcHRpb25zLm1vZGUgPT09ICdtdWx0aXBsZSc7XG4gICAgICAgIGNvbnN0IHNob3VsZEVtaXRTZWxlY3RBbGwgPSBoYXNPYnNlcnZlcnModGhpcy5zZWxlY3RBbGxDaGFuZ2UpO1xuICAgICAgICBpZiAoZW5hYmxlZEFuZE11bHRpcGxlIHx8IHNob3VsZEVtaXRTZWxlY3RBbGwpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWRBbmRNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UudXBkYXRlQWxsKGlzQ2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRFbWl0U2VsZWN0QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsQ2hhbmdlLmVtaXQoaXNDaGVja2VkID8gJ2NoZWNrZWQnIDogJ3VuY2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXRTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUkJDEgPSB0aGlzLnN0YXRlU2V0ID8gdGhpcy5zdGF0ZVRvQm9vbCgpIDogdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdEFsbFN0YXRlO1xuICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KGVsZW0sICdpbmRldGVybWluYXRlJywgIWlzUHJlc2VudChzdGF0ZSQkMSkpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KGVsZW0sICdjaGVja2VkJywgaXNQcmVzZW50KHN0YXRlJCQxKSA/IHN0YXRlJCQxIDogZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc3RhdGVUb0Jvb2woKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlICd1bmNoZWNrZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZWxlY3RBbGxDaGVja2JveERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3RhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBTZWxlY3RBbGxDaGVja2JveERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2VsZWN0QWxsQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci50eXBlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlbGVjdEFsbENoZWNrYm94RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5TZWxlY3RBbGxDaGVja2JveERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZFNlbGVjdEFsbENoZWNrYm94XSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1NlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTmdab25lXSlcbl0sIFNlbGVjdEFsbENoZWNrYm94RGlyZWN0aXZlKTtcblxuY29uc3QgaXNOb1ZhbHVlT3BlcmF0b3IgPSBvcGVyYXRvciA9PiAob3BlcmF0b3IgPT09IFwiaXNudWxsXCJcbiAgICB8fCBvcGVyYXRvciA9PT0gXCJpc25vdG51bGxcIlxuICAgIHx8IG9wZXJhdG9yID09PSBcImlzZW1wdHlcIlxuICAgIHx8IG9wZXJhdG9yID09PSBcImlzbm90ZW1wdHlcIik7XG5jb25zdCB2YWxpZEZpbHRlcnMgPSAoeyB2YWx1ZSwgb3BlcmF0b3IgfSkgPT4gIWlzTnVsbE9yRW1wdHlTdHJpbmcodmFsdWUpIHx8IGlzTm9WYWx1ZU9wZXJhdG9yKG9wZXJhdG9yKTtcbmNvbnN0IHRyaW1GaWx0ZXJzID0gZmlsdGVyJCQxID0+IHtcbiAgICBmaWx0ZXIkJDEuZmlsdGVycyA9IGZpbHRlciQkMS5maWx0ZXJzLmZpbHRlcih2YWxpZEZpbHRlcnMpO1xuICAgIHJldHVybiBmaWx0ZXIkJDE7XG59O1xuY29uc3QgZmluZFBhcmVudCA9IChmaWx0ZXJzLCBmaWVsZCwgcGFyZW50KSA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcnMucmVkdWNlKChhY2MsIGZpbHRlciQkMSkgPT4ge1xuICAgICAgICBpZiAoYWNjKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIkJDEuZmlsdGVycykge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRQYXJlbnQoZmlsdGVyJCQxLmZpbHRlcnMsIGZpZWxkLCBmaWx0ZXIkJDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlciQkMS5maWVsZCA9PT0gZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB1bmRlZmluZWQpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmFsaWduXG59O1xuY29uc3QgcGFyZW50TG9naWNPZkRlZmF1bHQgPSAoZmlsdGVyJCQxLCBmaWVsZCwgZGVmID0gXCJhbmRcIikgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGZpbmRQYXJlbnQoKChmaWx0ZXIkJDEgfHwge30pLmZpbHRlcnMgfHwgW10pLCBmaWVsZCk7XG4gICAgcmV0dXJuIGlzUHJlc2VudChwYXJlbnQpID8gcGFyZW50LmxvZ2ljIDogZGVmO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudCA9IGNsYXNzIEZpbHRlck1lbnVDb250YWluZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNlcnZpY2UsIGNoaWxkU2VydmljZSwgbG9jYWxpemF0aW9uLCBjZCwgbWVudVRhYmJpbmdTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucGFyZW50U2VydmljZSA9IHBhcmVudFNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hpbGRTZXJ2aWNlID0gY2hpbGRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3Rpb25zQ2xhc3MgPSAnay1hY3Rpb24tYnV0dG9ucyBrLWJ1dHRvbi1ncm91cCc7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQ29udGV4dCA9IHt9O1xuICAgICAgICB0aGlzLm1lbnVUYWJiaW5nU2VydmljZSA9IG1lbnVUYWJiaW5nU2VydmljZTtcbiAgICB9XG4gICAgZ2V0IGZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcm9vdCBmaWx0ZXIuXG4gICAgICogQHR5cGUge0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3J9XG4gICAgICovXG4gICAgc2V0IGZpbHRlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9maWx0ZXIgPSBjbG9uZUZpbHRlcnModmFsdWUpO1xuICAgIH1cbiAgICBnZXQgY2hpbGRGaWx0ZXIoKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuX2NoaWxkRmlsdGVyKSkge1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRGaWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyczogZmlsdGVyc0J5RmllbGQodGhpcy5maWx0ZXIsICh0aGlzLmNvbHVtbiB8fCB7fSkuZmllbGQpLFxuICAgICAgICAgICAgICAgIGxvZ2ljOiBwYXJlbnRMb2dpY09mRGVmYXVsdCh0aGlzLmZpbHRlciwgKHRoaXMuY29sdW1uIHx8IHt9KS5maWVsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkRmlsdGVyO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmNoaWxkU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZShmaWx0ZXIkJDEgPT4gdGhpcy5fY2hpbGRGaWx0ZXIgPSBmaWx0ZXIkJDEpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi5hZGQodGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZC5tYXJrRm9yQ2hlY2soKSkpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5tZW51VGFiYmluZ1NlcnZpY2UuaXNDb2x1bW5NZW51IHx8ICh0aGlzLmlzTGFzdCAmJiB0aGlzLmlzRXhwYW5kZWQpKSB7XG4gICAgICAgICAgICB0aGlzLm1lbnVUYWJiaW5nU2VydmljZS5sYXN0Rm9jdXNhYmxlID0gdGhpcy5kaXNhYmxlZCA/XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEJ1dHRvbi5uYXRpdmVFbGVtZW50IDogdGhpcy5maWx0ZXJCdXR0b24ubmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVudVRhYmJpbmdTZXJ2aWNlLmxhc3RGb2N1c2FibGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNoaWxkRmlsdGVyLmZpbHRlcnMuc29tZSh2YWxpZEZpbHRlcnMpO1xuICAgIH1cbiAgICBnZXQgdGVtcGxhdGVDb250ZXh0KCkge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbnRleHQuY29sdW1uID0gdGhpcy5jb2x1bW47XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQ29udGV4dC5maWx0ZXIgPSB0aGlzLmNoaWxkRmlsdGVyO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbnRleHQuZmlsdGVyU2VydmljZSA9IHRoaXMuY2hpbGRTZXJ2aWNlO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3RyaW5nLWxpdGVyYWxcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVDb250ZXh0W1wiJGltcGxpY2l0XCJdID0gdGhpcy5jaGlsZEZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlQ29udGV4dDtcbiAgICB9XG4gICAgZ2V0IGhhc1RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29sdW1uKSAmJiBpc1ByZXNlbnQodGhpcy5jb2x1bW4uZmlsdGVyTWVudVRlbXBsYXRlUmVmKTtcbiAgICB9XG4gICAgc3VibWl0KCkge1xuICAgICAgICBjb25zdCBmaWx0ZXIkJDEgPSB0cmltRmlsdGVycyh0aGlzLmNoaWxkRmlsdGVyKTtcbiAgICAgICAgaWYgKGZpbHRlciQkMS5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuZmlsdGVyIHx8IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiBbXSxcbiAgICAgICAgICAgICAgICBsb2dpYzogXCJhbmRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbW92ZUZpbHRlcihyb290LCB0aGlzLmNvbHVtbi5maWVsZCk7XG4gICAgICAgICAgICByb290LmZpbHRlcnMucHVzaChmaWx0ZXIkJDEpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRTZXJ2aWNlLmZpbHRlcihyb290KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlLmVtaXQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuZmlsdGVyIHx8IHtcbiAgICAgICAgICAgIGZpbHRlcnM6IFtdLFxuICAgICAgICAgICAgbG9naWM6IFwiYW5kXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmVtb3ZlRmlsdGVyKHJvb3QsIHRoaXMuY29sdW1uLmZpZWxkKTtcbiAgICAgICAgdGhpcy5wYXJlbnRTZXJ2aWNlLmZpbHRlcihyb290KTtcbiAgICAgICAgdGhpcy5jbG9zZS5lbWl0KCk7XG4gICAgfVxuICAgIG9uVGFiKGUsIGJ1dHRvblR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWVudVRhYmJpbmdTZXJ2aWNlLmZpcnN0Rm9jdXNhYmxlICYmICghdGhpcy5tZW51VGFiYmluZ1NlcnZpY2UuaXNDb2x1bW5NZW51IHx8IHRoaXMuaXNMYXN0KSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGJ1dHRvblR5cGUgPT09ICdyZXNldCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVkID8gdGhpcy5tZW51VGFiYmluZ1NlcnZpY2UuZmlyc3RGb2N1c2FibGUuZm9jdXMoKSA6IHRoaXMuZmlsdGVyQnV0dG9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWVudVRhYmJpbmdTZXJ2aWNlLmZpcnN0Rm9jdXNhYmxlLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNsZWFyVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChcImZpbHRlckNsZWFyQnV0dG9uXCIpO1xuICAgIH1cbiAgICBnZXQgZmlsdGVyVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChcImZpbHRlckZpbHRlckJ1dHRvblwiKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEZpbHRlck1lbnVDb250YWluZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNsb3NlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5Db21wb25lbnQpXG5dLCBGaWx0ZXJNZW51Q29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBGaWx0ZXJNZW51Q29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0xhc3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBGaWx0ZXJNZW51Q29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0V4cGFuZGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBNZW51VGFiYmluZ1NlcnZpY2UpXG5dLCBGaWx0ZXJNZW51Q29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtZW51VGFiYmluZ1NlcnZpY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aW9uc0NsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3Jlc2V0QnV0dG9uJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzZXRCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnZmlsdGVyQnV0dG9uJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyQnV0dG9uXCIsIHZvaWQgMCk7XG5GaWx0ZXJNZW51Q29udGFpbmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICAgICAgTWVudVRhYmJpbmdTZXJ2aWNlXG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1maWx0ZXItbWVudS1jb250YWluZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8Zm9ybSAoc3VibWl0KT1cInN1Ym1pdCgpXCIgKHJlc2V0KT1cInJlc2V0KClcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWZpbHRlci1tZW51IGstZ3JvdXAgay1yZXNldCBrLXN0YXRlLWJvcmRlci11cFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstZmlsdGVyLW1lbnUtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwiaGFzVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hDYXNlPVwiZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZW5kb0ZpbHRlck1lbnVIb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlclNlcnZpY2VdPVwiY2hpbGRTZXJ2aWNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJjaGlsZEZpbHRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW21lbnVUYWJiaW5nU2VydmljZV09XCJtZW51VGFiYmluZ1NlcnZpY2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hDYXNlPVwidHJ1ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJjb2x1bW4uZmlsdGVyTWVudVRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4uZmlsdGVyTWVudVRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwidGVtcGxhdGVDb250ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cImFjdGlvbnNDbGFzc1wiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAjcmVzZXRCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyZXNldFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstYnV0dG9uLXNvbGlkLWJhc2Ugay1idXR0b24tc29saWQgay1idXR0b24tbWQgay1yb3VuZGVkLW1kIGstYnV0dG9uLXJlY3RhbmdsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi50YWIpPVwib25UYWIoJGV2ZW50LCAncmVzZXQnKVwiPnt7Y2xlYXJUZXh0fX08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiAjZmlsdGVyQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1idXR0b24gay1idXR0b24tc29saWQtcHJpbWFyeSBrLWJ1dHRvbi1zb2xpZCBrLWJ1dHRvbi1tZCBrLXJvdW5kZWQtbWQgay1idXR0b24tcmVjdGFuZ2xlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi50YWIpPVwib25UYWIoJGV2ZW50LCAnZmlsdGVyJylcIj57e2ZpbHRlclRleHR9fTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZm9ybT5cbiAgICBgXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBTa2lwU2VsZigpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ZpbHRlclNlcnZpY2UsXG4gICAgICAgIEZpbHRlclNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBNZW51VGFiYmluZ1NlcnZpY2VdKVxuXSwgRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRmlsdGVyTWVudUlucHV0V3JhcHBlckNvbXBvbmVudCA9IGNsYXNzIEZpbHRlck1lbnVJbnB1dFdyYXBwZXJDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJJbnB1dFdyYXBwZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIobnVsbCk7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZpcnN0RHJvcERvd24gJiYgdGhpcy5maWx0ZXJTZXJ2aWNlICYmIHRoaXMuZmlsdGVyU2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2UuZmlyc3RGb2N1c2FibGUgPSB0aGlzLmZpcnN0T3BlcmF0b3JEcm9wRG93bjtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RPcGVyYXRvckRyb3BEb3duLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BlcmF0b3JDaGFuZ2UoZGF0YUl0ZW0pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50T3BlcmF0b3IgPSBkYXRhSXRlbTtcbiAgICB9XG4gICAgZmlsdGVyQ2hhbmdlKGZpbHRlciQkMSkge1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVyKGZpbHRlciQkMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGZpbHRlciBmb3IgdGhlIGFzc29jaWF0ZWQgY29sdW1uIGZpZWxkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtGaWx0ZXJEZXNjcmlwdG9yfVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEZpbHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZmlsdGVyIGZvciB0aGUgYXNzb2NpYXRlZCBjb2x1bW4gZmllbGQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge0ZpbHRlckRlc2NyaXB0b3J9XG4gICAgICovXG4gICAgc2V0IGN1cnJlbnRGaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEZpbHRlciA9IHZhbHVlO1xuICAgIH1cbiAgICB1cGRhdGVGaWx0ZXIoZmlsdGVyJCQxKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jdXJyZW50RmlsdGVyLCBmaWx0ZXIkJDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG4gICAgfVxuICAgIG9uQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyQ2hhbmdlKHRoaXMudXBkYXRlRmlsdGVyKHtcbiAgICAgICAgICAgIGZpZWxkOiB0aGlzLmNvbHVtbi5maWVsZCxcbiAgICAgICAgICAgIG9wZXJhdG9yOiB0aGlzLmN1cnJlbnRPcGVyYXRvcixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG9uU2hpZnRUYWIoZSkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoKCF0aGlzLm1lbnVUYWJiaW5nU2VydmljZSB8fCAhdGhpcy5tZW51VGFiYmluZ1NlcnZpY2UuaXNDb2x1bW5NZW51KSAmJiB0aGlzLmlzRmlyc3REcm9wRG93biAmJiB0aGlzLmZpbHRlclNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmxhc3RGb2N1c2FibGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2UubGFzdEZvY3VzYWJsZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaWx0ZXJNZW51RHJvcERvd25MYWJlbCgpIHtcbiAgICAgICAgY29uc3QgbG9jYWxpemF0aW9uTXNnID0gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnZmlsdGVyTWVudU9wZXJhdG9yc0Ryb3BEb3duTGFiZWwnKSB8fCAnJztcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uID8gdGhpcy5jb2x1bW4udGl0bGUgfHwgdGhpcy5jb2x1bW4uZmllbGQgOiAnJztcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VNZXNzYWdlUGxhY2Vob2xkZXIobG9jYWxpemF0aW9uTXNnLCAnY29sdW1uTmFtZScsIGNvbHVtbk5hbWUpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGaWx0ZXJTZXJ2aWNlKVxuXSwgRmlsdGVyTWVudUlucHV0V3JhcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyU2VydmljZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZpbHRlck1lbnVJbnB1dFdyYXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcImlzRmlyc3REcm9wRG93blwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTWVudVRhYmJpbmdTZXJ2aWNlKVxuXSwgRmlsdGVyTWVudUlucHV0V3JhcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWVudVRhYmJpbmdTZXJ2aWNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoRHJvcERvd25MaXN0Q29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERyb3BEb3duTGlzdENvbXBvbmVudClcbl0sIEZpbHRlck1lbnVJbnB1dFdyYXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZpcnN0T3BlcmF0b3JEcm9wRG93blwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBGaWx0ZXJNZW51SW5wdXRXcmFwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJyZW50RmlsdGVyXCIsIG51bGwpO1xuRmlsdGVyTWVudUlucHV0V3JhcHBlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1maWx0ZXItbWVudS1pbnB1dC13cmFwcGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWRyb3Bkb3dubGlzdFxuICAgICAgICAgICAga2VuZG9GaWx0ZXJNZW51RHJvcERvd25cbiAgICAgICAgICAgIFtmaWx0ZXJNZW51RHJvcERvd25MYWJlbF09XCJmaWx0ZXJNZW51RHJvcERvd25MYWJlbFwiXG4gICAgICAgICAgICBbZGF0YV09XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cIm9wZXJhdG9yQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgW3ZhbHVlXT1cImN1cnJlbnRPcGVyYXRvclwiXG4gICAgICAgICAgICBbdmFsdWVQcmltaXRpdmVdPVwidHJ1ZVwiXG4gICAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHZhbHVlRmllbGQ9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAoa2V5ZG93bi5zaGlmdC50YWIpPVwib25TaGlmdFRhYigkZXZlbnQpXCI+XG4gICAgICAgIDwva2VuZG8tZHJvcGRvd25saXN0PlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBGaWx0ZXJNZW51SW5wdXRXcmFwcGVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTdHJpbmdGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQgPSBjbGFzcyBTdHJpbmdGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5vcGVyYXRvcnMgPSBbXTtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbkxhYmVsKCkge1xuICAgICAgICBjb25zdCBsb2NhbGl6YXRpb25Nc2cgPSB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdmaWx0ZXJJbnB1dExhYmVsJykgfHwgJyc7XG4gICAgICAgIGNvbnN0IGNvbHVtbk5hbWUgPSB0aGlzLmNvbHVtbiA/IHRoaXMuY29sdW1uLnRpdGxlIHx8IHRoaXMuY29sdW1uLmZpZWxkIDogJyc7XG4gICAgICAgIHJldHVybiByZXBsYWNlTWVzc2FnZVBsYWNlaG9sZGVyKGxvY2FsaXphdGlvbk1zZywgJ2NvbHVtbk5hbWUnLCBjb2x1bW5OYW1lKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBTdHJpbmdGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm9wZXJhdG9yc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sdW1uQ29tcG9uZW50KVxuXSwgU3RyaW5nRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFN0cmluZ0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTdHJpbmdGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm9wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTdHJpbmdGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnJlbnRGaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZpbHRlclNlcnZpY2UpXG5dLCBTdHJpbmdGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclNlcnZpY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTdHJpbmdGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImlzRmlyc3REcm9wRG93blwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTWVudVRhYmJpbmdTZXJ2aWNlKVxuXSwgU3RyaW5nRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtZW51VGFiYmluZ1NlcnZpY2VcIiwgdm9pZCAwKTtcblN0cmluZ0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1zdHJpbmctZmlsdGVyLW1lbnUtaW5wdXQnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tZ3JpZC1maWx0ZXItbWVudS1pbnB1dC13cmFwcGVyXG4gICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbZGVmYXVsdE9wZXJhdG9yXT1cIm9wZXJhdG9yXCJcbiAgICAgICAgICAgIFtjdXJyZW50RmlsdGVyXT1cImN1cnJlbnRGaWx0ZXJcIlxuICAgICAgICAgICAgW2ZpbHRlclNlcnZpY2VdPVwiZmlsdGVyU2VydmljZVwiXG4gICAgICAgICAgICBbaXNGaXJzdERyb3BEb3duXT1cImlzRmlyc3REcm9wRG93blwiXG4gICAgICAgICAgICBbbWVudVRhYmJpbmdTZXJ2aWNlXT1cIm1lbnVUYWJiaW5nU2VydmljZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICBrZW5kb1RleHRCb3hcbiAgICAgICAgICAgICAgICBrZW5kb0ZpbHRlcklucHV0XG4gICAgICAgICAgICAgICAgW2NvbHVtbkxhYmVsXT1cImNvbHVtbkxhYmVsXCJcbiAgICAgICAgICAgICAgICBbZmlsdGVyRGVsYXldPVwiMFwiXG4gICAgICAgICAgICAgICAgW25nTW9kZWxdPVwiY3VycmVudEZpbHRlcj8udmFsdWVcIiAvPlxuICAgICAgICA8L2tlbmRvLWdyaWQtZmlsdGVyLW1lbnUtaW5wdXQtd3JhcHBlcj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFN0cmluZ0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN0cmluZy1maWx0ZXIgbWVudSBjb21wb25lbnQuXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV9ncmlkICV9I3RvYy1jb25maWd1cmF0aW9uLWNvbXBvbmVudHMtZm9yLWZpbHRlci10ZW1wbGF0ZXMpKS5cbiAqL1xubGV0IFN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQgPSBjbGFzcyBTdHJpbmdGaWx0ZXJNZW51Q29tcG9uZW50IGV4dGVuZHMgU3RyaW5nRmlsdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIobnVsbCwgbG9jYWxpemF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2dpY09wZXJhdG9ycyA9IGxvZ2ljT3BlcmF0b3JzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IG1lbnUgZmlsdGVyLlxuICAgICAgICAgKiBAdHlwZSB7Q29tcG9zaXRlRmlsdGVyRGVzY3JpcHRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyID0geyBmaWx0ZXJzOiBbXSwgbG9naWM6IFwiYW5kXCIgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIGlucHV0cyBvZiBzZWNvbmQgY3JpdGVyaWEgd2lsbCBkaXNwbGF5ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4dHJhID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZmlyc3RGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBzZXRGaWx0ZXIoMCwgdGhpcy5maWx0ZXIsICh0aGlzLmNvbHVtbiB8fCB7fSkuZmllbGQsIHRoaXMub3BlcmF0b3IpO1xuICAgIH1cbiAgICBnZXQgc2Vjb25kRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gc2V0RmlsdGVyKDEsIHRoaXMuZmlsdGVyLCAodGhpcy5jb2x1bW4gfHwge30pLmZpZWxkLCB0aGlzLm9wZXJhdG9yKTtcbiAgICB9XG4gICAgbG9naWNDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIubG9naWMgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGZpbHRlck1lbnVEcm9wRG93bkxhYmVsKCkge1xuICAgICAgICBjb25zdCBsb2NhbGl6YXRpb25Nc2cgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2ZpbHRlck1lbnVMb2dpY0Ryb3BEb3duTGFiZWwnKSB8fCAnJztcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uID8gdGhpcy5jb2x1bW4udGl0bGUgfHwgdGhpcy5jb2x1bW4uZmllbGQgOiAnJztcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VNZXNzYWdlUGxhY2Vob2xkZXIobG9jYWxpemF0aW9uTXNnLCAnY29sdW1uTmFtZScsIGNvbHVtbk5hbWUpO1xuICAgIH1cbiAgICBsb2NhbGl6YXRpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMubG9naWNPcGVyYXRvcnMgPSBsb2dpY09wZXJhdG9ycyh0aGlzLmxvY2FsaXphdGlvbik7XG4gICAgICAgIHN1cGVyLmxvY2FsaXphdGlvbkNoYW5nZSgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1maWx0ZXJjZWxsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sdW1uQ29tcG9uZW50KVxuXSwgU3RyaW5nRmlsdGVyTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTdHJpbmdGaWx0ZXJNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTdHJpbmdGaWx0ZXJNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJleHRyYVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRmlsdGVyU2VydmljZSlcbl0sIFN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclNlcnZpY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1lbnVUYWJiaW5nU2VydmljZSlcbl0sIFN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcIm1lbnVUYWJiaW5nU2VydmljZVwiLCB2b2lkIDApO1xuU3RyaW5nRmlsdGVyTWVudUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1zdHJpbmctZmlsdGVyLW1lbnUnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tZ3JpZC1zdHJpbmctZmlsdGVyLW1lbnUtaW5wdXRcbiAgICAgICAgICAgIFtjdXJyZW50RmlsdGVyXT1cImZpcnN0RmlsdGVyXCJcbiAgICAgICAgICAgIFtvcGVyYXRvcnNdPVwib3BlcmF0b3JzXCJcbiAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW2lzRmlyc3REcm9wRG93bl09XCJ0cnVlXCJcbiAgICAgICAgICAgIFttZW51VGFiYmluZ1NlcnZpY2VdPVwibWVudVRhYmJpbmdTZXJ2aWNlXCI+XG4gICAgICAgIDwva2VuZG8tZ3JpZC1zdHJpbmctZmlsdGVyLW1lbnUtaW5wdXQ+XG4gICAgICAgIDxrZW5kby1kcm9wZG93bmxpc3RcbiAgICAgICAgICAgICpuZ0lmPVwiZXh0cmFcIlxuICAgICAgICAgICAga2VuZG9GaWx0ZXJNZW51RHJvcERvd25cbiAgICAgICAgICAgIFtmaWx0ZXJNZW51RHJvcERvd25MYWJlbF09XCJmaWx0ZXJNZW51RHJvcERvd25MYWJlbFwiXG4gICAgICAgICAgICBjbGFzcz1cImstZmlsdGVyLWFuZFwiXG4gICAgICAgICAgICBbZGF0YV09XCJsb2dpY09wZXJhdG9yc1wiXG4gICAgICAgICAgICBbdmFsdWVQcmltaXRpdmVdPVwidHJ1ZVwiICh2YWx1ZUNoYW5nZSk9XCJsb2dpY0NoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJmaWx0ZXI/LmxvZ2ljXCJcbiAgICAgICAgICAgIHRleHRGaWVsZD1cInRleHRcIlxuICAgICAgICAgICAgdmFsdWVGaWVsZD1cInZhbHVlXCI+XG4gICAgICAgIDwva2VuZG8tZHJvcGRvd25saXN0PlxuICAgICAgICA8a2VuZG8tZ3JpZC1zdHJpbmctZmlsdGVyLW1lbnUtaW5wdXRcbiAgICAgICAgICAgICpuZ0lmPVwiZXh0cmFcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgW2N1cnJlbnRGaWx0ZXJdPVwic2Vjb25kRmlsdGVyXCJcbiAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW21lbnVUYWJiaW5nU2VydmljZV09XCJtZW51VGFiYmluZ1NlcnZpY2VcIj5cbiAgICAgICAgPC9rZW5kby1ncmlkLXN0cmluZy1maWx0ZXItbWVudS1pbnB1dD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBudW1lcmljLWZpbHRlciBtZW51IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogIGBgYGh0bWwtbm8tcnVuXG4gKiAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiIHRpdGxlPVwiVW5pdCBQcmljZVwiPlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZEZpbHRlck1lbnVUZW1wbGF0ZSBsZXQtZmlsdGVyIGxldC1jb2x1bW49XCJjb2x1bW5cIiBsZXQtZmlsdGVyU2VydmljZT1cImZpbHRlclNlcnZpY2VcIj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLW51bWVyaWMtZmlsdGVyLW1lbnVcbiAqICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gKiAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICogICAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICogICAgICAgICAgICAgID5cbiAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1udW1lcmljLWZpbHRlci1tZW51PlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgYGBgXG4gKi9cbmxldCBOdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudCA9IGNsYXNzIE51bWVyaWNGaWx0ZXJNZW51Q29tcG9uZW50IGV4dGVuZHMgTnVtZXJpY0ZpbHRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIGxvY2FsaXphdGlvbik7XG4gICAgICAgIHRoaXMubG9naWNPcGVyYXRvcnMgPSBsb2dpY09wZXJhdG9ycyh0aGlzLmxvY2FsaXphdGlvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBtZW51IGZpbHRlci5cbiAgICAgICAgICogQHR5cGUge0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlciA9IHsgZmlsdGVyczogW10sIGxvZ2ljOiBcImFuZFwiIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dHMgb2Ygc2Vjb25kIGNyaXRlcmlhIHdpbGwgZGlzcGxheWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHRyYSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gc2V0RmlsdGVyKDAsIHRoaXMuZmlsdGVyLCAodGhpcy5jb2x1bW4gfHwge30pLmZpZWxkLCB0aGlzLm9wZXJhdG9yKTtcbiAgICB9XG4gICAgZ2V0IHNlY29uZEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHNldEZpbHRlcigxLCB0aGlzLmZpbHRlciwgKHRoaXMuY29sdW1uIHx8IHt9KS5maWVsZCwgdGhpcy5vcGVyYXRvcik7XG4gICAgfVxuICAgIGxvZ2ljQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyLmxvZ2ljID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBmaWx0ZXJNZW51RHJvcERvd25MYWJlbCgpIHtcbiAgICAgICAgY29uc3QgbG9jYWxpemF0aW9uTXNnID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdmaWx0ZXJNZW51TG9naWNEcm9wRG93bkxhYmVsJykgfHwgJyc7XG4gICAgICAgIGNvbnN0IGNvbHVtbk5hbWUgPSB0aGlzLmNvbHVtbiA/IHRoaXMuY29sdW1uLnRpdGxlIHx8IHRoaXMuY29sdW1uLmZpZWxkIDogJyc7XG4gICAgICAgIHJldHVybiByZXBsYWNlTWVzc2FnZVBsYWNlaG9sZGVyKGxvY2FsaXphdGlvbk1zZywgJ2NvbHVtbk5hbWUnLCBjb2x1bW5OYW1lKTtcbiAgICB9XG4gICAgbG9jYWxpemF0aW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmxvZ2ljT3BlcmF0b3JzID0gbG9naWNPcGVyYXRvcnModGhpcy5sb2NhbGl6YXRpb24pO1xuICAgICAgICBzdXBlci5sb2NhbGl6YXRpb25DaGFuZ2UoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZmlsdGVyY2VsbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5Db21wb25lbnQpXG5dLCBOdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTnVtZXJpY0ZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImV4dHJhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGaWx0ZXJTZXJ2aWNlKVxuXSwgTnVtZXJpY0ZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclNlcnZpY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1lbnVUYWJiaW5nU2VydmljZSlcbl0sIE51bWVyaWNGaWx0ZXJNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtZW51VGFiYmluZ1NlcnZpY2VcIiwgdm9pZCAwKTtcbk51bWVyaWNGaWx0ZXJNZW51Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLW51bWVyaWMtZmlsdGVyLW1lbnUnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tZ3JpZC1udW1lcmljLWZpbHRlci1tZW51LWlucHV0XG4gICAgICAgICAgICBbY3VycmVudEZpbHRlcl09XCJmaXJzdEZpbHRlclwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbZmlsdGVyU2VydmljZV09XCJmaWx0ZXJTZXJ2aWNlXCJcbiAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgIFtmb3JtYXRdPVwiZm9ybWF0XCJcbiAgICAgICAgICAgIFtkZWNpbWFsc109XCJkZWNpbWFsc1wiXG4gICAgICAgICAgICBbc3Bpbm5lcnNdPVwic3Bpbm5lcnNcIlxuICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgW3N0ZXBdPVwic3RlcFwiXG4gICAgICAgICAgICBbbWVudVRhYmJpbmdTZXJ2aWNlXT1cIm1lbnVUYWJiaW5nU2VydmljZVwiXG4gICAgICAgICAgICBbaXNGaXJzdERyb3BEb3duXT1cInRydWVcIlxuICAgICAgICAgICAgPlxuICAgICAgICA8L2tlbmRvLWdyaWQtbnVtZXJpYy1maWx0ZXItbWVudS1pbnB1dD5cbiAgICAgICAgPGtlbmRvLWRyb3Bkb3dubGlzdFxuICAgICAgICAgICAgKm5nSWY9XCJleHRyYVwiXG4gICAgICAgICAgICBrZW5kb0ZpbHRlck1lbnVEcm9wRG93blxuICAgICAgICAgICAgW2ZpbHRlck1lbnVEcm9wRG93bkxhYmVsXT1cImZpbHRlck1lbnVEcm9wRG93bkxhYmVsXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay1maWx0ZXItYW5kXCJcbiAgICAgICAgICAgIFtkYXRhXT1cImxvZ2ljT3BlcmF0b3JzXCJcbiAgICAgICAgICAgIFt2YWx1ZVByaW1pdGl2ZV09XCJ0cnVlXCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJsb2dpY0NoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJmaWx0ZXI/LmxvZ2ljXCJcbiAgICAgICAgICAgIHRleHRGaWVsZD1cInRleHRcIlxuICAgICAgICAgICAgdmFsdWVGaWVsZD1cInZhbHVlXCI+XG4gICAgICAgIDwva2VuZG8tZHJvcGRvd25saXN0PlxuICAgICAgICA8a2VuZG8tZ3JpZC1udW1lcmljLWZpbHRlci1tZW51LWlucHV0XG4gICAgICAgICAgICAqbmdJZj1cImV4dHJhXCJcbiAgICAgICAgICAgIFtvcGVyYXRvcnNdPVwib3BlcmF0b3JzXCJcbiAgICAgICAgICAgIFtjdXJyZW50RmlsdGVyXT1cInNlY29uZEZpbHRlclwiXG4gICAgICAgICAgICBbZmlsdGVyU2VydmljZV09XCJmaWx0ZXJTZXJ2aWNlXCJcbiAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgIFtmb3JtYXRdPVwiZm9ybWF0XCJcbiAgICAgICAgICAgIFtkZWNpbWFsc109XCJkZWNpbWFsc1wiXG4gICAgICAgICAgICBbc3Bpbm5lcnNdPVwic3Bpbm5lcnNcIlxuICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgW3N0ZXBdPVwic3RlcFwiXG4gICAgICAgICAgICBbbWVudVRhYmJpbmdTZXJ2aWNlXT1cIm1lbnVUYWJiaW5nU2VydmljZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgIDwva2VuZG8tZ3JpZC1udW1lcmljLWZpbHRlci1tZW51LWlucHV0PlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgTnVtZXJpY0ZpbHRlck1lbnVDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE51bWVyaWNGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQgPSBjbGFzcyBOdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMub3BlcmF0b3JzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHZhbHVlIHdoaWNoIGlzIHVzZWQgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCB0aGUgY29tcG9uZW50IHZhbHVlLlxuICAgICAgICAgKiBAdHlwZSB7bnVtZXJpY31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RlcCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgKipVcCoqIGFuZCAqKkRvd24qKiBzcGluIGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwaW5uZXJzID0gdHJ1ZTtcbiAgICB9XG4gICAgbWVzc2FnZUZvcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkxhYmVsKCkge1xuICAgICAgICBjb25zdCBsb2NhbGl6YXRpb25Nc2cgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2ZpbHRlcklucHV0TGFiZWwnKSB8fCAnJztcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uID8gdGhpcy5jb2x1bW4udGl0bGUgfHwgdGhpcy5jb2x1bW4uZmllbGQgOiAnJztcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VNZXNzYWdlUGxhY2Vob2xkZXIobG9jYWxpemF0aW9uTXNnLCAnY29sdW1uTmFtZScsIGNvbHVtbk5hbWUpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIE51bWVyaWNGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm9wZXJhdG9yc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sdW1uQ29tcG9uZW50KVxuXSwgTnVtZXJpY0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE51bWVyaWNGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm9wZXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJyZW50RmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGaWx0ZXJTZXJ2aWNlKVxuXSwgTnVtZXJpY0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyU2VydmljZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE51bWVyaWNGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImlzRmlyc3REcm9wRG93blwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTWVudVRhYmJpbmdTZXJ2aWNlKVxuXSwgTnVtZXJpY0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwibWVudVRhYmJpbmdTZXJ2aWNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE51bWVyaWNGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE51bWVyaWNGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInNwaW5uZXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWNpbWFsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTnVtZXJpY0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5OdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLW51bWVyaWMtZmlsdGVyLW1lbnUtaW5wdXQnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tZ3JpZC1maWx0ZXItbWVudS1pbnB1dC13cmFwcGVyXG4gICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbZGVmYXVsdE9wZXJhdG9yXT1cIm9wZXJhdG9yXCJcbiAgICAgICAgICAgIFtjdXJyZW50RmlsdGVyXT1cImN1cnJlbnRGaWx0ZXJcIlxuICAgICAgICAgICAgW2ZpbHRlclNlcnZpY2VdPVwiZmlsdGVyU2VydmljZVwiXG4gICAgICAgICAgICBbaXNGaXJzdERyb3BEb3duXT1cImlzRmlyc3REcm9wRG93blwiXG4gICAgICAgICAgICBbbWVudVRhYmJpbmdTZXJ2aWNlXT1cIm1lbnVUYWJiaW5nU2VydmljZVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxrZW5kby1udW1lcmljdGV4dGJveFxuICAgICAgICAgICAgICAgIGtlbmRvRmlsdGVySW5wdXRcbiAgICAgICAgICAgICAgICBbY29sdW1uTGFiZWxdPVwiY29sdW1uTGFiZWxcIlxuICAgICAgICAgICAgICAgIFtmaWx0ZXJEZWxheV09XCIwXCJcbiAgICAgICAgICAgICAgICBbYXV0b0NvcnJlY3RdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cImN1cnJlbnRGaWx0ZXI/LnZhbHVlXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICAgICAgW2RlY2ltYWxzXT1cImRlY2ltYWxzXCJcbiAgICAgICAgICAgICAgICBbc3Bpbm5lcnNdPVwic3Bpbm5lcnNcIlxuICAgICAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgW3N0ZXBdPVwic3RlcFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGtlbmRvLW51bWVyaWN0ZXh0Ym94LW1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgIFtpbmNyZW1lbnRdPVwibWVzc2FnZUZvcignZmlsdGVyTnVtZXJpY0luY3JlbWVudCcpXCJcbiAgICAgICAgICAgICAgICAgICAgW2RlY3JlbWVudF09XCJtZXNzYWdlRm9yKCdmaWx0ZXJOdW1lcmljRGVjcmVtZW50JylcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLW51bWVyaWN0ZXh0Ym94LW1lc3NhZ2VzPlxuICAgICAgICAgICAgPC9rZW5kby1udW1lcmljdGV4dGJveD5cbiAgICAgICAgPC9rZW5kby1ncmlkLWZpbHRlci1tZW51LWlucHV0LXdyYXBwZXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBOdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGF0ZS1maWx0ZXIgbWVudSBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqICBgYGBodG1sLW5vLXJ1blxuICogICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJPcmRlckRhdGVcIiB0aXRsZT1cIk9yZGVyIERhdGVcIj5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRGaWx0ZXJNZW51VGVtcGxhdGUgbGV0LWZpbHRlciBsZXQtY29sdW1uPVwiY29sdW1uXCIgbGV0LWZpbHRlclNlcnZpY2U9XCJmaWx0ZXJTZXJ2aWNlXCI+XG4gKiAgICAgICAgICAgIDxrZW5kby1ncmlkLWRhdGUtZmlsdGVyLW1lbnVcbiAqICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAqICAgICAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAqICAgICAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICogICAgICAgICAgICAgICAgPlxuICogICAgICAgICAgICA8L2tlbmRvLWdyaWQtZGF0ZS1maWx0ZXItbWVudT5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgIGBgYFxuICovXG5sZXQgRGF0ZUZpbHRlck1lbnVDb21wb25lbnQgPSBjbGFzcyBEYXRlRmlsdGVyTWVudUNvbXBvbmVudCBleHRlbmRzIERhdGVGaWx0ZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikge1xuICAgICAgICBzdXBlcihudWxsLCBsb2NhbGl6YXRpb24pO1xuICAgICAgICB0aGlzLmxvZ2ljT3BlcmF0b3JzID0gbG9naWNPcGVyYXRvcnModGhpcy5sb2NhbGl6YXRpb24pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgbWVudSBmaWx0ZXIuXG4gICAgICAgICAqIEB0eXBlIHtDb21wb3NpdGVGaWx0ZXJEZXNjcmlwdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXIgPSB7IGZpbHRlcnM6IFtdLCBsb2dpYzogXCJhbmRcIiB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXRzIG9mIHNlY29uZCBjcml0ZXJpYSB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXh0cmEgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhvc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBmaXJzdEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHNldEZpbHRlcigwLCB0aGlzLmZpbHRlciwgKHRoaXMuY29sdW1uIHx8IHt9KS5maWVsZCwgdGhpcy5vcGVyYXRvcik7XG4gICAgfVxuICAgIGdldCBzZWNvbmRGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBzZXRGaWx0ZXIoMSwgdGhpcy5maWx0ZXIsICh0aGlzLmNvbHVtbiB8fCB7fSkuZmllbGQsIHRoaXMub3BlcmF0b3IpO1xuICAgIH1cbiAgICBsb2dpY0NoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZpbHRlci5sb2dpYyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZmlsdGVyTWVudURyb3BEb3duTGFiZWwoKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsaXphdGlvbk1zZyA9IHRoaXMubG9jYWxpemF0aW9uLmdldCgnZmlsdGVyTWVudUxvZ2ljRHJvcERvd25MYWJlbCcpIHx8ICcnO1xuICAgICAgICBjb25zdCBjb2x1bW5OYW1lID0gdGhpcy5jb2x1bW4gPyB0aGlzLmNvbHVtbi50aXRsZSB8fCB0aGlzLmNvbHVtbi5maWVsZCA6ICcnO1xuICAgICAgICByZXR1cm4gcmVwbGFjZU1lc3NhZ2VQbGFjZWhvbGRlcihsb2NhbGl6YXRpb25Nc2csICdjb2x1bW5OYW1lJywgY29sdW1uTmFtZSk7XG4gICAgfVxuICAgIGxvY2FsaXphdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5sb2dpY09wZXJhdG9ycyA9IGxvZ2ljT3BlcmF0b3JzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgc3VwZXIubG9jYWxpemF0aW9uQ2hhbmdlKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZpbHRlcmNlbGwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRGF0ZUZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sdW1uQ29tcG9uZW50KVxuXSwgRGF0ZUZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZUZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVGaWx0ZXJNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJleHRyYVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRmlsdGVyU2VydmljZSlcbl0sIERhdGVGaWx0ZXJNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJTZXJ2aWNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBNZW51VGFiYmluZ1NlcnZpY2UpXG5dLCBEYXRlRmlsdGVyTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWVudVRhYmJpbmdTZXJ2aWNlXCIsIHZvaWQgMCk7XG5EYXRlRmlsdGVyTWVudUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1kYXRlLWZpbHRlci1tZW51JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWdyaWQtZGF0ZS1maWx0ZXItbWVudS1pbnB1dFxuICAgICAgICAgICAgW2N1cnJlbnRGaWx0ZXJdPVwiZmlyc3RGaWx0ZXJcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgW2ZpbHRlclNlcnZpY2VdPVwiZmlsdGVyU2VydmljZVwiXG4gICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3XCJcbiAgICAgICAgICAgIFtib3R0b21WaWV3XT1cImJvdHRvbVZpZXdcIlxuICAgICAgICAgICAgW3RvcFZpZXddPVwidG9wVmlld1wiXG4gICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICBbZm9ybWF0UGxhY2Vob2xkZXJdPVwiZm9ybWF0UGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgIFt3ZWVrTnVtYmVyXT1cIndlZWtOdW1iZXJcIlxuICAgICAgICAgICAgW2lzRmlyc3REcm9wRG93bl09XCJ0cnVlXCJcbiAgICAgICAgICAgIFttZW51VGFiYmluZ1NlcnZpY2VdPVwibWVudVRhYmJpbmdTZXJ2aWNlXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgPC9rZW5kby1ncmlkLWRhdGUtZmlsdGVyLW1lbnUtaW5wdXQ+XG4gICAgICAgIDxrZW5kby1kcm9wZG93bmxpc3RcbiAgICAgICAgICAgICpuZ0lmPVwiZXh0cmFcIlxuICAgICAgICAgICAga2VuZG9GaWx0ZXJNZW51RHJvcERvd25cbiAgICAgICAgICAgIFtmaWx0ZXJNZW51RHJvcERvd25MYWJlbF09XCJmaWx0ZXJNZW51RHJvcERvd25MYWJlbFwiXG4gICAgICAgICAgICBjbGFzcz1cImstZmlsdGVyLWFuZFwiXG4gICAgICAgICAgICBbZGF0YV09XCJsb2dpY09wZXJhdG9yc1wiXG4gICAgICAgICAgICBbdmFsdWVQcmltaXRpdmVdPVwidHJ1ZVwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwibG9naWNDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwiZmlsdGVyPy5sb2dpY1wiXG4gICAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHZhbHVlRmllbGQ9XCJ2YWx1ZVwiPlxuICAgICAgICA8L2tlbmRvLWRyb3Bkb3dubGlzdD5cbiAgICAgICAgPGtlbmRvLWdyaWQtZGF0ZS1maWx0ZXItbWVudS1pbnB1dFxuICAgICAgICAgICAgKm5nSWY9XCJleHRyYVwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbY3VycmVudEZpbHRlcl09XCJzZWNvbmRGaWx0ZXJcIlxuICAgICAgICAgICAgW2ZpbHRlclNlcnZpY2VdPVwiZmlsdGVyU2VydmljZVwiXG4gICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3XCJcbiAgICAgICAgICAgIFtib3R0b21WaWV3XT1cImJvdHRvbVZpZXdcIlxuICAgICAgICAgICAgW3RvcFZpZXddPVwidG9wVmlld1wiXG4gICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICBbZm9ybWF0UGxhY2Vob2xkZXJdPVwiZm9ybWF0UGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgIFt3ZWVrTnVtYmVyXT1cIndlZWtOdW1iZXJcIlxuICAgICAgICAgICAgW21lbnVUYWJiaW5nU2VydmljZV09XCJtZW51VGFiYmluZ1NlcnZpY2VcIlxuICAgICAgICAgICAgPlxuICAgICAgICA8L2tlbmRvLWdyaWQtZGF0ZS1maWx0ZXItbWVudS1pbnB1dD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIERhdGVGaWx0ZXJNZW51Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBCb29sZWFuRmlsdGVyUmFkaW9CdXR0b25EaXJlY3RpdmUgPSBjbGFzcyBCb29sZWFuRmlsdGVyUmFkaW9CdXR0b25EaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RFbGVtZW50LCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnJhZGlvQnV0dG9uRWwgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2FyaWEtbGFiZWwnLCB0aGlzLmNvbHVtbkxhYmVsKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQm9vbGVhbkZpbHRlclJhZGlvQnV0dG9uRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb2x1bW5MYWJlbFwiLCB2b2lkIDApO1xuQm9vbGVhbkZpbHRlclJhZGlvQnV0dG9uRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdba2VuZG9GaWx0ZXJNZW51UmFkaW9CdXR0b25dJyB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBCb29sZWFuRmlsdGVyUmFkaW9CdXR0b25EaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBCb29sZWFuLWZpbHRlciBtZW51IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogIGBgYGh0bWwtbm8tcnVuXG4gKiAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkRpc2NvbnRpbnVlZFwiIHRpdGxlPVwiRGlzY29udGludWVkXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkRmlsdGVyTWVudVRlbXBsYXRlIGxldC1maWx0ZXIgbGV0LWNvbHVtbj1cImNvbHVtblwiIGxldC1maWx0ZXJTZXJ2aWNlPVwiZmlsdGVyU2VydmljZVwiPlxuICogICAgICAgICAgICA8a2VuZG8tZ3JpZC1ib29sZWFuLWZpbHRlci1tZW51XG4gKiAgICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gKiAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gKiAgICAgICAgICAgICAgICBbZmlsdGVyU2VydmljZV09XCJmaWx0ZXJTZXJ2aWNlXCJcbiAqICAgICAgICAgICAgICAgID5cbiAqICAgICAgICAgICAgPC9rZW5kby1ncmlkLWJvb2xlYW4tZmlsdGVyLW1lbnU+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICBgYGBcbiAqL1xubGV0IEJvb2xlYW5GaWx0ZXJNZW51Q29tcG9uZW50ID0gY2xhc3MgQm9vbGVhbkZpbHRlck1lbnVDb21wb25lbnQgZXh0ZW5kcyBCb29sZWFuRmlsdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIobnVsbCwgbG9jYWxpemF0aW9uKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IG1lbnUgZmlsdGVyLlxuICAgICAgICAgKiBAdHlwZSB7Q29tcG9zaXRlRmlsdGVyRGVzY3JpcHRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyID0geyBmaWx0ZXJzOiBbXSwgbG9naWM6IFwiYW5kXCIgfTtcbiAgICAgICAgdGhpcy5pZFByZWZpeCA9IGd1aWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2UuZmlyc3RGb2N1c2FibGUgPSB0aGlzLnJhZGlvQnV0dG9ucy5maXJzdC5yYWRpb0J1dHRvbkVsO1xuICAgICAgICB0aGlzLnJhZGlvQnV0dG9ucy5maXJzdC5yYWRpb0J1dHRvbkVsLmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByYWRpb0lkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkUHJlZml4fV8ke3ZhbHVlfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNoYW5nZSh2YWx1ZSwgaW5wdXQpIHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlcih0aGlzLnVwZGF0ZUZpbHRlcih7XG4gICAgICAgICAgICBmaWVsZDogdGhpcy5jb2x1bW4uZmllbGQsXG4gICAgICAgICAgICBvcGVyYXRvcjogXCJlcVwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlLm1lbnVUYWJiaW5nU2VydmljZS5maXJzdEZvY3VzYWJsZSA9IGlucHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaXNTZWxlY3RlZChyYWRpb1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnNCeUZpZWxkKHRoaXMuY29sdW1uLmZpZWxkKS5zb21lKCh7IHZhbHVlIH0pID0+IHZhbHVlID09PSByYWRpb1ZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uU2hpZnRUYWIoZSkge1xuICAgICAgICBpZiAoKCF0aGlzLm1lbnVUYWJiaW5nU2VydmljZSB8fCAhdGhpcy5tZW51VGFiYmluZ1NlcnZpY2UuaXNDb2x1bW5NZW51KSAmJiB0aGlzLmZpbHRlclNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmxhc3RGb2N1c2FibGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2UubGFzdEZvY3VzYWJsZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY29sdW1uTGFiZWwoKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsaXphdGlvbk1zZyA9IHRoaXMubG9jYWxpemF0aW9uLmdldCgnZmlsdGVySW5wdXRMYWJlbCcpIHx8ICcnO1xuICAgICAgICBjb25zdCBjb2x1bW5OYW1lID0gdGhpcy5jb2x1bW4udGl0bGUgfHwgdGhpcy5jb2x1bW4uZmllbGQ7XG4gICAgICAgIHJldHVybiByZXBsYWNlTWVzc2FnZVBsYWNlaG9sZGVyKGxvY2FsaXphdGlvbk1zZywgJ2NvbHVtbk5hbWUnLCBjb2x1bW5OYW1lKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZmlsdGVyY2VsbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBCb29sZWFuRmlsdGVyTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBCb29sZWFuRmlsdGVyTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGaWx0ZXJTZXJ2aWNlKVxuXSwgQm9vbGVhbkZpbHRlck1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclNlcnZpY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1lbnVUYWJiaW5nU2VydmljZSlcbl0sIEJvb2xlYW5GaWx0ZXJNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtZW51VGFiYmluZ1NlcnZpY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZHJlbihCb29sZWFuRmlsdGVyUmFkaW9CdXR0b25EaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBCb29sZWFuRmlsdGVyTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmFkaW9CdXR0b25zXCIsIHZvaWQgMCk7XG5Cb29sZWFuRmlsdGVyTWVudUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1ib29sZWFuLWZpbHRlci1tZW51JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHVsIGNsYXNzPVwiay1yYWRpby1saXN0IGstcmVzZXRcIj5cbiAgICAgICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgICAgICBrZW5kb0ZpbHRlck1lbnVSYWRpb0J1dHRvblxuICAgICAgICAgICAgICAgICAgICBbY29sdW1uTGFiZWxdPVwiY29sdW1uTGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICAjaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgW25hbWVdPVwiaWRQcmVmaXhcIlxuICAgICAgICAgICAgICAgICAgICBrZW5kb1JhZGlvQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIFtjaGVja2VkXT1cImlzU2VsZWN0ZWQoaXRlbS52YWx1ZSlcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5pZF09XCJyYWRpb0lkKGl0ZW0udmFsdWUpXCJcbiAgICAgICAgICAgICAgICAgICAgKGNoYW5nZSk9XCJvbkNoYW5nZShpdGVtLnZhbHVlLCBpbnB1dClcIlxuICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi5zaGlmdC50YWIpPVwib25TaGlmdFRhYigkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImstcmFkaW8tbGFiZWxcIiBbYXR0ci5mb3JdPVwicmFkaW9JZChpdGVtLnZhbHVlKVwiPnt7aXRlbS50ZXh0fX08L2xhYmVsPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIEJvb2xlYW5GaWx0ZXJNZW51Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogPiBMaXN0IHRoZSBmb2xsb3dpbmcgY29tcG9uZW50cyBhcyBgZW50cnlDb21wb25lbnRzYCBpbiB0aGUgR3JpZE1vZHVsZS5cbiAqL1xuY29uc3QgZmlsdGVyTWVudUNvbXBvbmVudEZhY3RvcnkgPSAodHlwZSkgPT4gKHtcbiAgICBcImJvb2xlYW5cIjogQm9vbGVhbkZpbHRlck1lbnVDb21wb25lbnQsXG4gICAgXCJkYXRlXCI6IERhdGVGaWx0ZXJNZW51Q29tcG9uZW50LFxuICAgIFwibnVtZXJpY1wiOiBOdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICBcInRleHRcIjogU3RyaW5nRmlsdGVyTWVudUNvbXBvbmVudFxufVt0eXBlXSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRmlsdGVyTWVudUhvc3REaXJlY3RpdmUgPSBjbGFzcyBGaWx0ZXJNZW51SG9zdERpcmVjdGl2ZSBleHRlbmRzIEZpbHRlckhvc3REaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIHJlc29sdmVyKSB7XG4gICAgICAgIHN1cGVyKGhvc3QsIHJlc29sdmVyKTtcbiAgICB9XG4gICAgY29tcG9uZW50VHlwZSgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmNvbHVtbikgJiYgIWlzTnVsbE9yRW1wdHlTdHJpbmcodGhpcy5jb2x1bW4uZmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlck1lbnVDb21wb25lbnRGYWN0b3J5KHRoaXMuY29sdW1uLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQ7XG4gICAgfVxuICAgIGluaXRDb21wb25lbnQoY3R4KSB7XG4gICAgICAgIHN1cGVyLmluaXRDb21wb25lbnQoY3R4KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFuY2UuZmlsdGVyU2VydmljZSA9IHRoaXMuZmlsdGVyU2VydmljZTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFuY2UubWVudVRhYmJpbmdTZXJ2aWNlID0gdGhpcy5tZW51VGFiYmluZ1NlcnZpY2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZpbHRlclNlcnZpY2UpXG5dLCBGaWx0ZXJNZW51SG9zdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmlsdGVyU2VydmljZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTWVudVRhYmJpbmdTZXJ2aWNlKVxuXSwgRmlsdGVyTWVudUhvc3REaXJlY3RpdmUucHJvdG90eXBlLCBcIm1lbnVUYWJiaW5nU2VydmljZVwiLCB2b2lkIDApO1xuRmlsdGVyTWVudUhvc3REaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0ZpbHRlck1lbnVIb3N0XSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1ZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcl0pXG5dLCBGaWx0ZXJNZW51SG9zdERpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudCA9IGNsYXNzIERhdGVGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHBvcHVwU2VydmljZSwgbG9jYWxpemF0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5vcGVyYXRvcnMgPSBbXTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuKHBpY2tlcikge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMucG9wdXBTZXJ2aWNlLm9uQ2xvc2VcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiBwaWNrZXIuaXNBY3RpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShlID0+IGUucHJldmVudERlZmF1bHQoKSk7XG4gICAgfVxuICAgIG1lc3NhZ2VGb3Ioa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KGtleSk7XG4gICAgfVxuICAgIGdldCBjb2x1bW5MYWJlbCgpIHtcbiAgICAgICAgY29uc3QgbG9jYWxpemF0aW9uTXNnID0gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnZmlsdGVySW5wdXRMYWJlbCcpIHx8ICcnO1xuICAgICAgICBjb25zdCBjb2x1bW5OYW1lID0gdGhpcy5jb2x1bW4gPyB0aGlzLmNvbHVtbi50aXRsZSB8fCB0aGlzLmNvbHVtbi5maWVsZCA6ICcnO1xuICAgICAgICByZXR1cm4gcmVwbGFjZU1lc3NhZ2VQbGFjZWhvbGRlcihsb2NhbGl6YXRpb25Nc2csICdjb2x1bW5OYW1lJywgY29sdW1uTmFtZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwib3BlcmF0b3JzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5Db21wb25lbnQpXG5dLCBEYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwib3BlcmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnJlbnRGaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZpbHRlclNlcnZpY2UpXG5dLCBEYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJTZXJ2aWNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBNZW51VGFiYmluZ1NlcnZpY2UpXG5dLCBEYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtZW51VGFiYmluZ1NlcnZpY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0UGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJib3R0b21WaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b3BWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImlzRmlyc3REcm9wRG93blwiLCB2b2lkIDApO1xuRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1kYXRlLWZpbHRlci1tZW51LWlucHV0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWdyaWQtZmlsdGVyLW1lbnUtaW5wdXQtd3JhcHBlclxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgW2RlZmF1bHRPcGVyYXRvcl09XCJvcGVyYXRvclwiXG4gICAgICAgICAgICBbY3VycmVudEZpbHRlcl09XCJjdXJyZW50RmlsdGVyXCJcbiAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICAgICAgICAgICAgW2lzRmlyc3REcm9wRG93bl09XCJpc0ZpcnN0RHJvcERvd25cIlxuICAgICAgICAgICAgW21lbnVUYWJiaW5nU2VydmljZV09XCJtZW51VGFiYmluZ1NlcnZpY2VcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8a2VuZG8tZGF0ZXBpY2tlclxuICAgICAgICAgICAgICAgICNwaWNrZXJcbiAgICAgICAgICAgICAgICBrZW5kb0ZpbHRlcklucHV0XG4gICAgICAgICAgICAgICAgW2NvbHVtbkxhYmVsXT1cImNvbHVtbkxhYmVsXCJcbiAgICAgICAgICAgICAgICBbZmlsdGVyRGVsYXldPVwiMFwiXG4gICAgICAgICAgICAgICAgKG9wZW4pPVwib3BlbihwaWNrZXIpXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVdPVwiY3VycmVudEZpbHRlcj8udmFsdWVcIlxuICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdFBsYWNlaG9sZGVyXT1cImZvcm1hdFBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3XCJcbiAgICAgICAgICAgICAgICBbYm90dG9tVmlld109XCJib3R0b21WaWV3XCJcbiAgICAgICAgICAgICAgICBbdG9wVmlld109XCJ0b3BWaWV3XCJcbiAgICAgICAgICAgICAgICBbd2Vla051bWJlcl09XCJ3ZWVrTnVtYmVyXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8a2VuZG8tZGF0ZXBpY2tlci1tZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICBbdG9nZ2xlXT1cIm1lc3NhZ2VGb3IoJ2ZpbHRlckRhdGVUb2dnbGUnKVwiXG4gICAgICAgICAgICAgICAgICAgIFt0b2RheV09XCJtZXNzYWdlRm9yKCdmaWx0ZXJEYXRlVG9kYXknKVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tZGF0ZXBpY2tlci1tZXNzYWdlcz5cbiAgICAgICAgICAgIDwva2VuZG8tZGF0ZXBpY2tlcj5cbiAgICAgICAgPC9rZW5kby1ncmlkLWZpbHRlci1tZW51LWlucHV0LXdyYXBwZXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU2luZ2xlUG9wdXBTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIERhdGVGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEZpbHRlck1lbnVEcm9wRG93bkxpc3REaXJlY3RpdmUgPSBjbGFzcyBGaWx0ZXJNZW51RHJvcERvd25MaXN0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMua2V5ZG93bkhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS2V5cy5Fc2NhcGUgJiYgdGhpcy5ob3N0LmlzT3Blbikge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0LnRvZ2dsZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlckVsZW1lbnQgPSB0aGlzLmhvc3Qud3JhcHBlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICB3cmFwcGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aGlzLmZpbHRlck1lbnVEcm9wRG93bkxhYmVsKTtcbiAgICAgICAgd3JhcHBlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIsIHRydWUpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5ob3N0LndyYXBwZXIubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcik7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZpbHRlck1lbnVEcm9wRG93bkxpc3REaXJlY3RpdmUucHJvdG90eXBlLCBcImZpbHRlck1lbnVEcm9wRG93bkxhYmVsXCIsIHZvaWQgMCk7XG5GaWx0ZXJNZW51RHJvcERvd25MaXN0RGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdba2VuZG9GaWx0ZXJNZW51RHJvcERvd25dJyB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Ryb3BEb3duTGlzdENvbXBvbmVudF0pXG5dLCBGaWx0ZXJNZW51RHJvcERvd25MaXN0RGlyZWN0aXZlKTtcblxuY29uc3QgSU5URVJOQUxfQ09NUE9ORU5UUyQyID0gW1xuICAgIEZpbHRlck1lbnVDb21wb25lbnQsXG4gICAgRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudCxcbiAgICBGaWx0ZXJNZW51SW5wdXRXcmFwcGVyQ29tcG9uZW50LFxuICAgIFN0cmluZ0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudCxcbiAgICBTdHJpbmdGaWx0ZXJNZW51Q29tcG9uZW50LFxuICAgIEZpbHRlck1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBOdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICBOdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LFxuICAgIERhdGVGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQsXG4gICAgRGF0ZUZpbHRlck1lbnVDb21wb25lbnQsXG4gICAgRmlsdGVyTWVudUhvc3REaXJlY3RpdmUsXG4gICAgQm9vbGVhbkZpbHRlck1lbnVDb21wb25lbnQsXG4gICAgRmlsdGVyTWVudURyb3BEb3duTGlzdERpcmVjdGl2ZSxcbiAgICBCb29sZWFuRmlsdGVyUmFkaW9CdXR0b25EaXJlY3RpdmVcbl07XG5jb25zdCBFTlRSWV9DT01QT05FTlRTJDEgPSBbXG4gICAgU3RyaW5nRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICBOdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICBEYXRlRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICBCb29sZWFuRmlsdGVyTWVudUNvbXBvbmVudFxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRmlsdGVyTWVudU1vZHVsZSA9IGNsYXNzIEZpbHRlck1lbnVNb2R1bGUge1xuICAgIHN0YXRpYyBleHBvcnRzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgU3RyaW5nRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICAgICAgICAgIEZpbHRlck1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIE51bWVyaWNGaWx0ZXJNZW51Q29tcG9uZW50LFxuICAgICAgICAgICAgRGF0ZUZpbHRlck1lbnVDb21wb25lbnQsXG4gICAgICAgICAgICBCb29sZWFuRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICAgICAgICAgIEZpbHRlck1lbnVEcm9wRG93bkxpc3REaXJlY3RpdmUsXG4gICAgICAgICAgICBCb29sZWFuRmlsdGVyUmFkaW9CdXR0b25EaXJlY3RpdmUsXG4gICAgICAgICAgICBTaGFyZWRGaWx0ZXJNb2R1bGUuZXhwb3J0cygpXG4gICAgICAgIF07XG4gICAgfVxufTtcbkZpbHRlck1lbnVNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0lOVEVSTkFMX0NPTVBPTkVOVFMkMl0sXG4gICAgICAgIGVudHJ5Q29tcG9uZW50czogRU5UUllfQ09NUE9ORU5UUyQxLFxuICAgICAgICBleHBvcnRzOiBbSU5URVJOQUxfQ09NUE9ORU5UUyQyLCBTaGFyZWRGaWx0ZXJNb2R1bGVdLFxuICAgICAgICBpbXBvcnRzOiBbU2hhcmVkRmlsdGVyTW9kdWxlXVxuICAgIH0pXG5dLCBGaWx0ZXJNZW51TW9kdWxlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb2x1bW5MaXN0Q29tcG9uZW50ID0gY2xhc3MgQ29sdW1uTGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmdab25lLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlc2V0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFwcGx5ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvbHVtbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hdXRvU3luYyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWxsb3dIaWRlQWxsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aW9uc0NsYXNzID0gJ2stYWN0aW9uLWJ1dHRvbnMnO1xuICAgICAgICB0aGlzLnVubG9ja2VkQ291bnQgPSAwO1xuICAgIH1cbiAgICBnZXQgY2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2V0IGNvbHVtbnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29sdW1ucyA9IHZhbHVlLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmluY2x1ZGVJbkNob29zZXIgIT09IGZhbHNlKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sdW1uU3RhdGUoKTtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xuICAgIH1cbiAgICBpc0Rpc2FibGVkKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gISh0aGlzLmFsbG93SGlkZUFsbCB8fCB0aGlzLmhhc0ZpbHRlcmVkIHx8IGNvbHVtbi5oaWRkZW4gfHwgdGhpcy5jb2x1bW5zLmZpbmQoY3VycmVudCA9PiBjdXJyZW50ICE9PSBjb2x1bW4gJiYgIWN1cnJlbnQuaGlkZGVuKSkgfHxcbiAgICAgICAgICAgICh0aGlzLmhhc1Zpc2libGVMb2NrZWQgJiYgIXRoaXMuaGFzVW5sb2NrZWRGaWx0ZXJlZCAmJiB0aGlzLnVubG9ja2VkQ291bnQgPT09IDEgJiYgIWNvbHVtbi5sb2NrZWQgJiYgIWNvbHVtbi5oaWRkZW4pO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3NlcyhlLnRhcmdldCwgJ2stY2hlY2tib3gnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvU3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZGRlbiA9ICFlLnRhcmdldC5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJvb2xlYW4oY29sdW1uLmhpZGRlbikgIT09IGhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5oaWRkZW4gPSBoaWRkZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uQ2hhbmdlLmVtaXQoW2NvbHVtbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNhYmxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMuaXNMYXN0ICYmIHRoaXMuaXNMYXN0KSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmxhc3RGb2N1c2FibGUgPSB0aGlzLmFwcGx5QnV0dG9uLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMuaXNFeHBhbmRlZCAmJiB0aGlzLmlzRXhwYW5kZWQgJiYgdGhpcy5pc0xhc3QgJiYgdGhpcy5hcHBseUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLm1lbnVUYWJiaW5nU2VydmljZS5sYXN0Rm9jdXNhYmxlID0gdGhpcy5hcHBseUJ1dHRvbi5uYXRpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5kb21TdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hDaGVja0JveCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9ICF0aGlzLmNvbHVtbnNbaW5kZXhdLmhpZGRlbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlzYWJsZWQoKTtcbiAgICAgICAgdGhpcy5yZXNldC5lbWl0KCk7XG4gICAgfVxuICAgIGFwcGx5Q2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2hDaGVja0JveCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuY29sdW1uc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBoaWRkZW4gPSAhZWxlbWVudC5jaGVja2VkO1xuICAgICAgICAgICAgaWYgKEJvb2xlYW4oY29sdW1uLmhpZGRlbikgIT09IGhpZGRlbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5oaWRkZW4gPSBoaWRkZW47XG4gICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc2FibGVkKCk7XG4gICAgICAgIHRoaXMuYXBwbHkuZW1pdChjaGFuZ2VkKTtcbiAgICB9XG4gICAgb25UYWIoZSkge1xuICAgICAgICBpZiAodGhpcy5pc0xhc3QpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmZpcnN0Rm9jdXNhYmxlLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yRWFjaENoZWNrQm94KGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdrLWNoZWNrYm94Jyk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNoZWNrYm94ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjaGVja2JveGVzW2lkeF0sIGlkeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRGlzYWJsZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93SGlkZUFsbCAmJiAhdGhpcy5oYXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja2VkSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoQ2hlY2tCb3goKGNoZWNrYm94LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkSXRlbXMucHVzaCh7IGNoZWNrYm94LCBpbmRleCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrYm94LmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dIaWRlQWxsICYmIGNoZWNrZWRJdGVtcy5sZW5ndGggPT09IDEgJiYgIXRoaXMuaGFzRmlsdGVyZWQpIHtcbiAgICAgICAgICAgIGNoZWNrZWRJdGVtc1swXS5jaGVja2JveC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNMb2NrZWQgJiYgIXRoaXMuaGFzVW5sb2NrZWRGaWx0ZXJlZCkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWRVbmxvY2tlZCA9IGNoZWNrZWRJdGVtcy5maWx0ZXIoaXRlbSA9PiAhY29sdW1uc1tpdGVtLmluZGV4XS5sb2NrZWQpO1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRVbmxvY2tlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkVW5sb2NrZWRbMF0uY2hlY2tib3guZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNvbHVtblN0YXRlKCkge1xuICAgICAgICB0aGlzLmhhc0xvY2tlZCA9IHRoaXMuYWxsQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5sb2NrZWQgJiYgKCFjb2x1bW4uaGlkZGVuIHx8IGNvbHVtbi5pbmNsdWRlSW5DaG9vc2VyICE9PSBmYWxzZSkpLmxlbmd0aCA+IDA7XG4gICAgICAgIHRoaXMuaGFzVmlzaWJsZUxvY2tlZCA9IHRoaXMuYWxsQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5sb2NrZWQgJiYgIWNvbHVtbi5oaWRkZW4pLmxlbmd0aCA+IDA7XG4gICAgICAgIHRoaXMudW5sb2NrZWRDb3VudCA9IHRoaXMuY29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICFjb2x1bW4ubG9ja2VkICYmICFjb2x1bW4uaGlkZGVuKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkQ29sdW1ucyA9IHRoaXMuYWxsQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5pbmNsdWRlSW5DaG9vc2VyID09PSBmYWxzZSAmJiAhY29sdW1uLmhpZGRlbik7XG4gICAgICAgIGlmIChmaWx0ZXJlZENvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0ZpbHRlcmVkID0gZmlsdGVyZWRDb2x1bW5zLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB0aGlzLmhhc1VubG9ja2VkRmlsdGVyZWQgPSBmaWx0ZXJlZENvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiAhY29sdW1uLmxvY2tlZCkubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFzRmlsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGFzVW5sb2NrZWRGaWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jb2x1bW4tbGlzdC13cmFwcGVyXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDb2x1bW5MaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGFzc05hbWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sdW1uTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzZXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDb2x1bW5MaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhcHBseVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbHVtbkxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbkNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgQ29sdW1uTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5MaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhdXRvU3luY1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImFsbG93SGlkZUFsbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sdW1uTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiYXBwbHlUZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2x1bW5MaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXNldFRleHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbkxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGlvbnNDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImlzTGFzdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImlzRXhwYW5kZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENvbHVtbk1lbnVTZXJ2aWNlKVxuXSwgQ29sdW1uTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VydmljZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdhcHBseUJ1dHRvbicsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIENvbHVtbkxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImFwcGx5QnV0dG9uXCIsIHZvaWQgMCk7XG5Db2x1bW5MaXN0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLWNvbHVtbmxpc3QnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1jb2x1bW4tbGlzdFwiPlxuICAgICAgICAgICAgPGxhYmVsICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgY29sdW1uczsgbGV0IGluZGV4ID0gaW5kZXg7XCIgY2xhc3M9J2stY29sdW1uLWxpc3QtaXRlbSc+XG4gICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiay1jaGVja2JveCBrLWNoZWNrYm94LW1kIGstcm91bmRlZC1tZFwiIHR5cGU9XCJjaGVja2JveFwiIFthdHRyLmRhdGEtaW5kZXhdPVwiaW5kZXhcIiBbY2hlY2tlZF09XCIhY29sdW1uLmhpZGRlblwiIFtkaXNhYmxlZF09XCJpc0Rpc2FibGVkKGNvbHVtbilcIiAvPjxzcGFuIGNsYXNzPVwiay1jaGVja2JveC1sYWJlbFwiPnt7IGNvbHVtbi5kaXNwbGF5VGl0bGUgfX08L3NwYW4+XG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBbbmdDbGFzc109XCJhY3Rpb25zQ2xhc3NcIiAqbmdJZj1cIiFhdXRvU3luY1wiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJrLWJ1dHRvbiBrLWJ1dHRvbi1zb2xpZC1iYXNlIGstYnV0dG9uLXNvbGlkIGstYnV0dG9uLW1kIGstcm91bmRlZC1tZCBrLWJ1dHRvbi1yZWN0YW5nbGVcIiAoY2xpY2spPVwiY2FuY2VsQ2hhbmdlcygpXCI+e3sgcmVzZXRUZXh0IH19PC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uICNhcHBseUJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgKGtleWRvd24udGFiKT1cIm9uVGFiKCRldmVudClcIiBjbGFzcz1cImstYnV0dG9uIGstYnV0dG9uLXNvbGlkLXByaW1hcnkgay1idXR0b24tc29saWQgay1idXR0b24tbWQgay1yb3VuZGVkLW1kIGstYnV0dG9uLXJlY3RhbmdsZVwiIChjbGljayk9XCJhcHBseUNoYW5nZXMoKVwiPnt7IGFwcGx5VGV4dCB9fTwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBDb2x1bW5MaXN0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb21wb25lbnQgZm9yIHNlbGVjdGluZyBjb2x1bW5zIGluIHRoZSBHcmlkLiBUbyBlbmFibGUgdGhlIHVzZXIgdG8gc2hvdyBvciBoaWRlIGNvbHVtbnMsXG4gKiBhZGQgdGhlIGNvbXBvbmVudCBpbnNpZGUgYSBbVG9vbGJhclRlbXBsYXRlXSh7JSBzbHVnIGFwaV9ncmlkX3Rvb2xiYXJ0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJkYXRhXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkVG9vbGJhclRlbXBsYXRlPlxuICogICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uLWNob29zZXI+PC9rZW5kby1ncmlkLWNvbHVtbi1jaG9vc2VyPlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkZpZWxkMVwiPjwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJGaWVsZDJcIiBbaGlkZGVuXT1cInRydWVcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgPC9rZW5kby1ncmlkPlxuICogICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGRhdGE6IGFueVtdID0gW3sgRmllbGQxOiAnRm9vJywgRmllbGQyOiAnQmFyJyB9XTtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgQ29sdW1uQ2hvb3NlckNvbXBvbmVudCA9IGNsYXNzIENvbHVtbkNob29zZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgY29sdW1uSW5mb1NlcnZpY2UsIHBvcHVwU2VydmljZSwgbmdab25lLCByZW5kZXJlciwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UgPSBjb2x1bW5JbmZvU2VydmljZTtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgY2hhbmdlcyBpbiB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgY29sdW1uIHdpbGwgYmUgaW1tZWRpYXRlbHkgYXBwbGllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b1N5bmMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiBhbGwgY29sdW1ucyBjYW4gYmUgaGlkZGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxvd0hpZGVBbGwgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgY29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UubGVhZk5hbWVkQ29sdW1ucztcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZShhbmNob3IsIHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKHtcbiAgICAgICAgICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1vZGU6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgYW5jaG9yQWxpZ246IHsgdmVydGljYWw6ICdib3R0b20nLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICBwb3B1cEFsaWduOiB7IHZlcnRpY2FsOiAndG9wJywgaG9yaXpvbnRhbDogZGlyZWN0aW9uIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQsICdkaXInLCB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInKTtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuY2xvc2VDbGljayA9IHRoaXMucmVuZGVyZXIubGlzdGVuKFwiZG9jdW1lbnRcIiwgXCJjbGlja1wiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY2xvc2VzdCh0YXJnZXQsIG5vZGUgPT4gbm9kZSA9PT0gdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQgfHwgbm9kZSA9PT0gYW5jaG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkFwcGx5KGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBpZiAoY2hhbmdlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLmNoYW5nZVZpc2liaWxpdHkoY2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ2hhbmdlKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZS5jaGFuZ2VWaXNpYmlsaXR5KGNoYW5nZWQpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0YWNoQ2xvc2UoKTtcbiAgICB9XG4gICAgZGV0YWNoQ2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDbGljaygpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUNsaWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uQ2hvb3NlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYXV0b1N5bmNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5DaG9vc2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbGxvd0hpZGVBbGxcIiwgdm9pZCAwKTtcbkNvbHVtbkNob29zZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWdyaWQtY29sdW1uLWNob29zZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uICNhbmNob3JcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZShhbmNob3IsIHRlbXBsYXRlKVwiXG4gICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstYnV0dG9uLWZsYXQtYmFzZSBrLWJ1dHRvbi1mbGF0IGstaWNvbi1idXR0b24gay1idXR0b24tbWQgay1yb3VuZGVkLW1kIGstYnV0dG9uLXJlY3RhbmdsZSBrLWljb24tYnV0dG9uXCJcbiAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImxvY2FsaXphdGlvbi5nZXQoJ2NvbHVtbnMnKVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWJ1dHRvbi1pY29uIGstaWNvbiBrLWktY29sdW1uc1wiPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjdGVtcGxhdGU+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nay1jb2x1bW4tY2hvb3Nlci10aXRsZSc+e3sgbG9jYWxpemF0aW9uLmdldCgnY29sdW1ucycpIH19PC9zcGFuPlxuICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubGlzdFxuICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImNvbHVtbnNcIlxuICAgICAgICAgICAgICAgIFthcHBseVRleHRdPVwibG9jYWxpemF0aW9uLmdldCgnY29sdW1uc0FwcGx5JylcIlxuICAgICAgICAgICAgICAgIFtyZXNldFRleHRdPVwibG9jYWxpemF0aW9uLmdldCgnY29sdW1uc1Jlc2V0JylcIlxuICAgICAgICAgICAgICAgIFthdXRvU3luY109XCJhdXRvU3luY1wiXG4gICAgICAgICAgICAgICAgW2FsbG93SGlkZUFsbF09XCJhbGxvd0hpZGVBbGxcIlxuICAgICAgICAgICAgICAgIChhcHBseSk9XCJvbkFwcGx5KCRldmVudClcIlxuICAgICAgICAgICAgICAgIChjb2x1bW5DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiPlxuICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbmxpc3Q+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sdW1uSW5mb1NlcnZpY2UsXG4gICAgICAgIFBvcHVwU2VydmljZSxcbiAgICAgICAgTmdab25lLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmXSlcbl0sIENvbHVtbkNob29zZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sdW1uTWVudUl0ZW1CYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmICF0aGlzLnNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZpY2UgaW5wdXQgb2YgdGhlIHByZWRlZmluZWQgY29sdW1uIG1lbnUgY29tcG9uZW50cyBpcyBtYW5kYXRvcnkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5NZW51U2VydmljZSlcbl0sIENvbHVtbk1lbnVJdGVtQmFzZS5wcm90b3R5cGUsIFwic2VydmljZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY29sdW1ubWVudS1pdGVtLXdyYXBwZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbk1lbnVJdGVtQmFzZS5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb21wb25lbnQgZm9yIHNlbGVjdGluZyBjb2x1bW5zIGluIHRoZSBHcmlkIHRoYXQgY2FuIGJlIHBsYWNlZFxuICogaW5zaWRlIGEgW0NvbHVtbk1lbnVUZW1wbGF0ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jb2x1bW5tZW51dGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZS5cbiAqXG4gKiA+IFlvdSBoYXZlIHRvIHNldCB0aGUgW0NvbHVtbk1lbnVTZXJ2aWNlXSh7JSBzbHVnIGFwaV9ncmlkX2NvbHVtbm1lbnVzZXJ2aWNlICV9KSB0aGF0IGlzIHBhc3NlZCBieVxuICogPiB0aGUgdGVtcGxhdGUgdG8gdGhlIHNlcnZpY2UgaW5wdXQgb2YgdGhlIGBrZW5kby1ncmlkLWNvbHVtbm1lbnUtY2hvb3NlcmAgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiB7JSBtZXRhIGhlaWdodDozMDAgJX1cbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJkYXRhXCIgW2NvbHVtbk1lbnVdPVwidHJ1ZVwiPlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENvbHVtbk1lbnVUZW1wbGF0ZSBsZXQtc2VydmljZT1cInNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LWNob29zZXIgW3NlcnZpY2VdPVwic2VydmljZVwiPlxuICogICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LWNob29zZXI+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiRmllbGQxXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkZpZWxkMlwiIFtoaWRkZW5dPVwidHJ1ZVwiPjwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgZGF0YTogYW55W10gPSBbeyBGaWVsZDE6ICdGb28nLCBGaWVsZDI6ICdCYXInIH1dO1xuICogfVxuICpcbiAqIGBgYFxuICogeyUgZW5kbWV0YSAlfVxuICovXG5sZXQgQ29sdW1uTWVudUNob29zZXJDb21wb25lbnQgPSBjbGFzcyBDb2x1bW5NZW51Q2hvb3NlckNvbXBvbmVudCBleHRlbmRzIENvbHVtbk1lbnVJdGVtQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCBjb2x1bW5JbmZvU2VydmljZSwgY2hhbmdlRGV0ZWN0b3IsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlID0gY29sdW1uSW5mb1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgY29udGVudCBpcyBleHBhbmRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgY29udGVudCBpcyBjb2xsYXBzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxhcHNlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBjb250ZW50IGlzIGV4cGFuZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0xhc3QgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aW9uc0NsYXNzID0gJ2stY29sdW1ubWVudS1hY3Rpb25zJztcbiAgICB9XG4gICAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLmxlYWZOYW1lZENvbHVtbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkFwcGx5KGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBpZiAoY2hhbmdlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLmNoYW5nZVZpc2liaWxpdHkoY2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ29sbGFwc2UoKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNMYXN0KSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmxhc3RGb2N1c2FibGUgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmstY29sdW1ubWVudS1pdGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xsYXBzZS5lbWl0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkV4cGFuZCgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZXhwYW5kLmVtaXQoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbHVtbk1lbnVDaG9vc2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDb2x1bW5NZW51Q2hvb3NlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sbGFwc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5NZW51Q2hvb3NlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5NZW51Q2hvb3NlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNMYXN0XCIsIHZvaWQgMCk7XG5Db2x1bW5NZW51Q2hvb3NlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1jb2x1bW5tZW51LWNob29zZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LWl0ZW1cbiAgICAgICAgICAgIFt0ZXh0XT1cImxvY2FsaXphdGlvbi5nZXQoJ2NvbHVtbnMnKVwiXG4gICAgICAgICAgICBpY29uPVwiY29sdW1uc1wiXG4gICAgICAgICAgICBbZXhwYW5kZWRdPVwiZXhwYW5kZWRcIlxuICAgICAgICAgICAgKGNvbGxhcHNlKT1cIm9uQ29sbGFwc2UoKVwiXG4gICAgICAgICAgICAoZXhwYW5kKT1cIm9uRXhwYW5kKClcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5saXN0XG4gICAgICAgICAgICAgICAgICAgIFthcHBseVRleHRdPVwibG9jYWxpemF0aW9uLmdldCgnY29sdW1uc0FwcGx5JylcIlxuICAgICAgICAgICAgICAgICAgICBbcmVzZXRUZXh0XT1cImxvY2FsaXphdGlvbi5nZXQoJ2NvbHVtbnNSZXNldCcpXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwiY29sdW1uc1wiXG4gICAgICAgICAgICAgICAgICAgIFthdXRvU3luY109XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgIFthbGxvd0hpZGVBbGxdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICBbYWN0aW9uc0NsYXNzXT1cImFjdGlvbnNDbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgIFtpc0xhc3RdPVwiaXNMYXN0XCJcbiAgICAgICAgICAgICAgICAgICAgW2lzRXhwYW5kZWRdPVwiZXhwYW5kZWRcIlxuICAgICAgICAgICAgICAgICAgICBbc2VydmljZV09XCJzZXJ2aWNlXCJcbiAgICAgICAgICAgICAgICAgICAgKGFwcGx5KT1cIm9uQXBwbHkoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5saXN0PlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbm1lbnUtaXRlbT5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2x1bW5JbmZvU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEVsZW1lbnRSZWZdKVxuXSwgQ29sdW1uTWVudUNob29zZXJDb21wb25lbnQpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29tcG9uZW50IGZvciBlZGl0aW5nIGNvbHVtbiBmaWx0ZXJzIGluIHRoZSBHcmlkIHRoYXQgY2FuIGJlIHBsYWNlZFxuICogaW5zaWRlIGEgW0NvbHVtbk1lbnVUZW1wbGF0ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jb2x1bW5tZW51dGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZS5cbiAqXG4gKiA+IFlvdSBoYXZlIHRvIHNldCB0aGUgW0NvbHVtbk1lbnVTZXJ2aWNlXSh7JSBzbHVnIGFwaV9ncmlkX2NvbHVtbm1lbnVzZXJ2aWNlICV9KSB0aGF0IGlzIHBhc3NlZCBieVxuICogPiB0aGUgdGVtcGxhdGUgdG8gdGhlIHNlcnZpY2UgaW5wdXQgb2YgdGhlIGBrZW5kby1ncmlkLWNvbHVtbm1lbnUtZmlsdGVyYCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tZ3JpZCBba2VuZG9HcmlkQmluZGluZ109XCJkYXRhXCIgW2NvbHVtbk1lbnVdPVwidHJ1ZVwiPlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENvbHVtbk1lbnVUZW1wbGF0ZSBsZXQtc2VydmljZT1cInNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LWZpbHRlciBbc2VydmljZV09XCJzZXJ2aWNlXCI+XG4gKiAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbm1lbnUtZmlsdGVyPlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkZpZWxkMVwiPjwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJGaWVsZDJcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgPC9rZW5kby1ncmlkPlxuICogICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGRhdGE6IGFueVtdID0gW3sgRmllbGQxOiAnRm9vJywgRmllbGQyOiAnQmFyJyB9XTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IENvbHVtbk1lbnVGaWx0ZXJDb21wb25lbnQgPSBjbGFzcyBDb2x1bW5NZW51RmlsdGVyQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uTWVudUl0ZW1CYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IGlzIGV4cGFuZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IGlzIGNvbGxhcHNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGNvbnRlbnQgaXMgZXhwYW5kZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzTGFzdCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3Rpb25zQ2xhc3MgPSAnay1jb2x1bW5tZW51LWFjdGlvbnMnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25Db2xsYXBzZSgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc0xhc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2UubGFzdEZvY3VzYWJsZSA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuay1jb2x1bW5tZW51LWl0ZW0nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbGxhcHNlLmVtaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uRXhwYW5kKCkge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5leHBhbmQuZW1pdCgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sdW1uTWVudUZpbHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sdW1uTWVudUZpbHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sbGFwc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5NZW51RmlsdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbk1lbnVGaWx0ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImlzTGFzdFwiLCB2b2lkIDApO1xuQ29sdW1uTWVudUZpbHRlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1jb2x1bW5tZW51LWZpbHRlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbm1lbnUtaXRlbVxuICAgICAgICAgICAgW3RleHRdPVwibG9jYWxpemF0aW9uLmdldCgnZmlsdGVyJylcIlxuICAgICAgICAgICAgaWNvbj1cImZpbHRlclwiXG4gICAgICAgICAgICBbZXhwYW5kZWRdPVwiZXhwYW5kZWRcIlxuICAgICAgICAgICAgKGNvbGxhcHNlKT1cIm9uQ29sbGFwc2UoKVwiXG4gICAgICAgICAgICAoZXhwYW5kKT1cIm9uRXhwYW5kKClcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1maWx0ZXItbWVudS1jb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJzZXJ2aWNlLmNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgIFttZW51VGFiYmluZ1NlcnZpY2VdPVwic2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2VcIlxuICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cInNlcnZpY2UuZmlsdGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2FjdGlvbnNDbGFzc109XCJhY3Rpb25zQ2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICBbaXNMYXN0XT1cImlzTGFzdFwiXG4gICAgICAgICAgICAgICAgICAgIFtpc0V4cGFuZGVkXT1cImV4cGFuZGVkXCJcbiAgICAgICAgICAgICAgICAgICAgKGtleWRvd24uc2hpZnQudGFiKT1cIiRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgICAgICAgICAgIChjbG9zZSk9XCJjbG9zZSgpXCI+XG4gICAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWZpbHRlci1tZW51LWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LWl0ZW0+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBDb2x1bW5NZW51RmlsdGVyQ29tcG9uZW50KTtcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbnRlbnQgdGVtcGxhdGUgb2YgdGhlXG4gKiBba2VuZG8tZ3JpZC1jb2x1bW5tZW51LWl0ZW1dKHslIHNsdWcgYXBpX2dyaWRfY29sdW1ubWVudWl0ZW1jb21wb25lbnQgJX0pIGNvbXBvbmVudC5cbiAqIFByb3ZpZGVzIGFuIG9wdGlvbiBmb3Igc3BlY2lmeWluZyB0aGUgY29udGVudCBvZiBhIGNvbHVtbiBpdGVtLlxuICogVG8gZGVmaW5lIHRoZSBjb250ZW50IHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGVcbiAqIGBrZW5kb0dyaWRDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBhIGA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LWl0ZW0+YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxrZW5kby1ncmlkIFtkYXRhXT1cImRhdGFcIiBbY29sdW1uTWVudV09XCJ0cnVlXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkQ29sdW1uTWVudVRlbXBsYXRlPlxuICogICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbm1lbnUtaXRlbSB0ZXh0PVwiSXRlbSBUZXh0XCIgW2V4cGFuZGVkXT1cInRydWVcIj5cbiAqICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENvbHVtbk1lbnVJdGVtQ29udGVudFRlbXBsYXRlPlxuICogICAgICAgICAgICAgICAgICAgICAgSXRlbSBDb250ZW50XG4gKiAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbm1lbnUtaXRlbT5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJGaWVsZDFcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiRmllbGQyXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFt7IEZpZWxkMTogJ0ZvbycsIEZpZWxkMjogJ0JhcicgfV07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIENvbHVtbk1lbnVJdGVtQ29udGVudFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkNvbHVtbk1lbnVJdGVtQ29udGVudFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkQ29sdW1uTWVudUl0ZW1Db250ZW50VGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpdGVtIHRoYXQgY2FuIGJlIHBsYWNlZCBpbnNpZGUgYVxuICogW0NvbHVtbk1lbnVUZW1wbGF0ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jb2x1bW5tZW51dGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxrZW5kby1ncmlkIFtkYXRhXT1cImRhdGFcIiBbY29sdW1uTWVudV09XCJ0cnVlXCIgW3Jlc2l6YWJsZV09XCJ0cnVlXCIgI2dyaWQ+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkQ29sdW1uTWVudVRlbXBsYXRlIGxldC1zZXJ2aWNlPVwic2VydmljZVwiIGxldC1jb2x1bW49XCJjb2x1bW5cIj5cbiAqICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LWl0ZW0gaWNvbj1cImFycm93cy1yZXNpemluZ1wiIHRleHQ9XCJGaXQgY29sdW1uXCJcbiAqICAgICAgICAgICAgICAgICAgKGl0ZW1DbGljayk9XCJncmlkLmF1dG9GaXRDb2x1bW4oY29sdW1uKTsgc2VydmljZS5jbG9zZSgpXCI+XG4gKiAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbm1lbnUtaXRlbT5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJGaWVsZDFcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiRmllbGQyXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFt7IEZpZWxkMTogJ0ZvbycsIEZpZWxkMjogJ0JhcicgfV07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBDb2x1bW5NZW51SXRlbUNvbXBvbmVudCA9IGNsYXNzIENvbHVtbk1lbnVJdGVtQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGl0ZW0gdGhhdCBjYW4gYmUgcGxhY2VkIGluc2lkZSBhXG4gICAgICogW0NvbHVtbk1lbnVUZW1wbGF0ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jb2x1bW5tZW51dGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtcHJldmlld1xuICAgICAqXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgICAgPGtlbmRvLWdyaWQgW2RhdGFdPVwiZGF0YVwiIFtjb2x1bW5NZW51XT1cInRydWVcIiBbcmVzaXphYmxlXT1cInRydWVcIiAjZ3JpZD5cbiAgICAgKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkQ29sdW1uTWVudVRlbXBsYXRlIGxldC1zZXJ2aWNlPVwic2VydmljZVwiIGxldC1jb2x1bW49XCJjb2x1bW5cIj5cbiAgICAgKiAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubWVudS1pdGVtIGljb249XCJhcnJvd3MtcmVzaXppbmdcIiB0ZXh0PVwiRml0IGNvbHVtblwiXG4gICAgICogICAgICAgICAgICAgICAgICAoaXRlbUNsaWNrKT1cImdyaWQuYXV0b0ZpdENvbHVtbihjb2x1bW4pOyBzZXJ2aWNlLmNsb3NlKClcIj5cbiAgICAgKiAgICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbm1lbnUtaXRlbT5cbiAgICAgKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkZpZWxkMVwiPjwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gICAgICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiRmllbGQyXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAgICAgKiAgICAgICA8L2tlbmRvLWdyaWQ+XG4gICAgICogICAgIGBcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFt7IEZpZWxkMTogJ0ZvbycsIEZpZWxkMjogJ0JhcicgfV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBpdGVtIGlzIGNsaWNrZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1DbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGNvbnRlbnQgaXMgZXhwYW5kZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGNvbnRlbnQgaXMgY29sbGFwc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsYXBzZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZW50U3RhdGUgPSAnY29sbGFwc2VkJztcbiAgICB9XG4gICAgZ2V0IGljb25DbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIGBrLWktJHt0aGlzLmljb259YDtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZW50U3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25DbGljayhlKSB7XG4gICAgICAgIHRoaXMuaXRlbUNsaWNrLmVtaXQoZSk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZW50U3RhdGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmQuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZS5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ29udGVudFN0YXRlKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnRTdGF0ZSA9IHRoaXMuZXhwYW5kZWQgPyAnZXhwYW5kZWQnIDogJ2NvbGxhcHNlZCc7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDb2x1bW5NZW51SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbUNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sdW1uTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImV4cGFuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbHVtbk1lbnVJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xsYXBzZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sdW1uTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbk1lbnVJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImV4cGFuZGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoQ29sdW1uTWVudUl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sdW1uTWVudUl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDb2x1bW5NZW51SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5Db2x1bW5NZW51SXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIHRyaWdnZXIoJ3N0YXRlJywgW1xuICAgICAgICAgICAgICAgIHN0YXRlKCdjb2xsYXBzZWQnLCBzdHlsZSh7IGRpc3BsYXk6ICdub25lJyB9KSksXG4gICAgICAgICAgICAgICAgc3RhdGUoJ2V4cGFuZGVkJywgc3R5bGUoeyBkaXNwbGF5OiAnYmxvY2snIH0pKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCdjb2xsYXBzZWQgPT4gZXhwYW5kZWQnLCBbXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzBweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKCcxMDBtcyBlYXNlLWluJywgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnKidcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbignZXhwYW5kZWQgPT4gY29sbGFwc2VkJywgW1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcqJ1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnMTAwbXMgZWFzZS1pbicsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzBweCdcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1jb2x1bW5tZW51LWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzcz1cImstY29sdW1ubWVudS1pdGVtXCJcbiAgICAgICAgICAgIChjbGljayk9XCJvbkNsaWNrKCRldmVudClcIlxuICAgICAgICAgICAgKGtleWRvd24uZW50ZXIpPVwib25DbGljaygkZXZlbnQpXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLXNlbGVjdGVkXT1cInNlbGVjdGVkXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJleHBhbmRlZFwiPlxuICAgICAgICAgICA8c3BhbiAqbmdJZj1cImljb25cIiBjbGFzcz1cImstaWNvblwiIFtuZ0NsYXNzXT1cImljb25DbGFzc1wiPlxuICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgIHt7IHRleHQgfX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgKm5nSWY9XCJjb250ZW50VGVtcGxhdGVcIiBbQHN0YXRlXT1cImNvbnRlbnRTdGF0ZVwiIHN0eWxlPVwib3ZlcmZsb3c6aGlkZGVuO1wiIGNsYXNzPVwiay1jb2x1bW5tZW51LWl0ZW0tY29udGVudFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJjb250ZW50VGVtcGxhdGUudGVtcGxhdGVSZWZcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8ZGl2PlxuICAgIGBcbiAgICB9KVxuXSwgQ29sdW1uTWVudUl0ZW1Db21wb25lbnQpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbHVtbi1tZW51IGl0ZW0gZm9yIHNvcnRpbmcgR3JpZCBjb2x1bW5zIHRoYXQgY2FuIGJlIHBsYWNlZCBpbnNpZGUgYVxuICogW0NvbHVtbk1lbnVUZW1wbGF0ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jb2x1bW5tZW51dGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZS5cbiAqIEFsbG93cyB0aGUgdXNlciB0byBzb3J0IHRoZSBjb2x1bW4uXG4gKlxuICogPiBZb3UgaGF2ZSB0byBzZXQgdGhlIFtDb2x1bW5NZW51U2VydmljZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jb2x1bW5tZW51c2VydmljZSAlfSkgdGhhdCBpcyBwYXNzZWQgYnlcbiAqID4gdGhlIHRlbXBsYXRlIHRvIHRoZSBzZXJ2aWNlIGlucHV0IG9mIHRoZSBga2VuZG8tZ3JpZC1jb2x1bW5tZW51LXNvcnRgIGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxrZW5kby1ncmlkIFtrZW5kb0dyaWRCaW5kaW5nXT1cImRhdGFcIiBbc29ydGFibGVdPVwidHJ1ZVwiIFtjb2x1bW5NZW51XT1cInRydWVcIj5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDb2x1bW5NZW51VGVtcGxhdGUgbGV0LXNlcnZpY2U9XCJzZXJ2aWNlXCI+XG4gKiAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubWVudS1zb3J0IFtzZXJ2aWNlXT1cInNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1zb3J0PlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkZpZWxkMVwiIFt3aWR0aF09XCIxMDBcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiRmllbGQyXCIgW3dpZHRoXT1cIjEwMFwiPjwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgZGF0YTogYW55W10gPSBbeyBGaWVsZDE6ICdGb28nLCBGaWVsZDI6ICdCYXInIH0sIHsgRmllbGQxOiAnRm9vMScsIEZpZWxkMjogJ0JhcjEnIH1dO1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgQ29sdW1uTWVudVNvcnRDb21wb25lbnQgPSBjbGFzcyBDb2x1bW5NZW51U29ydENvbXBvbmVudCBleHRlbmRzIENvbHVtbk1lbnVJdGVtQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCBzb3J0U2VydmljZSwgcmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuc29ydFNlcnZpY2UgPSBzb3J0U2VydmljZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cbiAgICBnZXQgc29ydGVkQXNjKCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvciAmJiAoIWRlc2NyaXB0b3IuZGlyIHx8IGRlc2NyaXB0b3IuZGlyID09PSAnYXNjJyk7XG4gICAgfVxuICAgIGdldCBzb3J0ZWREZXNjKCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmRpciA9PT0gJ2Rlc2MnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9nZ2xlU29ydChkaXIpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLnNlcnZpY2UuY29sdW1uLmZpZWxkO1xuICAgICAgICBjb25zdCB7IG1vZGUsIGFsbG93VW5zb3J0IH0gPSBub3JtYWxpemUkMSh0aGlzLnNlcnZpY2Uuc29ydGFibGUpO1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yO1xuICAgICAgICBjb25zdCBzb3J0ID0gbW9kZSA9PT0gJ211bHRpcGxlJyA/IHRoaXMuc2VydmljZS5zb3J0LmZpbHRlcihzID0+IHMuZmllbGQgIT09IGZpZWxkKSA6IFtdO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmRpciA9PT0gZGlyKSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93VW5zb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc29ydC5wdXNoKHsgZmllbGQsIGRpciB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvcnRTZXJ2aWNlLnNvcnQoc29ydCk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0b3IoKSB7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQodGhpcy5zZXJ2aWNlLnNvcnQgfHwgW10pLmZpbmQocyA9PiBzLmZpZWxkID09PSB0aGlzLnNlcnZpY2UuY29sdW1uLmZpZWxkKTtcbiAgICB9XG59O1xuQ29sdW1uTWVudVNvcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWdyaWQtY29sdW1ubWVudS1zb3J0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubWVudS1pdGVtXG4gICAgICAgICAgICBbdGV4dF09XCJsb2NhbGl6YXRpb24uZ2V0KCdzb3J0QXNjZW5kaW5nJylcIlxuICAgICAgICAgICAgaWNvbj1cInNvcnQtYXNjLXNtXCJcbiAgICAgICAgICAgIChpdGVtQ2xpY2spPVwidG9nZ2xlU29ydCgnYXNjJylcIlxuICAgICAgICAgICAgW3NlbGVjdGVkXT1cInNvcnRlZEFzY1wiPlxuICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1pdGVtPlxuICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LWl0ZW1cbiAgICAgICAgICAgIFt0ZXh0XT1cImxvY2FsaXphdGlvbi5nZXQoJ3NvcnREZXNjZW5kaW5nJylcIlxuICAgICAgICAgICAgaWNvbj1cInNvcnQtZGVzYy1zbVwiXG4gICAgICAgICAgICAoaXRlbUNsaWNrKT1cInRvZ2dsZVNvcnQoJ2Rlc2MnKVwiXG4gICAgICAgICAgICBbc2VsZWN0ZWRdPVwic29ydGVkRGVzY1wiPlxuICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1pdGVtPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIFNvcnRTZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjJdKVxuXSwgQ29sdW1uTWVudVNvcnRDb21wb25lbnQpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbHVtbi1tZW51IGl0ZW0gdGhhdCBjYW4gYmUgcGxhY2VkIGluc2lkZSBhXG4gKiBbQ29sdW1uTWVudVRlbXBsYXRlXSh7JSBzbHVnIGFwaV9ncmlkX2NvbHVtbm1lbnV0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlLlxuICogQWxsb3dzIHRoZSB1c2VyIHRvIGxvY2sgb3IgdW5sb2NrIHRoZSBjb2x1bW5zLlxuICpcbiAqID4gWW91IGhhdmUgdG8gc2V0IHRoZSBbQ29sdW1uTWVudVNlcnZpY2VdKHslIHNsdWcgYXBpX2dyaWRfY29sdW1ubWVudXNlcnZpY2UgJX0pIHRoYXQgaXMgcGFzc2VkIGJ5XG4gKiA+IHRoZSB0ZW1wbGF0ZSB0byB0aGUgc2VydmljZSBpbnB1dCBvZiB0aGUgYGtlbmRvLWdyaWQtY29sdW1ubWVudS1sb2NrYCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJkYXRhXCIgW2NvbHVtbk1lbnVdPVwidHJ1ZVwiPlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENvbHVtbk1lbnVUZW1wbGF0ZSBsZXQtc2VydmljZT1cInNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LWxvY2sgW3NlcnZpY2VdPVwic2VydmljZVwiPlxuICogICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LWxvY2s+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiRmllbGQxXCIgW3dpZHRoXT1cIjEwMFwiPjwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJGaWVsZDJcIiBbd2lkdGhdPVwiMTAwXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFt7IEZpZWxkMTogJ0ZvbycsIEZpZWxkMjogJ0JhcicgfV07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBDb2x1bW5NZW51TG9ja0NvbXBvbmVudCA9IGNsYXNzIENvbHVtbk1lbnVMb2NrQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uTWVudUl0ZW1CYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGNvbHVtbkluZm9TZXJ2aWNlLCBjaGFuZ2VEZXRlY3Rvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZSA9IGNvbHVtbkluZm9TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KHRoaXMubG9ja2VkID8gJ3VubG9jaycgOiAnbG9jaycpO1xuICAgIH1cbiAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja2VkID8gJ3VubG9jaycgOiAnbG9jayc7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmxvY2tlZCAmJiB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLnVubG9ja2VkUm9vdENvdW50IDwgMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZUNvbHVtbigpIHtcbiAgICAgICAgdGhpcy50b2dnbGVIaWVyYXJjaHkoIXRoaXMubG9ja2VkKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICB0b2dnbGVIaWVyYXJjaHkobG9ja2VkKSB7XG4gICAgICAgIGxldCByb290ID0gdGhpcy5zZXJ2aWNlLmNvbHVtbjtcbiAgICAgICAgd2hpbGUgKHJvb3QucGFyZW50KSB7XG4gICAgICAgICAgICByb290ID0gcm9vdC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sdW1ucyA9IFtyb290XTtcbiAgICAgICAgY29uc3QgYWxsQ2hhbmdlZCA9IFtdO1xuICAgICAgICB3aGlsZSAoY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnMuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbHVtbi5sb2NrZWQgPSBsb2NrZWQ7XG4gICAgICAgICAgICBhbGxDaGFuZ2VkLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goLi4uY29sdW1uLmNoaWxkcmVuQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UuY2hhbmdlTG9ja2VkKGFsbENoYW5nZWQpO1xuICAgIH1cbiAgICBnZXQgbG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmNvbHVtbi5sb2NrZWQ7XG4gICAgfVxufTtcbkNvbHVtbk1lbnVMb2NrQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLWNvbHVtbm1lbnUtbG9jaycsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubWVudS1pdGVtXG4gICAgICAgICAgICBbdGV4dF09XCJ0ZXh0XCJcbiAgICAgICAgICAgIFtpY29uXT1cImljb25cIlxuICAgICAgICAgICAgKGl0ZW1DbGljayk9XCJ0b2dnbGVDb2x1bW4oKVwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1pdGVtPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIENvbHVtbkluZm9TZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBDb2x1bW5NZW51TG9ja0NvbXBvbmVudCk7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb21wb25lbnQgZm9yIGVkaXRpbmcgY29sdW1uIGZpbHRlcnMgaW4gdGhlIEdyaWQgdGhhdCBjYW4gYmUgcGxhY2VkXG4gKiBpbnNpZGUgYSBbQ29sdW1uTWVudVRlbXBsYXRlXSh7JSBzbHVnIGFwaV9ncmlkX2NvbHVtbm1lbnV0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlLlxuICpcbiAqID4gWW91IGhhdmUgdG8gc2V0IHRoZSBbQ29sdW1uTWVudVNlcnZpY2VdKHslIHNsdWcgYXBpX2dyaWRfY29sdW1ubWVudXNlcnZpY2UgJX0pIHRoYXQgaXMgcGFzc2VkIGJ5XG4gKiA+IHRoZSB0ZW1wbGF0ZSB0byB0aGUgc2VydmljZSBpbnB1dCBvZiB0aGUgYGtlbmRvLWdyaWQtY29sdW1ubWVudS1maWx0ZXJgIGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxrZW5kby1ncmlkIFtrZW5kb0dyaWRCaW5kaW5nXT1cImRhdGFcIiBbY29sdW1uTWVudV09XCJ0cnVlXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkQ29sdW1uTWVudVRlbXBsYXRlIGxldC1zZXJ2aWNlPVwic2VydmljZVwiPlxuICogICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbm1lbnUtZmlsdGVyIFtzZXJ2aWNlXT1cInNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1maWx0ZXI+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiRmllbGQxXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkZpZWxkMlwiPjwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgZGF0YTogYW55W10gPSBbeyBGaWVsZDE6ICdGb28nLCBGaWVsZDI6ICdCYXInIH1dO1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgQ29sdW1uTWVudVBvc2l0aW9uQ29tcG9uZW50ID0gY2xhc3MgQ29sdW1uTWVudVBvc2l0aW9uQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uTWVudUl0ZW1CYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IGlzIGV4cGFuZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IGlzIGNvbGxhcHNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGNvbnRlbnQgaXMgZXhwYW5kZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGlvbnNDbGFzcyA9ICdrLWNvbHVtbm1lbnUtYWN0aW9ucyc7XG4gICAgICAgIHRoaXMuX2lzTGFzdCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGlzTGFzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmxhc3RGb2N1c2FibGUgPSB0aGlzLmdldExhc3RGb2N1c2FibGVJdGVtKCk7XG4gICAgICAgIHRoaXMuX2lzTGFzdCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzTGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzTGFzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uVGFiKGUsIGlzTGFzdEl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMYXN0ICYmIGlzTGFzdEl0ZW0pIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLm1lbnVUYWJiaW5nU2VydmljZS5maXJzdEZvY3VzYWJsZS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNvbGxhcHNlKCkge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzTGFzdCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLm1lbnVUYWJiaW5nU2VydmljZS5sYXN0Rm9jdXNhYmxlID0gdGhpcy5nZXRMYXN0Rm9jdXNhYmxlSXRlbSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGFwc2UuZW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25FeHBhbmQoKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc0xhc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2UubGFzdEZvY3VzYWJsZSA9IHRoaXMuZ2V0TGFzdEZvY3VzYWJsZUl0ZW0oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGFuZC5lbWl0KCk7XG4gICAgfVxuICAgIGdldExhc3RGb2N1c2FibGVJdGVtKCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmstY29sdW1ubWVudS1pdGVtJyk7XG4gICAgICAgIGNvbnN0IGxhc3RGb2N1c2FibGVJbmRleCA9IHRoaXMuZXhwYW5kZWQgPyBtZW51SXRlbXMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIHJldHVybiBtZW51SXRlbXNbbGFzdEZvY3VzYWJsZUluZGV4XTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbHVtbk1lbnVQb3NpdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sdW1uTWVudVBvc2l0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xsYXBzZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbk1lbnVQb3NpdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW5NZW51UG9zaXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInNob3dMb2NrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uTWVudVBvc2l0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93U3RpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBDb2x1bW5NZW51UG9zaXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcImlzTGFzdFwiLCBudWxsKTtcbkNvbHVtbk1lbnVQb3NpdGlvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1jb2x1bW5tZW51LXBvc2l0aW9uJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubWVudS1pdGVtXG4gICAgICAgICAgICBbdGV4dF09XCJsb2NhbGl6YXRpb24uZ2V0KCdzZXRDb2x1bW5Qb3NpdGlvbicpXCJcbiAgICAgICAgICAgIGljb249XCJzZXQtY29sdW1uLXBvc2l0aW9uXCJcbiAgICAgICAgICAgIFtleHBhbmRlZF09XCJleHBhbmRlZFwiXG4gICAgICAgICAgICAoa2V5ZG93bi50YWIpPVwib25UYWIoJGV2ZW50LCAhZXhwYW5kZWQpXCJcbiAgICAgICAgICAgIChjb2xsYXBzZSk9XCJvbkNvbGxhcHNlKClcIlxuICAgICAgICAgICAgKGV4cGFuZCk9XCJvbkV4cGFuZCgpXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkQ29sdW1uTWVudUl0ZW1Db250ZW50VGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubWVudS1sb2NrXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwic2hvd0xvY2tcIlxuICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi50YWIpPVwib25UYWIoJGV2ZW50LCAhc2hvd1N0aWNrKVwiXG4gICAgICAgICAgICAgICAgICAgIFtzZXJ2aWNlXT1cInNlcnZpY2VcIj5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1sb2NrPlxuICAgICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbm1lbnUtc3RpY2tcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJzaG93U3RpY2tcIlxuICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi50YWIpPVwib25UYWIoJGV2ZW50LCB0cnVlKVwiXG4gICAgICAgICAgICAgICAgICAgIFtzZXJ2aWNlXT1cInNlcnZpY2VcIj5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1zdGljaz5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LWl0ZW0+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBDb2x1bW5NZW51UG9zaXRpb25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENvbHVtbk1lbnVJdGVtRGlyZWN0aXZlID0gY2xhc3MgQ29sdW1uTWVudUl0ZW1EaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RFbGVtZW50LCByZW5kZXJlciwgbmdab25lKSB7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5faXNGaXJzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0xhc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLm9uVGFiID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgIT09IEtleXMuVGFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaXJzdCAmJiBlLnNoaWZ0S2V5ICYmIGUudGFyZ2V0ID09PSB0aGlzLmNvbHVtbk1lbnVJdGVtc1swXSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnVJdGVtQ29tcG9uZW50LnNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmxhc3RGb2N1c2FibGUuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTGFzdCAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDb2x1bW5NZW51SXRlbSA9IHRoaXMuZ2V0TGFzdENvbHVtbk1lbnVJdGVtKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFeHBhbmRlZCA9IHRoaXMubWVudUl0ZW1Db21wb25lbnQuZXhwYW5kZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RDb2x1bW5NZW51SXRlbSA9PT0gZS50YXJnZXQgJiYgIWlzRXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnVJdGVtQ29tcG9uZW50LnNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmZpcnN0Rm9jdXNhYmxlLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXQgaXNGaXJzdCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnQgPSB0aGlzLmNvbHVtbk1lbnVJdGVtc1swXTtcbiAgICAgICAgICAgIHRoaXMubWVudUl0ZW1Db21wb25lbnQuc2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2UuZmlyc3RGb2N1c2FibGUgPSBmb2N1c2FibGVFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0SXRlbUtleWRvd25TdWIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbihmb2N1c2FibGVFbGVtZW50LCAna2V5ZG93bicsIHRoaXMub25UYWIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vicy5hZGQoZmlyc3RJdGVtS2V5ZG93blN1Yik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0ZpcnN0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBpc0ZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNGaXJzdDtcbiAgICB9XG4gICAgc2V0IGlzTGFzdCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uTWVudUl0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Rm9jdXNhYmxlRWxlbWVudCA9IHRoaXMuZ2V0TGFzdENvbHVtbk1lbnVJdGVtKCk7XG4gICAgICAgICAgICB0aGlzLm1lbnVJdGVtQ29tcG9uZW50LnNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmxhc3RGb2N1c2FibGUgPSBsYXN0Rm9jdXNhYmxlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0SXRlbUtleWRvd25TdWIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihsYXN0Rm9jdXNhYmxlRWxlbWVudCwgJ2tleWRvd24nLCB0aGlzLm9uVGFiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnMuYWRkKGxhc3RJdGVtS2V5ZG93blN1Yik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRXhwYW5kYWJsZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVudUl0ZW1Db21wb25lbnQuaXNMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0xhc3QgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGlzTGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzTGFzdDtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmNvbHVtbk1lbnVJdGVtcyA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuay1jb2x1bW5tZW51LWl0ZW0nKTtcbiAgICAgICAgW10uc2xpY2UuYXBwbHkodGhpcy5jb2x1bW5NZW51SXRlbXMpLmZvckVhY2goZWwgPT4gdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoZWwsICd0YWJpbmRleCcsICcwJykpO1xuICAgICAgICBpZiAodGhpcy5tZW51SXRlbUNvbXBvbmVudCBpbnN0YW5jZW9mIENvbHVtbk1lbnVGaWx0ZXJDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMubWVudUl0ZW1Db21wb25lbnQuc2VydmljZS5tZW51VGFiYmluZ1NlcnZpY2UuaXNDb2x1bW5NZW51ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicykge1xuICAgICAgICAgICAgdGhpcy5zdWJzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGFzdENvbHVtbk1lbnVJdGVtKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29sdW1uTWVudUl0ZW1zLmxlbmd0aCA9PT0gMSA/IHRoaXMuY29sdW1uTWVudUl0ZW1zWzBdIDogdGhpcy5jb2x1bW5NZW51SXRlbXNbMV0pO1xuICAgIH1cbiAgICBpc0V4cGFuZGFibGVJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZW51SXRlbUNvbXBvbmVudCBpbnN0YW5jZW9mIENvbHVtbk1lbnVGaWx0ZXJDb21wb25lbnQgfHxcbiAgICAgICAgICAgIHRoaXMubWVudUl0ZW1Db21wb25lbnQgaW5zdGFuY2VvZiBDb2x1bW5NZW51Q2hvb3NlckNvbXBvbmVudCB8fFxuICAgICAgICAgICAgdGhpcy5tZW51SXRlbUNvbXBvbmVudCBpbnN0YW5jZW9mIENvbHVtbk1lbnVQb3NpdGlvbkNvbXBvbmVudDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2tlbmRvR3JpZENvbHVtbk1lbnVJdGVtJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbk1lbnVJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJtZW51SXRlbUNvbXBvbmVudFwiLCB2b2lkIDApO1xuQ29sdW1uTWVudUl0ZW1EaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1trZW5kb0dyaWRDb2x1bW5NZW51SXRlbV0nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBOZ1pvbmVdKVxuXSwgQ29sdW1uTWVudUl0ZW1EaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENvbHVtbk1lbnVDb250YWluZXJDb21wb25lbnQgPSBjbGFzcyBDb2x1bW5NZW51Q29udGFpbmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlLCBuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbk1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbk1lbnVJdGVtcy5maXJzdC5pc0ZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb2x1bW5NZW51SXRlbXMubGFzdC5pc0xhc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLm5nWm9uZS5vblN0YWJsZS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNlcnZpY2UubWVudVRhYmJpbmdTZXJ2aWNlLmZpcnN0Rm9jdXNhYmxlLmZvY3VzKCkpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oQ29sdW1uTWVudUl0ZW1EaXJlY3RpdmUsIHsgZGVzY2VuZGFudHM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIENvbHVtbk1lbnVDb250YWluZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbk1lbnVJdGVtc1wiLCB2b2lkIDApO1xuQ29sdW1uTWVudUNvbnRhaW5lckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1jb2x1bW5tZW51LWNvbnRhaW5lcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb2x1bW5NZW51U2VydmljZSxcbiAgICAgICAgTmdab25lXSlcbl0sIENvbHVtbk1lbnVDb250YWluZXJDb21wb25lbnQpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbHVtbi1tZW51IGl0ZW0gdGhhdCBjYW4gYmUgcGxhY2VkIGluc2lkZSBhXG4gKiBbQ29sdW1uTWVudVRlbXBsYXRlXSh7JSBzbHVnIGFwaV9ncmlkX2NvbHVtbm1lbnV0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlLlxuICogQWxsb3dzIHRoZSB1c2VyIHRvIHN0aWNrIG9yIHVuc3RpY2sgdGhlIGNvbHVtbnMuXG4gKlxuICogPiBZb3UgaGF2ZSB0byBzZXQgdGhlIFtDb2x1bW5NZW51U2VydmljZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jb2x1bW5tZW51c2VydmljZSAlfSkgdGhhdCBpcyBwYXNzZWQgYnlcbiAqID4gdGhlIHRlbXBsYXRlIHRvIHRoZSBzZXJ2aWNlIGlucHV0IG9mIHRoZSBga2VuZG8tZ3JpZC1jb2x1bW5tZW51LXN0aWNrYCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJkYXRhXCIgW2NvbHVtbk1lbnVdPVwidHJ1ZVwiPlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENvbHVtbk1lbnVUZW1wbGF0ZSBsZXQtc2VydmljZT1cInNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW5tZW51LXN0aWNrIFtzZXJ2aWNlXT1cInNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1ubWVudS1zdGljaz5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJGaWVsZDFcIiBbd2lkdGhdPVwiMTAwXCI+PC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIkZpZWxkMlwiIFt3aWR0aF09XCIxMDBcIj48L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgPC9rZW5kby1ncmlkPlxuICogICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGRhdGE6IGFueVtdID0gW3sgRmllbGQxOiAnRm9vJywgRmllbGQyOiAnQmFyJyB9XTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IENvbHVtbk1lbnVTdGlja0NvbXBvbmVudCA9IGNsYXNzIENvbHVtbk1lbnVTdGlja0NvbXBvbmVudCBleHRlbmRzIENvbHVtbk1lbnVJdGVtQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCBjb2x1bW5JbmZvU2VydmljZSwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UgPSBjb2x1bW5JbmZvU2VydmljZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgIH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldCh0aGlzLnN0aWNreSA/ICd1bnN0aWNrJyA6ICdzdGljaycpO1xuICAgIH1cbiAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RpY2t5ID8gJ3Vuc3RpY2snIDogJ3N0aWNrJztcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc3RpY2t5ICYmIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UudW5sb2NrZWRSb290Q291bnQgPCAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9nZ2xlQ29sdW1uKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZUhpZXJhcmNoeSghdGhpcy5zdGlja3kpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIHRvZ2dsZUhpZXJhcmNoeShzdGlja3kpIHtcbiAgICAgICAgbGV0IHJvb3QgPSB0aGlzLnNlcnZpY2UuY29sdW1uO1xuICAgICAgICB3aGlsZSAocm9vdC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJvb3QgPSByb290LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2x1bW5zID0gW3Jvb3RdO1xuICAgICAgICBjb25zdCBhbGxDaGFuZ2VkID0gW107XG4gICAgICAgIHdoaWxlIChjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gY29sdW1ucy5zaGlmdCgpO1xuICAgICAgICAgICAgY29sdW1uLnN0aWNreSA9IHN0aWNreTtcbiAgICAgICAgICAgIGFsbENoYW5nZWQucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNvbHVtbi5oYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaCguLi5jb2x1bW4uY2hpbGRyZW5BcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZS5jaGFuZ2VTdHVjayhhbGxDaGFuZ2VkKTtcbiAgICB9XG4gICAgZ2V0IHN0aWNreSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5jb2x1bW4uc3RpY2t5O1xuICAgIH1cbn07XG5Db2x1bW5NZW51U3RpY2tDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWdyaWQtY29sdW1ubWVudS1zdGljaycsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgPGtlbmRvLWdyaWQtY29sdW1ubWVudS1pdGVtIFt0ZXh0XT1cInRleHRcIiBbaWNvbl09XCJpY29uXCIgKGl0ZW1DbGljayk9XCJ0b2dnbGVDb2x1bW4oKVwiIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW5tZW51LWl0ZW0+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sdW1uSW5mb1NlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmXSlcbl0sIENvbHVtbk1lbnVTdGlja0NvbXBvbmVudCk7XG5cbmNvbnN0IENPTVBPTkVOVFMkMSA9IFtcbiAgICBDb2x1bW5MaXN0Q29tcG9uZW50LFxuICAgIENvbHVtbkNob29zZXJDb21wb25lbnQsXG4gICAgQ29sdW1uTWVudUNob29zZXJDb21wb25lbnQsXG4gICAgQ29sdW1uTWVudUZpbHRlckNvbXBvbmVudCxcbiAgICBDb2x1bW5NZW51SXRlbUNvbXBvbmVudCxcbiAgICBDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBDb2x1bW5NZW51U29ydENvbXBvbmVudCxcbiAgICBDb2x1bW5NZW51Q29tcG9uZW50LFxuICAgIENvbHVtbk1lbnVMb2NrQ29tcG9uZW50LFxuICAgIENvbHVtbk1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBDb2x1bW5NZW51Q29udGFpbmVyQ29tcG9uZW50LFxuICAgIENvbHVtbk1lbnVJdGVtRGlyZWN0aXZlLFxuICAgIENvbHVtbk1lbnVTdGlja0NvbXBvbmVudCxcbiAgICBDb2x1bW5NZW51UG9zaXRpb25Db21wb25lbnRcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENvbHVtbk1lbnVNb2R1bGUgPSBjbGFzcyBDb2x1bW5NZW51TW9kdWxlIHtcbiAgICBzdGF0aWMgZXhwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIENvbHVtbkNob29zZXJDb21wb25lbnQsXG4gICAgICAgICAgICBDb2x1bW5NZW51RmlsdGVyQ29tcG9uZW50LFxuICAgICAgICAgICAgQ29sdW1uTWVudUl0ZW1Db21wb25lbnQsXG4gICAgICAgICAgICBDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIENvbHVtbk1lbnVTb3J0Q29tcG9uZW50LFxuICAgICAgICAgICAgQ29sdW1uTWVudUxvY2tDb21wb25lbnQsXG4gICAgICAgICAgICBDb2x1bW5NZW51U3RpY2tDb21wb25lbnQsXG4gICAgICAgICAgICBDb2x1bW5NZW51UG9zaXRpb25Db21wb25lbnQsXG4gICAgICAgICAgICBDb2x1bW5NZW51Q2hvb3NlckNvbXBvbmVudCxcbiAgICAgICAgICAgIENvbHVtbk1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIENvbHVtbk1lbnVDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgICAgICBDb2x1bW5NZW51SXRlbURpcmVjdGl2ZSxcbiAgICAgICAgICAgIENvbHVtbk1lbnVDb21wb25lbnRcbiAgICAgICAgXTtcbiAgICB9XG59O1xuQ29sdW1uTWVudU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NUE9ORU5UUyQxXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRmlsdGVyTWVudU1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRTJDFdXG4gICAgfSlcbl0sIENvbHVtbk1lbnVNb2R1bGUpO1xuXG5jb25zdCBleHBvcnRlZE1vZHVsZXMkMiA9IFtcbiAgICBIZWFkZXJDb21wb25lbnQsXG4gICAgSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgQ29sdW1uSGFuZGxlRGlyZWN0aXZlLFxuICAgIFNlbGVjdEFsbENoZWNrYm94RGlyZWN0aXZlXG5dO1xuY29uc3QgaW1wb3J0ZWRNb2R1bGVzJDIgPSBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIEdyb3VwTW9kdWxlLFxuICAgIFJvd0ZpbHRlck1vZHVsZSxcbiAgICBGaWx0ZXJNZW51TW9kdWxlLFxuICAgIFNoYXJlZE1vZHVsZSxcbiAgICBEcmFnQW5kRHJvcE1vZHVsZSxcbiAgICBDb2x1bW5NZW51TW9kdWxlXG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBIZWFkZXJNb2R1bGUgPSBjbGFzcyBIZWFkZXJNb2R1bGUge1xuICAgIHN0YXRpYyBleHBvcnRzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBTZWxlY3RBbGxDaGVja2JveERpcmVjdGl2ZVxuICAgICAgICBdO1xuICAgIH1cbn07XG5IZWFkZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2V4cG9ydGVkTW9kdWxlcyQyXSxcbiAgICAgICAgZXhwb3J0czogW2V4cG9ydGVkTW9kdWxlcyQyXSxcbiAgICAgICAgaW1wb3J0czogWy4uLmltcG9ydGVkTW9kdWxlcyQyXVxuICAgIH0pXG5dLCBIZWFkZXJNb2R1bGUpO1xuXG52YXIgQ29tbWFuZENvbHVtbkNvbXBvbmVudF8xO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb21tYW5kIGNvbHVtbnMgb2YgdGhlIEdyaWQuIFlvdSBoYXZlIHRvIGRlZmluZSB0aGUgY29udGVudCBvZiB0aGVcbiAqIGNvbHVtbiBpbnNpZGUgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZy4gVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBjdXJyZW50XG4gKiBkYXRhIGl0ZW0uIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcyBvbiB1c2luZyB0aGUgcGFzc2VkIGZpZWxkc1xuICogYW5kIHRoZSBjb21tYW5kIGRpcmVjdGl2ZXMsIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gKiBbZWRpdGluZyB0aGUgR3JpZCBpbiBBbmd1bGFyIFJlYWN0aXZlIEZvcm1zXSh7JSBzbHVnIGVkaXRpbmdfcmVhY3RpdmVfZm9ybXNfZ3JpZCAlfSkuXG4gKlxuICogVGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgcGFzc2VkOlxuICogLSBgY29sdW1uSW5kZXhgJm1kYXNoO1RoZSBjdXJyZW50IGNvbHVtbiBpbmRleC5cbiAqIC0gYHJvd0luZGV4YCZtZGFzaDtUaGUgY3VycmVudCBkYXRhIHJvdyBpbmRleC4gSWYgaW5zaWRlIGEgbmV3IGl0ZW0gcm93LCBgcm93SW5kZXhgaXMgYC0xYC5cbiAqIC0gYGRhdGFJdGVtYCZtZGFzaDtUaGUgY3VycmVudCBkYXRhIGl0ZW0uXG4gKiAtIGBjb2x1bW5gJm1kYXNoO1RoZSBjdXJyZW50IGNvbHVtbiBpbnN0YW5jZS5cbiAqIC0gYGlzTmV3YCZtZGFzaDtUaGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgaXRlbS5cbiAqXG4gKiBVc3VhbGx5LCB0aGUgdGVtcGxhdGUgY29udGFpbnMgQ1JVRCBjb21tYW5kIGRpcmVjdGl2ZXMgc3VjaCBhczpcbiAqIC0gW0VkaXRDb21tYW5kRGlyZWN0aXZlXSh7JSBzbHVnIGFwaV9ncmlkX2VkaXRjb21tYW5kZGlyZWN0aXZlICV9KVxuICogLSBbUmVtb3ZlQ29tbWFuZERpcmVjdGl2ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9yZW1vdmVjb21tYW5kZGlyZWN0aXZlICV9KVxuICogLSBbQ2FuY2VsQ29tbWFuZERpcmVjdGl2ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jYW5jZWxjb21tYW5kZGlyZWN0aXZlICV9KVxuICogLSBbU2F2ZUNvbW1hbmREaXJlY3RpdmVdKHslIHNsdWcgYXBpX2dyaWRfc2F2ZWNvbW1hbmRkaXJlY3RpdmUgJX0pXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1ncmlkIFtkYXRhXT1cImdyaWREYXRhXCI+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0SURcIiB0aXRsZT1cIlByb2R1Y3QgSURcIiB3aWR0aD1cIjEyMFwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJVbml0UHJpY2VcIiB0aXRsZT1cIlVuaXQgUHJpY2VcIiB3aWR0aD1cIjIzMFwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbW1hbmQtY29sdW1uIHRpdGxlPVwiY29tbWFuZFwiIHdpZHRoPVwiMjIwXCI+XG4gKiAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDZWxsVGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtlbmRvR3JpZEVkaXRDb21tYW5kIGNsYXNzPVwiay1wcmltYXJ5XCI+RWRpdDwvYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZW5kb0dyaWRSZW1vdmVDb21tYW5kPlJlbW92ZTwvYnV0dG9uPlxuICogICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb21tYW5kLWNvbHVtbj5cbiAqICAgICAgICA8L2tlbmRvLWdyaWQ+XG4gKiAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICBwdWJsaWMgZ3JpZERhdGE6IGFueVtdO1xuICpcbiAqICAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgICAgIHRoaXMuZ3JpZERhdGEgPSBwcm9kdWN0cztcbiAqICAgIH1cbiAqIH1cbiAqXG4gKiBjb25zdCBwcm9kdWN0cyA9IFt7XG4gKiAgICBcIlByb2R1Y3RJRFwiOiAxLFxuICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAqICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gKiAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gKiAgfSwge1xuICogICAgXCJQcm9kdWN0SURcIjogMixcbiAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAqICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gKiAgfVxuICogXTtcbiAqXG4gKiBgYGBcbiAqL1xubGV0IENvbW1hbmRDb2x1bW5Db21wb25lbnQgPSBDb21tYW5kQ29sdW1uQ29tcG9uZW50XzEgPSBjbGFzcyBDb21tYW5kQ29sdW1uQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uQmFzZSQxIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGlkU2VydmljZSkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIGlkU2VydmljZSk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlID8gdGhpcy50ZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKENlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDb21tYW5kQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuQ29tbWFuZENvbHVtbkNvbXBvbmVudCA9IENvbW1hbmRDb2x1bW5Db21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbHVtbkJhc2UkMSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb21tYW5kQ29sdW1uQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1jb21tYW5kLWNvbHVtbicsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgU2tpcFNlbGYoKSksIF9fcGFyYW0oMCwgSG9zdCgpKSwgX19wYXJhbSgwLCBPcHRpb25hbCgpKSwgX19wYXJhbSgxLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbHVtbkJhc2UkMSwgSWRTZXJ2aWNlXSlcbl0sIENvbW1hbmRDb2x1bW5Db21wb25lbnQpO1xuXG52YXIgQ2hlY2tib3hDb2x1bW5Db21wb25lbnRfMTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY2hlY2tib3ggZm9yIHNlbGVjdGluZyBjb2x1bW5zIGluIHRoZSBHcmlkLiBJZiB0aGUgY29sdW1uIGlzXG4gKiBkZWZpbmVkIGFzIGVtcHR5LCBpdCByZW5kZXJzIGEgZGVmYXVsdCBjaGVja2JveCBmb3Igcm93IHNlbGVjdGlvbi5cbiAqIFlvdSBjYW4gYWxzbyBkZWZpbmUgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbHVtbiBpbnNpZGUgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZy5cbiAqIFRoZSBpbnB1dCByZXF1aXJlcyB5b3UgdG8gaW5jbHVkZSB0aGUgYFNlbGVjdGlvbkNoZWNrYm94YCBvcHRpb24uXG4gKlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGRhdGEgaXRlbSBhbmQgdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgcGFzc2VkOlxuICogLSBgY29sdW1uSW5kZXhgJm1kYXNoO1RoZSBjdXJyZW50IGNvbHVtbiBpbmRleC5cbiAqIC0gYHJvd0luZGV4YCZtZGFzaDtUaGUgY3VycmVudCBkYXRhIHJvdyBpbmRleC4gSWYgaW5zaWRlIGEgbmV3IGl0ZW0gcm93LCBpdCB3aWxsIGJlIGAtMWAuXG4gKiAtIGBkYXRhSXRlbWAmbWRhc2g7VGhlIGN1cnJlbnQgZGF0YSBpdGVtLlxuICogLSBgY29sdW1uYCZtZGFzaDtUaGUgY3VycmVudCBjb2x1bW4gaW5zdGFuY2UuXG4gKiAtIGBpc05ld2AmbWRhc2g7VGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0uXG4gKlxuICogRm9yIG1vcmUgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogLSBbU2VsZWN0aW5nIG9yIGRlc2VsZWN0aW5nIGFsbCBpdGVtcyBvbiBhIHBhZ2VdKHslIHNsdWcgc2VsZWN0aW9uX2dyaWQgJX0jdG9jLXNlbGVjdC1hbGwtZmVhdHVyZSlcbiAqIC0gW1BlcnNpc3RpbmcgdGhlIHNlbGVjdGlvbl0oeyUgc2x1ZyBzZWxlY3Rpb25fZ3JpZCAlfSN0b2MtaW4tY29tYmluYXRpb24td2l0aC10aGUtc2VsZWN0LWFsbC1mZWF0dXJlKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJncmlkRGF0YVwiIFtzZWxlY3RhYmxlXT1cIntlbmFibGVkOiB0cnVlLCBjaGVja2JveE9ubHk6IHRydWV9XCI+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0SURcIiB0aXRsZT1cIlByb2R1Y3QgSURcIiB3aWR0aD1cIjEyMFwiPlxuICogICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jaGVja2JveC1jb2x1bW4gdGl0bGU9XCJEZWZhdWx0IGNoZWNrYm94XCI+XG4gKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY2hlY2tib3gtY29sdW1uPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY2hlY2tib3gtY29sdW1uIHRpdGxlPVwiQ3VzdG9tIGNoZWNrYm94XCI+XG4gKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDZWxsVGVtcGxhdGUgbGV0LWlkeD1cInJvd0luZGV4XCI+XG4gKiAgICAgICAgICAgICAgU2VsZWN0IHJvdyA8aW5wdXQgW2tlbmRvR3JpZFNlbGVjdGlvbkNoZWNrYm94XT1cImlkeFwiIC8+XG4gKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY2hlY2tib3gtY29sdW1uPlxuICogICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgIHB1YmxpYyBncmlkRGF0YTogYW55W107XG4gKlxuICogICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgICAgdGhpcy5ncmlkRGF0YSA9IHByb2R1Y3RzO1xuICogICAgfVxuICogfVxuICpcbiAqIGNvbnN0IHByb2R1Y3RzID0gW3tcbiAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICogICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAqICB9LCB7XG4gKiAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gKiAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAqICB9XG4gKiBdO1xuICpcbiAqIGBgYFxuICovXG5sZXQgQ2hlY2tib3hDb2x1bW5Db21wb25lbnQgPSBDaGVja2JveENvbHVtbkNvbXBvbmVudF8xID0gY2xhc3MgQ2hlY2tib3hDb2x1bW5Db21wb25lbnQgZXh0ZW5kcyBDb2x1bW5CYXNlJDEge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgaWRTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgaWRTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNDaGVja2JveENvbHVtbiA9IHRydWU7XG4gICAgfVxuICAgIGdldCB0ZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGUgPyB0aGlzLnRlbXBsYXRlLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2hlY2tib3hDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcInNob3dTZWxlY3RBbGxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ2hlY2tib3hDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcInRlbXBsYXRlXCIsIHZvaWQgMCk7XG5DaGVja2JveENvbHVtbkNvbXBvbmVudCA9IENoZWNrYm94Q29sdW1uQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBDb2x1bW5CYXNlJDEsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb2x1bW5Db21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLWNoZWNrYm94LWNvbHVtbicsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgU2tpcFNlbGYoKSksIF9fcGFyYW0oMCwgSG9zdCgpKSwgX19wYXJhbSgwLCBPcHRpb25hbCgpKSwgX19wYXJhbSgxLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbHVtbkJhc2UkMSwgSWRTZXJ2aWNlXSlcbl0sIENoZWNrYm94Q29sdW1uQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSByb3ctc2VsZWN0aW9uIGNoZWNrYm94IG9mIHRoZSBHcmlkLiBUaGUgZGlyZWN0aXZlIGV4cGVjdHMgdGhlXG4gKiBpbmRleCBvZiB0aGUgY3VycmVudCByb3cgYXMgYW4gaW5wdXQgcGFyYW1ldGVyLiBJbnNpZGUgdGhlXG4gKiBbQ2hlY2tib3hDb2x1bW5Db21wb25lbnRdKHslIHNsdWcgYXBpX2dyaWRfY2hlY2tib3hjb2x1bW5jb21wb25lbnQgJX0pLCBhcHBseSB0aGVcbiAqIGRpcmVjdGl2ZSB0byBhbiBgaW5wdXRgIGVsZW1lbnQuIFdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBjaGVja2JveCB0aGF0IGlzIGFzc29jaWF0ZWRcbiAqIHdpdGggdGhlIGRpcmVjdGl2ZSwgYSBbc2VsZWN0aW9uQ2hhbmdlXSh7JSBzbHVnIGFwaV9ncmlkX2dyaWRjb21wb25lbnQgJX0jdG9jLXNlbGVjdGlvbkNoYW5nZSlcbiAqIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgPGtlbmRvLWdyaWQgW2RhdGFdPVwiZ3JpZERhdGFcIiBbc2VsZWN0YWJsZV09XCJ7ZW5hYmxlZDogdHJ1ZSwgY2hlY2tib3hPbmx5OiB0cnVlfVwiPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY2hlY2tib3gtY29sdW1uIHRpdGxlPVwiQ3VzdG9tIGNoZWNrYm94XCI+XG4gKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDZWxsVGVtcGxhdGUgbGV0LWlkeD1cInJvd0luZGV4XCI+XG4gKiAgICAgICAgICAgICAgU2VsZWN0IHJvdyA8aW5wdXQgW2tlbmRvR3JpZFNlbGVjdGlvbkNoZWNrYm94XT1cImlkeFwiIC8+XG4gKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY2hlY2tib3gtY29sdW1uPlxuICogICAgICAgICAgPGtlbmRvLWdyaWQtY29sdW1uIGZpZWxkPVwiUHJvZHVjdElEXCIgdGl0bGU9XCJQcm9kdWN0IElEXCIgd2lkdGg9XCIxMjBcIj5cbiAqICAgICAgICAgIDwva2VuZG8tZ3JpZC1jb2x1bW4+XG4gKiAgICAgICAgICA8a2VuZG8tZ3JpZC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCI+XG4gKiAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgIHB1YmxpYyBncmlkRGF0YTogYW55W107XG4gKlxuICogICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgICAgdGhpcy5ncmlkRGF0YSA9IHByb2R1Y3RzO1xuICogICAgfVxuICogfVxuICpcbiAqIGNvbnN0IHByb2R1Y3RzID0gW3tcbiAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICogICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAqICB9LCB7XG4gKiAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gKiAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICogICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAqICB9XG4gKiBdO1xuICpcbiAqIGBgYFxuICovXG5sZXQgU2VsZWN0aW9uQ2hlY2tib3hEaXJlY3RpdmUgPSBjbGFzcyBTZWxlY3Rpb25DaGVja2JveERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3Ioc2VsZWN0aW9uU2VydmljZSwgZWwsIHJlbmRlcmVyLCBuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlID0gc2VsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUNsaWNrID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbC5uYXRpdmVFbGVtZW50LCBcImNsaWNrXCIsIHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUtleURvd24gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFwia2V5ZG93blwiLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICAgICAgdGhpcy5zZXRDaGVja2VkU3RhdGUoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3lDbGljaykge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95Q2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95S2V5RG93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95S2V5RG93bigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblNlcnZpY2Uub3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnRvZ2dsZUJ5SW5kZXgodGhpcy5pdGVtSW5kZXgpO1xuICAgICAgICAgICAgICAgIGV2LmN0cmxLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV2LnNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNoYW5nZXMuZW1pdChldik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbktleURvd24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLZXlzLkVudGVyKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xpY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXRDaGVja2VkU3RhdGUoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5lbC5uYXRpdmVFbGVtZW50LCBcImNoZWNrZWRcIiwgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzU2VsZWN0ZWQodGhpcy5pdGVtSW5kZXgpKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoXCJrZW5kb0dyaWRTZWxlY3Rpb25DaGVja2JveFwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VsZWN0aW9uQ2hlY2tib3hEaXJlY3RpdmUucHJvdG90eXBlLCBcIml0ZW1JbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIudHlwZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZWxlY3Rpb25DaGVja2JveERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuU2VsZWN0aW9uQ2hlY2tib3hEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRTZWxlY3Rpb25DaGVja2JveF0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBTZWxlY3Rpb25DaGVja2JveERpcmVjdGl2ZSk7XG5cbmNvbnN0IGNvbHVtbkNlbGxJbmRleCA9IChjZWxsLCBjZWxscykgPT4ge1xuICAgIGxldCBjZWxsSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGNlbGxzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKGNlbGxzW2lkeF0gPT09IGNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNDbGFzc2VzKGNlbGxzW2lkeF0sICdrLWhpZXJhcmNoeS1jZWxsIGstZ3JvdXAtY2VsbCcpKSB7XG4gICAgICAgICAgICBjZWxsSW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRhYmxlQm9keUNvbXBvbmVudCA9IGNsYXNzIFRhYmxlQm9keUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGV0YWlsc1NlcnZpY2UsIGdyb3Vwc1NlcnZpY2UsIGNoYW5nZU5vdGlmaWNhdGlvbiwgZWRpdFNlcnZpY2UsIGxvY2FsaXphdGlvbiwgbmdab25lLCByZW5kZXJlciwgZWxlbWVudCwgZG9tRXZlbnRzLCBzZWxlY3Rpb25TZXJ2aWNlLCBjZWxsU2VsZWN0aW9uU2VydmljZSwgY29sdW1uSW5mb1NlcnZpY2UsIG5hdmlnYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGV0YWlsc1NlcnZpY2UgPSBkZXRhaWxzU2VydmljZTtcbiAgICAgICAgdGhpcy5ncm91cHNTZXJ2aWNlID0gZ3JvdXBzU2VydmljZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VOb3RpZmljYXRpb24gPSBjaGFuZ2VOb3RpZmljYXRpb247XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UgPSBlZGl0U2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzID0gZG9tRXZlbnRzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNlbGxTZWxlY3Rpb25TZXJ2aWNlID0gY2VsbFNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UgPSBjb2x1bW5JbmZvU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBbXTtcbiAgICAgICAgdGhpcy5za2lwID0gMDtcbiAgICAgICAgdGhpcy5ub1JlY29yZHNUZXh0ID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdub1JlY29yZHMnKTtcbiAgICAgICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNraXBHcm91cERlY29yYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93R3JvdXBGb290ZXJzID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9ja2VkQ29sdW1uc0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy50b3RhbENvbHVtbnNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudHJhY2tCeSA9IGRlZmF1bHRUcmFja0J5O1xuICAgICAgICB0aGlzLnJvd0NsYXNzID0gKCkgPT4gbnVsbDtcbiAgICAgICAgdGhpcy5jZWxsS2V5ZG93blN1YnNjcmlwdGlvbiA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2UuY2VsbEtleWRvd24uc3Vic2NyaWJlKChhcmdzKSA9PiB0aGlzLmNlbGxLZXlkb3duSGFuZGxlcihhcmdzKSk7XG4gICAgICAgIHRoaXMudHJhY2tCeVdyYXBwZXIgPSB0aGlzLnRyYWNrQnlXcmFwcGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhY2tCeUNvbHVtbnMgPSB0aGlzLnRyYWNrQnlDb2x1bW5zLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdldCBuZXdEYXRhSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdFNlcnZpY2UubmV3RGF0YUl0ZW07XG4gICAgfVxuICAgIC8vIE51bWJlciBvZiB1bmxvY2tlZCBjb2x1bW5zIGluIHRoZSBuZXh0IHRhYmxlLCBpZiBhbnlcbiAgICBnZXQgdW5sb2NrZWRDb2x1bW5zQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29sdW1uc0NvdW50IC0gdGhpcy5sb2NrZWRDb2x1bW5zQ291bnQgLSAodGhpcy5hbGxDb2x1bW5zIHx8IHRoaXMuY29sdW1ucykubGVuZ3RoO1xuICAgIH1cbiAgICBpc0FyaWFTZWxlY3RlZChpdGVtLCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbFNlbGVjdGlvblNlcnZpY2UuaXNDZWxsU2VsZWN0ZWQoaXRlbSwgY29sdW1uKSB8fFxuICAgICAgICAgICAgdGhpcy5pc1Jvd1NlbGVjdGVkKGl0ZW0pID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB9XG4gICAgdG9nZ2xlUm93KGluZGV4LCBkYXRhSXRlbSkge1xuICAgICAgICB0aGlzLmRldGFpbHNTZXJ2aWNlLnRvZ2dsZVJvdyhpbmRleCwgZGF0YUl0ZW0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzRXhwYW5kZWQodmlld0l0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWlsc1NlcnZpY2UuaXNFeHBhbmRlZCh2aWV3SXRlbS5pbmRleCwgdmlld0l0ZW0uZGF0YSk7XG4gICAgfVxuICAgIGRldGFpbEJ1dHRvblN0eWxlcyh2aWV3SXRlbSkge1xuICAgICAgICBjb25zdCBleHBhbmRlZCA9IHRoaXMuaXNFeHBhbmRlZCh2aWV3SXRlbSk7XG4gICAgICAgIHJldHVybiBleHBhbmRlZCA/ICdrLWktbWludXMnIDogJ2staS1wbHVzJztcbiAgICB9XG4gICAgZGV0YWlsQnV0dG9uVGl0bGUodmlld0l0ZW0pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUtleSA9IHRoaXMuaXNFeHBhbmRlZCh2aWV3SXRlbSkgPyAnZGV0YWlsQ29sbGFwc2UnIDogJ2RldGFpbEV4cGFuZCc7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQobWVzc2FnZUtleSk7XG4gICAgfVxuICAgIGlzR3JvdXAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50eXBlID09PSAnZ3JvdXAnO1xuICAgIH1cbiAgICBpc0RhdGFJdGVtKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzR3JvdXAoaXRlbSkgJiYgIXRoaXMuaXNGb290ZXIoaXRlbSk7XG4gICAgfVxuICAgIGlzRm9vdGVyKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gJ2Zvb3Rlcic7XG4gICAgfVxuICAgIGlzRm9vdGVySXRlbUluRXhwYW5kZWRHcm91cChpdGVtKSB7XG4gICAgICAgIGNvbnN0IGZvb3Rlckl0ZW0gPSB7IGRhdGE6IGl0ZW0uZGF0YSwgaW5kZXg6IGl0ZW0uZ3JvdXBJbmRleCwgcGFyZW50R3JvdXA6IGl0ZW0uZ3JvdXAucGFyZW50R3JvdXAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJbkV4cGFuZGVkR3JvdXAoZm9vdGVySXRlbSk7XG4gICAgfVxuICAgIGlzRGF0YUl0ZW1JbkV4cGFuZGVkR3JvdXAoaXRlbSkge1xuICAgICAgICBjb25zdCBkYXRhSXRlbSA9IHsgZGF0YTogaXRlbS5ncm91cC5kYXRhLCBpbmRleDogaXRlbS5ncm91cEluZGV4LCBwYXJlbnRHcm91cDogaXRlbS5ncm91cC5wYXJlbnRHcm91cCB9O1xuICAgICAgICByZXR1cm4gdGhpcy5pc0luRXhwYW5kZWRHcm91cChkYXRhSXRlbSk7XG4gICAgfVxuICAgIGlzSW5FeHBhbmRlZEdyb3VwKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzU2VydmljZS5pc0luRXhwYW5kZWRHcm91cChpdGVtKTtcbiAgICB9XG4gICAgaXNQYXJlbnRHcm91cEV4cGFuZGVkKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzU2VydmljZS5pc0luRXhwYW5kZWRHcm91cChpdGVtLnBhcmVudEdyb3VwKTtcbiAgICB9XG4gICAgaXNPZGQoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5pbmRleCAlIDIgIT09IDA7XG4gICAgfVxuICAgIGlzU2VsZWN0YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0YWJsZSAmJiB0aGlzLnNlbGVjdGFibGUuZW5hYmxlZCAhPT0gZmFsc2U7XG4gICAgfVxuICAgIGlzUm93U2VsZWN0ZWQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzU2VsZWN0ZWQoaXRlbS5pbmRleCk7XG4gICAgfVxuICAgIHRyYWNrQnlXcmFwcGVyKGluZGV4LCBpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgaXRlbS5pc0VkaXRpbmcgPSB0aGlzLmVkaXRTZXJ2aWNlLmhhc0VkaXRlZChpdGVtLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFja0J5KGluZGV4LCBpdGVtKTtcbiAgICB9XG4gICAgdHJhY2tCeUNvbHVtbnMoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlydHVhbENvbHVtbnMgPyBpbmRleCA6IGl0ZW07XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzR3JvdXBIZWFkZXJDb2x1bW4pIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJDb2x1bW5zID0gY29sdW1uc1RvUmVuZGVyKHRoaXMuc2tpcEdyb3VwRGVjb3JhdGlvbiA/IHRoaXMuY29sdW1ucyA6IHRoaXMuY29sdW1ucy50b0FycmF5KCkuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncm91cEhlYWRlckNvbHVtbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEhlYWRlclNsYXZlQ2VsbHNDb3VudCA9XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNHcm91cEhlYWRlckNvbHVtbiA/IHRoaXMuY29sdW1uc0NvbnRhaW5lci5ub25Mb2NrZWRDb2x1bW5zVG9SZW5kZXIubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJTbGF2ZUNlbGxzQ291bnQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm93U3RpY2t5KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5U3RpY2t5Um93c1N0eWxpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ2NvbHVtbnMnLCBjaGFuZ2VzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTm90aWZpY2F0aW9uLm5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ2ljYWxSb3dJbmRleChyb3dJbmRleCkge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5za2lwICsgcm93SW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmhhc0RldGFpbFRlbXBsYXRlKSB7XG4gICAgICAgICAgICBwb3MgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYnNvbHV0ZVJvd0luZGV4ID0gMSArIHBvcztcbiAgICAgICAgY29uc3QgYWRkUm93T2Zmc2V0ID0gdGhpcy5lZGl0U2VydmljZS5oYXNOZXdJdGVtID8gMSA6IDA7XG4gICAgICAgIGNvbnN0IGZpbHRlclJvd09mZnNldCA9IGhhc0ZpbHRlclJvdyh0aGlzLmZpbHRlcmFibGUpID8gMSA6IDA7XG4gICAgICAgIGNvbnN0IGhlYWRlclJvd0NvdW50ID0gdGhpcy5jb2x1bW5JbmZvU2VydmljZS50b3RhbExldmVscyArIGZpbHRlclJvd09mZnNldCArIGFkZFJvd09mZnNldDtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlUm93SW5kZXggKyBoZWFkZXJSb3dDb3VudDtcbiAgICB9XG4gICAgYWRkUm93TG9naWNhbEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5JbmZvU2VydmljZS50b3RhbExldmVscyArIDEgK1xuICAgICAgICAgICAgKGhhc0ZpbHRlclJvdyh0aGlzLmZpbHRlcmFibGUpID8gMSA6IDApO1xuICAgIH1cbiAgICBsb2dpY2FsQ29sSW5kZXgoY29sdW1uKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGNvbHVtbi5sZWFmSW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbi5sZWFmSW5kZXggKyAodGhpcy5oYXNEZXRhaWxUZW1wbGF0ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlciA9IHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBtb3VzZWRvd25TdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ21vdXNlZG93bicsIGNsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICBjb25zdCBtb3VzZXVwU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtb3VzZXVwJywgY2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWNrU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdjbGljaycsIGNsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0bWVudVN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnY29udGV4dG1lbnUnLCBjbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgY29uc3QgdG91Y2hzdGFydFN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndG91Y2hzdGFydCcsIGNsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICBjb25zdCB0b3VjaGVuZFN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndG91Y2hlbmQnLCBjbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5jbGlja1N1YnNjcmlwdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBtb3VzZWRvd25TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBtb3VzZXVwU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgY2xpY2tTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0bWVudVN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudG91Y2hTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdG91Y2hzdGFydFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHRvdWNoZW5kU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG9yaWdpbmFsTm9SZWNvcmRUZXh0ID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdub1JlY29yZHMnKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9SZWNvcmRzVGV4dCA9PT0gb3JpZ2luYWxOb1JlY29yZFRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vUmVjb3Jkc1RleHQgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ25vUmVjb3JkcycpO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTm9SZWNvcmRUZXh0ID0gdGhpcy5ub1JlY29yZHNUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWNrU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG91Y2hTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2hTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNlbGxLZXlkb3duU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrVGltZW91dCk7XG4gICAgfVxuICAgIGlzRWRpdGluZ0NlbGwoaW5kZXgsIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0U2VydmljZS5pc0VkaXRpbmcoKSAmJiB0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGVkQ29sdW1uKGluZGV4LCBjb2x1bW4pO1xuICAgIH1cbiAgICBpc0VkaXRpbmdSb3coaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdFNlcnZpY2UuaXNFZGl0aW5nKCkgJiYgdGhpcy5lZGl0U2VydmljZS5oYXNFZGl0ZWQoaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgaGFzR3JvdXBIZWFkZXJDb2x1bW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIuaGFzR3JvdXBIZWFkZXJDb2x1bW47XG4gICAgfVxuICAgIGdldCBjb2x1bW5zQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5JbmZvU2VydmljZS5jb2x1bW5zQ29udGFpbmVyO1xuICAgIH1cbiAgICBnZXQgY29sdW1uc1NwYW4oKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zU3Bhbih0aGlzLmNvbHVtbnMpO1xuICAgIH1cbiAgICBnZXQgYWxsQ29sdW1uc1NwYW4oKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zU3Bhbih0aGlzLmFsbENvbHVtbnMgfHwgdGhpcy5jb2x1bW5zKTtcbiAgICB9XG4gICAgZ2V0IGNvbFNwYW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNTcGFuICsgdGhpcy5ncm91cHMubGVuZ3RoICsgKHRoaXMuaGFzRGV0YWlsVGVtcGxhdGUgPyAxIDogMCk7XG4gICAgfVxuICAgIGdldCBmb290ZXJDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xvY2tlZCA/IHRoaXMuY29sdW1uc0NvbnRhaW5lci5sb2NrZWRDb2x1bW5zVG9SZW5kZXIgOiB0aGlzLmNvbHVtbnNDb250YWluZXIubm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyO1xuICAgIH1cbiAgICBzaG93R3JvdXBIZWFkZXIoaXRlbSkge1xuICAgICAgICByZXR1cm4gIWl0ZW0uZGF0YS5za2lwSGVhZGVyO1xuICAgIH1cbiAgICBhZGRTdGlja3lDb2x1bW5TdHlsZXMoY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IHN0aWNreVN0eWxlcyA9IHRoaXMuY29sdW1uSW5mb1NlcnZpY2Uuc3RpY2t5Q29sdW1uc1N0eWxlcyhjb2x1bW4pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29sdW1uLnN0eWxlLCBzdGlja3lTdHlsZXMpO1xuICAgIH1cbiAgICByZXNpemVIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmFwcGx5U3RpY2t5Um93c1N0eWxpbmcoKTtcbiAgICB9XG4gICAgZ2V0IGhhc0RldGFpbFRlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZGV0YWlsVGVtcGxhdGUpO1xuICAgIH1cbiAgICBjbGlja0hhbmRsZXIoZXZlbnRBcmcpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmV2ZW50VGFyZ2V0KGV2ZW50QXJnKTtcbiAgICAgICAgbGV0IGNlbGwsIHJvdywgYm9keSwgZ3JpZEVsZW1lbnQ7XG4gICAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjZWxsID0gY2xvc2VzdChjdXJyZW50VGFyZ2V0LCBtYXRjaGVzTm9kZU5hbWUoJ3RkJykpO1xuICAgICAgICAgICAgcm93ID0gY2xvc2VzdChjZWxsLCBtYXRjaGVzTm9kZU5hbWUoJ3RyJykpO1xuICAgICAgICAgICAgYm9keSA9IGNsb3Nlc3Qocm93LCBtYXRjaGVzTm9kZU5hbWUoJ3Rib2R5JykpO1xuICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IGJvZHk7XG4gICAgICAgICAgICBncmlkRWxlbWVudCA9IGNsb3Nlc3RJblNjb3BlKGN1cnJlbnRUYXJnZXQsIG1hdGNoZXNDbGFzc2VzKCdrLWdyaWQnKSwgZWxlbWVudCk7XG4gICAgICAgIH0gd2hpbGUgKGJvZHkgJiYgYm9keSAhPT0gZWxlbWVudCAmJiAhZ3JpZEVsZW1lbnQpO1xuICAgICAgICBpZiAoY2VsbCAmJiAhaGFzQ2xhc3NlcyhjZWxsLCBOT05fREFUQV9DRUxMX0NMQVNTRVMpICYmXG4gICAgICAgICAgICAhaGFzQ2xhc3Nlcyhyb3csIE5PTl9EQVRBX1JPV19DTEFTU0VTKSAmJlxuICAgICAgICAgICAgYm9keSA9PT0gZWxlbWVudCAmJiAhZ3JpZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdFNlcnZpY2UucHJldmVudENlbGxDbG9zZSgpO1xuICAgICAgICAgICAgY29uc3QgZm9jdXNhYmxlID0gdGFyZ2V0ICE9PSBjZWxsICYmIGlzRm9jdXNhYmxlV2l0aFRhYktleSh0YXJnZXQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghZm9jdXNhYmxlICYmICFtYXRjaGVzTm9kZU5hbWUoJ2xhYmVsJykodGFyZ2V0KSAmJiAhaGFzQ2xhc3Nlcyh0YXJnZXQsIElHTk9SRV9UQVJHRVRfQ0xBU1NTRVMpICYmXG4gICAgICAgICAgICAgICAgIWNsb3Nlc3RJblNjb3BlKHRhcmdldCwgbWF0Y2hlc0NsYXNzZXMoSUdOT1JFX0NPTlRBSU5FUl9DTEFTU0VTKSwgY2VsbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5jZWxsQ2xpY2tBcmdzKGNlbGwsIHJvdywgZXZlbnRBcmcpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudEFyZy50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudEFyZy50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb21FdmVudHMuY2VsbE1vdXNlZG93bi5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudEFyZy50eXBlID09PSAnbW91c2V1cCcgfHwgZXZlbnRBcmcudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbUV2ZW50cy5jZWxsTW91c2V1cC5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MuaXNFZGl0ZWRDb2x1bW4gfHwgIXRoaXMuZWRpdFNlcnZpY2UuY2xvc2VDZWxsKGV2ZW50QXJnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50QXJnLnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRDZWxsQ2xpY2soYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRDZWxsQ2xpY2soYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdENlbGxDbGljayhhcmdzKSB7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLmNlbGxDbGljay5lbWl0KE9iamVjdC5hc3NpZ24oYXJncywge1xuICAgICAgICAgICAgaXNFZGl0ZWQ6IGFyZ3MuaXNFZGl0ZWRSb3cgfHwgYXJncy5pc0VkaXRlZENvbHVtblxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNlbGxLZXlkb3duSGFuZGxlcihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuRW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpY2tIYW5kbGVyKGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNlbGxDbGlja0FyZ3MoY2VsbCwgcm93LCBldmVudEFyZykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNvbHVtbkNlbGxJbmRleChjZWxsLCByb3cuY2VsbHMpO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmNvbHVtbnMudG9BcnJheSgpW2luZGV4XTtcbiAgICAgICAgY29uc3QgY29sdW1uSW5kZXggPSB0aGlzLmxvY2tlZENvbHVtbnNDb3VudCArIGluZGV4O1xuICAgICAgICBsZXQgcm93SW5kZXggPSByb3cuZ2V0QXR0cmlidXRlKCdkYXRhLWtlbmRvLWdyaWQtaXRlbS1pbmRleCcpO1xuICAgICAgICByb3dJbmRleCA9IHJvd0luZGV4ID8gcGFyc2VJbnQocm93SW5kZXgsIDEwKSA6IC0xO1xuICAgICAgICBjb25zdCBkYXRhSXRlbSA9IHJvd0luZGV4ID09PSAtMSA/IHRoaXMuZWRpdFNlcnZpY2UubmV3RGF0YUl0ZW0gOiB0aGlzLmRhdGEuYXQocm93SW5kZXggLSB0aGlzLnNraXApO1xuICAgICAgICBjb25zdCBpc0VkaXRlZENvbHVtbiA9IHRoaXMuZWRpdFNlcnZpY2UuaXNFZGl0ZWRDb2x1bW4ocm93SW5kZXgsIGNvbHVtbik7XG4gICAgICAgIGNvbnN0IGlzRWRpdGVkUm93ID0gdGhpcy5lZGl0U2VydmljZS5pc0VkaXRlZChyb3dJbmRleCk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBldmVudEFyZy50eXBlID09PSAna2V5ZG93bicgPyAnY2xpY2snIDogZXZlbnRBcmcudHlwZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgZGF0YUl0ZW06IGRhdGFJdGVtLFxuICAgICAgICAgICAgaXNFZGl0ZWRDb2x1bW46IGlzRWRpdGVkQ29sdW1uLFxuICAgICAgICAgICAgaXNFZGl0ZWRSb3c6IGlzRWRpdGVkUm93LFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRBcmcsXG4gICAgICAgICAgICByb3dJbmRleDogcm93SW5kZXgsXG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGV2ZW50VGFyZ2V0KGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSBhcmdzLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3MudGFyZ2V0O1xuICAgIH1cbiAgICBhcHBseVN0aWNreVJvd3NTdHlsaW5nKCkge1xuICAgICAgICBjb25zdCBzdGlja3lSb3dzID0gbm9kZXNUb0FycmF5KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5rLWdyaWQtcm93LXN0aWNreScpKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc3RpY2t5Um93cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBhY2N1bXVsYXRlZEhlaWdodCA9IDA7XG4gICAgICAgICAgICBjb25zdCBzdGlja3lSb3dzT2Zmc2V0cyA9IFtdO1xuICAgICAgICAgICAgc3RpY2t5Um93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93SGVpZ2h0ID0gcm93LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgICAgICBzdGlja3lSb3dzT2Zmc2V0cy5wdXNoKHsgYWNjdW11bGF0ZWRIZWlnaHQsIHJvd0hlaWdodCB9KTtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZEhlaWdodCArPSByb3dIZWlnaHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0aWNreVJvd3MuZm9yRWFjaCgocm93LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUocm93LCAndG9wJywgYCR7c3RpY2t5Um93c09mZnNldHNbaW5kZXhdLmFjY3VtdWxhdGVkSGVpZ2h0fXB4YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShyb3csICdib3R0b20nLCBgJHthY2N1bXVsYXRlZEhlaWdodCAtIHN0aWNreVJvd3NPZmZzZXRzW2luZGV4XS5hY2N1bXVsYXRlZEhlaWdodCAtIHN0aWNreVJvd3NPZmZzZXRzW2luZGV4XS5yb3dIZWlnaHR9cHhgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWxsQ29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3Vwc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGV0YWlsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcImRldGFpbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOb1JlY29yZHNUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIFRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUsIFwibm9SZWNvcmRzVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcInNraXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcIm5vUmVjb3Jkc1RleHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcImlzTG9ja2VkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0xvYWRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcImlzVmlydHVhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxMb2FkaW5nVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcInNraXBHcm91cERlY29yYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcm91cEZvb3RlcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUsIFwibG9ja2VkQ29sdW1uc0NvdW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcInRvdGFsQ29sdW1uc0NvdW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXJ0dWFsQ29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcInRyYWNrQnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3dTdGlja3lcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3dDbGFzc1wiLCB2b2lkIDApO1xuVGFibGVCb2R5Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkVGFibGVCb2R5XScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVkaXRTZXJ2aWNlLmhhc05ld0l0ZW1cIj5cbiAgICAgICAgPHRyIGNsYXNzPVwiay1ncmlkLWFkZC1yb3cgay1ncmlkLWVkaXQtcm93XCJcbiAgICAgICAgICAgIGtlbmRvR3JpZExvZ2ljYWxSb3dcbiAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImFkZFJvd0xvZ2ljYWxJbmRleCgpXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbFNsYXZlUm93XT1cImxvY2tlZENvbHVtbnNDb3VudCA+IDBcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsQ2VsbHNDb3VudF09XCJjb2x1bW5zLmxlbmd0aFwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZUNlbGxzQ291bnRdPVwidW5sb2NrZWRDb2x1bW5zQ291bnRcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhc2tpcEdyb3VwRGVjb3JhdGlvblwiPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cImstZ3JvdXAtY2VsbFwiICpuZ0Zvcj1cImxldCBnIG9mIGdyb3Vwc1wiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L3RkPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImstaGllcmFyY2h5LWNlbGxcIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwiZGV0YWlsVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICBrZW5kb0dyaWRMb2dpY2FsQ2VsbFxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImFkZFJvd0xvZ2ljYWxJbmRleCgpXCJcbiAgICAgICAgICAgICAgICAgICAgW2xvZ2ljYWxDb2xJbmRleF09XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgY29sdW1uczsgbGV0IGNvbHVtbkluZGV4ID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlDb2x1bW5zO1wiXG4gICAgICAgICAgICAgICAga2VuZG9HcmlkQ2VsbFxuICAgICAgICAgICAgICAgICAgICBbcm93SW5kZXhdPVwiLTFcIlxuICAgICAgICAgICAgICAgICAgICBbY29sdW1uSW5kZXhdPVwibG9ja2VkQ29sdW1uc0NvdW50ICsgY29sdW1uSW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICBbaXNOZXddPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgW2RhdGFJdGVtXT1cIm5ld0RhdGFJdGVtXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1ncmlkLWNvbnRlbnQtc3RpY2t5XT1cImNvbHVtbi5zdGlja3lcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cImNvbHVtbi5jc3NDbGFzc1wiXG4gICAgICAgICAgICAgICAgW3N0eWxlLmxlZnRdPVwiY29sdW1uLnN0aWNreSA/ICcwJyA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPVwiY29sdW1uLnN0aWNreSA/IGFkZFN0aWNreUNvbHVtblN0eWxlcyhjb2x1bW4pIDogY29sdW1uLnN0eWxlXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5jb2xzcGFuXT1cImNvbHVtbi5jb2xzcGFuXCJcbiAgICAgICAgICAgICAgICBrZW5kb0dyaWRMb2dpY2FsQ2VsbFxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImFkZFJvd0xvZ2ljYWxJbmRleCgpXCJcbiAgICAgICAgICAgICAgICAgICAgW2xvZ2ljYWxDb2xJbmRleF09XCJsb2dpY2FsQ29sSW5kZXgoY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2xTcGFuXT1cImNvbHVtbi5jb2xzcGFuXCJcbiAgICAgICAgICAgICAgICByb2xlPVwiZ3JpZGNlbGxcIj5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvdHI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8dHIgKm5nSWY9XCJkYXRhPy5sZW5ndGggPT09IDAgfHwgZGF0YSA9PSBudWxsXCIgY2xhc3M9XCJrLWdyaWQtbm9yZWNvcmRzXCI+XG4gICAgICAgIDx0ZCBbYXR0ci5jb2xzcGFuXT1cImNvbFNwYW5cIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgIFtuZ0lmXT1cIm5vUmVjb3Jkc1RlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiBub1JlY29yZHNUZW1wbGF0ZT8udGVtcGxhdGVSZWZcbiAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhbm9SZWNvcmRzVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCI+XG4gICAgICAgICAgICAgICAge3tub1JlY29yZHNUZXh0fX1cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3RkPlxuICAgIDwvdHI+XG5cbiAgICA8bmctdGVtcGxhdGUgbmdGb3JcbiAgICAgICAgW25nRm9yT2ZdPVwiZGF0YVwiXG4gICAgICAgIFtuZ0ZvclRyYWNrQnldPVwidHJhY2tCeVdyYXBwZXJcIlxuICAgICAgICBsZXQtaXRlbVxuICAgICAgICBsZXQtcm93SW5kZXg9XCJpbmRleFwiPlxuICAgICAgICA8dHIgKm5nSWY9XCJpc0dyb3VwKGl0ZW0pICYmIGlzUGFyZW50R3JvdXBFeHBhbmRlZChpdGVtKSAmJiBzaG93R3JvdXBIZWFkZXIoaXRlbSlcIlxuICAgICAgICAgICAga2VuZG9HcmlkR3JvdXBIZWFkZXJcbiAgICAgICAgICAgICAgICBbY29sdW1uc109XCJjb2x1bW5zXCJcbiAgICAgICAgICAgICAgICBbZ3JvdXBzXT1cImdyb3Vwc1wiXG4gICAgICAgICAgICAgICAgW2l0ZW1dPVwiaXRlbVwiXG4gICAgICAgICAgICAgICAgW2hhc0RldGFpbHNdPVwiZGV0YWlsVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICBbc2tpcEdyb3VwRGVjb3JhdGlvbl09XCJza2lwR3JvdXBEZWNvcmF0aW9uXCJcbiAgICAgICAgICAgICAgICBbaGFzR3JvdXBIZWFkZXJDb2x1bW5dPVwiaGFzR3JvdXBIZWFkZXJDb2x1bW5cIlxuICAgICAgICAgICAgICAgIFtncm91cEhlYWRlckNvbHVtbnNdPVwiZ3JvdXBIZWFkZXJDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICBbcm93SW5kZXhdPVwicm93SW5kZXggKyAxXCJcbiAgICAgICAgICAgICAgICBbdG90YWxDb2x1bW5zQ291bnRdPVwidG90YWxDb2x1bW5zQ291bnRcIlxuICAgICAgICAgICAga2VuZG9HcmlkTG9naWNhbFJvd1xuICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibG9naWNhbFJvd0luZGV4KHJvd0luZGV4KVwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZVJvd109XCJsb2NrZWRDb2x1bW5zQ291bnQgPiAwXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbENlbGxzQ291bnRdPVwiY29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVDZWxsc0NvdW50XT1cImdyb3VwSGVhZGVyU2xhdmVDZWxsc0NvdW50XCI+XG4gICAgICAgIDwvdHI+XG4gICAgICAgIDx0clxuICAgICAgICAgICAgKm5nSWY9XCJpc0RhdGFJdGVtKGl0ZW0pICYmICghaXRlbS5ncm91cCB8fCBpc0RhdGFJdGVtSW5FeHBhbmRlZEdyb3VwKGl0ZW0pKVwiXG4gICAgICAgICAgICBrZW5kb0dyaWRMb2dpY2FsUm93XG4gICAgICAgICAgICAgICAgW2RhdGFSb3dJbmRleF09XCJpdGVtLmluZGV4XCJcbiAgICAgICAgICAgICAgICBbZGF0YUl0ZW1dPVwiaXRlbS5kYXRhXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImxvZ2ljYWxSb3dJbmRleChyb3dJbmRleClcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVSb3ddPVwibG9ja2VkQ29sdW1uc0NvdW50ID4gMFwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxDZWxsc0NvdW50XT1cImNvbHVtbnMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbFNsYXZlQ2VsbHNDb3VudF09XCJ1bmxvY2tlZENvbHVtbnNDb3VudFwiXG4gICAgICAgICAgICBbY2xhc3Muay1ncmlkLXJvdy1zdGlja3ldPVwicm93U3RpY2t5ID8gcm93U3RpY2t5KHsgZGF0YUl0ZW06IGl0ZW0uZGF0YSwgaW5kZXg6IGl0ZW0uaW5kZXggfSkgOiBmYWxzZVwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJyb3dDbGFzcyh7IGRhdGFJdGVtOiBpdGVtLmRhdGEsIGluZGV4OiBpdGVtLmluZGV4IH0pXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLWFsdF09XCJpc09kZChpdGVtKVwiXG4gICAgICAgICAgICBbY2xhc3Muay1tYXN0ZXItcm93XT1cImRldGFpbFRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICBbY2xhc3Muay1ncmlkLWVkaXQtcm93XT1cImlzRWRpdGluZ1JvdyhpdGVtLmluZGV4KVwiXG4gICAgICAgICAgICBbYXR0ci5kYXRhLWtlbmRvLWdyaWQtaXRlbS1pbmRleF09XCJpdGVtLmluZGV4XCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLXNlbGVjdGVkXT1cImlzU2VsZWN0YWJsZSgpICYmIGlzUm93U2VsZWN0ZWQoaXRlbSlcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhc2tpcEdyb3VwRGVjb3JhdGlvblwiPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cImstZ3JvdXAtY2VsbFwiICpuZ0Zvcj1cImxldCBnIG9mIGdyb3Vwc1wiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L3RkPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImstaGllcmFyY2h5LWNlbGxcIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwiZGV0YWlsVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICBrZW5kb0dyaWRMb2dpY2FsQ2VsbFxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImxvZ2ljYWxSb3dJbmRleChyb3dJbmRleClcIlxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbENvbEluZGV4XT1cIjBcIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YVJvd0luZGV4XT1cIml0ZW0uaW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YUl0ZW1dPVwiaXRlbS5kYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbEV4cGFuZENlbGxdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwiay1pY29uXCJcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJkZXRhaWxUZW1wbGF0ZS5zaG93SWYoaXRlbS5kYXRhLCBpdGVtLmluZGV4KVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cImRldGFpbEJ1dHRvblN0eWxlcyhpdGVtKVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImRldGFpbEJ1dHRvblRpdGxlKGl0ZW0pXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJkZXRhaWxCdXR0b25UaXRsZShpdGVtKVwiXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCIjXCIgdGFiaW5kZXg9XCItMVwiIChjbGljayk9XCJ0b2dnbGVSb3coaXRlbS5pbmRleCwgaXRlbS5kYXRhKVwiPjwvYT5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgICBrZW5kb0dyaWRDZWxsXG4gICAgICAgICAgICAgICAgICAgIFtyb3dJbmRleF09XCJpdGVtLmluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbkluZGV4XT1cImxvY2tlZENvbHVtbnNDb3VudCArIGNvbHVtbkluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1rZW5kby1ncmlkLWNvbHVtbi1pbmRleF09XCJsb2NrZWRDb2x1bW5zQ291bnQgKyBjb2x1bW5JbmRleFwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgW2RhdGFJdGVtXT1cIml0ZW0uZGF0YVwiXG4gICAgICAgICAgICAgICAgICAgIFtpc0xvYWRpbmddPVwiaXNMb2FkaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgW2lzVmlydHVhbF09XCJpc1ZpcnR1YWxcIlxuICAgICAgICAgICAgICAgICAgICBbbG9hZGluZ1RlbXBsYXRlXT1cImNlbGxMb2FkaW5nVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIGtlbmRvR3JpZExvZ2ljYWxDZWxsXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibG9naWNhbFJvd0luZGV4KHJvd0luZGV4KVwiXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsQ29sSW5kZXhdPVwibG9naWNhbENvbEluZGV4KGNvbHVtbilcIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YVJvd0luZGV4XT1cIml0ZW0uaW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YUl0ZW1dPVwiaXRlbS5kYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbEluZGV4XT1cImNvbHVtbkluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbFNwYW5dPVwiY29sdW1uLmNvbHNwYW5cIlxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiZ3JpZGNlbGxcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cImlzU2VsZWN0YWJsZSgpID8gaXNBcmlhU2VsZWN0ZWQoaXRlbSwgY29sdW1uKSA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLWdyaWQtY29udGVudC1zdGlja3ldPVwiY29sdW1uLnN0aWNreVwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLXRvdWNoLWFjdGlvbi1ub25lXT1cImlzU2VsZWN0YWJsZSgpICYmICRhbnkoc2VsZWN0YWJsZSkuZHJhZ1wiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLXRvdWNoLWFjdGlvbi1hdXRvXT1cIiEoaXNTZWxlY3RhYmxlKCkgJiYgJGFueShzZWxlY3RhYmxlKS5kcmFnKVwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiY29sdW1uLmNzc0NsYXNzXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1ncmlkLWVkaXQtY2VsbF09XCJpc0VkaXRpbmdDZWxsKGl0ZW0uaW5kZXgsIGNvbHVtbilcIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNvbHVtbi5zdGlja3kgPyBhZGRTdGlja3lDb2x1bW5TdHlsZXMoY29sdW1uKSA6IGNvbHVtbi5zdHlsZVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuY29sc3Bhbl09XCJjb2x1bW4uY29sc3BhblwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RhdGUtc2VsZWN0ZWRdPVwiaXNTZWxlY3RhYmxlICYmIGNlbGxTZWxlY3Rpb25TZXJ2aWNlLmlzQ2VsbFNlbGVjdGVkKGl0ZW0sIGNvbHVtbilcIlxuICAgICAgICAgICAgICAgICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgY29sdW1uczsgbGV0IGNvbHVtbkluZGV4ID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlDb2x1bW5zO1wiPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgPC90cj5cbiAgICAgICAgPHRyICpuZ0lmPVwiaXNEYXRhSXRlbShpdGVtKSAmJlxuICAgICAgICAgICAgICAgICghaXRlbS5ncm91cCB8fCBpc0RhdGFJdGVtSW5FeHBhbmRlZEdyb3VwKGl0ZW0pKSAmJlxuICAgICAgICAgICAgICAgIGRldGFpbFRlbXBsYXRlPy50ZW1wbGF0ZVJlZiAmJlxuICAgICAgICAgICAgICAgIGRldGFpbFRlbXBsYXRlLnNob3dJZihpdGVtLmRhdGEsIGl0ZW0uaW5kZXgpICYmXG4gICAgICAgICAgICAgICAgaXNFeHBhbmRlZChpdGVtKVwiXG4gICAgICAgICAgICBjbGFzcz1cImstZGV0YWlsLXJvd1wiXG4gICAgICAgICAgICBbY2xhc3Muay1hbHRdPVwiaXNPZGQoaXRlbSlcIlxuICAgICAgICAgICAga2VuZG9HcmlkTG9naWNhbFJvd1xuICAgICAgICAgICAgICAgIFtkYXRhUm93SW5kZXhdPVwiaXRlbS5pbmRleFwiXG4gICAgICAgICAgICAgICAgW2RhdGFJdGVtXT1cIml0ZW0uZGF0YVwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxSb3dJbmRleF09XCJsb2dpY2FsUm93SW5kZXgocm93SW5kZXgpICsgMVwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZVJvd109XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxDZWxsc0NvdW50XT1cIjFcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiay1ncm91cC1jZWxsXCIgKm5nRm9yPVwibGV0IGcgb2YgZ3JvdXBzXCI+PC90ZD5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImstaGllcmFyY2h5LWNlbGxcIj48L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiay1kZXRhaWwtY2VsbFwiXG4gICAgICAgICAgICAgICAgW2F0dHIuY29sc3Bhbl09XCJjb2x1bW5zU3BhblwiXG4gICAgICAgICAgICAgICAga2VuZG9HcmlkTG9naWNhbENlbGxcbiAgICAgICAgICAgICAgICAgICAgW2xvZ2ljYWxSb3dJbmRleF09XCJsb2dpY2FsUm93SW5kZXgocm93SW5kZXgpICsgMVwiXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsQ29sSW5kZXhdPVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIFtkYXRhUm93SW5kZXhdPVwiaXRlbS5pbmRleFwiXG4gICAgICAgICAgICAgICAgICAgIFtkYXRhSXRlbV09XCJpdGVtLmRhdGFcIlxuICAgICAgICAgICAgICAgICAgICBbY29sSW5kZXhdPVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2xTcGFuXT1cImFsbENvbHVtbnNTcGFuICsgMVwiXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJncmlkY2VsbFwiIGFyaWEtc2VsZWN0ZWQ9XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJkZXRhaWxUZW1wbGF0ZS50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbTogaXRlbS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg6IGl0ZW0uaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGl0ZW0uZGF0YVxuICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvdHI+XG4gICAgICAgIDx0ciAqbmdJZj1cImlzRm9vdGVyKGl0ZW0pICYmXG4gICAgICAgICAgICAgICAgaXRlbS5ncm91cCAmJlxuICAgICAgICAgICAgICAgIChpc0Zvb3Rlckl0ZW1JbkV4cGFuZGVkR3JvdXAoaXRlbSkgfHwgKHNob3dHcm91cEZvb3RlcnMgJiYgaXNQYXJlbnRHcm91cEV4cGFuZGVkKGl0ZW0uZ3JvdXApKSkgJiZcbiAgICAgICAgICAgICAgICAhaXRlbS5kYXRhLmhpZGVGb290ZXJcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWdyb3VwLWZvb3RlclwiXG4gICAgICAgICAgICBrZW5kb0dyaWRMb2dpY2FsUm93XG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxSb3dJbmRleF09XCJsb2dpY2FsUm93SW5kZXgocm93SW5kZXgpXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbFNsYXZlUm93XT1cImxvY2tlZENvbHVtbnNDb3VudCA+IDBcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsQ2VsbHNDb3VudF09XCJjb2x1bW5zLmxlbmd0aFwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZUNlbGxzQ291bnRdPVwidW5sb2NrZWRDb2x1bW5zQ291bnRcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhc2tpcEdyb3VwRGVjb3JhdGlvblwiPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cImstZ3JvdXAtY2VsbFwiICpuZ0Zvcj1cImxldCBnIG9mIGdyb3Vwc1wiPjwvdGQ+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiay1oaWVyYXJjaHktY2VsbFwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJkZXRhaWxUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgIGtlbmRvR3JpZExvZ2ljYWxDZWxsXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibG9naWNhbFJvd0luZGV4KHJvd0luZGV4KVwiXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsQ29sSW5kZXhdPVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZCBrZW5kb0dyaWRMb2dpY2FsQ2VsbFxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImxvZ2ljYWxSb3dJbmRleChyb3dJbmRleClcIlxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbENvbEluZGV4XT1cImxvZ2ljYWxDb2xJbmRleChjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXNraXBdPVwic2tpcEdyb3VwRGVjb3JhdGlvblwiXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBmb290ZXJDb2x1bW5zOyBsZXQgY29sdW1uSW5kZXggPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeUNvbHVtbnM7XCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGNvbHVtbi5ncm91cEZvb3RlclRlbXBsYXRlUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGl0ZW0uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBjb2x1bW4uZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZXM6IGl0ZW0uZGF0YT8uYWdncmVnYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogaXRlbS5kYXRhPy5hZ2dyZWdhdGVzXG4gICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICA8L3RyPlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKm5nSWY9XCJyb3dTdGlja3lcIiAocmVzaXplKT1cInJlc2l6ZUhhbmRsZXIoKVwiPjwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEZXRhaWxzU2VydmljZSxcbiAgICAgICAgR3JvdXBzU2VydmljZSxcbiAgICAgICAgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgRWRpdFNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBEb21FdmVudHNTZXJ2aWNlLFxuICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBDZWxsU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgQ29sdW1uSW5mb1NlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlXSlcbl0sIFRhYmxlQm9keUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ2VsbENvbXBvbmVudCA9IGNsYXNzIENlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRTZXJ2aWNlLCBpZFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UsIGNlbGxDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UgPSBlZGl0U2VydmljZTtcbiAgICAgICAgdGhpcy5pZFNlcnZpY2UgPSBpZFNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2VsbENvbnRleHQgPSBjZWxsQ29udGV4dDtcbiAgICAgICAgdGhpcy5pc05ldyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVmlydHVhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbnRleHQgPSB7fTtcbiAgICAgICAgdGhpcy5fZWRpdFRlbXBsYXRlQ29udGV4dCA9IHt9O1xuICAgIH1cbiAgICBnZXQgY29tbWFuZENlbGxDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDb21tYW5kKHRoaXMuY29sdW1uKTtcbiAgICB9XG4gICAgc2V0IHJvd0luZGV4KGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3Jvd0luZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudXBkYXRlQ2VsbENvbnRleHQoKTtcbiAgICB9XG4gICAgZ2V0IHJvd0luZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm93SW5kZXg7XG4gICAgfVxuICAgIGdldCBpc0VkaXRlZCgpIHtcbiAgICAgICAgaWYgKCEodGhpcy5lZGl0U2VydmljZS5pc0VkaXRpbmcoKSB8fCB0aGlzLmlzTmV3KSB8fCAhdGhpcy5pc0NvbHVtbkVkaXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRpdENvbnRleHQgPSB0aGlzLmVkaXRTZXJ2aWNlLmNvbHVtbkNvbnRleHQodGhpcy5yb3dJbmRleCwgdGhpcy5jb2x1bW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpZWxkRWRpdGFibGUoZWRpdENvbnRleHQsIHRoaXMuY29sdW1uKTtcbiAgICB9XG4gICAgZ2V0IHNob3dMb2FkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZpcnR1YWwgJiYgdGhpcy5pc0xvYWRpbmc7XG4gICAgfVxuICAgIGdldCBmb3JtR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRTZXJ2aWNlLmNvbnRleHQodGhpcy5yb3dJbmRleCkuZ3JvdXA7XG4gICAgfVxuICAgIGdldCB0ZW1wbGF0ZUNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZUNvbnRleHQ7XG4gICAgfVxuICAgIGdldCBlZGl0VGVtcGxhdGVDb250ZXh0KCkge1xuICAgICAgICB0aGlzLl9lZGl0VGVtcGxhdGVDb250ZXh0LiRpbXBsaWNpdCA9IHRoaXMuZm9ybUdyb3VwO1xuICAgICAgICB0aGlzLl9lZGl0VGVtcGxhdGVDb250ZXh0LmlzTmV3ID0gdGhpcy5pc05ldztcbiAgICAgICAgdGhpcy5fZWRpdFRlbXBsYXRlQ29udGV4dC5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdGhpcy5fZWRpdFRlbXBsYXRlQ29udGV4dC5kYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW07XG4gICAgICAgIHRoaXMuX2VkaXRUZW1wbGF0ZUNvbnRleHQuZm9ybUdyb3VwID0gdGhpcy5mb3JtR3JvdXA7XG4gICAgICAgIHRoaXMuX2VkaXRUZW1wbGF0ZUNvbnRleHQucm93SW5kZXggPSB0aGlzLnJvd0luZGV4O1xuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdFRlbXBsYXRlQ29udGV4dDtcbiAgICB9XG4gICAgZ2V0IGZvcm1hdCgpIHtcbiAgICAgICAgaWYgKGlzQ29sdW1uQ29tcG9uZW50KHRoaXMuY29sdW1uKSAmJiAhaXNOdWxsT3JFbXB0eVN0cmluZyh0aGlzLmNvbHVtbi5mb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmFjdEZvcm1hdCh0aGlzLmNvbHVtbi5mb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBpc0JvdW5kQ29sdW1uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW4uZmllbGQgJiYgIXRoaXMuY29sdW1uLnRlbXBsYXRlUmVmO1xuICAgIH1cbiAgICBnZXQgaXNDaGVja2JveENvbHVtbigpIHtcbiAgICAgICAgcmV0dXJuIGlzQ2hlY2tib3hDb2x1bW4odGhpcy5jb2x1bW4pICYmICF0aGlzLmNvbHVtbi50ZW1wbGF0ZVJlZjtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGlvbkNoZWNrYm94SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkU2VydmljZS5zZWxlY3Rpb25DaGVja2JveElkKHRoaXMucm93SW5kZXgpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0aW9uQ2hlY2tib3hMYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ3NlbGVjdGlvbkNoZWNrYm94TGFiZWwnKTtcbiAgICB9XG4gICAgZ2V0IGlzU3BhbkNvbHVtbigpIHtcbiAgICAgICAgcmV0dXJuIGlzU3BhbkNvbHVtbih0aGlzLmNvbHVtbikgJiYgIXRoaXMuY29sdW1uLnRlbXBsYXRlUmVmO1xuICAgIH1cbiAgICBnZXQgY2hpbGRDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gY29sdW1uc1RvUmVuZGVyKFt0aGlzLmNvbHVtbl0pO1xuICAgIH1cbiAgICBnZXQgaXNDb2x1bW5FZGl0YWJsZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbiB8fCB0aGlzLmlzQ29tbWFuZCh0aGlzLmNvbHVtbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW4uZWRpdGFibGUgIT09IGZhbHNlO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2VsbENvbnRleHQoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoX2NoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZW1wbGF0ZUNvbnRleHQoKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlQ29udGV4dCgpO1xuICAgIH1cbiAgICBpc0NvbW1hbmQoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW4gaW5zdGFuY2VvZiBDb21tYW5kQ29sdW1uQ29tcG9uZW50O1xuICAgIH1cbiAgICBpc0ZpZWxkRWRpdGFibGUoZWRpdENvbnRleHQsIGNvbHVtbikge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChlZGl0Q29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbHVtbi5lZGl0VGVtcGxhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNQcmVzZW50KGVkaXRDb250ZXh0Lmdyb3VwKSAmJiBpc1ByZXNlbnQoZWRpdENvbnRleHQuZ3JvdXAuZ2V0KGNvbHVtbi5maWVsZCkpO1xuICAgIH1cbiAgICB1cGRhdGVDZWxsQ29udGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbENvbnRleHQucm93SW5kZXggPSB0aGlzLl9yb3dJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVUZW1wbGF0ZUNvbnRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW4udGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fdGVtcGxhdGVDb250ZXh0O1xuICAgICAgICBjb250ZXh0LmlzTmV3ID0gdGhpcy5pc05ldztcbiAgICAgICAgY29udGV4dC5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICAgICAgY29udGV4dC5kYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW07XG4gICAgICAgIGNvbnRleHQucm93SW5kZXggPSB0aGlzLnJvd0luZGV4O1xuICAgICAgICBjb250ZXh0LmNvbHVtbkluZGV4ID0gdGhpcy5jb2x1bW5JbmRleDtcbiAgICAgICAgY29udGV4dC4kaW1wbGljaXQgPSB0aGlzLmRhdGFJdGVtO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jb21tYW5kLWNlbGwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29tbWFuZENlbGxDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uSW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc05ld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImlzTG9hZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImlzVmlydHVhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsb2FkaW5nVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwicm93SW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhSXRlbVwiLCB2b2lkIDApO1xuQ2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZENlbGxdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwiaXNFZGl0ZWRcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cImZhbHNlXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFzaG93TG9hZGluZzsgZWxzZSBsb2FkaW5nXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJjb2x1bW4udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sdW1uLnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ0ZW1wbGF0ZUNvbnRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzU3BhbkNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jaGlsZENvbHVtbiBbbmdGb3JPZl09XCJjaGlsZENvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyBkYXRhSXRlbSB8IHZhbHVlT2Y6IGNoaWxkQ29sdW1uLmZpZWxkOiBjaGlsZENvbHVtbi5mb3JtYXR9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzQm91bmRDb2x1bW5cIj57eyBkYXRhSXRlbSB8IHZhbHVlT2Y6IGNvbHVtbi5maWVsZDogY29sdW1uLmZvcm1hdH19PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzQ2hlY2tib3hDb2x1bW4gJiYgIWlzTmV3XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstY2hlY2tib3ggay1jaGVja2JveC1tZCBrLXJvdW5kZWQtbWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtrZW5kb0dyaWRTZWxlY3Rpb25DaGVja2JveF09XCJyb3dJbmRleFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuaWRdPVwic2VsZWN0aW9uQ2hlY2tib3hJZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJzZWxlY3Rpb25DaGVja2JveExhYmVsXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2xvYWRpbmc+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJsb2FkaW5nVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwibG9hZGluZ1RlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBjb2x1bW59XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XCIhbG9hZGluZ1RlbXBsYXRlXCIgY2xhc3M9XCJrLXNrZWxldG9uLXRleHQgay1za2VsZXRvblwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cInRydWVcIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJjb2x1bW4uZWRpdFRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sdW1uLmVkaXRUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJlZGl0VGVtcGxhdGVDb250ZXh0XCI+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJjb2x1bW4uZWRpdG9yXCIgKm5nSWY9XCIhY29sdW1uLmVkaXRUZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgICAgICAgICA8a2VuZG8tbnVtZXJpY3RleHRib3hcbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ1N3aXRjaENhc2U9XCInbnVtZXJpYydcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Zvcm1Db250cm9sXT1cImZvcm1Hcm91cC5nZXQoY29sdW1uLmZpZWxkKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBrZW5kb0dyaWRGb2N1c2FibGVcbiAgICAgICAgICAgICAgICAgICAgPjwva2VuZG8tbnVtZXJpY3RleHRib3g+XG5cbiAgICAgICAgICAgICAgICAgICAgPGtlbmRvLWRhdGVwaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ1N3aXRjaENhc2U9XCInZGF0ZSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Zvcm1Db250cm9sXT1cImZvcm1Hcm91cC5nZXQoY29sdW1uLmZpZWxkKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBrZW5kb0dyaWRGb2N1c2FibGVcbiAgICAgICAgICAgICAgICAgICAgPjwva2VuZG8tZGF0ZXBpY2tlcj5cblxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ1N3aXRjaENhc2U9XCInYm9vbGVhbidcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1jaGVja2JveCBrLWNoZWNrYm94LW1kIGstcm91bmRlZC1tZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZm9ybUNvbnRyb2xdPVwiZm9ybUdyb3VwLmdldChjb2x1bW4uZmllbGQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlbmRvR3JpZEZvY3VzYWJsZVxuICAgICAgICAgICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nU3dpdGNoRGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLXRleHRib3ggay1pbnB1dCBrLXJvdW5kZWQtbWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Zvcm1Db250cm9sXT1cImZvcm1Hcm91cC5nZXQoY29sdW1uLmZpZWxkKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBrZW5kb0dyaWRGb2N1c2FibGVcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgfSksXG4gICAgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBJbmplY3QoQ0VMTF9DT05URVhUKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFZGl0U2VydmljZSxcbiAgICAgICAgSWRTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLCBPYmplY3RdKVxuXSwgQ2VsbENvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYGVkaXRgIGNvbW1hbmQgb2YgdGhlIEdyaWQuIFlvdSBjYW4gYXBwbHkgdGhpcyBkaXJlY3RpdmUgdG8gYW55IGBidXR0b25gXG4gKiBlbGVtZW50IGluc2lkZSBhIFtDb21tYW5kQ29sdW1uQ29tcG9uZW50XSh7JSBzbHVnIGFwaV9ncmlkX2NvbW1hbmRjb2x1bW5jb21wb25lbnQgJX0pLlxuICogV2hlbiBhbiBhc3NvY2lhdGVkIGJ1dHRvbiB3aXRoIHRoZSBkaXJlY3RpdmUgaXMgY2xpY2tlZCwgdGhlXG4gKiBbZWRpdF0oeyUgc2x1ZyBhcGlfZ3JpZF9ncmlkY29tcG9uZW50ICV9I3RvYy1lZGl0KSBldmVudFxuICogaXMgdHJpZ2dlcmVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ19ncmlkICV9KSkuXG4gKlxuICogPiBXaGVuIHRoZSByb3cgaXMgaW4gdGhlIGVkaXQgbW9kZSwgdGhlIGJ1dHRvbiB3aXRoIGBrZW5kb0dyaWRFZGl0Q29tbWFuZGAgaXMgYXV0b21hdGljYWxseSBoaWRkZW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tZ3JpZD5cbiAqICAgPGtlbmRvLWdyaWQtY29tbWFuZC1jb2x1bW4gdGl0bGU9XCJjb21tYW5kXCI+XG4gKiAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENlbGxUZW1wbGF0ZT5cbiAqICAgICAgIDxidXR0b24ga2VuZG9HcmlkRWRpdENvbW1hbmQgY2xhc3M9XCJrLXByaW1hcnlcIj5FZGl0PC9idXR0b24+XG4gKiAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgPC9rZW5kby1ncmlkLWNvbW1hbmQtY29sdW1uPlxuICogPC9rZW5kby1ncmlkPlxuICogYGBgXG4gKlxuICovXG5sZXQgRWRpdENvbW1hbmREaXJlY3RpdmUgPSBjbGFzcyBFZGl0Q29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJ1dHRvbiB7XG4gICAgY29uc3RydWN0b3IoZWRpdFNlcnZpY2UsIGNlbGxDb250ZXh0LCBlbGVtZW50LCByZW5kZXJlciwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudCwgcmVuZGVyZXIsIG51bGwsIGxvY2FsaXphdGlvbiwgbmdab25lKTtcbiAgICAgICAgdGhpcy5lZGl0U2VydmljZSA9IGVkaXRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNlbGxDb250ZXh0ID0gY2VsbENvbnRleHQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbW1hbmRDbGFzcyA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFZGl0ZWQgPyAnbm9uZScgOiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ2xpY2soZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuYmVnaW5FZGl0KHRoaXMucm93SW5kZXgpO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnJvd0luZGV4ID0gdGhpcy5jZWxsQ29udGV4dC5yb3dJbmRleDtcbiAgICAgICAgICAgIHRoaXMuaXNFZGl0ZWQgPSB0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGVkKHRoaXMucm93SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5kaXNwbGF5JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRWRpdENvbW1hbmREaXJlY3RpdmUucHJvdG90eXBlLCBcInZpc2libGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1ncmlkLWVkaXQtY29tbWFuZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRWRpdENvbW1hbmREaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbW1hbmRDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgRWRpdENvbW1hbmREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XG5FZGl0Q29tbWFuZERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZEVkaXRDb21tYW5kXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDEsIEluamVjdChDRUxMX0NPTlRFWFQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VkaXRTZXJ2aWNlLCBPYmplY3QsIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgTmdab25lXSlcbl0sIEVkaXRDb21tYW5kRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgY2FuY2VsYCBjb21tYW5kIG9mIHRoZSBHcmlkLiBZb3UgY2FuIGFwcGx5IHRoaXMgZGlyZWN0aXZlIHRvIGFueSBgYnV0dG9uYFxuICogZWxlbWVudCBpbnNpZGUgYSBbQ29tbWFuZENvbHVtbkNvbXBvbmVudF0oeyUgc2x1ZyBhcGlfZ3JpZF9jb21tYW5kY29sdW1uY29tcG9uZW50ICV9KS5cbiAqIFdoZW4gYW4gYXNzb2NpYXRlZCBidXR0b24gd2l0aCB0aGUgZGlyZWN0aXZlIGlzIGNsaWNrZWQsIHRoZVxuICogW2NhbmNlbF0oeyUgc2x1ZyBhcGlfZ3JpZF9ncmlkY29tcG9uZW50ICV9I3RvYy1jYW5jZWwpIGV2ZW50XG4gKiBpcyB0cmlnZ2VyZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX2dyaWQgJX0pKS5cbiAqXG4gKiA+IFdoZW4gdGhlIHJvdyBpcyBub3QgaW4gdGhlIGVkaXQgbW9kZSwgdGhlIGJ1dHRvbiB3aXRoIHRoZSBga2VuZG9HcmlkQ2FuY2VsQ29tbWFuZGAgaXMgYXV0b21hdGljYWxseSBoaWRkZW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tZ3JpZD5cbiAqICAgPGtlbmRvLWdyaWQtY29tbWFuZC1jb2x1bW4gdGl0bGU9XCJjb21tYW5kXCI+XG4gKiAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZENlbGxUZW1wbGF0ZT5cbiAqICAgICAgIDxidXR0b24ga2VuZG9HcmlkQ2FuY2VsQ29tbWFuZD5DYW5jZWwgY2hhbmdlczwvYnV0dG9uPlxuICogICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgIDwva2VuZG8tZ3JpZC1jb21tYW5kLWNvbHVtbj5cbiAqIDwva2VuZG8tZ3JpZD5cbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gY29udHJvbCB0aGUgY29udGVudCBvZiB0aGUgYnV0dG9uIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgcm93LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLWdyaWQ+XG4gKiAgIDxrZW5kby1ncmlkLWNvbW1hbmQtY29sdW1uIHRpdGxlPVwiY29tbWFuZFwiPlxuICogICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDZWxsVGVtcGxhdGUgbGV0LWlzTmV3PVwiaXNOZXdcIj5cbiAqICAgICAgIDxidXR0b24ga2VuZG9HcmlkQ2FuY2VsQ29tbWFuZD57e2lzTmV3ID8gJ0Rpc2NhcmQnIDogJ0NhbmNlbCBjaGFuZ2VzJ319PC9idXR0b24+XG4gKiAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgPC9rZW5kby1ncmlkLWNvbW1hbmQtY29sdW1uPlxuICogPC9rZW5kby1ncmlkPlxuICogYGBgXG4gKi9cbmxldCBDYW5jZWxDb21tYW5kRGlyZWN0aXZlID0gY2xhc3MgQ2FuY2VsQ29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJ1dHRvbiB7XG4gICAgY29uc3RydWN0b3IoZWRpdFNlcnZpY2UsIGNlbGxDb250ZXh0LCBlbGVtZW50LCByZW5kZXJlciwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudCwgcmVuZGVyZXIsIG51bGwsIGxvY2FsaXphdGlvbiwgbmdab25lKTtcbiAgICAgICAgdGhpcy5lZGl0U2VydmljZSA9IGVkaXRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNlbGxDb250ZXh0ID0gY2VsbENvbnRleHQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbW1hbmRDbGFzcyA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRWRpdGVkID8gJ25vbmUnIDogJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5pc0VkaXRlZCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS5lbmRFZGl0KHRoaXMucm93SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucm93SW5kZXggPSB0aGlzLmNlbGxDb250ZXh0LnJvd0luZGV4O1xuICAgICAgICAgICAgdGhpcy5pc0VkaXRlZCA9IHRoaXMuZWRpdFNlcnZpY2UuaXNFZGl0ZWQodGhpcy5yb3dJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLmRpc3BsYXknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDYW5jZWxDb21tYW5kRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZ3JpZC1jYW5jZWwtY29tbWFuZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FuY2VsQ29tbWFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29tbWFuZENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBDYW5jZWxDb21tYW5kRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvbkNsaWNrXCIsIG51bGwpO1xuQ2FuY2VsQ29tbWFuZERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZENhbmNlbENvbW1hbmRdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMSwgSW5qZWN0KENFTExfQ09OVEVYVCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWRpdFNlcnZpY2UsIE9iamVjdCwgRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmVdKVxuXSwgQ2FuY2VsQ29tbWFuZERpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYHNhdmVgIGNvbW1hbmQgb2YgdGhlIEdyaWQuIFlvdSBjYW4gYXBwbHkgdGhpcyBkaXJlY3RpdmUgdG8gYW55IGBidXR0b25gXG4gKiBlbGVtZW50IGluc2lkZSBhIFtDb21tYW5kQ29sdW1uQ29tcG9uZW50XSh7JSBzbHVnIGFwaV9ncmlkX2NvbW1hbmRjb2x1bW5jb21wb25lbnQgJX0pLlxuICogV2hlbiBhbiBhc3NvY2lhdGVkIGJ1dHRvbiB3aXRoIHRoZSBkaXJlY3RpdmUgaXMgY2xpY2tlZCwgdGhlXG4gKiBbc2F2ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9ncmlkY29tcG9uZW50ICV9I3RvYy1zYXZlKSBldmVudFxuICogaXMgdHJpZ2dlcmVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ19ncmlkICV9KSkuXG4gKlxuICogPiBXaGVuIHRoZSByb3cgaXMgbm90IGluIHRoZSBlZGl0IG1vZGUsIHRoZSBidXR0b24gd2l0aCBga2VuZG9HcmlkU2F2ZUNvbW1hbmRgIGlzIGF1dG9tYXRpY2FsbHkgaGlkZGVuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLWdyaWQ+XG4gKiAgIDxrZW5kby1ncmlkLWNvbW1hbmQtY29sdW1uIHRpdGxlPVwiY29tbWFuZFwiPlxuICogICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDZWxsVGVtcGxhdGU+XG4gKiAgICAgICA8YnV0dG9uIGtlbmRvR3JpZFNhdmVDb21tYW5kPlNhdmUgY2hhbmdlczwvYnV0dG9uPlxuICogICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgIDwva2VuZG8tZ3JpZC1jb21tYW5kLWNvbHVtbj5cbiAqIDwva2VuZG8tZ3JpZD5cbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gY29udHJvbCB0aGUgY29udGVudCBvZiB0aGUgYnV0dG9uIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgcm93LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLWdyaWQ+XG4gKiAgIDxrZW5kby1ncmlkLWNvbW1hbmQtY29sdW1uIHRpdGxlPVwiY29tbWFuZFwiPlxuICogICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDZWxsVGVtcGxhdGUgbGV0LWlzTmV3PVwiaXNOZXdcIj5cbiAqICAgICAgIDxidXR0b24ga2VuZG9HcmlkU2F2ZUNvbW1hbmQ+e3tpc05ldyA/ICdBZGQnIDogJ1VwZGF0ZSd9fTwvYnV0dG9uPlxuICogICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgIDwva2VuZG8tZ3JpZC1jb21tYW5kLWNvbHVtbj5cbiAqIDwva2VuZG8tZ3JpZD5cbiAqIGBgYFxuICovXG5sZXQgU2F2ZUNvbW1hbmREaXJlY3RpdmUgPSBjbGFzcyBTYXZlQ29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJ1dHRvbiB7XG4gICAgY29uc3RydWN0b3IoZWRpdFNlcnZpY2UsIGNlbGxDb250ZXh0LCBlbGVtZW50LCByZW5kZXJlciwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudCwgcmVuZGVyZXIsIG51bGwsIGxvY2FsaXphdGlvbiwgbmdab25lKTtcbiAgICAgICAgdGhpcy5lZGl0U2VydmljZSA9IGVkaXRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNlbGxDb250ZXh0ID0gY2VsbENvbnRleHQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbW1hbmRDbGFzcyA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRWRpdGVkID8gJ25vbmUnIDogJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5pc0VkaXRlZCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS5zYXZlKHRoaXMucm93SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucm93SW5kZXggPSB0aGlzLmNlbGxDb250ZXh0LnJvd0luZGV4O1xuICAgICAgICAgICAgdGhpcy5pc0VkaXRlZCA9IHRoaXMuZWRpdFNlcnZpY2UuaXNFZGl0ZWQodGhpcy5yb3dJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLmRpc3BsYXknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBTYXZlQ29tbWFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWdyaWQtc2F2ZS1jb21tYW5kJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTYXZlQ29tbWFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29tbWFuZENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBTYXZlQ29tbWFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcblNhdmVDb21tYW5kRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkU2F2ZUNvbW1hbmRdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMSwgSW5qZWN0KENFTExfQ09OVEVYVCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWRpdFNlcnZpY2UsIE9iamVjdCwgRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmVdKVxuXSwgU2F2ZUNvbW1hbmREaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGByZW1vdmVgIGNvbW1hbmQgb2YgdGhlIEdyaWQuIFlvdSBjYW4gYXBwbHkgdGhpcyBkaXJlY3RpdmUgdG8gYW55IGBidXR0b25gIGVsZW1lbnRcbiAqIGluc2lkZSBhIFtDb21tYW5kQ29sdW1uQ29tcG9uZW50XSh7JSBzbHVnIGFwaV9ncmlkX2NvbW1hbmRjb2x1bW5jb21wb25lbnQgJX0pLlxuICogV2hlbiBhbiBhc3NvY2lhdGVkIGJ1dHRvbiB3aXRoIHRoZSBkaXJlY3RpdmUgaXMgY2xpY2tlZCwgdGhlXG4gKiBbcmVtb3ZlIGV2ZW50XSh7JSBzbHVnIGFwaV9ncmlkX2dyaWRjb21wb25lbnQgJX0jdG9jLXJlbW92ZSlcbiAqIGlzIHRyaWdnZXJlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfcmVhY3RpdmVfZm9ybXNfZ3JpZCAlfSkpLlxuICpcbiAqID4gV2hlbiB0aGUgcm93IGlzIGluIHRoZSBlZGl0IG1vZGUsIHRoZSBidXR0b24gd2l0aCB0aGUgYGtlbmRvR3JpZFJlbW92ZUNvbW1hbmRgIGlzIGF1dG9tYXRpY2FsbHkgaGlkZGVuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLWdyaWQ+XG4gKiAgIDxrZW5kby1ncmlkLWNvbW1hbmQtY29sdW1uIHRpdGxlPVwiY29tbWFuZFwiPlxuICogICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRDZWxsVGVtcGxhdGU+XG4gKiAgICAgICA8YnV0dG9uIGtlbmRvR3JpZFJlbW92ZUNvbW1hbmQ+UmVtb3ZlIHJvdzwvYnV0dG9uPlxuICogICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgIDwva2VuZG8tZ3JpZC1jb21tYW5kLWNvbHVtbj5cbiAqIDwva2VuZG8tZ3JpZD5cbiAqIGBgYFxuICovXG5sZXQgUmVtb3ZlQ29tbWFuZERpcmVjdGl2ZSA9IGNsYXNzIFJlbW92ZUNvbW1hbmREaXJlY3RpdmUgZXh0ZW5kcyBCdXR0b24ge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRTZXJ2aWNlLCBjZWxsQ29udGV4dCwgZWxlbWVudCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnQsIHJlbmRlcmVyLCBudWxsLCBsb2NhbGl6YXRpb24sIG5nWm9uZSk7XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UgPSBlZGl0U2VydmljZTtcbiAgICAgICAgdGhpcy5jZWxsQ29udGV4dCA9IGNlbGxDb250ZXh0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21tYW5kQ2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRWRpdGVkID8gJ25vbmUnIDogJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLnJlbW92ZSh0aGlzLnJvd0luZGV4KTtcbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5yb3dJbmRleCA9IHRoaXMuY2VsbENvbnRleHQucm93SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmlzRWRpdGVkID0gdGhpcy5lZGl0U2VydmljZS5pc0VkaXRlZCh0aGlzLnJvd0luZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUuZGlzcGxheScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFJlbW92ZUNvbW1hbmREaXJlY3RpdmUucHJvdG90eXBlLCBcInZpc2libGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1ncmlkLXJlbW92ZS1jb21tYW5kJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBSZW1vdmVDb21tYW5kRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb21tYW5kQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFJlbW92ZUNvbW1hbmREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XG5SZW1vdmVDb21tYW5kRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9HcmlkUmVtb3ZlQ29tbWFuZF0nXG4gICAgfSksXG4gICAgX19wYXJhbSgxLCBJbmplY3QoQ0VMTF9DT05URVhUKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFZGl0U2VydmljZSwgT2JqZWN0LCBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBSZW1vdmVDb21tYW5kRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb21tYW5kIGZvciBhZGRpbmcgYSBuZXcgaXRlbSB0byB0aGUgR3JpZC4gWW91IGNhbiBhcHBseSB0aGlzIGRpcmVjdGl2ZSB0byBhbnlcbiAqIGBidXR0b25gIGVsZW1lbnQgaW5zaWRlIGEgW1Rvb2xiYXJUZW1wbGF0ZV0oeyUgc2x1ZyBhcGlfZ3JpZF9jb21tYW5kY29sdW1uY29tcG9uZW50ICV9KS5cbiAqIFdoZW4gYW4gYXNzb2NpYXRlZCBidXR0b24gd2l0aCB0aGUgZGlyZWN0aXZlIGlzIGNsaWNrZWQsIHRoZVxuICogW2FkZF0oeyUgc2x1ZyBhcGlfZ3JpZF9ncmlkY29tcG9uZW50ICV9I3RvYy1hZGQpIGV2ZW50IGlzIHRyaWdnZXJlZFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX2dyaWQgJX0pKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbC1uby1ydW5cbiAqIDxrZW5kby1ncmlkPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZFRvb2xiYXJUZW1wbGF0ZT5cbiAqICAgICAgIDxidXR0b24ga2VuZG9HcmlkQWRkQ29tbWFuZD5BZGQgbmV3PC9idXR0b24+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogPC9rZW5kby1ncmlkPlxuICogYGBgXG4gKi9cbmxldCBBZGRDb21tYW5kRGlyZWN0aXZlID0gY2xhc3MgQWRkQ29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJ1dHRvbiB7XG4gICAgY29uc3RydWN0b3IoZWRpdFNlcnZpY2UsIGVsZW1lbnQsIHJlbmRlcmVyLCBsb2NhbGl6YXRpb24sIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihlbGVtZW50LCByZW5kZXJlciwgbnVsbCwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpO1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlID0gZWRpdFNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmJlZ2luQWRkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY29tbWFuZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgQWRkQ29tbWFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWdyaWQtYWRkLWNvbW1hbmQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQWRkQ29tbWFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29tbWFuZENsYXNzXCIsIG51bGwpO1xuQWRkQ29tbWFuZERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZEFkZENvbW1hbmRdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWRpdFNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgTmdab25lXSlcbl0sIEFkZENvbW1hbmREaXJlY3RpdmUpO1xuXG5jb25zdCBleHBvcnRlZCQxID0gW1xuICAgIENvbW1hbmRDb2x1bW5Db21wb25lbnQsXG4gICAgQ2hlY2tib3hDb2x1bW5Db21wb25lbnQsXG4gICAgU2VsZWN0aW9uQ2hlY2tib3hEaXJlY3RpdmUsXG4gICAgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEVkaXRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBUYWJsZUJvZHlDb21wb25lbnQsXG4gICAgTm9SZWNvcmRzVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgQ2VsbENvbXBvbmVudCxcbiAgICBFZGl0Q29tbWFuZERpcmVjdGl2ZSxcbiAgICBDYW5jZWxDb21tYW5kRGlyZWN0aXZlLFxuICAgIFNhdmVDb21tYW5kRGlyZWN0aXZlLFxuICAgIFJlbW92ZUNvbW1hbmREaXJlY3RpdmUsXG4gICAgQWRkQ29tbWFuZERpcmVjdGl2ZSxcbiAgICBDZWxsTG9hZGluZ1RlbXBsYXRlRGlyZWN0aXZlLFxuICAgIExvYWRpbmdUZW1wbGF0ZURpcmVjdGl2ZVxuXTtcbmNvbnN0IGltcG9ydGVkTW9kdWxlcyQzID0gW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgIEZvcm1zTW9kdWxlLFxuICAgIFNoYXJlZE1vZHVsZSxcbiAgICBHcm91cE1vZHVsZSxcbiAgICBOdW1lcmljVGV4dEJveE1vZHVsZSxcbiAgICBEYXRlUGlja2VyTW9kdWxlLFxuICAgIFJlc2l6ZVNlbnNvck1vZHVsZVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQm9keU1vZHVsZSA9IGNsYXNzIEJvZHlNb2R1bGUge1xuICAgIHN0YXRpYyBleHBvcnRzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgQ29tbWFuZENvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgICAgIENoZWNrYm94Q29sdW1uQ29tcG9uZW50LFxuICAgICAgICAgICAgU2VsZWN0aW9uQ2hlY2tib3hEaXJlY3RpdmUsXG4gICAgICAgICAgICBDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBOb1JlY29yZHNUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIEVkaXRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIEVkaXRDb21tYW5kRGlyZWN0aXZlLFxuICAgICAgICAgICAgQ2FuY2VsQ29tbWFuZERpcmVjdGl2ZSxcbiAgICAgICAgICAgIFNhdmVDb21tYW5kRGlyZWN0aXZlLFxuICAgICAgICAgICAgUmVtb3ZlQ29tbWFuZERpcmVjdGl2ZSxcbiAgICAgICAgICAgIEFkZENvbW1hbmREaXJlY3RpdmUsXG4gICAgICAgICAgICBDZWxsTG9hZGluZ1RlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgTG9hZGluZ1RlbXBsYXRlRGlyZWN0aXZlXG4gICAgICAgIF07XG4gICAgfVxufTtcbkJvZHlNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2V4cG9ydGVkJDFdLFxuICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWQkMV0sXG4gICAgICAgIGltcG9ydHM6IFsuLi5pbXBvcnRlZE1vZHVsZXMkM11cbiAgICB9KVxuXSwgQm9keU1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRm9vdGVyQ29tcG9uZW50ID0gY2xhc3MgRm9vdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5JbmZvU2VydmljZSkge1xuICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlID0gY29sdW1uSW5mb1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IFtdO1xuICAgICAgICB0aGlzLmxvY2tlZENvbHVtbnNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubG9naWNhbFJvd0luZGV4ID0gMDtcbiAgICB9XG4gICAgZ2V0IGZvb3RlckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc2Nyb2xsYWJsZTtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbnNUb1JlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnNUb1JlbmRlcih0aGlzLmNvbHVtbnMgfHwgW10pO1xuICAgIH1cbiAgICBsb2dpY2FsQ29sdW1uSW5kZXgoY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29sdW1uLmxlYWZJbmRleDtcbiAgICAgICAgaWYgKGlzUHJlc2VudChpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCArIChpc1ByZXNlbnQodGhpcy5kZXRhaWxUZW1wbGF0ZSkgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBhZGRTdGlja3lTdHlsZXMoY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IHN0aWNreVN0eWxlcyA9IHRoaXMuY29sdW1uSW5mb1NlcnZpY2Uuc3RpY2t5Q29sdW1uc1N0eWxlcyhjb2x1bW4pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29sdW1uLnN0eWxlLCBzdGlja3lTdHlsZXMpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEZvb3RlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBGb290ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3Vwc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGV0YWlsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBGb290ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRldGFpbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRm9vdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBGb290ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImxvY2tlZENvbHVtbnNDb3VudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRm9vdGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsb2dpY2FsUm93SW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWdyaWQtZm9vdGVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEZvb3RlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9vdGVyQ2xhc3NcIiwgbnVsbCk7XG5Gb290ZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRGb290ZXJdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwidHJ1ZVwiPlxuICAgICAgICA8dHJcbiAgICAgICAgICAgIFtjbGFzcy5rLWZvb3Rlci10ZW1wbGF0ZV09XCJ0cnVlXCJcbiAgICAgICAgICAgIGtlbmRvR3JpZExvZ2ljYWxSb3dcbiAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cImxvZ2ljYWxSb3dJbmRleFwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZVJvd109XCJsb2NrZWRDb2x1bW5zQ291bnQgPiAwXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbENlbGxzQ291bnRdPVwiY29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVDZWxsc0NvdW50XT1cImNvbHVtbnMubGVuZ3RoIC0gbG9ja2VkQ29sdW1uc0NvdW50XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDx0ZFxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLWdyb3VwLWNlbGxdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IGcgb2YgZ3JvdXBzXCI+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstaGllcmFyY2h5LWNlbGxdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJkZXRhaWxUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIj5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgICAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbnNUb1JlbmRlcjsgbGV0IGNvbHVtbkluZGV4ID0gaW5kZXhcIlxuICAgICAgICAgICAgICAgIGtlbmRvR3JpZExvZ2ljYWxDZWxsXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibG9naWNhbFJvd0luZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgW2xvZ2ljYWxDb2xJbmRleF09XCJsb2dpY2FsQ29sdW1uSW5kZXgoY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJjb2x1bW5mb290ZXJcIlxuICAgICAgICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLWdyaWQtZm9vdGVyLXN0aWNreV09XCJjb2x1bW4uc3RpY2t5XCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJjb2x1bW4uZm9vdGVyQ2xhc3NcIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNvbHVtbi5zdGlja3kgPyBhZGRTdGlja3lTdHlsZXMoY29sdW1uKSA6IGNvbHVtbi5mb290ZXJTdHlsZVwiPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGVDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiBjb2x1bW4uZm9vdGVyVGVtcGxhdGVSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogbG9ja2VkQ29sdW1uc0NvdW50ICsgY29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgPC90cj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbHVtbkluZm9TZXJ2aWNlXSlcbl0sIEZvb3RlckNvbXBvbmVudCk7XG5cbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyQzID0gW1xuICAgIEZvb3RlckNvbXBvbmVudFxuXTtcbmNvbnN0IGltcG9ydGVkTW9kdWxlcyQ0ID0gW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBTaGFyZWRNb2R1bGVcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEZvb3Rlck1vZHVsZSA9IGNsYXNzIEZvb3Rlck1vZHVsZSB7XG4gICAgc3RhdGljIGV4cG9ydHMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuRm9vdGVyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtleHBvcnRlZE1vZHVsZXMkM10sXG4gICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXMkM10sXG4gICAgICAgIGltcG9ydHM6IFsuLi5pbXBvcnRlZE1vZHVsZXMkNF1cbiAgICB9KVxuXSwgRm9vdGVyTW9kdWxlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUb29sYmFyQ29tcG9uZW50ID0gY2xhc3MgVG9vbGJhckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZ3JpZCkge1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7fTtcbiAgICB9XG4gICAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5wb3NpdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdG9vbGJhclRlbXBsYXRlUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnRvb2xiYXJUZW1wbGF0ZSA/IHRoaXMuZ3JpZC50b29sYmFyVGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgVG9vbGJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgbnVsbCk7XG5Ub29sYmFyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLXRvb2xiYXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICpuZ0lmPVwidG9vbGJhclRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRvb2xiYXJUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwiY29udGV4dFwiXG4gICAgICAgICAgICA+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbR3JpZENvbXBvbmVudF0pXG5dLCBUb29sYmFyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExvY2FsRWRpdFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGdyaWQsIGxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgICAgIHRoaXMubG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UgPSBsb2NhbERhdGFDaGFuZ2VzU2VydmljZTtcbiAgICB9XG4gICAgY3JlYXRlKGl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTG9jYWxEYXRhICYmIHRoaXMuZ3JpZC5za2lwKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlLmRhdGEuc3BsaWNlKHRoaXMuZ3JpZC5za2lwLCAwLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZWQoKTtcbiAgICB9XG4gICAgdXBkYXRlKF9pdGVtKSB7IH0gLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1lbXB0eVxuICAgIHJlbW92ZShpdGVtKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGRhdGEubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IGRhdGFbaWR4XSkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCh7IGFjdGlvbjogJ3JlbW92ZScsIGl0ZW06IGl0ZW0gfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWVzKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpO1xuICAgIH1cbiAgICBkYXRhQ2hhbmdlZChhcmdzID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTG9jYWxEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlLmNoYW5nZXMuZW1pdChhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGFzTG9jYWxEYXRhKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlLmRhdGEpO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTG9jYWxEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERhdGFDaGFuZ2VzU2VydmljZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdyaWQuZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVmYXVsdCBlZGl0IHNlcnZpY2Ugb2YgdGhlIGVkaXRpbmcgZGlyZWN0aXZlcyB3b3JrcyBvbmx5IHdoZW4gYmluZGluZyB0byBwbGFpbiBhcnJheS4nICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIHByb3ZpZGUgYW4gZWRpdFNlcnZpY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEVkaXRpbmdEaXJlY3RpdmVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihncmlkLCBsb2NhbERhdGFDaGFuZ2VzU2VydmljZSkge1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgICAgICB0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlID0gbG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVkaXRTZXJ2aWNlID0gdGhpcy5jcmVhdGVEZWZhdWx0U2VydmljZSgpO1xuICAgIH1cbiAgICAvLyBDb25zaWRlciBhZGRpbmcgc3VwcG9ydCBmb3IgdGhlIGRlcGVuZGVuY3kgaW5qZWN0aW9uIG9mIHRoZSBzZXJ2aWNlIHRvIGFsbG93IGZvciBzcGVjaWZ5aW5nIGEgZ2VuZXJpYyBzZXJ2aWNlIHdpdGhvdXQgY29kZS5cbiAgICAvLyBUaGUgSW5wdXQgc2hvdWxkIHN0aWxsIGJlIGtlcHQuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXQgc2VydmljZSB0aGF0IHdpbGwgaGFuZGxlIHRoZSBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIHNldCBlZGl0U2VydmljZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnVzZXJFZGl0U2VydmljZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZWRpdFNlcnZpY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJFZGl0U2VydmljZSB8fCB0aGlzLmRlZmF1bHRFZGl0U2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB0aGlzLmdyaWQuYWRkLnN1YnNjcmliZSh0aGlzLmFkZEhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5ncmlkLnJlbW92ZS5zdWJzY3JpYmUodGhpcy5yZW1vdmVIYW5kbGVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmdyaWQuY2FuY2VsLnN1YnNjcmliZSh0aGlzLmNhbmNlbEhhbmRsZXIuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuZ3JpZC5zYXZlLnN1YnNjcmliZSh0aGlzLnNhdmVIYW5kbGVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmdyaWQuZGF0YVN0YXRlQ2hhbmdlLnN1YnNjcmliZSh0aGlzLm9uU3RhdGVDaGFuZ2UuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBjcmVhdGVEZWZhdWx0U2VydmljZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbEVkaXRTZXJ2aWNlKHRoaXMuZ3JpZCwgdGhpcy5sb2NhbERhdGFDaGFuZ2VzU2VydmljZSk7XG4gICAgfVxuICAgIGFkZEhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5hZGRSb3codGhpcy5jcmVhdGVNb2RlbCh7IGlzTmV3OiB0cnVlIH0pKTtcbiAgICB9XG4gICAgc2F2ZUhhbmRsZXIoYXJncykge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zYXZlTW9kZWwoYXJncyk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5pc05ldykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuY3JlYXRlKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS51cGRhdGUoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmNsb3NlUm93KGFyZ3Mucm93SW5kZXgpO1xuICAgIH1cbiAgICBjYW5jZWxIYW5kbGVyKHsgcm93SW5kZXggfSkge1xuICAgICAgICB0aGlzLmNsb3NlRWRpdG9yKHJvd0luZGV4KTtcbiAgICB9XG4gICAgcmVtb3ZlSGFuZGxlcih7IGRhdGFJdGVtIH0pIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlSXRlbSA9IChzaG91bGRSZW1vdmUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLnJlbW92ZShkYXRhSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZUNvbmZpcm1hdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZW1vdmVDb25maXJtYXRpb24oZGF0YUl0ZW0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGhlbihyZW1vdmVJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUocmVtb3ZlSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVJdGVtKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVJdGVtKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IoKTtcbiAgICB9XG4gICAgY2xvc2VFZGl0b3Iocm93SW5kZXgpIHtcbiAgICAgICAgdGhpcy5ncmlkLmNsb3NlUm93KHJvd0luZGV4KTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIEVkaXRpbmdEaXJlY3RpdmVCYXNlLnByb3RvdHlwZSwgXCJlZGl0U2VydmljZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgRWRpdGluZ0RpcmVjdGl2ZUJhc2UucHJvdG90eXBlLCBcInJlbW92ZUNvbmZpcm1hdGlvblwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTG9jYWxSb3dFZGl0U2VydmljZSBleHRlbmRzIExvY2FsRWRpdFNlcnZpY2Uge1xuICAgIHVwZGF0ZShfaXRlbSkge1xuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUm93RWRpdGluZ0RpcmVjdGl2ZUJhc2UgZXh0ZW5kcyBFZGl0aW5nRGlyZWN0aXZlQmFzZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIC5hZGQodGhpcy5ncmlkLmVkaXQuc3Vic2NyaWJlKHRoaXMuZWRpdEhhbmRsZXIuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICBjcmVhdGVEZWZhdWx0U2VydmljZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFJvd0VkaXRTZXJ2aWNlKHRoaXMuZ3JpZCwgdGhpcy5sb2NhbERhdGFDaGFuZ2VzU2VydmljZSk7XG4gICAgfVxuICAgIGFkZEhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IoKTtcbiAgICAgICAgc3VwZXIuYWRkSGFuZGxlcigpO1xuICAgIH1cbiAgICBlZGl0SGFuZGxlcihhcmdzKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IoKTtcbiAgICAgICAgdGhpcy5yb3dJbmRleCA9IGFyZ3Mucm93SW5kZXg7XG4gICAgICAgIHRoaXMuZ3JpZC5lZGl0Um93KGFyZ3Mucm93SW5kZXgsIHRoaXMuY3JlYXRlTW9kZWwoYXJncykpO1xuICAgIH1cbiAgICBzYXZlSGFuZGxlcihhcmdzKSB7XG4gICAgICAgIHN1cGVyLnNhdmVIYW5kbGVyKGFyZ3MpO1xuICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgfVxuICAgIGNsb3NlRWRpdG9yKHJvd0luZGV4ID0gdGhpcy5yb3dJbmRleCkge1xuICAgICAgICBzdXBlci5jbG9zZUVkaXRvcihyb3dJbmRleCk7XG4gICAgICAgIHRoaXMuY2xlYW4oKTtcbiAgICB9XG4gICAgY2xlYW4oKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJvd0luZGV4O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIGVkaXRpbmcgb3BlcmF0aW9ucyBvZiB0aGUgR3JpZCB3aGVuIHVzaW5nXG4gKiB0aGUgVGVtcGxhdGUtRHJpdmVuIEFuZ3VsYXIgRm9ybXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX2RpcmVjdGl2ZXNfZ3JpZCAlfSN0b2MtdGhlLXRlbXBsYXRlLWRpcmVjdGl2ZSkpLlxuICovXG5sZXQgVGVtcGxhdGVFZGl0aW5nRGlyZWN0aXZlID0gY2xhc3MgVGVtcGxhdGVFZGl0aW5nRGlyZWN0aXZlIGV4dGVuZHMgUm93RWRpdGluZ0RpcmVjdGl2ZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGdyaWQsIGxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGdyaWQsIGxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5ncmlkID0gZ3JpZDtcbiAgICAgICAgdGhpcy5sb2NhbERhdGFDaGFuZ2VzU2VydmljZSA9IGxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlO1xuICAgIH1cbiAgICBlZGl0SGFuZGxlcihhcmdzKSB7XG4gICAgICAgIHN1cGVyLmVkaXRIYW5kbGVyKGFyZ3MpO1xuICAgICAgICB0aGlzLmRhdGFJdGVtID0gYXJncy5kYXRhSXRlbTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmFzc2lnblZhbHVlcyh0aGlzLm9yaWdpbmFsVmFsdWVzLCB0aGlzLmRhdGFJdGVtKTtcbiAgICB9XG4gICAgY2xvc2VFZGl0b3Iocm93SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuYXNzaWduVmFsdWVzKHRoaXMuZGF0YUl0ZW0sIHRoaXMub3JpZ2luYWxWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmNsb3NlRWRpdG9yKHJvd0luZGV4KTtcbiAgICB9XG4gICAgY3JlYXRlTW9kZWwoYXJncykge1xuICAgICAgICBpZiAoYXJncy5pc05ldykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTmV3SXRlbSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNhdmVNb2RlbChhcmdzKSB7XG4gICAgICAgIHJldHVybiBhcmdzLmRhdGFJdGVtO1xuICAgIH1cbiAgICBjbGVhbigpIHtcbiAgICAgICAgc3VwZXIuY2xlYW4oKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YUl0ZW07XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdrZW5kb0dyaWRUZW1wbGF0ZUVkaXRpbmcnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUZW1wbGF0ZUVkaXRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcImNyZWF0ZU5ld0l0ZW1cIiwgdm9pZCAwKTtcblRlbXBsYXRlRWRpdGluZ0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZFRlbXBsYXRlRWRpdGluZ10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtHcmlkQ29tcG9uZW50LCBMb2NhbERhdGFDaGFuZ2VzU2VydmljZV0pXG5dLCBUZW1wbGF0ZUVkaXRpbmdEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWFya0FsbEFzVG91Y2hlZCA9IChjb250cm9sKSA9PiB7XG4gICAgY29udHJvbC5tYXJrQXNUb3VjaGVkKCk7XG4gICAgaWYgKGNvbnRyb2wuaGFzT3duUHJvcGVydHkoJ2NvbnRyb2xzJykpIHtcbiAgICAgICAgbGV0IGNvbnRyb2xzID0gY29udHJvbC5jb250cm9scztcbiAgICAgICAgZm9yIChsZXQgaW5uZXIgaW4gY29udHJvbHMpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9scy5oYXNPd25Qcm9wZXJ0eShpbm5lcikpIHtcbiAgICAgICAgICAgICAgICBtYXJrQWxsQXNUb3VjaGVkKGNvbnRyb2xzW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgZWRpdGluZyBvcGVyYXRpb25zIG9mIHRoZSBHcmlkIHdoZW4gdXNpbmcgdGhlXG4gKiBSZWFjdGl2ZSBGb3JtcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfZGlyZWN0aXZlc19ncmlkICV9I3RvYy10aGUtcmVhY3RpdmUtZGlyZWN0aXZlKSkuXG4gKi9cbmxldCBSZWFjdGl2ZUVkaXRpbmdEaXJlY3RpdmUgPSBjbGFzcyBSZWFjdGl2ZUVkaXRpbmdEaXJlY3RpdmUgZXh0ZW5kcyBSb3dFZGl0aW5nRGlyZWN0aXZlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoZ3JpZCwgbG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoZ3JpZCwgbG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UpO1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgICAgICB0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlID0gbG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2U7XG4gICAgfVxuICAgIGNyZWF0ZU1vZGVsKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRm9ybUdyb3VwKGFyZ3MpO1xuICAgIH1cbiAgICBzYXZlTW9kZWwoeyBkYXRhSXRlbSwgZm9ybUdyb3VwLCBpc05ldyB9KSB7XG4gICAgICAgIGlmICghZm9ybUdyb3VwLmRpcnR5ICYmICFpc05ldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtR3JvdXAudmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuYXNzaWduVmFsdWVzKGRhdGFJdGVtLCBmb3JtR3JvdXAudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtBbGxBc1RvdWNoZWQoZm9ybUdyb3VwKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2tlbmRvR3JpZFJlYWN0aXZlRWRpdGluZycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFJlYWN0aXZlRWRpdGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY3JlYXRlRm9ybUdyb3VwXCIsIHZvaWQgMCk7XG5SZWFjdGl2ZUVkaXRpbmdEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRSZWFjdGl2ZUVkaXRpbmddJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbR3JpZENvbXBvbmVudCwgTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2VdKVxuXSwgUmVhY3RpdmVFZGl0aW5nRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIGVkaXRpbmcgb3BlcmF0aW9ucyBvZiB0aGUgR3JpZCB3aGVuIHVzaW5nIHRoZSBpbi1jZWxsXG4gKiBlZGl0aW5nIHdpdGggUmVhY3RpdmUgRm9ybXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX2RpcmVjdGl2ZXNfZ3JpZCAlfSN0b2MtdGhlLWluY2VsbC1kaXJlY3RpdmUpKS5cbiAqL1xubGV0IEluQ2VsbEVkaXRpbmdEaXJlY3RpdmUgPSBjbGFzcyBJbkNlbGxFZGl0aW5nRGlyZWN0aXZlIGV4dGVuZHMgRWRpdGluZ0RpcmVjdGl2ZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGdyaWQsIGxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlLCBjZHIpIHtcbiAgICAgICAgc3VwZXIoZ3JpZCwgbG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UpO1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgICAgICB0aGlzLmxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlID0gbG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgIH1cbiAgICAvLyBOZWVkIG1peGluXG4gICAgY3JlYXRlTW9kZWwoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGb3JtR3JvdXAoYXJncyk7XG4gICAgfVxuICAgIHNhdmVNb2RlbCh7IGRhdGFJdGVtLCBmb3JtR3JvdXAsIGlzTmV3IH0pIHtcbiAgICAgICAgaWYgKCFmb3JtR3JvdXAuZGlydHkgJiYgIWlzTmV3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1Hcm91cC52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS5hc3NpZ25WYWx1ZXMoZGF0YUl0ZW0sIGZvcm1Hcm91cC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbWFya0FsbEFzVG91Y2hlZChmb3JtR3JvdXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5ncmlkLmNlbGxDbGljay5zdWJzY3JpYmUodGhpcy5jZWxsQ2xpY2tIYW5kbGVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmdyaWQuY2VsbENsb3NlLnN1YnNjcmliZSh0aGlzLmNlbGxDbG9zZUhhbmRsZXIuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICByZW1vdmVIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlSGFuZGxlcihhcmdzKTtcbiAgICAgICAgdGhpcy5ncmlkLmNhbmNlbENlbGwoKTtcbiAgICB9XG4gICAgY2VsbENsaWNrSGFuZGxlcihhcmdzKSB7XG4gICAgICAgIGlmICghYXJncy5pc0VkaXRlZCAmJiBhcmdzLnR5cGUgIT09ICdjb250ZXh0bWVudScpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5lZGl0Q2VsbChhcmdzLnJvd0luZGV4LCBhcmdzLmNvbHVtbkluZGV4LCB0aGlzLmNyZWF0ZUZvcm1Hcm91cChhcmdzKSk7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjZWxsQ2xvc2VIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBmb3JtR3JvdXAsIGRhdGFJdGVtIH0gPSBhcmdzO1xuICAgICAgICBpZiAoIWZvcm1Hcm91cC52YWxpZCkge1xuICAgICAgICAgICAgYXJncy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcm1Hcm91cC5kaXJ0eSkge1xuICAgICAgICAgICAgaWYgKGFyZ3Mub3JpZ2luYWxFdmVudCAmJiBhcmdzLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gS2V5cy5Fc2NhcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmFzc2lnblZhbHVlcyhkYXRhSXRlbSwgZm9ybUdyb3VwLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdFNlcnZpY2UudXBkYXRlKGRhdGFJdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgna2VuZG9HcmlkSW5DZWxsRWRpdGluZycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIEluQ2VsbEVkaXRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcImNyZWF0ZUZvcm1Hcm91cFwiLCB2b2lkIDApO1xuSW5DZWxsRWRpdGluZ0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZEluQ2VsbEVkaXRpbmddJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbR3JpZENvbXBvbmVudCxcbiAgICAgICAgTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmXSlcbl0sIEluQ2VsbEVkaXRpbmdEaXJlY3RpdmUpO1xuXG5jb25zdCBoYXNHcm91cHMgPSAoaXRlbXMpID0+IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1swXS5maWVsZCAmJiBpdGVtc1swXS5pdGVtcztcbmNvbnN0IGdyb3VwRGVzY3JpcHRvcnNQcmVzZW50ID0gKGRlc2NyaXB0b3JzKSA9PiBpc1ByZXNlbnQoZGVzY3JpcHRvcnMpICYmIGRlc2NyaXB0b3JzLmxlbmd0aCA+IDA7XG5jb25zdCBwcm9jZXNzR3JvdXBzID0gKGRhdGEsIHN0YXRlJCQxKSA9PiBwcm9jZXNzKGRhdGEsIHN0YXRlJCQxKS5kYXRhO1xuY29uc3QgcmVtb3ZlUGFyZW50RGVzY3JpcHRvcnMgPSAocGFyZW50cywgb3duZXIpID0+IGcgPT4gZy5maWVsZCAhPT0gb3duZXIuZmllbGQgJiYgIXBhcmVudHMuc29tZSh5ID0+IHkuZmllbGQgPT09IGcuZmllbGQpO1xuY29uc3QgZmluZEdyb3VwID0gKGdyb3VwSW5kZXgsIGdyb3VwcykgPT4ge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBncm91cDogZ3JvdXBJbmRleC5zcGxpdChcIl9cIikucmVkdWNlKChhY2MsIHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHBhcnNlSW50KHgsIDEwKTtcbiAgICAgICAgICAgIGlmIChhY2MuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjLml0ZW1zW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheShhY2MpID8gYWNjW2lkeF0gOiBhY2M7XG4gICAgICAgIH0sIGdyb3VwcyksXG4gICAgICAgIHBhcmVudHNcbiAgICB9O1xufTtcbmNvbnN0IGZpbmRDaGlsZHJlbiA9IChkYXRhLCBwYXJlbnRzKSA9PiB7XG4gICAgY29uc3QgZmlsdGVycyA9IHBhcmVudHMubWFwKHAgPT4gKHsgZmllbGQ6IHAuZmllbGQsIG9wZXJhdG9yOiBcImVxXCIsIHZhbHVlOiBwLnZhbHVlIH0pKTtcbiAgICByZXR1cm4gZmlsdGVyQnkoZGF0YSwge1xuICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgICBsb2dpYzogXCJhbmRcIlxuICAgIH0pO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjb3VudCA9IChncm91cHMsIGluY2x1ZGVGb290ZXJzID0gZmFsc2UpID0+IChncm91cHMucmVkdWNlKChhY2MsIGdyb3VwKSA9PiB7XG4gICAgaWYgKCFncm91cC5za2lwSGVhZGVyKSB7XG4gICAgICAgIGFjYysrO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAuaXRlbXMpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBjb3VudChncm91cC5pdGVtcywgaW5jbHVkZUZvb3RlcnMpO1xuICAgICAgICBpZiAoaW5jbHVkZUZvb3RlcnMgJiYgY2hpbGRyZW4gJiYgIWdyb3VwLmhpZGVGb290ZXIpIHtcbiAgICAgICAgICAgIGFjYysrO1xuICAgICAgICB9XG4gICAgICAgIGFjYyArPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbn0sIDApIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc2xpY2UgPSAoZ3JvdXBzLCBza2lwLCB0YWtlJCQxLCBpbmNsdWRlRm9vdGVycyA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKCFpc1ByZXNlbnQodGFrZSQkMSkpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaWR4ID0gMCwgbGVuZ3RoID0gZ3JvdXBzLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAodGFrZSQkMSA8PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1tpZHhdO1xuICAgICAgICBjb25zdCBncm91cEl0ZW1zID0gZ3JvdXAuaXRlbXM7XG4gICAgICAgIGxldCBpdGVtQ291bnQgPSBjb3VudChncm91cEl0ZW1zLCBpbmNsdWRlRm9vdGVycyk7XG4gICAgICAgIGlmIChpbmNsdWRlRm9vdGVycyAmJiBncm91cEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2tpcEhlYWRlciA9IHNraXAgPiAwO1xuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgc2tpcC0tO1xuICAgICAgICAgICAgaWYgKGl0ZW1Db3VudCAmJiBza2lwID49IGl0ZW1Db3VudCkge1xuICAgICAgICAgICAgICAgIHNraXAgLT0gaXRlbUNvdW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcEhlYWRlciB8fCBpdGVtQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgICAgICBsZXQgaGlkZUZvb3RlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXNraXBIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0YWtlJCQxLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFrZSQkMSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNHcm91cHMoZ3JvdXBJdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbGljZShncm91cEl0ZW1zLCBza2lwLCB0YWtlJCQxLCBpbmNsdWRlRm9vdGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB0YWtlJCQxIC09IGNvdW50KGNoaWxkcmVuLCBpbmNsdWRlRm9vdGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKC4uLmdyb3VwSXRlbXMuc2xpY2Uoc2tpcCwgTWF0aC5taW4oc2tpcCArIHRha2UkJDEsIGdyb3VwSXRlbXMubGVuZ3RoKSkpO1xuICAgICAgICAgICAgICAgICAgICB0YWtlJCQxIC09IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRha2UkJDEgJiYgaW5jbHVkZUZvb3RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZUZvb3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0YWtlJCQxLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZXM6IGdyb3VwLmFnZ3JlZ2F0ZXMsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGdyb3VwLmZpZWxkLFxuICAgICAgICAgICAgICAgIGhpZGVGb290ZXIsXG4gICAgICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBpZHgsXG4gICAgICAgICAgICAgICAgc2tpcEhlYWRlcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3Qgc2tpcHBlZEhlYWRlcnMgPSAoZ3JvdXBJdGVtKSA9PiB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICB3aGlsZSAoZ3JvdXBJdGVtKSB7XG4gICAgICAgIGlmIChncm91cEl0ZW0uc2tpcEhlYWRlcikge1xuICAgICAgICAgICAgdG90YWwrKztcbiAgICAgICAgfVxuICAgICAgICBncm91cEl0ZW0gPSBncm91cEl0ZW0uaXRlbXMgJiYgZ3JvdXBJdGVtLml0ZW1zWzBdIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgaW4tbWVtb3J5IGhhbmRsaW5nIG9mIGdyb3VwaW5nIHdpdGggdmlydHVhbCBzY3JvbGxpbmcuXG4gKi9cbmxldCBHcm91cEJpbmRpbmdEaXJlY3RpdmUgPSBjbGFzcyBHcm91cEJpbmRpbmdEaXJlY3RpdmUgZXh0ZW5kcyBEYXRhQmluZGluZ0RpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZ3JpZCwgY2hhbmdlRGV0ZWN0b3IsIGxvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGdyaWQsIGNoYW5nZURldGVjdG9yLCBsb2NhbERhdGFDaGFuZ2VzU2VydmljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiBkYXRhIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBwb3B1bGF0ZSB0aGUgR3JpZC5cbiAgICAgKi9cbiAgICBzZXQga2VuZG9HcmlkR3JvdXBCaW5kaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gbnVsbDtcbiAgICAgICAgdGhpcy5ncmlkLnJlc2V0R3JvdXBzU3RhdGUoKTtcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgZGVzY3JpcHRvcnMgYnkgd2hpY2ggdGhlIGRhdGEgd2lsbCBiZSBzb3J0ZWQuXG4gICAgICovXG4gICAgc2V0IHNvcnQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2xlYXIgPSB0aGlzLnN0YXRlLnNvcnQgIT09IHZhbHVlO1xuICAgICAgICB0aGlzLmdyaWQuc29ydCA9IHRoaXMuc3RhdGUuc29ydCA9IHZhbHVlO1xuICAgICAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5yZXNldEdyb3Vwc1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgZGVzY3JpcHRvciBieSB3aGljaCB0aGUgZGF0YSB3aWxsIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIHNldCBmaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2xlYXIgPSBkaWZmRmlsdGVycyh0aGlzLnN0YXRlLmZpbHRlciwgdmFsdWUpO1xuICAgICAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZmlsdGVyID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmdyaWQuZmlsdGVyID0gY2xvbmVGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5yZXNldEdyb3Vwc1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgZGVzY3JpcHRvcnMgYnkgd2hpY2ggdGhlIGRhdGEgd2lsbCBiZSBncm91cGVkLlxuICAgICAqL1xuICAgIHNldCBncm91cCh2YWx1ZSkge1xuICAgICAgICAvLyBkb24ndCBjbGVhciBpZiBubyBncm91cHMgYXJlIHByZXNlbnQgaW4gcHJldmlvdXMgYW5kIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgY29uc3QgZ3JvdXBzUHJlc2VudCA9IGdyb3VwRGVzY3JpcHRvcnNQcmVzZW50KHRoaXMuc3RhdGUuZ3JvdXApIHx8IGdyb3VwRGVzY3JpcHRvcnNQcmVzZW50KHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2xlYXIgPSB0aGlzLnN0YXRlLmdyb3VwICE9PSB2YWx1ZSAmJiBncm91cHNQcmVzZW50O1xuICAgICAgICB0aGlzLmdyaWQuZ3JvdXAgPSB0aGlzLnN0YXRlLmdyb3VwID0gdmFsdWU7XG4gICAgICAgIGlmIChjbGVhcikge1xuICAgICAgICAgICAgdGhpcy5ncm91cHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ncmlkLnJlc2V0R3JvdXBzU3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuc2tpcCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLmdyaWQuZ3JvdXBFeHBhbmQuc3Vic2NyaWJlKHRoaXMuZ3JvdXBFeHBhbmQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZ3JpZC5ncm91cENvbGxhcHNlLnN1YnNjcmliZSh0aGlzLmdyb3VwQ29sbGFwc2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmIHRoaXMuZ3JpZC5pc0dyb3VwRXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgdGhlIGBrZW5kb0dyaWRHcm91cEJpbmRpbmdgIGRpcmVjdGl2ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBga2VuZG9HcmlkRXhwYW5kR3JvdXBCeWAgZGlyZWN0aXZlICcgK1xuICAgICAgICAgICAgICAgICdvciB0aGUgYGlzR3JvdXBFeHBhbmRlZGAgY2FsbGJhY2sgaXMgbm90IHN1cHBvcnRlZC4gVG8gdXNlIGdyb3VwaW5nIHdpdGggdGhlIGBrZW5kb0dyaWRHcm91cEJpbmRpbmdgIGRpcmVjdGl2ZSwgJyArXG4gICAgICAgICAgICAgICAgJ3NldCB0aGUgR3JpZCBgZ3JvdXBhYmxlYCBwcm9wZXJ0eSB0byBgdHJ1ZWAuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXBFeHBhbmQoeyBncm91cEluZGV4IH0pIHtcbiAgICAgICAgdGhpcy5ncmlkLmV4cGFuZEdyb3VwQ2hpbGRyZW4oZ3JvdXBJbmRleCk7XG4gICAgICAgIGNvbnN0IHsgZ3JvdXAsIHBhcmVudHMgfSA9IGZpbmRHcm91cChncm91cEluZGV4LCB0aGlzLmdyb3Vwcyk7XG4gICAgICAgIGlmICghZ3JvdXAuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuc3RhdGUuZ3JvdXAuZmlsdGVyKHJlbW92ZVBhcmVudERlc2NyaXB0b3JzKHBhcmVudHMsIGdyb3VwKSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGZpbmRDaGlsZHJlbih0aGlzLm9yaWdpbmFsRGF0YSwgcGFyZW50cy5jb25jYXQoZ3JvdXApKTtcbiAgICAgICAgICAgIGdyb3VwLml0ZW1zID0gcHJvY2Vzc0dyb3VwcyhjaGlsZHJlbiwge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogdGhpcy5zdGF0ZS5maWx0ZXIsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGRlc2NyaXB0b3JzLFxuICAgICAgICAgICAgICAgIHNvcnQ6IHRoaXMuc3RhdGUuc29ydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmRhdGEgPSB0aGlzLmRhdGFSZXN1bHQodGhpcy5zdGF0ZS5za2lwLCB0aGlzLnN0YXRlLnRha2UpO1xuICAgIH1cbiAgICBncm91cENvbGxhcHNlKHsgZ3JvdXBJbmRleCB9KSB7XG4gICAgICAgIGNvbnN0IHsgZ3JvdXAgfSA9IGZpbmRHcm91cChncm91cEluZGV4LCB0aGlzLmdyb3Vwcyk7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAuaXRlbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyaWQuZGF0YSA9IHRoaXMuZGF0YVJlc3VsdCh0aGlzLnN0YXRlLnNraXAsIHRoaXMuc3RhdGUudGFrZSk7XG4gICAgfVxuICAgIHByb2Nlc3Moc3RhdGUkJDEpIHtcbiAgICAgICAgaWYgKHN0YXRlJCQxLmdyb3VwICYmIHN0YXRlJCQxLmdyb3VwLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBzID0gdGhpcy5wcm9jZXNzR3JvdXBzKHN0YXRlJCQxKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5za2lwIC09IHNraXBwZWRIZWFkZXJzKGdyb3Vwcy5kYXRhWzBdKTtcbiAgICAgICAgICAgIHJldHVybiBncm91cHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnByb2Nlc3Moc3RhdGUkJDEpO1xuICAgIH1cbiAgICBwcm9jZXNzR3JvdXBzKHN0YXRlJCQxKSB7XG4gICAgICAgIGlmICghdGhpcy5ncm91cHMgfHwgIXRoaXMuZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHMgPSBwcm9jZXNzR3JvdXBzKHRoaXMub3JpZ2luYWxEYXRhLCB7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBzdGF0ZSQkMS5maWx0ZXIsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IHN0YXRlJCQxLmdyb3VwLFxuICAgICAgICAgICAgICAgIHNvcnQ6IHN0YXRlJCQxLnNvcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFSZXN1bHQoc3RhdGUkJDEuc2tpcCwgc3RhdGUkJDEudGFrZSk7XG4gICAgfVxuICAgIGRhdGFSZXN1bHQoc2tpcCwgdGFrZSQkMSkge1xuICAgICAgICBjb25zdCBpbmNsdWRlRm9vdGVycyA9IHRoaXMuZ3JpZC5zaG93R3JvdXBGb290ZXJzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogc2xpY2UodGhpcy5ncm91cHMsIHNraXAsIHRha2UkJDEsIGluY2x1ZGVGb290ZXJzKSxcbiAgICAgICAgICAgIHRvdGFsOiBjb3VudCh0aGlzLmdyb3VwcywgaW5jbHVkZUZvb3RlcnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5U3RhdGUoeyBza2lwLCB0YWtlOiB0YWtlJCQxLCBzb3J0LCBncm91cCwgZmlsdGVyOiBmaWx0ZXIkJDEgfSkge1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLnN0YXRlLnRha2UgPSB0YWtlJCQxO1xuICAgICAgICAvLyB0aGlzLnBhZ2VTaXplID0gdGFrZTsgLy8gZG8gbmVlZCB0byB1cGRhdGUgdGFrZSBhcyB0aGUgcHJvY2VzcyB3aXRoIHNsaWNlIGNvcnJlY3RseVxuICAgICAgICB0aGlzLnNvcnQgPSBzb3J0O1xuICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyJCQxO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dChcImtlbmRvR3JpZEdyb3VwQmluZGluZ1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgR3JvdXBCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJrZW5kb0dyaWRHcm91cEJpbmRpbmdcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBHcm91cEJpbmRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcInNvcnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIEdyb3VwQmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgR3JvdXBCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJncm91cFwiLCBudWxsKTtcbkdyb3VwQmluZGluZ0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2tlbmRvR3JpZEdyb3VwQmluZGluZ10nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbR3JpZENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIExvY2FsRGF0YUNoYW5nZXNTZXJ2aWNlXSlcbl0sIEdyb3VwQmluZGluZ0RpcmVjdGl2ZSk7XG5cbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyQ0ID0gW1xuICAgIEdyaWRDb21wb25lbnQsXG4gICAgVG9vbGJhclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIFRvb2xiYXJDb21wb25lbnQsXG4gICAgR3JpZFNwYWNlckNvbXBvbmVudCxcbiAgICBEYXRhQmluZGluZ0RpcmVjdGl2ZSxcbiAgICBTZWxlY3Rpb25EaXJlY3RpdmUsXG4gICAgQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgR3JvdXBCaW5kaW5nRGlyZWN0aXZlLFxuICAgIFRlbXBsYXRlRWRpdGluZ0RpcmVjdGl2ZSxcbiAgICBSZWFjdGl2ZUVkaXRpbmdEaXJlY3RpdmUsXG4gICAgSW5DZWxsRWRpdGluZ0RpcmVjdGl2ZSxcbiAgICBFeHBhbmREZXRhaWxzRGlyZWN0aXZlLFxuICAgIEV4cGFuZEdyb3VwRGlyZWN0aXZlLFxuICAgIC4uLkdyb3VwTW9kdWxlLmV4cG9ydHMoKSxcbiAgICAuLi5TaGFyZWRNb2R1bGUuZXhwb3J0cygpLFxuICAgIC4uLkJvZHlNb2R1bGUuZXhwb3J0cygpLFxuICAgIC4uLkhlYWRlck1vZHVsZS5leHBvcnRzKCksXG4gICAgLi4uRm9vdGVyTW9kdWxlLmV4cG9ydHMoKSxcbiAgICAuLi5QYWdlck1vZHVsZS5leHBvcnRzKCksXG4gICAgLi4uUm93RmlsdGVyTW9kdWxlLmV4cG9ydHMoKSxcbiAgICAuLi5GaWx0ZXJNZW51TW9kdWxlLmV4cG9ydHMoKSxcbiAgICAuLi5Db2x1bW5NZW51TW9kdWxlLmV4cG9ydHMoKVxuXTtcbmNvbnN0IGRlY2xhcmF0aW9ucyA9IFtcbiAgICBHcmlkQ29tcG9uZW50LFxuICAgIExpc3RDb21wb25lbnQsXG4gICAgVG9vbGJhckNvbXBvbmVudCxcbiAgICBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSxcbiAgICBDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICBEYXRhQmluZGluZ0RpcmVjdGl2ZSxcbiAgICBUb29sYmFyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgU2VsZWN0aW9uRGlyZWN0aXZlLFxuICAgIFRlbXBsYXRlRWRpdGluZ0RpcmVjdGl2ZSxcbiAgICBSZWFjdGl2ZUVkaXRpbmdEaXJlY3RpdmUsXG4gICAgSW5DZWxsRWRpdGluZ0RpcmVjdGl2ZSxcbiAgICBFeHBhbmREZXRhaWxzRGlyZWN0aXZlLFxuICAgIEV4cGFuZEdyb3VwRGlyZWN0aXZlLFxuICAgIEdyb3VwQmluZGluZ0RpcmVjdGl2ZSxcbiAgICBHcmlkTWFycXVlZURpcmVjdGl2ZSxcbiAgICBHcmlkU3BhY2VyQ29tcG9uZW50XG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgR3JpZCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgR3JpZCBtb2R1bGVcbiAqIGltcG9ydCB7IEdyaWRNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1ncmlkJztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgR3JpZE1vZHVsZV0sIC8vIGltcG9ydCBHcmlkIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xubGV0IEdyaWRNb2R1bGUgPSBjbGFzcyBHcmlkTW9kdWxlIHtcbn07XG5HcmlkTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtkZWNsYXJhdGlvbnNdLFxuICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDRdLFxuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICBHcm91cE1vZHVsZSxcbiAgICAgICAgICAgIFNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgIEJvZHlNb2R1bGUsXG4gICAgICAgICAgICBIZWFkZXJNb2R1bGUsXG4gICAgICAgICAgICBGb290ZXJNb2R1bGUsXG4gICAgICAgICAgICBQYWdlck1vZHVsZSxcbiAgICAgICAgICAgIFJvd0ZpbHRlck1vZHVsZSxcbiAgICAgICAgICAgIEZpbHRlck1lbnVNb2R1bGUsXG4gICAgICAgICAgICBSZXNpemVTZW5zb3JNb2R1bGUsXG4gICAgICAgICAgICBDb2x1bW5NZW51TW9kdWxlXG4gICAgICAgIF1cbiAgICB9KVxuXSwgR3JpZE1vZHVsZSk7XG5cbmxldCBQREZNYXJnaW5Db21wb25lbnQgPSBjbGFzcyBQREZNYXJnaW5Db21wb25lbnQgZXh0ZW5kcyBQREZFeHBvcnRNYXJnaW5Db21wb25lbnQge1xufTtcblBERk1hcmdpbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1wZGYtbWFyZ2luJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSlcbl0sIFBERk1hcmdpbkNvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgUERGIHBhZ2UgdGVtcGxhdGUgb2YgdGhlIEdyaWQgdGhhdCBoZWxwcyB0byBjdXN0b21pemUgdGhlIFBERiBwYWdlcy4gVG8gZGVmaW5lIGEgcGFnZSB0ZW1wbGF0ZSxcbiAqIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9HcmlkUERGVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYDxrZW5kby1ncmlkLXBkZj5gLlxuICpcbiAqIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICogLSBgcGFnZU51bWJlcmAmbWRhc2g7RGVmaW5lcyBQREYgcGFnZSBudW1iZXIuXG4gKiAtIGB0b3RhbFBhZ2VzYCZtZGFzaDtEZWZpbmVzIHRoZSB0b3RhbCBudW1iZXIgb2YgUERGIHBhZ2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICA8a2VuZG8tZ3JpZCBbZGF0YV09XCJncmlkRGF0YVwiPlxuICogICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvR3JpZFRvb2xiYXJUZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICAgICA8YnV0dG9uIGtlbmRvR3JpZFBERkNvbW1hbmQgaWNvbj1cImZpbGUtcGRmXCI+RXhwb3J0IHRvIFBERjwvYnV0dG9uPlxuICogICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCI+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWdyaWQtY29sdW1uPlxuICogICAgICAgICAgICAgIDxrZW5kby1ncmlkLWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiPlxuICogICAgICAgICAgICAgPC9rZW5kby1ncmlkLWNvbHVtbj5cbiAqICAgICAgICAgICAgIDxrZW5kby1ncmlkLXBkZiBmaWxlTmFtZT1cIlByb2R1Y3RzLnBkZlwiIHBhcGVyU2l6ZT1cIkE0XCIgW21hcmdpbl09XCJ7IHRvcDogJzFjbScsIGxlZnQ6ICcxY20nLCByaWdodDogJzFjbScsIGJvdHRvbTogJzFjbScgfVwiPlxuICogICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRQREZUZW1wbGF0ZSBsZXQtcGFnZU51bT1cInBhZ2VOdW1cIiBsZXQtdG90YWxQYWdlcz1cInRvdGFsUGFnZXNcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTt0b3A6IDVweDsgbGVmdDogNXB4O1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgUGFnZSB7eyBwYWdlTnVtIH19IG9mIHt7IHRvdGFsUGFnZXMgfX1cbiAqICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgIDwva2VuZG8tZ3JpZC1wZGY+XG4gKiAgICAgICAgIDwva2VuZG8tZ3JpZD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgcHVibGljIGdyaWREYXRhID0gW3tcbiAqICAgICAgICAgXCJQcm9kdWN0SURcIjogMSxcbiAqICAgICAgICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAqICAgICAgICAgXCJVbml0UHJpY2VcIjogMTguMDAwMFxuICogICAgICAgfSwge1xuICogICAgICAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICogICAgICAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAqICAgICAgICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMFxuICogICAgICAgfVxuICogICAgIF07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBQREZUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIFBERlRlbXBsYXRlRGlyZWN0aXZlIGV4dGVuZHMgUERGRXhwb3J0VGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHN1cGVyKHRlbXBsYXRlUmVmKTtcbiAgICB9XG59O1xuUERGVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRQREZUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIFBERlRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEhFQURFUl9DTEFTUyA9ICdrLWdyaWQtaGVhZGVyJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBGT09URVJfQ0xBU1MgPSAnay1ncmlkLWZvb3Rlcic7XG5jb25zdCBHUklEX0xJU1QgPSAnS0VORE8tR1JJRC1MSVNUJztcbmNvbnN0IFRBQkxFID0gJ1RBQkxFJztcbmNvbnN0IG1hdGNoZXNMaXN0ID0gbWF0Y2hlc05vZGVOYW1lKEdSSURfTElTVCk7XG5jb25zdCBtYXRjaGVzVGFibGUgPSBtYXRjaGVzTm9kZU5hbWUoVEFCTEUpO1xuY29uc3Qgc3VmZml4ID0gKGxvY2tlZCkgPT4gbG9ja2VkID8gJ2xvY2tlZCcgOiAnd3JhcCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgR3JpZFF1ZXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubGlzdCA9IGZpbmRFbGVtZW50KGVsZW1lbnQsIG1hdGNoZXNMaXN0KTtcbiAgICB9XG4gICAgY29udGVudChsb2NrZWQpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRFbGVtZW50KHRoaXMubGlzdCwgbWF0Y2hlc0NsYXNzZXMoYGstZ3JpZC1jb250ZW50JHtsb2NrZWQgPyAnLWxvY2tlZCcgOiAnJ31gKSk7XG4gICAgfVxuICAgIGhlYWRlcihsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJXcmFwID0gdGhpcy5oZWFkZXJXcmFwIHx8IGZpbmRFbGVtZW50KHRoaXMuZWxlbWVudCwgbWF0Y2hlc0NsYXNzZXMoSEVBREVSX0NMQVNTKSk7XG4gICAgICAgIHJldHVybiBmaW5kRWxlbWVudCh0aGlzLmhlYWRlcldyYXAsIG1hdGNoZXNDbGFzc2VzKGAke0hFQURFUl9DTEFTU30tJHtzdWZmaXgobG9ja2VkKX1gKSk7XG4gICAgfVxuICAgIGZvb3Rlcihsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5mb290ZXJXcmFwID0gdGhpcy5mb290ZXJXcmFwIHx8IGZpbmRFbGVtZW50KHRoaXMuZWxlbWVudCwgbWF0Y2hlc0NsYXNzZXMoRk9PVEVSX0NMQVNTKSk7XG4gICAgICAgIHJldHVybiBmaW5kRWxlbWVudCh0aGlzLmZvb3RlcldyYXAsIG1hdGNoZXNDbGFzc2VzKGAke0ZPT1RFUl9DTEFTU30tJHtzdWZmaXgobG9ja2VkKX1gKSk7XG4gICAgfVxuICAgIHRhYmxlKCkge1xuICAgICAgICByZXR1cm4gZmluZEVsZW1lbnQodGhpcy5lbGVtZW50LCBtYXRjaGVzVGFibGUpO1xuICAgIH1cbn1cblxuY29uc3QgRklSU1RfQ0xBU1MgPSAnay1maXJzdCc7XG5jb25zdCBJTlBVVFMgPSBbJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYScsICdvcHRpb24nXTtcbi8qKiBAaGlkZGVuICovXG5jb25zdCBjbG9uZU5vZGUgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGNsb25lID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgIGlmIChub2RlLl9rZW5kb0V4cG9ydFZpc3VhbCkge1xuICAgICAgICBjbG9uZS5fa2VuZG9FeHBvcnRWaXN1YWwgPSBub2RlLl9rZW5kb0V4cG9ydFZpc3VhbDtcbiAgICB9XG4gICAgaWYgKElOUFVUUy5pbmRleE9mKFN0cmluZyhub2RlLm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgIGNsb25lLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICBjbG9uZS5yZW1vdmVBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgICAgICBjbG9uZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIGNsb25lLmNoZWNrZWQgPSBub2RlLmNoZWNrZWQ7XG4gICAgICAgIGNsb25lLnNlbGVjdGVkID0gbm9kZS5zZWxlY3RlZDtcbiAgICB9XG4gICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBjbG9uZS5hcHBlbmRDaGlsZChjbG9uZU5vZGUoY2hpbGQpKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufTtcbmNvbnN0IGFwcGVuZE5vZGVzID0gKGVsZW1lbnQsIG5vZGVzKSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjbG9uZU5vZGUobm9kZXNbaWR4XSkpO1xuICAgIH1cbn07XG5jb25zdCB3cmFwVGFibGUgPSAodGFibGUpID0+IHtcbiAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlci5jbGFzc05hbWUgPSAnay1ncmlkJztcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRhYmxlKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbn07XG5jb25zdCBjcmVhdGVUYWJsZUVsZW1lbnQgPSAoc291cmNlcykgPT4ge1xuICAgIGNvbnN0IHNvdXJjZUNvdW50ID0gc291cmNlcy5sZW5ndGg7XG4gICAgY29uc3QgZWxlbWVudCA9IGNsb25lTm9kZShzb3VyY2VzWzBdKTtcbiAgICBjb25zdCByb3dzQ291bnQgPSBlbGVtZW50LnJvd3MubGVuZ3RoO1xuICAgIGlmIChzb3VyY2VDb3VudCA+IDEpIHtcbiAgICAgICAgZm9yIChsZXQgcm93SWR4ID0gMDsgcm93SWR4IDwgcm93c0NvdW50OyByb3dJZHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgc291cmNlSWR4ID0gMTsgc291cmNlSWR4IDwgc291cmNlQ291bnQ7IHNvdXJjZUlkeCsrKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kTm9kZXMoZWxlbWVudC5yb3dzW3Jvd0lkeF0sIHNvdXJjZXNbc291cmNlSWR4XS5yb3dzW3Jvd0lkeF0uY2VsbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufTtcbmNvbnN0IHNldEZpcnN0Q2VsbENsYXNzID0gKGhlYWRlciwgaGVhZGVycykgPT4ge1xuICAgIGlmIChoZWFkZXJzLmxlbmd0aCA+IDEgJiYgaGVhZGVyLnJvd3MubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAxOyBpZHggPCBoZWFkZXIucm93cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdENlbGxJbmRleCA9IGhlYWRlcnNbMF0ucm93c1tpZHhdLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBoZWFkZXIucm93c1tpZHhdLmNlbGxzW2ZpcnN0Q2VsbEluZGV4XTtcbiAgICAgICAgICAgIGlmIChTdHJpbmcoY2VsbC5jbGFzc05hbWUpLmluZGV4T2YoRklSU1RfQ0xBU1MpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NOYW1lICs9IGAgJHtGSVJTVF9DTEFTU31gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGNyZWF0ZVRhYmxlID0gKGNvbEdyb3VwcywgaGVhZGVycywgYm9kaWVzLCBmb290ZXJzKSA9PiB7XG4gICAgY29uc3QgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuICAgIGNvbnN0IGNvbEdyb3VwID0gY29sR3JvdXBzWzBdLmNsb25lTm9kZSh0cnVlKTtcbiAgICBmb3IgKGxldCBpZHggPSAxOyBpZHggPCBjb2xHcm91cHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBhcHBlbmROb2Rlcyhjb2xHcm91cCwgY29sR3JvdXBzW2lkeF0ucXVlcnlTZWxlY3RvckFsbCgnY29sJykpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBjcmVhdGVUYWJsZUVsZW1lbnQoaGVhZGVycyk7XG4gICAgY29uc3QgYm9keSA9IGNyZWF0ZVRhYmxlRWxlbWVudChib2RpZXMpO1xuICAgIGhlYWRlci5jbGFzc05hbWUgPSBIRUFERVJfQ0xBU1M7XG4gICAgc2V0Rmlyc3RDZWxsQ2xhc3MoaGVhZGVyLCBoZWFkZXJzKTtcbiAgICB0YWJsZS5hcHBlbmRDaGlsZChjb2xHcm91cCk7XG4gICAgdGFibGUuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICB0YWJsZS5hcHBlbmRDaGlsZChib2R5KTtcbiAgICBpZiAoZm9vdGVycy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZm9vdGVyID0gY3JlYXRlVGFibGVFbGVtZW50KGZvb3RlcnMpO1xuICAgICAgICBmb290ZXIuY2xhc3NOYW1lID0gRk9PVEVSX0NMQVNTO1xuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChmb290ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcFRhYmxlKHRhYmxlKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZXhwb3J0RWxlbWVudCA9ICh3cmFwcGVyKSA9PiB7XG4gICAgY29uc3QgcXVlcnkgPSBuZXcgR3JpZFF1ZXJ5KHdyYXBwZXIpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBxdWVyeS5jb250ZW50KCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgICBjb25zdCBjb2xHcm91cHMgPSBbY29udGVudC5xdWVyeVNlbGVjdG9yKCdjb2xncm91cCcpXTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IFtxdWVyeS5oZWFkZXIoKS5xdWVyeVNlbGVjdG9yKCd0aGVhZCcpXTtcbiAgICAgICAgY29uc3QgYm9kaWVzID0gW2NvbnRlbnQucXVlcnlTZWxlY3RvcigndGJvZHknKV07XG4gICAgICAgIGNvbnN0IGZvb3RlciA9IHF1ZXJ5LmZvb3RlcigpO1xuICAgICAgICBjb25zdCBmb290ZXJzID0gW107XG4gICAgICAgIGlmIChmb290ZXIpIHtcbiAgICAgICAgICAgIGZvb3RlcnMucHVzaChmb290ZXIucXVlcnlTZWxlY3RvcigndGZvb3QnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9ja2VkQ29udGVudCA9IHF1ZXJ5LmNvbnRlbnQodHJ1ZSk7XG4gICAgICAgIGlmIChsb2NrZWRDb250ZW50KSB7XG4gICAgICAgICAgICBjb2xHcm91cHMudW5zaGlmdChsb2NrZWRDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvbGdyb3VwJykpO1xuICAgICAgICAgICAgaGVhZGVycy51bnNoaWZ0KHF1ZXJ5LmhlYWRlcih0cnVlKS5xdWVyeVNlbGVjdG9yKCd0aGVhZCcpKTtcbiAgICAgICAgICAgIGJvZGllcy51bnNoaWZ0KGxvY2tlZENvbnRlbnQucXVlcnlTZWxlY3RvcigndGJvZHknKSk7XG4gICAgICAgICAgICBpZiAoZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgZm9vdGVycy51bnNoaWZ0KHF1ZXJ5LmZvb3Rlcih0cnVlKS5xdWVyeVNlbGVjdG9yKCd0Zm9vdCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBjcmVhdGVUYWJsZShjb2xHcm91cHMsIGhlYWRlcnMsIGJvZGllcywgZm9vdGVycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB3cmFwVGFibGUocXVlcnkudGFibGUoKS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY3JlYXRlRWxlbWVudCQxID0gKHRhZ05hbWUsIGNsYXNzTmFtZSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufTtcbmNvbnN0IGNyZWF0ZURpdiA9IChjbGFzc05hbWUpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCQxKCdkaXYnLCBjbGFzc05hbWUpO1xufTtcbi8qKlxuICogQ29uZmlndXJlcyB0aGUgc2V0dGluZ3MgZm9yIHRoZSBleHBvcnQgb2YgR3JpZCBpbiBQREYgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwZGZleHBvcnRfZ3JpZCAlfSkpLlxuICovXG5sZXQgUERGQ29tcG9uZW50ID0gY2xhc3MgUERGQ29tcG9uZW50IGV4dGVuZHMgUERGRXhwb3J0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwZGZTZXJ2aWNlLCBzdXNwZW5kU2VydmljZSwgbmdab25lLCBlbGVtZW50KSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnBkZlNlcnZpY2UgPSBwZGZTZXJ2aWNlO1xuICAgICAgICB0aGlzLnN1c3BlbmRTZXJ2aWNlID0gc3VzcGVuZFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgZXhwb3J0aW5nIHRoZSBHcmlkIGNvbnRlbnQuXG4gICAgICAgICAqIFVzZWZ1bCBmb3Igc2NlbmFyaW9zIHdoaWNoIGludm9sdmUgZXhwb3J0aW5nIGNvbXBsZXggY29tcG9uZW50cyB1c2VkIGluIHRoZSBHcmlkXG4gICAgICAgICAqIHRlbXBsYXRlcyBzdWNoIGFzIGNoYXJ0cyBvciBkYXRhLWJvdW5kIGNvbXBvbmVudHMgd2l0aCBhc3luY2hyb25vdXMgZGF0YSByZXRyaWV2YWwgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwZGZleHBvcnRfZ3JpZCAlfSN0b2MtZXhwb3J0aW5nLWFsbC1wYWdlcykpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLnNhdmVTdWJzY3JpcHRpb24gPSBwZGZTZXJ2aWNlLnNhdmVQREYuc3Vic2NyaWJlKHRoaXMuc2F2ZVBERi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5kcmF3U3Vic2NyaXB0aW9uID0gcGRmU2VydmljZS5kcmF3UERGLnN1YnNjcmliZSh0aGlzLmRyYXdQREYuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucmVzZXQgPSB0aGlzLnJlc2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZHJhdyA9IHRoaXMuZHJhdy5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zYXZlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZHJhd1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzYXZlQXMoXykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQuIFVzZSBHcmlkQ29tcG9uZW50LnNhdmVBc1BERicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZXhwb3J0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQuIFVzZSBHcmlkQ29tcG9uZW50LmRyYXdQREYnKTtcbiAgICB9XG4gICAgc2F2ZVBERihjb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVQREYoY29tcG9uZW50LCB0aGlzLmRyYXcpO1xuICAgIH1cbiAgICBkcmF3UERGKHsgY29tcG9uZW50LCBwcm9taXNlIH0pIHtcbiAgICAgICAgdGhpcy5jcmVhdGVQREYoY29tcG9uZW50LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUV4cG9ydEdyb3VwKHByb21pc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlUERGKGNvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcGFnZVNpemUgPSBjb21wb25lbnQucGFnZVNpemU7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gY29tcG9uZW50LnZpZXcudG90YWw7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMudG9BcnJheSgpO1xuICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxDb2x1bW5zID0gY29tcG9uZW50LmNvbHVtbnMudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLnN1c3BlbmRTZXJ2aWNlLnNjcm9sbCA9IHRydWU7XG4gICAgICAgIHRoaXMucGRmU2VydmljZS5leHBvcnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmluaXRQcm9ncmVzcygpO1xuICAgICAgICB0aGlzLnJlbmRlckFsbFBhZ2VzID0gdGhpcy5hbGxQYWdlcyAmJiBwYWdlU2l6ZSA8IHRvdGFsO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJBbGxQYWdlcykge1xuICAgICAgICAgICAgdGhpcy5za2lwID0gY29tcG9uZW50LnNraXA7XG4gICAgICAgICAgICB0aGlzLnBhZ2VTaXplID0gcGFnZVNpemU7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVBhZ2UoMCwgdG90YWwsIGNhbGxiYWNrLCBjb2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2x1bW5zLmxlbmd0aCB8fCBjb21wb25lbnQudmlydHVhbENvbHVtbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlQ29sdW1ucyhjb2x1bW5zLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRQcm9ncmVzcygpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlckVsZW1lbnQgPSB0aGlzLmNvbXBvbmVudC53cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gdGhpcy5wcm9ncmVzcyA9IGNyZWF0ZURpdignay1sb2FkaW5nLXBkZi1tYXNrJyk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXkgPSBjbG9uZU5vZGUod3JhcHBlckVsZW1lbnQpO1xuICAgICAgICBwcm9ncmVzcy5hcHBlbmRDaGlsZChvdmVybGF5KTtcbiAgICAgICAgcHJvZ3Jlc3MuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2KCdrLWxvYWRpbmctY29sb3InKSk7XG4gICAgICAgIHByb2dyZXNzLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicsICdrLWktbG9hZGluZyBrLWljb24nKSk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxIZWlnaHQgPSB3cmFwcGVyRWxlbWVudC5zdHlsZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3JpZ2luYWxPdmVyZmxvdyA9IHdyYXBwZXJFbGVtZW50LnN0eWxlLm92ZXJmbG93O1xuICAgICAgICB3cmFwcGVyRWxlbWVudC5zdHlsZS5oZWlnaHQgPSB3cmFwcGVyRWxlbWVudC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICB3cmFwcGVyRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB3cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChwcm9ncmVzcyk7XG4gICAgICAgIHRoaXMuYXBwbHlTY3JvbGwob3ZlcmxheSk7XG4gICAgfVxuICAgIGFwcGx5U2Nyb2xsKG92ZXJsYXkpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgR3JpZFF1ZXJ5KHRoaXMuY29tcG9uZW50LndyYXBwZXIubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBxdWVyeS5jb250ZW50KCk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5UXVlcnkgPSBuZXcgR3JpZFF1ZXJ5KG92ZXJsYXkpO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheUNvbnRlbnQgPSBvdmVybGF5UXVlcnkuY29udGVudCgpO1xuICAgICAgICAgICAgb3ZlcmxheUNvbnRlbnQuc2Nyb2xsVG9wID0gY29udGVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBvdmVybGF5Q29udGVudC5zY3JvbGxMZWZ0ID0gY29udGVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgb3ZlcmxheVF1ZXJ5LmhlYWRlcigpLnNjcm9sbExlZnQgPSBxdWVyeS5oZWFkZXIoKS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgY29uc3QgZm9vdGVyID0gcXVlcnkuZm9vdGVyKCk7XG4gICAgICAgICAgICBpZiAoZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheVF1ZXJ5LmZvb3RlcigpLnNjcm9sbExlZnQgPSBmb290ZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2tlZENvbnRlbnQgPSBxdWVyeS5jb250ZW50KHRydWUpO1xuICAgICAgICAgICAgaWYgKGxvY2tlZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5TG9ja2VkQ29udGVudCA9IG92ZXJsYXlRdWVyeS5jb250ZW50KHRydWUpO1xuICAgICAgICAgICAgICAgIG92ZXJsYXlMb2NrZWRDb250ZW50LnNjcm9sbFRvcCA9IGxvY2tlZENvbnRlbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIG92ZXJsYXlMb2NrZWRDb250ZW50LnNjcm9sbExlZnQgPSBsb2NrZWRDb250ZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVFeHBvcnRFbGVtZW50KChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhdmUoZWxlbWVudCwgdGhpcy5maWxlTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVFeHBvcnRHcm91cChwcm9taXNlKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlRXhwb3J0RWxlbWVudCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRFbGVtZW50KGVsZW1lbnQpLnRoZW4oZ3JvdXAgPT4gcHJvbWlzZS5yZXNvbHZlKGdyb3VwKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVFeHBvcnRFbGVtZW50KGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyID0gY3JlYXRlRGl2KCdrLWdyaWQtcGRmLWV4cG9ydC1lbGVtZW50Jyk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZXhwb3J0RWxlbWVudCh0aGlzLmNvbXBvbmVudC53cmFwcGVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkcmF3T3B0aW9ucygpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHN1cGVyLmRyYXdPcHRpb25zKCk7XG4gICAgICAgIG9wdGlvbnMuX2Rlc3RydWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHN1cGVyLmNsZWFudXAoKTtcbiAgICAgICAgdGhpcy5wZGZTZXJ2aWNlLmV4cG9ydGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ29sdW1ucyA9IHRoaXMub3JpZ2luYWxDb2x1bW5zO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3JpZ2luYWxDb2x1bW5zO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyQWxsUGFnZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVBhZ2UodGhpcy5za2lwLCB0aGlzLnBhZ2VTaXplLCB0aGlzLnJlc2V0LCBvcmlnaW5hbENvbHVtbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luYWxDb2x1bW5zIHx8IHRoaXMuY29tcG9uZW50LnZpcnR1YWxDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VDb2x1bW5zKG9yaWdpbmFsQ29sdW1ucywgdGhpcy5yZXNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVDb250YWluZXIoKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVBhZ2Uoc2tpcCwgX3Rha2UsIGNhbGxiYWNrLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBkZlNlcnZpY2UuZGF0YUNoYW5nZWQucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgoY29sdW1ucyAmJiBjb2x1bW5zLmxlbmd0aCkgfHwgdGhpcy5jb21wb25lbnQudmlydHVhbENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VDb2x1bW5zKGNvbHVtbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TdGFibGUoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQubm90aWZ5UGFnZUNoYW5nZSgncGRmJywgeyBza2lwOiBza2lwLCB0YWtlOiBfdGFrZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoYW5nZUNvbHVtbnMoY29sdW1ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25TdGFibGUoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGNvbHVtbnMgJiYgY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5jb2x1bW5zLnJlc2V0KGNvbHVtbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZFNlcnZpY2Uuc2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyQWxsUGFnZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZXJFbGVtZW50ID0gdGhpcy5jb21wb25lbnQud3JhcHBlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICB3cmFwcGVyRWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnByb2dyZXNzKTtcbiAgICAgICAgd3JhcHBlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5vcmlnaW5hbEhlaWdodDtcbiAgICAgICAgd3JhcHBlckVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLm9yaWdpbmFsT3ZlcmZsb3c7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb2dyZXNzO1xuICAgICAgICBkZWxldGUgdGhpcy5jb21wb25lbnQ7XG4gICAgfVxuICAgIG9uU3RhYmxlKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIG5vdCBzdXJlIGlmIGl0IGlzIGFuIGFjdHVhbCBzY2VuYXJpby4gb2NjdXJzIGluIHRoZSB0ZXN0cy5cbiAgICAgICAgLy8gb25TdGFibGUgaXMgdHJpZ2dlcmVkIGluIHRoZSBzYW1lIHBhc3Mgd2l0aG91dCB0aGUgY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgICAgLy8gdGh1cywgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGNoYW5nZXMgYXJlIGFwcGxpZWQgd2l0aG91dCB0aGUgdGltZW91dC5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgb25TdGFibGUgPSB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgb25TdGFibGUgPSBvblN0YWJsZS5waXBlKGRlbGF5KHRoaXMuZGVsYXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uU3RhYmxlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIH0sIDApOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOiBhbGlnblxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUERGQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbGxQYWdlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUERGQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWxheVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKENvbHVtbkJhc2UkMSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFBERkNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFBERk1hcmdpbkNvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQREZNYXJnaW5Db21wb25lbnQpXG5dLCBQREZDb21wb25lbnQucHJvdG90eXBlLCBcIm1hcmdpbkNvbXBvbmVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFBERlRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFBERlRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgUERGQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWdlVGVtcGxhdGVEaXJlY3RpdmVcIiwgdm9pZCAwKTtcblBERkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZC1wZGYnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BERlNlcnZpY2UsXG4gICAgICAgIFN1c3BlbmRTZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIEVsZW1lbnRSZWZdKVxuXSwgUERGQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgZXhwb3J0LXRvLVBERmAgY29tbWFuZCBvZiB0aGUgR3JpZC5cbiAqIFlvdSBjYW4gYXBwbHkgdGhpcyBkaXJlY3RpdmUgdG8gYW55IGBidXR0b25gIGVsZW1lbnQgaW5zaWRlIGFcbiAqIFtUb29sYmFyVGVtcGxhdGVdKHslIHNsdWcgYXBpX2dyaWRfY29tbWFuZGNvbHVtbmNvbXBvbmVudCAlfSkuXG4gKiBXaGVuIHRoZSB1c2VyIGNsaWNrcyBhIGJ1dHRvbiB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGlyZWN0aXZlLCB0aGVcbiAqIFtwZGZFeHBvcnRdKHslIHNsdWcgYXBpX2dyaWRfZ3JpZGNvbXBvbmVudCAlfSN0b2MtcGRmZXhwb3J0KSBldmVudFxuICogZmlyZXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwZGZleHBvcnRfZ3JpZCAlfSkpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLWdyaWQ+XG4gKiAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0dyaWRUb29sYmFyVGVtcGxhdGU+XG4gKiAgICAgICAgICA8YnV0dG9uIGtlbmRvR3JpZFBERkNvbW1hbmQ+RXhwb3J0IHRvIFBERjwvYnV0dG9uPlxuICogICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8a2VuZG8tZ3JpZC1wZGYgZmlsZU5hbWU9XCJHcmlkLnBkZlwiPlxuICogICAgICA8L2tlbmRvLWdyaWQtcGRmPlxuICogPC9rZW5kby1ncmlkPlxuICogYGBgXG4gKi9cbmxldCBQREZDb21tYW5kRGlyZWN0aXZlID0gY2xhc3MgUERGQ29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJ1dHRvbiB7XG4gICAgY29uc3RydWN0b3IocGRmU2VydmljZSwgZWxlbWVudCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnQsIHJlbmRlcmVyLCBudWxsLCBsb2NhbGl6YXRpb24sIG5nWm9uZSk7XG4gICAgICAgIHRoaXMucGRmU2VydmljZSA9IHBkZlNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25DbGljayhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5wZGZTZXJ2aWNlLmV4cG9ydENsaWNrLmVtaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBwZGZDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFBERkNvbW1hbmREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1ncmlkLXBkZicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQREZDb21tYW5kRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwZGZDbGFzc1wiLCBudWxsKTtcblBERkNvbW1hbmREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0dyaWRQREZDb21tYW5kXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BERlNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgTmdab25lXSlcbl0sIFBERkNvbW1hbmREaXJlY3RpdmUpO1xuXG5jb25zdCBleHBvcnRlZE1vZHVsZXMkNSA9IFtcbiAgICBQREZDb21wb25lbnQsXG4gICAgUERGTWFyZ2luQ29tcG9uZW50LFxuICAgIFBERkNvbW1hbmREaXJlY3RpdmUsXG4gICAgUERGVGVtcGxhdGVEaXJlY3RpdmVcbl07XG5jb25zdCBkZWNsYXJhdGlvbnMkMSA9IFtcbiAgICBQREZDb21wb25lbnQsXG4gICAgUERGTWFyZ2luQ29tcG9uZW50LFxuICAgIFBERkNvbW1hbmREaXJlY3RpdmUsXG4gICAgUERGVGVtcGxhdGVEaXJlY3RpdmVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBHcmlkIFBERiBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgR3JpZCBhbmQgUERGIG1vZHVsZXNcbiAqIGltcG9ydCB7IEdyaWRNb2R1bGUsIFBERk1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWdyaWQnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBHcmlkTW9kdWxlLCBQREZNb2R1bGVdLCAvLyBpbXBvcnQgR3JpZCBhbmQgUERGIG1vZHVsZXNcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBQREZNb2R1bGUgPSBjbGFzcyBQREZNb2R1bGUge1xufTtcblBERk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDFdLFxuICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDVdXG4gICAgfSlcbl0sIFBERk1vZHVsZSk7XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGV4Y2VsRXhwb3J0YCBldmVudC5cbiAqL1xuY2xhc3MgRXhjZWxFeHBvcnRFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHdvcmtib29rKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud29ya2Jvb2sgPSB3b3JrYm9vaztcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlIG9iamVjdC1saXRlcmFsLXNvcnQta2V5cyAqL1xuY29uc3QgZmV0Y2hDb21wb25lbnREYXRhID0gKGNvbXBvbmVudCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGNvbXBvbmVudC52aWV3Lm1hcChpdGVtID0+IGl0ZW0pLFxuICAgICAgICBncm91cDogY29tcG9uZW50Lmdyb3VwXG4gICAgfTtcbn07XG5jb25zdCB0b0V4Y2VsQ29sdW1uID0gKGNvbHVtbikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiBjb2x1bW4udGl0bGUsXG4gICAgICAgIGZpZWxkOiBjb2x1bW4uZmllbGQsXG4gICAgICAgIGxvY2tlZDogQm9vbGVhbihjb2x1bW4ubG9ja2VkKSxcbiAgICAgICAgd2lkdGg6IGNvbHVtbi53aWR0aCxcbiAgICAgICAgbGV2ZWw6IGNvbHVtbi5sZXZlbCxcbiAgICAgICAgaGlkZGVuOiAhY29sdW1uLmlzVmlzaWJsZSxcbiAgICAgICAgZ3JvdXBIZWFkZXJUZW1wbGF0ZTogY29sdW1uLmdyb3VwSGVhZGVyVGVtcGxhdGUsXG4gICAgICAgIGdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGU6IGNvbHVtbi5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlLFxuICAgICAgICBncm91cEZvb3RlclRlbXBsYXRlOiBjb2x1bW4uZ3JvdXBGb290ZXJUZW1wbGF0ZSxcbiAgICAgICAgZm9vdGVyVGVtcGxhdGU6IGNvbHVtbi5mb290ZXJUZW1wbGF0ZVxuICAgIH07XG59O1xuY29uc3QgdG9FeGNlbENvbHVtbnMgPSAoY29sdW1ucykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHNvcnRDb2x1bW5zKGNvbHVtbnMpXG4gICAgICAgIC5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbi5pc1NwYW5Db2x1bW4pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLnRvRXhjZWxDb2x1bW5zKGNvbHVtbi5jaGlsZHJlbkFycmF5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleGNlbENvbHVtbiA9IHRvRXhjZWxDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uaXNDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIGV4Y2VsQ29sdW1uLmNoaWxkcmVuID0gW2V4Y2VsQ29sdW1uXS5jb25jYXQodG9FeGNlbENvbHVtbnMoY29sdW1uLmNoaWxkcmVuQXJyYXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4Y2VsQ29sdW1uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgY29tcG9uZW50Q29sdW1ucyA9IChjb21wb25lbnQpID0+IHtcbiAgICBjb25zdCBjb2x1bW5zID0gdG9FeGNlbENvbHVtbnMoY29tcG9uZW50LmNvbHVtbnMudG9BcnJheSgpKTtcbiAgICByZXR1cm4gb3JkZXJCeShjb2x1bW5zLCBbeyBmaWVsZDogJ2xvY2tlZCcsIGRpcjogJ2Rlc2MnIH1dKTtcbn07XG4vKipcbiAqIENvbmZpZ3VyZXMgdGhlIHNldHRpbmdzIGZvciB0aGUgZXhwb3J0IG9mIEdyaWQgaW4gRXhjZWwgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBleGNlbGV4cG9ydF9ncmlkICV9KSkuXG4gKi9cbmxldCBFeGNlbENvbXBvbmVudCA9IGNsYXNzIEV4Y2VsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihleGNlbFNlcnZpY2UsIGxvY2FsaXphdGlvbiwgem9uZSkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZmlsZSBuYW1lIG9mIHRoZSBleHBvcnRlZCBFeGNlbCBmaWxlLlxuICAgICAgICAgKiBAZGVmYXVsdCBcIkV4cG9ydC54bHN4XCJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSAnRXhwb3J0Lnhsc3gnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLnNhdmVTdWJzY3JpcHRpb24gPSBleGNlbFNlcnZpY2Uuc2F2ZVRvRXhjZWwuc3Vic2NyaWJlKHRoaXMuc2F2ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2F2ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAodGhpcy5kYXRhU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzYXZlKGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBkYXRhID0gKHRoaXMuZmV0Y2hEYXRhIHx8IGZldGNoQ29tcG9uZW50RGF0YSkoY29tcG9uZW50KTtcbiAgICAgICAgY29uc3QgZXhwb3J0RGF0YSA9IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFTdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0aGlzLmV4cG9ydERhdGEoY29tcG9uZW50LCByZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIGRhdGEudGhlbihleHBvcnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU3Vic2NyaXB0aW9uID0gZGF0YS5waXBlKHRha2UoMSkpLnN1YnNjcmliZShleHBvcnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydERhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0RGF0YShjb21wb25lbnQsIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gd29ya2Jvb2tPcHRpb25zKHtcbiAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuY29sdW1ucy5sZW5ndGggPyB0aGlzLmNvbHVtbnMgOiBjb21wb25lbnRDb2x1bW5zKGNvbXBvbmVudCksXG4gICAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgIGdyb3VwOiByZXN1bHQuZ3JvdXAsXG4gICAgICAgICAgICBmaWx0ZXJhYmxlOiB0aGlzLmZpbHRlcmFibGUsXG4gICAgICAgICAgICBjcmVhdG9yOiB0aGlzLmNyZWF0b3IsXG4gICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGUsXG4gICAgICAgICAgICBwYWRkaW5nQ2VsbE9wdGlvbnM6IHRoaXMucGFkZGluZ0NlbGxPcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zOiB0aGlzLmhlYWRlclBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgICAgIHJ0bDogdGhpcy5sb2NhbGl6YXRpb24ucnRsLFxuICAgICAgICAgICAgY29sbGFwc2libGU6IHRoaXMuY29sbGFwc2libGVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBuZXcgRXhjZWxFeHBvcnRFdmVudChvcHRpb25zKTtcbiAgICAgICAgY29tcG9uZW50LmV4Y2VsRXhwb3J0LmVtaXQoYXJncyk7XG4gICAgICAgIGlmICghYXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuc2F2ZUZpbGUob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNhdmVGaWxlKG9wdGlvbnMpIHtcbiAgICAgICAgdG9EYXRhVVJMKG9wdGlvbnMpLnRoZW4oKGRhdGFVUkwpID0+IHtcbiAgICAgICAgICAgIHNhdmVBcyhkYXRhVVJMLCB0aGlzLmZpbGVOYW1lLCB7XG4gICAgICAgICAgICAgICAgZm9yY2VQcm94eTogdGhpcy5mb3JjZVByb3h5LFxuICAgICAgICAgICAgICAgIHByb3h5VVJMOiB0aGlzLnByb3h5VVJMXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEV4Y2VsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxlTmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEV4Y2VsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBFeGNlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3JlYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIEV4Y2VsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRXhjZWxDb21wb25lbnQucHJvdG90eXBlLCBcImZvcmNlUHJveHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEV4Y2VsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcm94eVVSTFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBFeGNlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmV0Y2hEYXRhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBFeGNlbENvbXBvbmVudC5wcm90b3R5cGUsIFwicGFkZGluZ0NlbGxPcHRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBFeGNlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRXhjZWxDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oQ29sdW1uQmFzZSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgRXhjZWxDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbnNcIiwgdm9pZCAwKTtcbkV4Y2VsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1ncmlkLWV4Y2VsJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFeGNlbFNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBFeGNlbENvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYGV4cG9ydC10by1FeGNlbGAgY29tbWFuZCBvZiB0aGUgR3JpZC4gWW91IGNhbiBhcHBseSB0aGlzXG4gKiBkaXJlY3RpdmUgdG8gYW55IGBidXR0b25gIGVsZW1lbnQgaW5zaWRlIGFcbiAqIFtUb29sYmFyVGVtcGxhdGVdKHslIHNsdWcgYXBpX2dyaWRfY29tbWFuZGNvbHVtbmNvbXBvbmVudCAlfSkuXG4gKiBXaGVuIHRoZSB1c2VyIGNsaWNrcyBhIGJ1dHRvbiBhc3NvY2lhdGVkIHdpdGggdGhlIGRpcmVjdGl2ZSwgdGhlXG4gKiBbZXhjZWxFeHBvcnRdKHslIHNsdWcgYXBpX2dyaWRfZ3JpZGNvbXBvbmVudCAlfSN0b2MtZXhjZWxleHBvcnQpIGV2ZW50XG4gKiBmaXJlcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGV4Y2VsZXhwb3J0X2dyaWQgJX0pKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbC1uby1ydW5cbiAqIDxrZW5kby1ncmlkPlxuICogICAgICA8bmctdGVtcGxhdGUga2VuZG9HcmlkVG9vbGJhclRlbXBsYXRlPlxuICogICAgICAgICAgPGJ1dHRvbiBrZW5kb0dyaWRFeGNlbENvbW1hbmQ+RXhwb3J0IHRvIFBERjwvYnV0dG9uPlxuICogICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8a2VuZG8tZ3JpZC1leGNlbCBmaWxlTmFtZT1cIkdyaWQueGxzeFwiPlxuICogICAgICA8L2tlbmRvLWdyaWQtZXhjZWw+XG4gKiA8L2tlbmRvLWdyaWQ+XG4gKiBgYGBcbiAqL1xubGV0IEV4Y2VsQ29tbWFuZERpcmVjdGl2ZSA9IGNsYXNzIEV4Y2VsQ29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJ1dHRvbiB7XG4gICAgY29uc3RydWN0b3IoZXhjZWxTZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudCwgcmVuZGVyZXIsIG51bGwsIGxvY2FsaXphdGlvbiwgbmdab25lKTtcbiAgICAgICAgdGhpcy5leGNlbFNlcnZpY2UgPSBleGNlbFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25DbGljayhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5leGNlbFNlcnZpY2UuZXhwb3J0Q2xpY2suZW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGV4Y2VsQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBFeGNlbENvbW1hbmREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1ncmlkLWV4Y2VsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEV4Y2VsQ29tbWFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXhjZWxDbGFzc1wiLCBudWxsKTtcbkV4Y2VsQ29tbWFuZERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvR3JpZEV4Y2VsQ29tbWFuZF0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFeGNlbFNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgTmdab25lXSlcbl0sIEV4Y2VsQ29tbWFuZERpcmVjdGl2ZSk7XG5cbmNvbnN0IGRlY2xhcmF0aW9ucyQyID0gW0V4Y2VsQ29tcG9uZW50LCBFeGNlbENvbW1hbmREaXJlY3RpdmVdO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgRXhjZWwgY29tcG9uZW50IG9mIHRoZSBHcmlkLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIEdyaWQgYW5kIEV4Y2VsIG1vZHVsZXNcbiAqIGltcG9ydCB7IEdyaWRNb2R1bGUsIEV4Y2VsTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZ3JpZCc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIEdyaWRNb2R1bGUsIEV4Y2VsTW9kdWxlXSwgLy8gaW1wb3J0IEdyaWQgYW5kIEV4Y2VsIG1vZHVsZXNcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBFeGNlbE1vZHVsZSA9IGNsYXNzIEV4Y2VsTW9kdWxlIHtcbn07XG5FeGNlbE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDJdLFxuICAgICAgICBleHBvcnRzOiBbZGVjbGFyYXRpb25zJDIsIEV4Y2VsRXhwb3J0TW9kdWxlXVxuICAgIH0pXG5dLCBFeGNlbE1vZHVsZSk7XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQ29sdW1uQ2hvb3NlckNvbXBvbmVudCwgQ29sdW1uTGlzdENvbXBvbmVudCwgQ29sdW1uTWVudUNob29zZXJDb21wb25lbnQsIENvbHVtbk1lbnVDb250YWluZXJDb21wb25lbnQsIENvbHVtbk1lbnVGaWx0ZXJDb21wb25lbnQsIENvbHVtbk1lbnVJdGVtQmFzZSwgQ29sdW1uTWVudUl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUsIENvbHVtbk1lbnVJdGVtQ29tcG9uZW50LCBDb2x1bW5NZW51SXRlbURpcmVjdGl2ZSwgQ29sdW1uTWVudUxvY2tDb21wb25lbnQsIENvbHVtbk1lbnVQb3NpdGlvbkNvbXBvbmVudCwgQ29sdW1uTWVudVNvcnRDb21wb25lbnQsIENvbHVtbk1lbnVTdGlja0NvbXBvbmVudCwgQ29sdW1uTWVudVRlbXBsYXRlRGlyZWN0aXZlLCBDb2x1bW5NZW51TW9kdWxlLCBDb2x1bW5NZW51U2VydmljZSwgQ29sdW1uSGFuZGxlRGlyZWN0aXZlLCBDb2x1bW5SZXNpemluZ1NlcnZpY2UsIFRhYmxlRGlyZWN0aXZlLCBDb2x1bW5JbmZvU2VydmljZSwgRG9tRXZlbnRzU2VydmljZSwgSWRTZXJ2aWNlLCBQcmV2ZW50YWJsZUV2ZW50LCBTb3J0U2VydmljZSwgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSwgQ29sdW1uUmVvcmRlclNlcnZpY2UsIERyYWdBbmREcm9wTW9kdWxlLCBEcmFnQW5kRHJvcFNlcnZpY2UsIERyYWdIaW50U2VydmljZSwgRHJhZ2dhYmxlQ29sdW1uRGlyZWN0aXZlLCBEcm9wQ3VlU2VydmljZSwgRHJvcFRhcmdldERpcmVjdGl2ZSwgRWRpdGluZ0RpcmVjdGl2ZUJhc2UsIFJvd0VkaXRpbmdEaXJlY3RpdmVCYXNlLCBBZGRDb21tYW5kRGlyZWN0aXZlLCBDYW5jZWxDb21tYW5kRGlyZWN0aXZlLCBFZGl0Q29tbWFuZERpcmVjdGl2ZSwgRWRpdFNlcnZpY2UgYXMgRWRpdFNlcnZpY2UkMSwgTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UsIFJlbW92ZUNvbW1hbmREaXJlY3RpdmUsIFNhdmVDb21tYW5kRGlyZWN0aXZlLCBFeGNlbENvbW1hbmREaXJlY3RpdmUsIEJvb2xlYW5GaWx0ZXJDb21wb25lbnQsIEJvb2xlYW5GaWx0ZXJDZWxsQ29tcG9uZW50LCBGaWx0ZXJDZWxsSG9zdERpcmVjdGl2ZSwgRmlsdGVyQ2VsbE9wZXJhdG9yc0NvbXBvbmVudCwgRmlsdGVyQ2VsbFdyYXBwZXJDb21wb25lbnQsIERhdGVGaWx0ZXJDb21wb25lbnQsIEZpbHRlckhvc3REaXJlY3RpdmUsIEZpbHRlcklucHV0V3JhcHBlckNvbXBvbmVudCwgRmlsdGVySW5wdXREaXJlY3RpdmUsIEZpbHRlclJvd0NvbXBvbmVudCwgRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudCwgRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudCwgRmlsdGVyTWVudURyb3BEb3duTGlzdERpcmVjdGl2ZSwgRmlsdGVyTWVudUhvc3REaXJlY3RpdmUsIEZpbHRlck1lbnVJbnB1dFdyYXBwZXJDb21wb25lbnQsIEZpbHRlck1lbnVDb21wb25lbnQsIEJvb2xlYW5GaWx0ZXJSYWRpb0J1dHRvbkRpcmVjdGl2ZSwgTnVtZXJpY0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudCwgU3RyaW5nRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LCBOdW1lcmljRmlsdGVyQ29tcG9uZW50LCBGaWx0ZXJPcGVyYXRvckJhc2UsIFNoYXJlZEZpbHRlck1vZHVsZSwgU3RyaW5nRmlsdGVyQ29tcG9uZW50LCBHcm91cEhlYWRlckNvbXBvbmVudCwgR3JvdXBJbmRpY2F0b3JDb21wb25lbnQsIEdyb3VwSW5mb1NlcnZpY2UsIEdyb3VwUGFuZWxDb21wb25lbnQsIEdyb3Vwc1NlcnZpY2UsIEJyb3dzZXJTdXBwb3J0U2VydmljZSwgUmVzaXplU2VydmljZSwgUmVzcG9uc2l2ZVNlcnZpY2UsIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLCBNZXNzYWdlcywgRm9jdXNHcm91cCwgRk9DVVNfUk9PVF9BQ1RJVkUsIEZvY3VzUm9vdCwgTG9naWNhbENlbGxEaXJlY3RpdmUsIExvZ2ljYWxSb3dEaXJlY3RpdmUsIE5hdmlnYXRpb25TZXJ2aWNlLCBQYWdlckNvbnRleHRTZXJ2aWNlLCBQYWdlckRyb3BEb3duTGlzdERpcmVjdGl2ZSwgUGFnZXJFbGVtZW50Q29tcG9uZW50LCBQYWdlcklucHV0RGlyZWN0aXZlLCBQREZDb21tYW5kRGlyZWN0aXZlLCBQREZUZW1wbGF0ZURpcmVjdGl2ZSwgQ2VsbENvbXBvbmVudCwgQ0VMTF9DT05URVhULCBFTVBUWV9DRUxMX0NPTlRFWFQsIEZpZWxkQWNjZXNzb3JQaXBlLCBEZXRhaWxzU2VydmljZSwgREVGQVVMVF9TQ1JPTExFUl9GQUNUT1JZLCBTQ1JPTExFUl9GQUNUT1JZX1RPS0VOLCBTY3JvbGxSZXF1ZXN0U2VydmljZSwgU2Nyb2xsU3luY1NlcnZpY2UsIFNjcm9sbGVyU2VydmljZSwgQ2VsbFNlbGVjdGlvblNlcnZpY2UsIEdyaWRNYXJxdWVlRGlyZWN0aXZlLCBTZWxlY3RBbGxDaGVja2JveERpcmVjdGl2ZSwgU2VsZWN0aW9uQ2hlY2tib3hEaXJlY3RpdmUsIFNlbGVjdGlvbiwgU2VsZWN0aW9uU2VydmljZSwgR3JpZE1vZHVsZSwgU2hhcmVkTW9kdWxlLCBHcmlkQ29tcG9uZW50LCBDb2x1bW5CYXNlJDEgYXMgQ29sdW1uQmFzZSwgQ29sdW1uQ29tcG9uZW50LCBDb21tYW5kQ29sdW1uQ29tcG9uZW50LCBTcGFuQ29sdW1uQ29tcG9uZW50LCBDb2x1bW5Hcm91cENvbXBvbmVudCwgQ2hlY2tib3hDb2x1bW5Db21wb25lbnQsIFRvb2xiYXJDb21wb25lbnQsIFRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZSwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCBDZWxsTG9hZGluZ1RlbXBsYXRlRGlyZWN0aXZlLCBMb2FkaW5nVGVtcGxhdGVEaXJlY3RpdmUsIEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgUGFnZXJUZW1wbGF0ZURpcmVjdGl2ZSwgR3JpZFNwYWNlckNvbXBvbmVudCwgRXhwYW5kRGV0YWlsc0RpcmVjdGl2ZSwgRXhwYW5kR3JvdXBEaXJlY3RpdmUsIERldGFpbFRlbXBsYXRlRGlyZWN0aXZlLCBEZXRhaWxFeHBhbmRFdmVudCwgRGV0YWlsQ29sbGFwc2VFdmVudCwgR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSwgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgUmVzaXphYmxlQ29udGFpbmVyRGlyZWN0aXZlLCBUZW1wbGF0ZUNvbnRleHREaXJlY3RpdmUsIE5vUmVjb3Jkc1RlbXBsYXRlRGlyZWN0aXZlLCBEYXRhQmluZGluZ0RpcmVjdGl2ZSwgU2VsZWN0aW9uRGlyZWN0aXZlLCBGaWx0ZXJTZXJ2aWNlLCBGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIEZpbHRlckNlbGxDb21wb25lbnQsIFN0cmluZ0ZpbHRlckNlbGxDb21wb25lbnQsIERhdGVGaWx0ZXJDZWxsQ29tcG9uZW50LCBCYXNlRmlsdGVyQ2VsbENvbXBvbmVudCwgRmlsdGVyTWVudVRlbXBsYXRlRGlyZWN0aXZlLCBOdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudCwgU3RyaW5nRmlsdGVyTWVudUNvbXBvbmVudCwgRGF0ZUZpbHRlck1lbnVDb21wb25lbnQsIEJvb2xlYW5GaWx0ZXJNZW51Q29tcG9uZW50LCBCZWZvcmVFcUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBCZWZvcmVGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgQWZ0ZXJFcUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBBZnRlckZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBDb250YWluc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBEb2VzTm90Q29udGFpbkZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBFbmRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBJc0VtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnQsIElzTm90RW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgSXNOb3ROdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsIElzTnVsbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBOb3RFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBTdGFydHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsIE51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50LCBBdXRvQ29tcGxldGVGaWx0ZXJDZWxsQ29tcG9uZW50LCBHcmVhdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsIEdyZWF0ZXJPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgTGVzc09yRXF1YWxUb0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBMZXNzRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsIFBhZ2VyUHJldkJ1dHRvbnNDb21wb25lbnQsIFBhZ2VyTmV4dEJ1dHRvbnNDb21wb25lbnQsIFBhZ2VyTnVtZXJpY0J1dHRvbnNDb21wb25lbnQsIFBhZ2VySW5wdXRDb21wb25lbnQsIFBhZ2VySW5mb0NvbXBvbmVudCwgUGFnZXJQYWdlU2l6ZXNDb21wb25lbnQsIFJvd0ZpbHRlck1vZHVsZSwgRmlsdGVyTWVudU1vZHVsZSwgQm9keU1vZHVsZSwgR3JvdXBNb2R1bGUsIEhlYWRlck1vZHVsZSwgRm9vdGVyTW9kdWxlLCBQYWdlck1vZHVsZSwgVGVtcGxhdGVFZGl0aW5nRGlyZWN0aXZlLCBSZWFjdGl2ZUVkaXRpbmdEaXJlY3RpdmUsIEluQ2VsbEVkaXRpbmdEaXJlY3RpdmUsIEVkaXRUZW1wbGF0ZURpcmVjdGl2ZSwgQ29sR3JvdXBDb21wb25lbnQsIEhlYWRlckNvbXBvbmVudCwgTGlzdENvbXBvbmVudCwgRm9vdGVyQ29tcG9uZW50LCBUYWJsZUJvZHlDb21wb25lbnQsIFBhZ2VyQ29tcG9uZW50LCBDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgTG9hZGluZ0NvbXBvbmVudCwgUERGTW9kdWxlLCBQREZDb21wb25lbnQsIFBERk1hcmdpbkNvbXBvbmVudCwgUERGU2VydmljZSwgRXhjZWxNb2R1bGUsIEV4Y2VsQ29tcG9uZW50LCBFeGNlbFNlcnZpY2UsIEV4Y2VsRXhwb3J0RXZlbnQsIENlbGxDbG9zZUV2ZW50LCBTdXNwZW5kU2VydmljZSwgR3JvdXBCaW5kaW5nRGlyZWN0aXZlLCBzbGljZSwgY291bnQsIFNraXAsIENvbHVtblJlb3JkZXJFdmVudCwgRm9jdXNhYmxlRGlyZWN0aXZlLCBDb2x1bW5WaXNpYmlsaXR5Q2hhbmdlRXZlbnQsIENvbHVtbk1lbnVDb21wb25lbnQsIENvbHVtbkxvY2tlZENoYW5nZUV2ZW50LCBDb2x1bW5TdGlja3lDaGFuZ2VFdmVudCwgU2luZ2xlUG9wdXBTZXJ2aWNlLCBQb3B1cENsb3NlRXZlbnQsIE1lbnVUYWJiaW5nU2VydmljZSB9O1xuIl19