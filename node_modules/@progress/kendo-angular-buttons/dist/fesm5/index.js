/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param, __extends } from 'tslib';
import { Injectable, Input, Output, EventEmitter, HostBinding, HostListener, Directive, Optional, ElementRef, Renderer2, NgZone, isDevMode, ContentChildren, QueryList, Component, NgModule, TemplateRef, ViewContainerRef, InjectionToken, Inject, ContentChild, ViewChild, ChangeDetectorRef, forwardRef } from '@angular/core';
import { Subject, fromEvent, merge, Subscription } from 'rxjs';
import { isDocumentAvailable, Keys, isChanged, hasObservers, guid, EventsModule } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { validatePackage } from '@progress/kendo-licensing';
import { detectDesktopBrowser, detectMobileOS } from '@progress/kendo-common';
import { CommonModule } from '@angular/common';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import { filter, take } from 'rxjs/operators';
import { sequence, query, style, stagger, animate, AnimationBuilder } from '@angular/animations';

/**
 * @hidden
 */
var KendoButtonService = /** @class */ (function () {
    function KendoButtonService() {
        this.buttonClicked = new Subject();
        this.buttonClicked$ = this.buttonClicked.asObservable();
    }
    KendoButtonService.prototype.click = function (button) {
        this.buttonClicked.next(button);
    };
    KendoButtonService = __decorate([
        Injectable()
    ], KendoButtonService);
    return KendoButtonService;
}());

/**
 * @hidden
 */
var packageMetadata = {
    name: '@progress/kendo-angular-buttons',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1648649426,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/* tslint:disable:no-null-keyword */
var resolvedPromise = Promise.resolve(null);
/**
 * @hidden
 */
var isPresent = function (value) { return value !== null && value !== undefined; };
/**
 * @hidden
 */
var tick = function (f) { return (resolvedPromise.then(f)); };
/**
 * @hidden
 */
function isDocumentNode(container) {
    return container.nodeType === 9;
}
/**
 * @hidden
 */
function closest(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
    var matches = Element.prototype.matches ?
        function (el, sel) { return el.matches(sel); }
        : function (el, sel) { return el.msMatchesSelector(sel); };
    var node = element;
    while (node && !isDocumentNode(node)) {
        if (matches(node, selector)) {
            return node;
        }
        node = node.parentNode;
    }
}
/**
 * @hidden
 */
var replaceMessagePlaceholder = function (message, name, value) {
    return message.replace(new RegExp("{\\s*" + name + "\\s*}", 'g'), value);
};
/**
 * @hidden
 */
var SIZES = {
    small: 'sm',
    medium: 'md',
    large: 'lg'
};
var ROUNDNESS = {
    small: 'sm',
    medium: 'md',
    large: 'lg',
    full: 'full'
};
/**
 * @hidden
 *
 * Returns the styling classes to be added and removed
 */
var getStylingClasses = function (componentType, stylingOption, previousValue, newValue) {
    switch (stylingOption) {
        case 'size':
            return {
                toRemove: "k-" + componentType + "-" + SIZES[previousValue],
                toAdd: newValue ? "k-" + componentType + "-" + SIZES[newValue] : null
            };
        case 'rounded':
            return {
                toRemove: "k-rounded-" + ROUNDNESS[previousValue],
                toAdd: newValue ? "k-rounded-" + ROUNDNESS[newValue] : null
            };
        case 'fillMode':
        case 'shape':
            return {
                toRemove: "k-" + componentType + "-" + previousValue,
                toAdd: newValue ? "k-" + componentType + "-" + newValue : null
            };
        default:
            break;
    }
};
/**
 * @hidden
 *
 * Returns the themeColor classes to be added and removed
 */
var getThemeColorClasses = function (componentType, prevFillMode, fillMode, previousValue, newValue) {
    return {
        toRemove: "k-" + componentType + "-" + prevFillMode + "-" + previousValue,
        toAdd: newValue ? "k-" + componentType + "-" + fillMode + "-" + newValue : null
    };
};
/**
 * @hidden
 *
 * Returns true if the used browser is Firefox.
 */
var isFirefox = function (userAgent) {
    var desktopBrowser = detectDesktopBrowser(userAgent);
    var mobileOS = detectMobileOS(userAgent);
    return (desktopBrowser && desktopBrowser.mozilla) || (mobileOS && mobileOS.browser === 'firefox');
};

var SPAN_TAG_NAME = 'SPAN';
/**
 * Represents the Kendo UI Button component for Angular.
 */
var ButtonDirective = /** @class */ (function () {
    function ButtonDirective(element, renderer, service, localization, ngZone) {
        var _this = this;
        this.service = service;
        this.ngZone = ngZone;
        /**
         * Provides visual styling that indicates if the Button is active.
         * By default, `toggleable` is set to `false`.
         */
        this.toggleable = false;
        /**
         * @hidden
         */
        this.role = 'button';
        /**
         * Fires each time the selected state of a toggleable button is changed.
         *
         * The event argument is the new selected state (boolean).
         */
        this.selectedChange = new EventEmitter();
        /**
         * Fires each time the user clicks the button.
         */
        this.click = new EventEmitter();
        this.isDisabled = false;
        this.isIcon = false;
        this.isIconClass = false;
        this._size = 'medium';
        this._rounded = 'medium';
        this._shape = 'rectangle';
        this._fillMode = 'solid';
        this._themeColor = 'base';
        this._focused = false;
        this.domEvents = [];
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.localizationChangeSubscription = localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            return (_this.direction = rtl ? 'rtl' : 'ltr');
        });
        this.element = element.nativeElement;
        this.renderer = renderer;
    }
    Object.defineProperty(ButtonDirective.prototype, "togglable", {
        /**
         * Backwards-compatible alias
         *
         * @hidden
         */
        get: function () {
            return this.toggleable;
        },
        /**
         * @hidden
         */
        set: function (value) {
            this.toggleable = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "selected", {
        /**
         * Sets the selected state of the Button.
         */
        get: function () {
            return this._selected || false;
        },
        set: function (value) {
            this._selected = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "tabIndex", {
        get: function () {
            return this.element.tabIndex;
        },
        /**
         * @hidden
         */
        set: function (index) {
            this.element.tabIndex = index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "icon", {
        /**
         * Defines the name for an existing icon in a Kendo UI theme.
         * The icon is rendered inside the Button by a `span.k-icon` element.
         */
        set: function (icon) {
            var _this = this;
            if (icon) {
                this.iconSetter(icon, function () {
                    _this.isIcon = true;
                    var classes = 'k-button-icon k-icon k-i-' + icon;
                    _this.addIcon(classes);
                });
            }
            else {
                this.isIcon = false;
                this.updateIconNode();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "iconClass", {
        /**
         * Defines a CSS class&mdash;or multiple classes separated by spaces&mdash;
         * which are applied to a `span` element inside the Button. Allows the usage of custom icons.
         */
        set: function (iconClassName) {
            var _this = this;
            if (iconClassName) {
                this.iconSetter(iconClassName, function () {
                    _this.isIconClass = true;
                    var classes = 'k-button-icon ' + iconClassName;
                    _this.addIcon(classes);
                });
            }
            else {
                this.isIconClass = false;
                this.updateIconNode();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "imageUrl", {
        /**
         * Defines a URL which is used for an `img` element inside the Button.
         * The URL can be relative or absolute. If relative, it is evaluated with relation to the web page URL.
         */
        set: function (imageUrl) {
            if (imageUrl) {
                this.iconSetter(imageUrl, this.addImgIcon.bind(this));
            }
            else {
                this.removeImageNode();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "disabled", {
        get: function () {
            return this.isDisabled;
        },
        /**
         * If set to `true`, it disables the Button.
         */
        set: function (disabled) {
            //Required, because in FF focused buttons are not blurred on disabled
            if (disabled && isDocumentAvailable() && isFirefox(navigator.userAgent)) {
                this.blur();
            }
            this.isDisabled = disabled;
            this.renderer.setProperty(this.element, 'disabled', disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "size", {
        get: function () {
            return this._size;
        },
        /**
         * The size property specifies the padding of the Button
         * ([see example]({% slug appearance_button %}#toc-size)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `null`
         */
        set: function (size) {
            this.handleClasses(size, 'size');
            this._size = size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "rounded", {
        get: function () {
            return this._rounded;
        },
        /**
         * The rounded property specifies the border radius of the Button
         * ([see example]({% slug appearance_button %}#toc-rounded)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `'full'`
         * * `null`
         */
        set: function (rounded) {
            this.handleClasses(rounded, 'rounded');
            this._rounded = rounded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "fillMode", {
        get: function () {
            return this._fillMode;
        },
        /**
         * The fillMode property specifies the background and border styles of the Button
         * ([see example]({% slug appearance_button %}#toc-fillMode)).
         *
         * The possible values are:
         * * `'flat'`
         * * `'solid'` (default)
         * * `'outline'`
         * * `'clear'`
         * * `'link'`
         * * `null`
         */
        set: function (fillMode) {
            this.handleClasses(fillMode, 'fillMode');
            this._fillMode = fillMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "themeColor", {
        get: function () {
            return this._themeColor;
        },
        /**
         * The Button allows you to specify predefined theme colors.
         * The theme color will be applied as a background and border color while also amending the text color accordingly
         * ([see example]({% slug appearance_button %}#toc-themeColor)).
         *
         * The possible values are:
         * * `'base'` (default)
         * * `'primary'`
         * * `'secondary'`
         * * `'tertiary'`
         * * `'info'`
         * * `'success'`
         * * `'warning'`
         * * `'error'`
         * * `'dark'`
         * * `'light`'
         * * `'inverse'`
         */
        set: function (themeColor) {
            this.handleThemeColor(themeColor);
            this._themeColor = themeColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "shape", {
        get: function () {
            return this._shape;
        },
        /**
         * The shape property specifies if the Button will form a rectangle or square.
         * ([see example]({% slug appearance_button %}#toc-shape)).
         *
         * The possible values are:
         * * `'square'`
         * * `'rectangle'` (default)
         */
        set: function (shape) {
            this.handleClasses(shape, 'shape');
            this._shape = shape;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "isFocused", {
        get: function () {
            return this._focused;
        },
        set: function (isFocused) {
            this.toggleClass('k-focus', isFocused);
            this._focused = isFocused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "classButton", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "isToggleable", {
        get: function () {
            return this.toggleable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "roleSetter", {
        get: function () {
            return this.role;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "classDisabled", {
        get: function () {
            return this.isDisabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "classActive", {
        get: function () {
            return this.selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "getDirection", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    ButtonDirective.prototype.onFocus = function () {
        this.isFocused = true;
    };
    /**
     * @hidden
     */
    ButtonDirective.prototype.onBlur = function () {
        this.isFocused = false;
    };
    Object.defineProperty(ButtonDirective.prototype, "primary", {
        /**
         * @hidden
         */
        set: function (value) {
            this.themeColor = value ? 'primary' : 'base';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonDirective.prototype, "look", {
        /**
         * @hidden
         */
        set: function (value) {
            switch (value) {
                case 'default':
                    this.fillMode = 'solid';
                    break;
                default:
                    this.fillMode = value;
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    ButtonDirective.prototype.ngOnInit = function () {
        var _this = this;
        var isSpan = this.element.tagName === SPAN_TAG_NAME;
        this.addTextSpan();
        if (!this.element.hasAttribute('role') && this.togglable) {
            this.toggleAriaPressed(this.toggleable);
        }
        if (this.role) {
            this.setAttribute('role', this.role);
        }
        this.ngZone.runOutsideAngular(function () {
            _this.domEvents.push(_this.renderer.listen(_this.element, 'click', _this._onButtonClick.bind(_this)));
            _this.domEvents.push(_this.renderer.listen(_this.element, 'keydown', function (event) {
                var isSpaceOrEnter = event.keyCode === Keys.Space || event.keyCode === Keys.Enter;
                if (isSpan && isSpaceOrEnter) {
                    _this.click.emit(event);
                    _this._onButtonClick();
                }
            }));
        });
    };
    ButtonDirective.prototype.ngOnChanges = function (change) {
        if (isChanged('togglable', change) || isChanged('toggleable', change)) {
            this.toggleAriaPressed(this.toggleable);
        }
    };
    ButtonDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        var stylingOptions = ['size', 'rounded', 'shape', 'fillMode'];
        stylingOptions.forEach(function (input) {
            _this.handleClasses(_this[input], input);
        });
    };
    ButtonDirective.prototype.ngAfterViewChecked = function () {
        this.setIconTextClasses();
    };
    ButtonDirective.prototype.ngOnDestroy = function () {
        this.imageNode = null;
        this.iconNode = null;
        this.iconSpanNode = null;
        this.renderer = null;
        this.localizationChangeSubscription.unsubscribe();
        clearTimeout(this.deferTimeout);
        this.domEvents.forEach(function (unbindHandler) { return unbindHandler(); });
    };
    /**
     * Focuses the Button component.
     */
    ButtonDirective.prototype.focus = function () {
        if (isDocumentAvailable()) {
            this.element.focus();
            this.isFocused = true;
        }
    };
    /**
     * Blurs the Button component.
     */
    ButtonDirective.prototype.blur = function () {
        if (isDocumentAvailable()) {
            this.element.blur();
            this.isFocused = false;
        }
    };
    /**
     * @hidden
     */
    ButtonDirective.prototype.setAttribute = function (attribute, value) {
        this.renderer.setAttribute(this.element, attribute, value);
    };
    /**
     * @hidden
     */
    ButtonDirective.prototype.removeAttribute = function (attribute) {
        this.renderer.removeAttribute(this.element, attribute);
    };
    /**
     * @hidden
     *
     * Internal setter that triggers selectedChange
     */
    ButtonDirective.prototype.setSelected = function (value) {
        var _this = this;
        var changed = this.selected !== value;
        this.selected = value;
        this.setAttribute('aria-pressed', this.selected.toString());
        this.toggleClass('k-selected', this.selected);
        if (changed && hasObservers(this.selectedChange)) {
            this.ngZone.run(function () {
                _this.selectedChange.emit(value);
            });
        }
    };
    ButtonDirective.prototype.toggleAriaPressed = function (shouldSet) {
        if (!isDocumentAvailable()) {
            return;
        }
        if (shouldSet) {
            this.setAttribute('aria-pressed', this.selected.toString());
        }
        else {
            this.removeAttribute('aria-pressed');
        }
    };
    ButtonDirective.prototype.hasText = function () {
        return isDocumentAvailable() && this.element.textContent.trim().length > 0;
    };
    ButtonDirective.prototype.addImgIcon = function (imageUrl) {
        var renderer = this.renderer;
        if (!this.iconSpanNode) {
            this.iconSpanNode = renderer.createElement('span');
            renderer.setProperty(this.iconSpanNode, 'className', 'k-button-icon k-icon');
        }
        if (this.imageNode) {
            renderer.setProperty(this.imageNode, 'src', imageUrl);
        }
        else if (isDocumentAvailable()) {
            this.imageNode = renderer.createElement('img');
            renderer.setProperty(this.imageNode, 'src', imageUrl);
            renderer.setProperty(this.imageNode, 'className', 'k-image');
            renderer.setAttribute(this.imageNode, 'role', 'presentation');
        }
        this.iconSpanNode.appendChild(this.imageNode);
        this.prependChild(this.iconSpanNode);
    };
    ButtonDirective.prototype.addIcon = function (classNames) {
        var renderer = this.renderer;
        if (this.iconNode) {
            renderer.setProperty(this.iconNode, 'className', classNames);
        }
        else if (isDocumentAvailable()) {
            this.iconNode = renderer.createElement('span');
            renderer.setProperty(this.iconNode, 'className', classNames);
            renderer.setAttribute(this.iconNode, 'role', 'presentation');
            this.prependChild(this.iconNode);
        }
    };
    ButtonDirective.prototype.addTextSpan = function () {
        var _this = this;
        if (isDocumentAvailable() && this.hasText()) {
            var span_1 = this.renderer.createElement('span');
            this.renderer.addClass(span_1, 'k-button-text');
            var buttonContentNodes = Array.from(this.element.childNodes);
            buttonContentNodes.forEach(function (node) { return _this.renderer.appendChild(span_1, node); });
            this.renderer.appendChild(this.element, span_1);
        }
    };
    ButtonDirective.prototype.prependChild = function (node) {
        var _this = this;
        this.defer(function () {
            if (_this.renderer && node !== _this.element.firstChild) {
                _this.renderer.insertBefore(_this.element, node, _this.element.firstChild);
            }
        });
    };
    ButtonDirective.prototype.defer = function (callback) {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            _this.deferTimeout = setTimeout(callback, 0);
        });
    };
    ButtonDirective.prototype.iconSetter = function (icon, insertIcon) {
        if (icon) {
            insertIcon(icon);
        }
        this.setIconTextClasses();
    };
    ButtonDirective.prototype.removeImageNode = function () {
        if (this.imageNode && this.renderer.parentNode(this.imageNode)) {
            this.renderer.removeChild(this.element, this.imageNode);
            this.renderer.removeChild(this.element, this.iconSpanNode);
            this.imageNode = null;
            this.iconSpanNode = null;
        }
    };
    ButtonDirective.prototype.removeIconNode = function () {
        if (this.iconNode && this.renderer.parentNode(this.iconNode)) {
            this.renderer.removeChild(this.element, this.iconNode);
            this.iconNode = null;
        }
        if (this.iconSpanNode) {
            this.renderer.removeChild(this.element, this.iconSpanNode);
            this.iconSpanNode = null;
        }
    };
    ButtonDirective.prototype.updateIconNode = function () {
        if (!this.isIcon && !this.isIconClass) {
            this.removeIconNode();
        }
    };
    ButtonDirective.prototype.setIconTextClasses = function () {
        var hasIcon = this.isIcon || this.isIconClass || this.imageNode;
        this.toggleClass('k-icon-button', hasIcon && !this.hasText());
    };
    ButtonDirective.prototype.toggleClass = function (className, add) {
        if (add) {
            this.renderer.addClass(this.element, className);
        }
        else {
            this.renderer.removeClass(this.element, className);
        }
    };
    ButtonDirective.prototype._onButtonClick = function () {
        var _this = this;
        if (!this.disabled && this.service) {
            this.ngZone.run(function () {
                _this.service.click(_this);
            });
        }
        if (this.togglable && !this.service) {
            this.setSelected(!this.selected);
        }
    };
    ButtonDirective.prototype.handleClasses = function (value, input) {
        var elem = this.element;
        var classes = getStylingClasses('button', input, this[input], value);
        if (input === 'fillMode') {
            this.handleThemeColor(this.themeColor, this[input], value);
        }
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    };
    ButtonDirective.prototype.handleThemeColor = function (value, prevFillMode, fillMode) {
        var elem = this.element;
        var removeFillMode = prevFillMode ? prevFillMode : this.fillMode;
        var addFillMode = fillMode ? fillMode : this.fillMode;
        var themeColorClass = getThemeColorClasses('button', removeFillMode, addFillMode, this.themeColor, value);
        this.renderer.removeClass(elem, themeColorClass.toRemove);
        if (addFillMode !== null && fillMode !== null) {
            if (themeColorClass.toAdd) {
                this.renderer.addClass(elem, themeColorClass.toAdd);
            }
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ButtonDirective.prototype, "toggleable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], ButtonDirective.prototype, "togglable", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], ButtonDirective.prototype, "selected", null);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], ButtonDirective.prototype, "tabIndex", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ButtonDirective.prototype, "icon", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ButtonDirective.prototype, "iconClass", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ButtonDirective.prototype, "imageUrl", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], ButtonDirective.prototype, "disabled", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ButtonDirective.prototype, "size", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ButtonDirective.prototype, "rounded", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ButtonDirective.prototype, "fillMode", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ButtonDirective.prototype, "themeColor", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ButtonDirective.prototype, "shape", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ButtonDirective.prototype, "role", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ButtonDirective.prototype, "selectedChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ButtonDirective.prototype, "click", void 0);
    __decorate([
        HostBinding('class.k-button'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ButtonDirective.prototype, "classButton", null);
    __decorate([
        HostBinding('class.k-toggle-button'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ButtonDirective.prototype, "isToggleable", null);
    __decorate([
        HostBinding('attr.role'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], ButtonDirective.prototype, "roleSetter", null);
    __decorate([
        HostBinding('attr.aria-disabled'),
        HostBinding('class.k-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ButtonDirective.prototype, "classDisabled", null);
    __decorate([
        HostBinding('class.k-selected'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ButtonDirective.prototype, "classActive", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], ButtonDirective.prototype, "getDirection", null);
    __decorate([
        HostListener('focus'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ButtonDirective.prototype, "onFocus", null);
    __decorate([
        HostListener('blur'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ButtonDirective.prototype, "onBlur", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], ButtonDirective.prototype, "primary", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ButtonDirective.prototype, "look", null);
    ButtonDirective = __decorate([
        Directive({
            exportAs: 'kendoButton',
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.button'
                }
            ],
            selector: 'button[kendoButton], span[kendoButton]',
        }),
        __param(2, Optional()),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            KendoButtonService,
            LocalizationService,
            NgZone])
    ], ButtonDirective);
    return ButtonDirective;
}());

/**
 * @hidden
 */
var PreventableEvent = /** @class */ (function () {
    function PreventableEvent() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    PreventableEvent.prototype.preventDefault = function () {
        this.prevented = true;
    };
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    PreventableEvent.prototype.isDefaultPrevented = function () {
        return this.prevented;
    };
    return PreventableEvent;
}());

/**
 * @hidden
 */
var tabindex = 'tabindex';
/**
 * Represents the Kendo UI ButtonGroup component for Angular.
 */
var ButtonGroupComponent = /** @class */ (function () {
    function ButtonGroupComponent(service, localization, element) {
        var _this = this;
        this.service = service;
        this.element = element;
        /**
         * By default, the selection mode of the ButtonGroup is set to `multiple`.
         */
        this.selection = 'multiple';
        /**
         * Fires every time keyboard navigation occurs.
         */
        this.navigate = new EventEmitter();
        this._tabIndex = 0;
        this.currentTabIndex = 0;
        validatePackage(packageMetadata);
        this.localizationChangeSubscription = localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            return _this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    Object.defineProperty(ButtonGroupComponent.prototype, "tabIndex", {
        get: function () {
            return this._tabIndex;
        },
        /**
         * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        set: function (value) {
            this._tabIndex = value;
            this.currentTabIndex = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonGroupComponent.prototype, "wrapperClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonGroupComponent.prototype, "disabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonGroupComponent.prototype, "stretchedClass", {
        get: function () {
            return !!this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonGroupComponent.prototype, "getRole", {
        get: function () {
            return this.isSelectionSingle() ? 'radiogroup' : 'group';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonGroupComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonGroupComponent.prototype, "ariaDisabled", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonGroupComponent.prototype, "wrapperWidth", {
        get: function () {
            return this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonGroupComponent.prototype, "wrapperTabIndex", {
        get: function () {
            return this.disabled ? undefined : this.currentTabIndex;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    ButtonGroupComponent.prototype.keydown = function (event) {
        if (!this.disabled) {
            this.navigateFocus(event);
        }
    };
    /**
     * @hidden
     */
    ButtonGroupComponent.prototype.onFocus = function () {
        this.currentTabIndex = -1;
        var focusedIndex = this.buttons.toArray().findIndex(function (current) { return current.element.tabIndex !== -1; });
        var index = focusedIndex === -1 ? 0 : focusedIndex;
        this.focus(this.buttons.filter(function (_current, i) {
            return i === index;
        }));
    };
    /**
     * @hidden
     */
    ButtonGroupComponent.prototype.focusout = function (event) {
        if (event.relatedTarget && event.relatedTarget.parentNode !== this.element.nativeElement) {
            this.defocus(this.buttons.toArray());
            this.currentTabIndex = this.tabIndex;
        }
    };
    ButtonGroupComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscription = this.service.buttonClicked$.subscribe(function (button) {
            var newSelectionValue;
            if (_this.isSelectionSingle()) {
                newSelectionValue = true;
                _this.deactivate(_this.buttons.filter(function (current) { return current !== button; }));
            }
            else {
                _this.defocus(_this.buttons.toArray());
                newSelectionValue = !button.selected;
            }
            if (button.togglable) {
                button.setSelected(newSelectionValue);
            }
            button.setAttribute(tabindex, '0');
        });
    };
    ButtonGroupComponent.prototype.ngOnChanges = function (change) {
        var _this = this;
        if (isChanged('disabled', change)) {
            this.buttons.forEach(function (button) {
                if (isPresent(_this.disabled)) {
                    button.disabled = _this.disabled;
                }
            });
        }
    };
    ButtonGroupComponent.prototype.ngAfterContentInit = function () {
        this.buttons.forEach(function (button) {
            if (button.selected) {
                button.setAttribute(tabindex, '0');
            }
            else {
                button.setAttribute(tabindex, '-1');
            }
        });
    };
    ButtonGroupComponent.prototype.ngAfterViewChecked = function () {
        if (this.buttons.length) {
            this.buttons.first.renderer.addClass(this.buttons.first.element, 'k-group-start');
            this.buttons.last.renderer.addClass(this.buttons.last.element, 'k-group-end');
        }
    };
    ButtonGroupComponent.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
        this.localizationChangeSubscription.unsubscribe();
    };
    ButtonGroupComponent.prototype.ngAfterContentChecked = function () {
        this.verifySettings();
    };
    ButtonGroupComponent.prototype.navigateFocus = function (event) {
        var focusedIndex = this.buttons.toArray().findIndex(function (current) { return current.element.tabIndex !== -1; });
        var firstIndex = 0;
        var lastIndex = this.buttons.length - 1;
        var eventArgs = new PreventableEvent();
        if (event.keyCode === Keys.ArrowRight && focusedIndex < lastIndex) {
            this.navigate.emit(eventArgs);
            if (!eventArgs.isDefaultPrevented()) {
                this.defocus(this.buttons.toArray());
                this.focus(this.buttons.filter(function (_current, index) {
                    return index === focusedIndex + 1;
                }));
            }
        }
        if (event.keyCode === Keys.ArrowLeft && focusedIndex > firstIndex) {
            this.navigate.emit(eventArgs);
            if (!eventArgs.isDefaultPrevented()) {
                this.defocus(this.buttons.toArray());
                this.focus(this.buttons.filter(function (_current, index) {
                    return index === focusedIndex - 1;
                }));
            }
        }
    };
    ButtonGroupComponent.prototype.deactivate = function (buttons) {
        buttons.forEach(function (button) {
            button.setSelected(false);
            button.setAttribute(tabindex, '-1');
        });
    };
    ButtonGroupComponent.prototype.activate = function (buttons) {
        buttons.forEach(function (button) {
            button.setSelected(true);
            button.setAttribute(tabindex, '0');
            button.focus();
        });
    };
    ButtonGroupComponent.prototype.defocus = function (buttons) {
        buttons.forEach(function (button) {
            button.setAttribute(tabindex, '-1');
        });
    };
    ButtonGroupComponent.prototype.focus = function (buttons) {
        buttons.forEach(function (button) {
            button.setAttribute(tabindex, '0');
            button.focus();
        });
    };
    ButtonGroupComponent.prototype.verifySettings = function () {
        if (isDevMode()) {
            if (this.isSelectionSingle() && this.buttons.filter(function (button) { return button.selected; }).length > 1) {
                throw new Error('Having multiple selected buttons with single selection mode is not supported');
            }
        }
    };
    ButtonGroupComponent.prototype.isSelectionSingle = function () {
        return this.selection === 'single';
    };
    __decorate([
        Input('disabled'),
        __metadata("design:type", Boolean)
    ], ButtonGroupComponent.prototype, "disabled", void 0);
    __decorate([
        Input('selection'),
        __metadata("design:type", String)
    ], ButtonGroupComponent.prototype, "selection", void 0);
    __decorate([
        Input('width'),
        __metadata("design:type", String)
    ], ButtonGroupComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], ButtonGroupComponent.prototype, "tabIndex", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ButtonGroupComponent.prototype, "navigate", void 0);
    __decorate([
        ContentChildren(ButtonDirective),
        __metadata("design:type", QueryList)
    ], ButtonGroupComponent.prototype, "buttons", void 0);
    __decorate([
        HostBinding('class.k-button-group'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ButtonGroupComponent.prototype, "wrapperClass", null);
    __decorate([
        HostBinding('class.k-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ButtonGroupComponent.prototype, "disabledClass", null);
    __decorate([
        HostBinding('class.k-button-group-stretched'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ButtonGroupComponent.prototype, "stretchedClass", null);
    __decorate([
        HostBinding('attr.role'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], ButtonGroupComponent.prototype, "getRole", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], ButtonGroupComponent.prototype, "dir", null);
    __decorate([
        HostBinding('attr.aria-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ButtonGroupComponent.prototype, "ariaDisabled", null);
    __decorate([
        HostBinding('style.width'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], ButtonGroupComponent.prototype, "wrapperWidth", null);
    __decorate([
        HostBinding('attr.tabindex'),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [])
    ], ButtonGroupComponent.prototype, "wrapperTabIndex", null);
    __decorate([
        HostListener('keydown', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], ButtonGroupComponent.prototype, "keydown", null);
    __decorate([
        HostListener('focus'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ButtonGroupComponent.prototype, "onFocus", null);
    __decorate([
        HostListener('focusout', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], ButtonGroupComponent.prototype, "focusout", null);
    ButtonGroupComponent = __decorate([
        Component({
            exportAs: 'kendoButtonGroup',
            providers: [
                KendoButtonService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.buttongroup'
                }
            ],
            selector: 'kendo-buttongroup',
            template: "\n        <ng-content select=\"[kendoButton]\"></ng-content>\n    "
        }),
        __metadata("design:paramtypes", [KendoButtonService,
            LocalizationService,
            ElementRef])
    ], ButtonGroupComponent);
    return ButtonGroupComponent;
}());

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmodules'] }})
 * definition for the Button directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Button module
 * import { ButtonModule } from '@progress/kendo-angular-buttons';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, ButtonModule], // import Button module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var ButtonModule = /** @class */ (function () {
    function ButtonModule() {
    }
    ButtonModule = __decorate([
        NgModule({
            declarations: [ButtonDirective],
            exports: [ButtonDirective]
        })
    ], ButtonModule);
    return ButtonModule;
}());

/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `ButtonGroupComponent`&mdash;The ButtonGroupComponent component class.
 */
var ButtonGroupModule = /** @class */ (function () {
    function ButtonGroupModule() {
    }
    ButtonGroupModule = __decorate([
        NgModule({
            declarations: [ButtonGroupComponent],
            exports: [ButtonGroupComponent],
            imports: [CommonModule, ButtonModule]
        })
    ], ButtonGroupModule);
    return ButtonGroupModule;
}());

/**
 * Used for rendering the list item content.
 *
 * To define the item template, nest a `<ng-template>` tag with the `kendo<ComponentName>ItemTemplate` directive inside the component tag.
 *
 * For the DropDownButton, use the `kendoDropDownButtonItemTemplate` directive.
 * For the SplitButton, use the `kendoSplitButtonItemTemplate` directive.
 *
 * The template context is set to the current component. To get a reference to the current data item, use the `let-dataItem` directive.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-splitbutton [data]="listItems">
 *    <ng-template kendoSplitButtonItemTemplate let-dataItem>
 *      <span>{{dataItem}} option</span>
 *    </ng-template>
 *  </kendo-splitbutton>
 *  <kendo-dropdownbutton [data]="listItems">
 *    <ng-template kendoDropDownButtonItemTemplate let-dataItem>
 *      <span>{{dataItem}} option</span>
 *    </ng-template>
 *  </kendo-dropdownbutton>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<any> = [{
 *      text: 'item1',
 *      icon: 'refresh',
 *      disabled: false,
 *      click: (dataItem: any) => {
 *          //action
 *      }
 *  }, {
 *      text: 'item2',
 *      icon: 'refresh',
 *      disabled: false,
 *      click: (dataItem: any) => {
 *          //action
 *      }
 *  }]
 * }
 * ```
 *
 * For more examples, refer to the article on the [DropDownList templates]({% slug overview_ddl %}#templates).
 */
var ButtonItemTemplateDirective = /** @class */ (function () {
    function ButtonItemTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    ButtonItemTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDropDownButtonItemTemplate],[kendoSplitButtonItemTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], ButtonItemTemplateDirective);
    return ButtonItemTemplateDirective;
}());

/**
 * @hidden
 */
var ListComponent = /** @class */ (function () {
    function ListComponent() {
        this.onItemClick = new EventEmitter();
        this.onItemBlur = new EventEmitter();
        this.sizeClass = '';
        validatePackage(packageMetadata);
    }
    Object.defineProperty(ListComponent.prototype, "size", {
        set: function (size) {
            if (size) {
                this.sizeClass = "k-menu-group-" + SIZES[size];
            }
            else {
                this.sizeClass = '';
            }
        },
        enumerable: true,
        configurable: true
    });
    ListComponent.prototype.getText = function (dataItem) {
        if (dataItem) {
            return this.textField ? dataItem[this.textField] : dataItem.text || dataItem;
        }
        return undefined;
    };
    ListComponent.prototype.getIconClasses = function (dataItem) {
        var icon = dataItem.icon ? 'k-icon k-i-' + dataItem.icon : undefined;
        var classes = {};
        classes[icon || dataItem.iconClass] = true;
        return classes;
    };
    ListComponent.prototype.onClick = function (index) {
        this.onItemClick.emit(index);
    };
    ListComponent.prototype.onBlur = function () {
        this.onItemBlur.emit();
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ListComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ListComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", ButtonItemTemplateDirective)
    ], ListComponent.prototype, "itemTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ListComponent.prototype, "onItemClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ListComponent.prototype, "onItemBlur", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ListComponent.prototype, "size", null);
    ListComponent = __decorate([
        Component({
            selector: 'kendo-button-list',
            template: "\n        <ul class=\"k-group k-menu-group k-reset\" [ngClass]=\"sizeClass\" unselectable=\"on\" role=\"menu\">\n            <li role=\"menuitem\" unselectable=\"on\"\n                kendoButtonFocusable\n                *ngFor=\"let dataItem of data; let index = index;\"\n                [index]=\"index\"\n                tabindex=\"-1\"\n                class=\"k-item k-menu-item\"\n                (click)=\"onClick(index)\"\n                (blur)=\"onBlur()\"\n                [attr.aria-disabled]=\"dataItem.disabled ? true : false\">\n                <ng-template [ngIf]=\"itemTemplate?.templateRef\">\n                    <span class=\"k-link k-menu-link\" [class.k-disabled]=\"dataItem.disabled\">\n                        <ng-template [templateContext]=\"{templateRef: itemTemplate?.templateRef, $implicit: dataItem}\"></ng-template>\n                    </span>\n                </ng-template>\n                <ng-template [ngIf]=\"!itemTemplate?.templateRef\">\n                    <span class=\"k-link k-menu-link\" [class.k-disabled]=\"dataItem.disabled\">\n                        <span\n                            *ngIf=\"dataItem.icon || dataItem.iconClass\"\n                            [ngClass]=\"getIconClasses(dataItem)\"\n                        ></span>\n                        <img\n                            *ngIf=\"dataItem.imageUrl\"\n                            class=\"k-image\"\n                            [src]=\"dataItem.imageUrl\"\n                            alt=\"\"\n                        >\n                        <span *ngIf=\"getText(dataItem)\" class=\"k-menu-link-text\">\n                        {{ getText(dataItem) }}\n                        </span>\n                    </span>\n                </ng-template>\n            </li>\n        </ul>\n      "
        }),
        __metadata("design:paramtypes", [])
    ], ListComponent);
    return ListComponent;
}());

/**
 * @hidden
 */
var FocusService = /** @class */ (function () {
    function FocusService() {
        this.onFocus = new EventEmitter();
    }
    FocusService.prototype.isFocused = function (index) {
        return index === this.focused;
    };
    FocusService.prototype.focus = function (index) {
        if (this.isFocused(index)) {
            return;
        }
        this.focused = index;
        this.onFocus.emit(index);
    };
    FocusService.prototype.resetFocus = function () {
        this.focused = -1;
    };
    Object.defineProperty(FocusService.prototype, "focused", {
        get: function () {
            return this.focusedIndex;
        },
        set: function (index) {
            this.focusedIndex = index;
            this.onFocus.emit(index);
        },
        enumerable: true,
        configurable: true
    });
    FocusService = __decorate([
        Injectable()
    ], FocusService);
    return FocusService;
}());

/**
 * @hidden
 */
var FocusableDirective = /** @class */ (function () {
    function FocusableDirective(focusService, elementRef, renderer) {
        this.focusService = focusService;
        this.renderer = renderer;
        this.element = elementRef.nativeElement;
        this.subscribeEvents();
    }
    FocusableDirective.prototype.ngOnInit = function () {
        if (this.index === this.focusService.focused) {
            this.renderer.addClass(this.element, 'k-focus');
        }
        else {
            this.renderer.removeClass(this.element, 'k-focus');
        }
    };
    /**
     * @hidden
     */
    FocusableDirective.prototype.ngOnDestroy = function () {
        this.unsubscribeEvents();
    };
    FocusableDirective.prototype.subscribeEvents = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        this.focusSubscription = this.focusService.onFocus.subscribe(function (index) {
            if (_this.index === index) {
                _this.renderer.addClass(_this.element, 'k-focus');
                _this.element.focus();
            }
            else {
                _this.renderer.removeClass(_this.element, 'k-focus');
            }
        });
    };
    FocusableDirective.prototype.unsubscribeEvents = function () {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.focusSubscription) {
            this.focusSubscription.unsubscribe();
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], FocusableDirective.prototype, "index", void 0);
    FocusableDirective = __decorate([
        Directive({
            selector: '[kendoButtonFocusable]'
        }),
        __metadata("design:paramtypes", [FocusService, ElementRef, Renderer2])
    ], FocusableDirective);
    return FocusableDirective;
}());

/**
 * @hidden
 */
var TemplateContextDirective = /** @class */ (function () {
    function TemplateContextDirective(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    Object.defineProperty(TemplateContextDirective.prototype, "templateContext", {
        set: function (context) {
            if (this.insertedViewRef) {
                this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));
                this.insertedViewRef = undefined;
            }
            if (context.templateRef) {
                this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);
            }
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], TemplateContextDirective.prototype, "templateContext", null);
    TemplateContextDirective = __decorate([
        Directive({
            selector: '[templateContext]' // tslint:disable-line:directive-selector
        }),
        __metadata("design:paramtypes", [ViewContainerRef])
    ], TemplateContextDirective);
    return TemplateContextDirective;
}());

var EXPORTED_DIRECTIVES = [
    ListComponent,
    FocusableDirective,
    ButtonItemTemplateDirective,
    TemplateContextDirective
];
/**
 * @hidden
 */
var ListModule = /** @class */ (function () {
    function ListModule() {
    }
    ListModule = __decorate([
        NgModule({
            declarations: [EXPORTED_DIRECTIVES],
            exports: [EXPORTED_DIRECTIVES],
            imports: [CommonModule]
        })
    ], ListModule);
    return ListModule;
}());

/**
 * @hidden
 */
var KeyEvents;
(function (KeyEvents) {
    KeyEvents[KeyEvents["keydown"] = 0] = "keydown";
    KeyEvents[KeyEvents["keypress"] = 1] = "keypress";
    KeyEvents[KeyEvents["keyup"] = 2] = "keyup";
})(KeyEvents || (KeyEvents = {}));

/**
 * @hidden
 */
var NavigationAction;
(function (NavigationAction) {
    NavigationAction[NavigationAction["Undefined"] = 0] = "Undefined";
    NavigationAction[NavigationAction["Open"] = 1] = "Open";
    NavigationAction[NavigationAction["Close"] = 2] = "Close";
    NavigationAction[NavigationAction["Enter"] = 3] = "Enter";
    NavigationAction[NavigationAction["EnterPress"] = 4] = "EnterPress";
    NavigationAction[NavigationAction["EnterUp"] = 5] = "EnterUp";
    NavigationAction[NavigationAction["Tab"] = 6] = "Tab";
    NavigationAction[NavigationAction["Esc"] = 7] = "Esc";
    NavigationAction[NavigationAction["Navigate"] = 8] = "Navigate";
})(NavigationAction || (NavigationAction = {}));

/* tslint:disable:deprecation */
/**
 * @hidden
 */
var ListButton = /** @class */ (function () {
    function ListButton(focusService, navigationService, wrapperRef, _zone, localization, cdr) {
        var _this = this;
        this.focusService = focusService;
        this.navigationService = navigationService;
        this.wrapperRef = wrapperRef;
        this._zone = _zone;
        this.cdr = cdr;
        this._open = false;
        this._disabled = false;
        this._active = false;
        this._popupSettings = { animate: true, popupClass: '' };
        this.listId = guid();
        this._isFocused = false;
        validatePackage(packageMetadata);
        this.focusService = focusService;
        this.navigationService = navigationService;
        this.wrapper = wrapperRef.nativeElement;
        this.localizationChangeSubscription = localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            return (_this.direction = rtl ? 'rtl' : 'ltr');
        });
        this.subscribeEvents();
    }
    Object.defineProperty(ListButton.prototype, "popupClasses", {
        get: function () {
            var popupClasses = ['k-menu-popup'];
            if (this._popupSettings.popupClass) {
                popupClasses.push(this._popupSettings.popupClass);
            }
            return popupClasses.join(' ');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListButton.prototype, "openState", {
        get: function () {
            return this._open;
        },
        set: function (open) {
            this._open = open;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    ListButton.prototype.togglePopupVisibility = function () {
        if (this._disabled) {
            return;
        }
        this.openState = !this.openState;
        if (!this.openState) {
            this.focusService.focus(-1);
        }
    };
    /**
     * @hidden
     */
    ListButton.prototype.onItemClick = function (index) {
        var _this = this;
        this.emitItemClickHandler(index);
        setTimeout(function () { return _this.focusWrapper(); }, 1);
    };
    ListButton.prototype.ngOnDestroy = function () {
        this.openState = false;
        this.unsubscribeEvents();
        clearTimeout(this.focusFirstTimeout);
        clearTimeout(this.blurTimeout);
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    };
    ListButton.prototype.subscribeEvents = function () {
        if (!isDocumentAvailable()) {
            return;
        }
        this.subscribeListItemFocusEvent();
        this.subscribeComponentBlurredEvent();
        this.subscribeNavigationEvents();
    };
    ListButton.prototype.subscribeListItemFocusEvent = function () {
        var _this = this;
        this.focusSubscription = this.focusService.onFocus.subscribe(function () {
            _this._isFocused = true;
        });
    };
    ListButton.prototype.subscribeComponentBlurredEvent = function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            _this.tabSubscription = _this.navigationService.tab.pipe(filter(function () { return _this._isFocused; })).subscribe(_this.handleTab.bind(_this));
            _this.componentBlurredSubscription = fromEvent(document, 'click')
                .pipe(filter(function (event) { return !_this.wrapperContains(event.target); }), filter(function () { return _this._isFocused; }))
                .subscribe(function () { return _this._zone.run(function () { return _this.blurWrapper(); }); });
        });
    };
    ListButton.prototype.subscribeNavigationEvents = function () {
        var _this = this;
        this.navigationSubscription = this.navigationService.navigate.subscribe(this.focusService.focus.bind(this.focusService));
        this.enterUpSubscription = this.navigationService.enterup.subscribe(function () {
            _this.enterHandler();
            _this.focusWrapper();
        });
        this.openSubscription = this.navigationService.open.subscribe(function () {
            if (!_this._open) {
                _this.togglePopupVisibility();
                _this.focusFirstItem();
            }
            else {
                _this.focusWrapper();
            }
        });
        this.closeSubscription = merge(this.navigationService.close, this.navigationService.esc).subscribe(function () { return _this.focusWrapper(); });
    };
    ListButton.prototype.enterHandler = function () { }; // tslint:disable-line
    ListButton.prototype.unsubscribeEvents = function () {
        if (!isDocumentAvailable()) {
            return;
        }
        this.unsubscribe(this.componentBlurredSubscription);
        this.unsubscribe(this.focusSubscription);
        this.unsubscribe(this.navigationSubscription);
        this.unsubscribe(this.enterPressSubscription);
        this.unsubscribe(this.enterUpSubscription);
        this.unsubscribe(this.openSubscription);
        this.unsubscribe(this.closeSubscription);
        this.unsubscribe(this.tabSubscription);
    };
    ListButton.prototype.unsubscribe = function (subscription) {
        if (subscription) {
            subscription.unsubscribe();
        }
    };
    /**
     * @hidden
     */
    ListButton.prototype.keyDownHandler = function (event) {
        this.keyHandler(event);
    };
    /**
     * @hidden
     */
    ListButton.prototype.keyPressHandler = function (event) {
        this.keyHandler(event, KeyEvents.keypress);
    };
    /**
     * @hidden
     */
    ListButton.prototype.keyUpHandler = function (event) {
        this.keyHandler(event, KeyEvents.keyup);
    };
    /**
     * @hidden
     */
    ListButton.prototype.keyHandler = function (event, keyEvent) {
        if (this._disabled) {
            return;
        }
        var focused = this.focusService.focused || 0;
        var eventData = event;
        var action = this.navigationService.process({
            altKey: eventData.altKey,
            current: focused,
            keyCode: eventData.keyCode,
            keyEvent: keyEvent,
            max: this._data ? this._data.length - 1 : 0,
            min: 0
        });
        if (action !== NavigationAction.Undefined &&
            action !== NavigationAction.Tab &&
            (action !== NavigationAction.Enter || (action === NavigationAction.Enter && this._open))) {
            if (event.keyCode === Keys.Space && action === NavigationAction.EnterUp) {
                this._open = false;
            }
            else {
                eventData.preventDefault();
            }
        }
    };
    ListButton.prototype.emitItemClickHandler = function (index) {
        var dataItem = this._data[index];
        if (this._itemClick) {
            this._itemClick.emit(dataItem);
        }
        if (dataItem && dataItem.click && !dataItem.disabled) {
            dataItem.click(dataItem);
        }
    };
    ListButton.prototype.focusFirstItem = function () {
        var _this = this;
        if (this._data && isPresent(this._data[0])) {
            this.focusFirstTimeout = setTimeout(function () { return _this.focusService.focus(0); }, 1);
        }
    };
    ListButton.prototype.focusWrapper = function () {
        if (this._open) {
            this.togglePopupVisibility();
            this.focusButton();
        }
    };
    ListButton.prototype.wrapperContains = function (element) {
        return this.wrapper === element || this.wrapper.contains(element);
    };
    ListButton.prototype.blurWrapper = function (emit) {
        if (emit === void 0) { emit = true; }
        if (this._open) {
            this.togglePopupVisibility();
        }
        this._isFocused = false;
        if (emit) {
            this._blur.emit();
            this.cdr.markForCheck();
        }
    };
    ListButton.prototype.focusButton = function () {
        if (this.button) {
            this.button.nativeElement.focus();
        }
    };
    ListButton.prototype.handleTab = function () {
        this.focusButton();
        this.blurWrapper(false);
    };
    return ListButton;
}());

/**
 * @hidden
 */
var NAVIGATION_CONFIG = new InjectionToken('navigation.config');

/**
 * @hidden
 */
var NavigationService = /** @class */ (function () {
    function NavigationService(config) {
        this.navigate = new EventEmitter();
        this.open = new EventEmitter();
        this.close = new EventEmitter();
        this.enter = new EventEmitter();
        this.enterpress = new EventEmitter();
        this.enterup = new EventEmitter();
        this.tab = new EventEmitter();
        this.esc = new EventEmitter();
        this.useLeftRightArrows = config.useLeftRightArrows;
    }
    NavigationService.prototype.process = function (args) {
        var keyCode = args.keyCode;
        var keyEvent = args.keyEvent;
        var index;
        var action = NavigationAction.Undefined;
        if (keyEvent === KeyEvents.keypress) {
            if (this.isEnter(keyCode)) {
                action = NavigationAction.EnterPress;
            }
        }
        else if (keyEvent === KeyEvents.keyup) {
            if (this.isEnter(keyCode)) {
                action = NavigationAction.EnterUp;
            }
        }
        else {
            if (args.altKey && keyCode === Keys.ArrowDown) {
                action = NavigationAction.Open;
            }
            else if (args.altKey && keyCode === Keys.ArrowUp) {
                action = NavigationAction.Close;
            }
            else if (this.isEnter(keyCode)) {
                action = NavigationAction.Enter;
            }
            else if (keyCode === Keys.Escape) {
                action = NavigationAction.Esc;
            }
            else if (keyCode === Keys.Tab) {
                action = NavigationAction.Tab;
            }
            else if (keyCode === Keys.ArrowUp || (this.useLeftRightArrows && keyCode === Keys.ArrowLeft)) {
                var step = args.flipNavigation ? 1 : -1;
                var start = args.flipNavigation ? args.min : args.max;
                var end = args.flipNavigation ? args.max : args.min;
                index = this.next({
                    current: args.current,
                    start: start,
                    end: end,
                    step: step
                });
                action = NavigationAction.Navigate;
            }
            else if (keyCode === Keys.ArrowDown || (this.useLeftRightArrows && keyCode === Keys.ArrowRight)) {
                var step = args.flipNavigation ? -1 : 1;
                var start = args.flipNavigation ? args.max : args.min;
                var end = args.flipNavigation ? args.min : args.max;
                index = this.next({
                    current: args.current,
                    start: start,
                    end: end,
                    step: step
                });
                action = NavigationAction.Navigate;
            }
            else if (keyCode === Keys.Home) {
                index = args.min;
                action = NavigationAction.Navigate;
            }
            else if (keyCode === Keys.End) {
                index = args.max;
                action = NavigationAction.Navigate;
            }
        }
        if (action !== NavigationAction.Undefined) {
            this[NavigationAction[action].toLowerCase()].emit(index);
        }
        return action;
    };
    NavigationService.prototype.isEnter = function (keyCode) {
        return keyCode === Keys.Enter || keyCode === Keys.Space;
    };
    NavigationService.prototype.next = function (args) {
        if (!isPresent(args.current)) {
            return args.start;
        }
        else {
            return args.current !== args.end ? args.current + args.step : args.end;
        }
    };
    NavigationService = __decorate([
        Injectable(),
        __param(0, Inject(NAVIGATION_CONFIG)),
        __metadata("design:paramtypes", [Object])
    ], NavigationService);
    return NavigationService;
}());

var NAVIGATION_SETTINGS = {
    useLeftRightArrows: true
};
var Éµ0 = NAVIGATION_SETTINGS;
var NAVIGATION_SETTINGS_PROVIDER = {
    provide: NAVIGATION_CONFIG,
    useValue: Éµ0
};
/**
 * Represents the Kendo UI SplitButton component for Angular.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-splitbutton [data]="data" icon="paste"
 *      (itemClick)="onSplitButtonItemClick($event)"
 *      (buttonClick)="onSplitButtonClick()">Paste</kendo-splitbutton>
 * `
 * })
 *
 * class AppComponent {
 *   public data: Array<any> = [{
 *       text: 'Keep Text Only',
 *       icon: 'paste-plain-text',
 *       click: () => { console.log('Keep Text Only click handler'); }
 *   }, {
 *       text: 'Paste as HTML',
 *       icon: 'paste-as-html'
 *   }, {
 *       text: 'Paste Markdown',
 *       icon: 'paste-markdown'
 *   }, {
 *       text: 'Set Default Paste'
 *   }];
 *
 *   public onSplitButtonClick(dataItem: any): void {
 *       console.log('Paste');
 *   }
 *
 *   public onSplitButtonItemClick(dataItem: any): void {
 *       if (dataItem) {
 *           console.log(dataItem.text);
 *       }
 *   }
 * }
 * ```
 */
var SplitButtonComponent = /** @class */ (function (_super) {
    __extends(SplitButtonComponent, _super);
    function SplitButtonComponent(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr, renderer) {
        var _this = _super.call(this, focusService, navigationService, wrapperRef, zone, localization, cdr) || this;
        _this.popupService = popupService;
        _this.elRef = elRef;
        _this.localization = localization;
        _this.renderer = renderer;
        /**
         * Sets the text of the SplitButton.
         */
        _this.text = '';
        /**
         * Defines an icon to be rendered next to the button text
         * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).
         */
        _this.icon = '';
        /**
         * Defines an icon with a custom CSS class to be rendered next to the button text
         * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).
         */
        _this.iconClass = '';
        /**
         * Defines the type attribute of the main button
         */
        _this.type = 'button';
        /**
         * Defines the location of an image to be displayed next to the button text
         * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).
         */
        _this.imageUrl = '';
        /**
         * The size property specifies the padding of the SplitButton
         * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-size)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `null`
         */
        _this.size = 'medium';
        /**
         * The SplitButton allows you to specify predefined theme colors.
         * The theme color will be applied as a background and border color while also amending the text color accordingly
         * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-themeColor)).
         *
         * The possible values are:
         * * `base` &mdash;Applies coloring based on the `base` theme color. (default)
         * * `primary` &mdash;Applies coloring based on the `primary` theme color.
         * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.
         * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.
         * * `info`&mdash;Applies coloring based on the `info` theme color.
         * * `success`&mdash; Applies coloring based on the `success` theme color.
         * * `warning`&mdash; Applies coloring based on the `warning` theme color.
         * * `error`&mdash; Applies coloring based on the `error` theme color.
         * * `dark`&mdash; Applies coloring based on the `dark` theme color.
         * * `light`&mdash; Applies coloring based on the `light` theme color.
         * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.
         */
        _this.themeColor = 'base';
        /**
         * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        _this.tabIndex = 0;
        /**
         * Specifies the name of the [font icon]({% slug icons %}#toc-list-of-font-icons) that will
         * be rendered for the button which opens the popup.
         */
        _this.arrowButtonIcon = 'arrow-s';
        /**
         * Fires each time the user clicks the main button.
         *
         * @example
         * ```ts
         * _@Component({
         *    selector: 'my-app',
         *    template: `
         *        <kendo-splitbutton (buttonClick)="onSplitButtonClick()" [data]="data">
         *            Reply
         *        </kendo-splitbutton>
         *    `
         * })
         * class AppComponent {
         *    public data: Array<any> = ['Reply All', 'Forward', 'Reply & Delete'];
         *
         *    public onSplitButtonClick(): void {
         *      console.log('SplitButton click');
         *    }
         * }
         * ```
         *
         */
        _this.buttonClick = new EventEmitter();
        /**
         * Fires each time the user clicks on the drop-down list. The event data contains the data item bound to the clicked list item.
         *
         * @example
         * ```ts
         * _@Component({
         *     selector: 'my-app',
         *    template: `
         *        <kendo-splitbutton (itemClick)="onSplitButtonItemClick($event)" [data]="data">
         *          Reply
         *      </kendo-splitbutton>
         *    `
         * })
         * class AppComponent {
         *    public data: Array<any> = ['Reply All', 'Forward', 'Reply & Delete'];
         *
         *   public onSplitButtonItemClick(dataItem?: string): void {
         *        if (dataItem) {
         *            console.log(dataItem);
         *       }
         *    }
         * }
         * ```
         *
         */
        _this.itemClick = new EventEmitter();
        /**
         * Fires each time the SplitButton gets focused.
         */
        _this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the SplitButton gets blurred.
         */
        _this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel the event, the popup will remain closed.
         */
        _this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel the event, the popup will remain open.
         */
        _this.close = new EventEmitter();
        /**
         * @hidden
         */
        _this.activeArrow = false;
        _this.listId = guid();
        _this.buttonText = '';
        _this.lockFocus = false;
        _this._rounded = 'medium';
        _this._fillMode = "solid";
        _this._itemClick = _this.itemClick;
        _this._blur = _this.onBlur;
        return _this;
    }
    Object.defineProperty(SplitButtonComponent.prototype, "rounded", {
        get: function () {
            return this._rounded;
        },
        /**
         * The rounded property specifies the border radius of the SplitButton
         * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-rounded)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `'full'`
         * * `null`
         */
        set: function (rounded) {
            this.handleClasses(rounded, 'rounded');
            this._rounded = rounded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "fillMode", {
        get: function () {
            return this._fillMode;
        },
        /**
         * The fillMode property specifies the background and border styles of the SplitButton
         * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-fillMode)).
         *
         * The available values are:
         * * `solid` (default)
         * * `flat`
         * * `outline`
         * * `link`
         */
        set: function (fillMode) {
            this._fillMode = fillMode === 'clear' ? 'flat' : fillMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "disabled", {
        get: function () {
            return this._disabled;
        },
        /**
         * When set to `true`, disables a SplitButton item
         * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).
         */
        set: function (value) {
            if (this.isOpen) {
                this.toggle(false);
            }
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "popupSettings", {
        get: function () {
            return this._popupSettings;
        },
        /**
         * Configures the popup of the SplitButton.
         *
         * The available options are:
         * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
         * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
         * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
         * - `align: "left" | "center" | "right"`&mdash;Specifies the alignment of the popup.
         */
        set: function (settings) {
            this._popupSettings = Object.assign({ animate: true, popupClass: '' }, settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "data", {
        get: function () {
            if (!this._data) {
                this.data = [];
            }
            return this._data;
        },
        /**
         * Sets the data of the SplitButton.
         *
         * > The data has to be provided in an array-like list.
         */
        set: function (data) {
            this._data = data || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "openState", {
        /**
         * @hidden
         */
        get: function () {
            return this._open;
        },
        /**
         * @hidden
         */
        set: function (open) {
            if (this.disabled) {
                return;
            }
            var eventArgs = new PreventableEvent();
            if (open) {
                this.open.emit(eventArgs);
            }
            else {
                this.close.emit(eventArgs);
            }
            if (eventArgs.isDefaultPrevented()) {
                return;
            }
            this._toggle(open);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "active", {
        /**
         * @hidden
         */
        get: function () {
            return this._active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "componentTabIndex", {
        /**
         * @hidden
         */
        get: function () {
            return this.disabled ? -1 : this.tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "isFocused", {
        get: function () {
            return this._isFocused && !this._disabled;
        },
        set: function (value) {
            this._isFocused = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "widgetClasses", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "ariaLabel", {
        /**
         * @hidden
         */
        get: function () {
            var localizationMsg = this.localization.get('splitButtonLabel') || '';
            return replaceMessagePlaceholder(localizationMsg, 'buttonText', this.buttonText);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.onButtonFocus = function () {
        if (!this.isFocused) {
            this._isFocused = true;
            this.onFocus.emit();
        }
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.onArrowButtonClick = function () {
        this.lockFocus = true;
        this.togglePopupVisibility();
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.toggleButtonActiveState = function (enable) {
        this._active = enable;
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.toggleArrowButtonActiveState = function (enable) {
        this.activeArrow = enable;
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.onButtonClick = function () {
        this.lockFocus = true;
        this.buttonClick.emit();
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.onButtonBlur = function () {
        if (!this.isOpen && !this.lockFocus) {
            this.blurWrapper();
        }
        this.lockFocus = false;
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.keydown = function (event) {
        this.keyDownHandler(event);
        if (event.keyCode === Keys.Space) {
            this._active = true;
        }
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.keypress = function (event) {
        this.keyPressHandler(event);
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.keyup = function (event) {
        this._active = false;
        if (event.keyCode !== Keys.Space) {
            this.keyUpHandler(event);
        }
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.ngAfterViewInit = function () {
        this.updateButtonText();
        this.handleClasses(this.rounded, 'rounded');
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.ngOnChanges = function (changes) {
        if (changes.hasOwnProperty('text')) {
            this.updateButtonText();
        }
        if (isChanged("popupSettings", changes) && isPresent(this.popupRef)) {
            var popup = this.popupRef.popup.instance;
            var newSettings = changes.popupSettings.currentValue;
            popup.popupClass = newSettings.popupClass;
            popup.animate = newSettings.animate;
            popup.popupAlign = this.popupAlign;
        }
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.togglePopupVisibility = function () {
        _super.prototype.togglePopupVisibility.call(this);
        if (isDocumentAvailable() && this.lockFocus) {
            this.button.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    SplitButtonComponent.prototype.wrapperContains = function (element) {
        return (this.wrapper === element || this.wrapper.contains(element) || (this.popupRef && this.popupRef.popupElement.contains(element)));
    };
    Object.defineProperty(SplitButtonComponent.prototype, "anchorAlign", {
        /**
         * @hidden
         */
        get: function () {
            var align = { horizontal: this.popupSettings.align || 'left', vertical: 'bottom' };
            if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {
                align.horizontal = 'right';
            }
            return align;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitButtonComponent.prototype, "popupAlign", {
        /**
         * @hidden
         */
        get: function () {
            var align = { horizontal: this.popupSettings.align || 'left', vertical: 'top' };
            if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {
                align.horizontal = 'right';
            }
            return align;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Focuses the SplitButton component.
     */
    SplitButtonComponent.prototype.focus = function () {
        if (isDocumentAvailable()) {
            this.button.nativeElement.focus();
        }
    };
    /**
     * Blurs the SplitButton component.
     */
    SplitButtonComponent.prototype.blur = function () {
        if (isDocumentAvailable()) {
            this.button.nativeElement.blur();
            this.blurWrapper();
        }
    };
    SplitButtonComponent.prototype.ngOnDestroy = function () {
        _super.prototype.ngOnDestroy.call(this);
        this.destroyPopup();
    };
    /**
     * Toggles the visibility of the popup.
     * If the `toggle` method is used to open or close the popup, the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    SplitButtonComponent.prototype.toggle = function (open) {
        var _this = this;
        if (this.disabled) {
            return;
        }
        tick(function () { return _this._toggle(open === undefined ? !_this._open : open); });
    };
    Object.defineProperty(SplitButtonComponent.prototype, "isOpen", {
        /**
         * Returns the current open state of the popup.
         */
        get: function () {
            return this.openState;
        },
        enumerable: true,
        configurable: true
    });
    SplitButtonComponent.prototype.enterHandler = function () {
        if (this.disabled) {
            return;
        }
        if (this.openState) {
            var focused = this.focusService.focused;
            if (isPresent(focused) && focused !== -1) {
                this.emitItemClickHandler(focused);
            }
        }
        else {
            this.buttonClick.emit();
        }
    };
    SplitButtonComponent.prototype.updateButtonText = function () {
        var _this = this;
        if (isDocumentAvailable()) {
            var innerText_1 = this.wrapper.innerText
                .split('\n')
                .join('')
                .trim();
            //setTimout is needed because of `Expression has changed after it was checked.` error;
            setTimeout(function () { return (_this.buttonText = innerText_1); }, 0);
        }
    };
    Object.defineProperty(SplitButtonComponent.prototype, "appendTo", {
        get: function () {
            var appendTo = this.popupSettings.appendTo;
            if (!appendTo || appendTo === 'root') {
                return undefined;
            }
            return appendTo === 'component' ? this.containerRef : appendTo;
        },
        enumerable: true,
        configurable: true
    });
    SplitButtonComponent.prototype._toggle = function (open) {
        this._open = open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    };
    SplitButtonComponent.prototype.createPopup = function () {
        var _this = this;
        this.popupRef = this.popupService.open({
            anchor: this.elRef,
            anchorAlign: this.anchorAlign,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupAlign: this.popupAlign,
            popupClass: this.popupClasses
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(function () { return (_this.openState = false); });
        this.popupRef.popupOpen.subscribe(this.focusFirstItem.bind(this));
    };
    SplitButtonComponent.prototype.destroyPopup = function () {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
    };
    SplitButtonComponent.prototype.handleClasses = function (value, input) {
        var elem = this.wrapperRef.nativeElement;
        var classes = getStylingClasses('button', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitButtonComponent.prototype, "text", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitButtonComponent.prototype, "icon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitButtonComponent.prototype, "iconClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitButtonComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitButtonComponent.prototype, "imageUrl", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitButtonComponent.prototype, "size", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], SplitButtonComponent.prototype, "rounded", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], SplitButtonComponent.prototype, "fillMode", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitButtonComponent.prototype, "themeColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], SplitButtonComponent.prototype, "disabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], SplitButtonComponent.prototype, "popupSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SplitButtonComponent.prototype, "tabIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitButtonComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], SplitButtonComponent.prototype, "data", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SplitButtonComponent.prototype, "buttonClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SplitButtonComponent.prototype, "arrowButtonClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitButtonComponent.prototype, "arrowButtonIcon", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SplitButtonComponent.prototype, "buttonClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SplitButtonComponent.prototype, "itemClick", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], SplitButtonComponent.prototype, "onFocus", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], SplitButtonComponent.prototype, "onBlur", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SplitButtonComponent.prototype, "open", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SplitButtonComponent.prototype, "close", void 0);
    __decorate([
        ContentChild(ButtonItemTemplateDirective, { static: false }),
        __metadata("design:type", ButtonItemTemplateDirective)
    ], SplitButtonComponent.prototype, "itemTemplate", void 0);
    __decorate([
        ViewChild('button', { static: true }),
        __metadata("design:type", ElementRef)
    ], SplitButtonComponent.prototype, "button", void 0);
    __decorate([
        ViewChild('arrowButton', { static: true, read: ElementRef }),
        __metadata("design:type", ElementRef)
    ], SplitButtonComponent.prototype, "arrowButton", void 0);
    __decorate([
        ViewChild('popupTemplate', { static: true }),
        __metadata("design:type", TemplateRef)
    ], SplitButtonComponent.prototype, "popupTemplate", void 0);
    __decorate([
        ViewChild('container', { read: ViewContainerRef, static: true }),
        __metadata("design:type", ViewContainerRef)
    ], SplitButtonComponent.prototype, "containerRef", void 0);
    __decorate([
        HostBinding('class.k-focus'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], SplitButtonComponent.prototype, "isFocused", null);
    __decorate([
        HostBinding('class.k-split-button'),
        HostBinding('class.k-button-group'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SplitButtonComponent.prototype, "widgetClasses", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], SplitButtonComponent.prototype, "dir", null);
    __decorate([
        HostListener('keydown', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SplitButtonComponent.prototype, "keydown", null);
    __decorate([
        HostListener('keypress', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SplitButtonComponent.prototype, "keypress", null);
    __decorate([
        HostListener('keyup', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SplitButtonComponent.prototype, "keyup", null);
    SplitButtonComponent = __decorate([
        Component({
            exportAs: 'kendoSplitButton',
            providers: [
                FocusService,
                NavigationService,
                NAVIGATION_SETTINGS_PROVIDER,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.splitbutton'
                }
            ],
            selector: 'kendo-splitbutton',
            template: "\n        <ng-container kendoSplitButtonLocalizedMessages\n            i18n-splitButtonLabel=\"kendo.splitbutton.splitButtonLabel|The text for the SplitButton aria-label\"\n            splitButtonLabel=\"{{ '{buttonText} splitbutton' }}\">\n        </ng-container>\n        <button\n            kendoButton\n            #button\n            [type]=\"type\"\n            [tabindex]=\"componentTabIndex\"\n            [disabled]=\"disabled\"\n            [size]=\"size\"\n            [rounded]=\"rounded\"\n            [fillMode]=\"fillMode\"\n            [themeColor]=\"themeColor\"\n            [icon]=\"icon\"\n            [class.k-active]=\"active\"\n            [class.k-icon-button]=\"!text && icon\"\n            [iconClass]=\"iconClass\"\n            [imageUrl]=\"imageUrl\"\n            [ngClass]=\"buttonClass\"\n            (focus)=\"onButtonFocus()\"\n            (click)=\"onButtonClick()\"\n            (blur)=\"onButtonBlur()\"\n            (mousedown)=\"toggleButtonActiveState(true)\"\n            (mouseup)=\"toggleButtonActiveState(false)\"\n            [attr.aria-disabled]=\"disabled\"\n            [attr.aria-expanded]=\"openState\"\n            [attr.aria-haspopup]=\"true\"\n            [attr.aria-owns]=\"listId\"\n            [attr.aria-label]=\"ariaLabel\"\n        >\n            <span *ngIf=\"text\" class=\"k-button-text\">\n                {{ text }}\n            </span><ng-content></ng-content>\n        </button>\n        <button\n            kendoButton\n            #arrowButton\n            type=\"button\"\n            [class.k-active]=\"activeArrow\"\n            [disabled]=\"disabled\"\n            [icon]=\"arrowButtonIcon\"\n            [size]=\"size\"\n            [rounded]=\"rounded\"\n            [fillMode]=\"fillMode\"\n            [themeColor]=\"fillMode ? themeColor : null\"\n            [tabindex]=\"-1\"\n            [ngClass]=\"arrowButtonClass\"\n            (click)=\"onArrowButtonClick()\"\n            (mousedown)=\"toggleArrowButtonActiveState(true)\"\n            (mouseup)=\"toggleArrowButtonActiveState(false)\"\n        ></button>\n        <ng-template #popupTemplate>\n            <kendo-button-list\n                [id]=\"listId\"\n                [data]=\"data\"\n                [textField]=\"textField\"\n                [itemTemplate]=\"itemTemplate\"\n                (onItemClick)=\"onItemClick($event)\"\n                (keydown)=\"keyDownHandler($event)\"\n                (keypress)=\"keyPressHandler($event)\"\n                (keyup)=\"keyUpHandler($event)\"\n                [attr.dir]=\"dir\"\n                [size]=\"size\"\n            >\n            </kendo-button-list>\n        </ng-template>\n        <ng-container #container></ng-container>\n    "
        }),
        __metadata("design:paramtypes", [FocusService,
            NavigationService,
            ElementRef,
            NgZone,
            PopupService,
            ElementRef,
            LocalizationService,
            ChangeDetectorRef,
            Renderer2])
    ], SplitButtonComponent);
    return SplitButtonComponent;
}(ListButton));

/**
 * @hidden
 */
var Messages = /** @class */ (function (_super) {
    __extends(Messages, _super);
    function Messages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], Messages.prototype, "splitButtonLabel", void 0);
    return Messages;
}(ComponentMessages));

/**
 * @hidden
 */
var LocalizedSplitButtonMessagesDirective = /** @class */ (function (_super) {
    __extends(LocalizedSplitButtonMessagesDirective, _super);
    function LocalizedSplitButtonMessagesDirective(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    LocalizedSplitButtonMessagesDirective_1 = LocalizedSplitButtonMessagesDirective;
    var LocalizedSplitButtonMessagesDirective_1;
    LocalizedSplitButtonMessagesDirective = LocalizedSplitButtonMessagesDirective_1 = __decorate([
        Directive({
            providers: [
                {
                    provide: Messages,
                    useExisting: forwardRef(function () { return LocalizedSplitButtonMessagesDirective_1; })
                }
            ],
            selector: '[kendoSplitButtonLocalizedMessages]'
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], LocalizedSplitButtonMessagesDirective);
    return LocalizedSplitButtonMessagesDirective;
}(Messages));

/**
 * Custom component messages override default component messages
 * ([see example]({% slug rtl_buttons %}).
 */
var SplitButtonCustomMessagesComponent = /** @class */ (function (_super) {
    __extends(SplitButtonCustomMessagesComponent, _super);
    function SplitButtonCustomMessagesComponent(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    SplitButtonCustomMessagesComponent_1 = SplitButtonCustomMessagesComponent;
    Object.defineProperty(SplitButtonCustomMessagesComponent.prototype, "override", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    var SplitButtonCustomMessagesComponent_1;
    SplitButtonCustomMessagesComponent = SplitButtonCustomMessagesComponent_1 = __decorate([
        Component({
            providers: [
                {
                    provide: Messages,
                    useExisting: forwardRef(function () { return SplitButtonCustomMessagesComponent_1; })
                }
            ],
            selector: 'kendo-splitbutton-messages',
            template: ""
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], SplitButtonCustomMessagesComponent);
    return SplitButtonCustomMessagesComponent;
}(Messages));

/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `SplitButtonComponent`&mdash;The SplitButtonComponent component class.
 */
var SplitButtonModule = /** @class */ (function () {
    function SplitButtonModule() {
    }
    SplitButtonModule = __decorate([
        NgModule({
            declarations: [SplitButtonComponent, LocalizedSplitButtonMessagesDirective, SplitButtonCustomMessagesComponent],
            exports: [SplitButtonComponent, ListModule, LocalizedSplitButtonMessagesDirective, SplitButtonCustomMessagesComponent],
            imports: [CommonModule, PopupModule, ButtonModule, ListModule]
        })
    ], SplitButtonModule);
    return SplitButtonModule;
}());

var NAVIGATION_SETTINGS$1 = {
    useLeftRightArrows: true
};
var Éµ0$1 = NAVIGATION_SETTINGS$1;
var NAVIGATION_SETTINGS_PROVIDER$1 = {
    provide: NAVIGATION_CONFIG,
    useValue: Éµ0$1
};
/**
 * Represents the Kendo UI DropDownButton component for Angular.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-dropdownbutton [data]="data">
 *    User Settings
 *  </kendo-dropdownbutton>
 * `
 * })
 * class AppComponent {
 *   public data: Array<any> = [{
 *       text: 'My Profile'
 *   }, {
 *       text: 'Friend Requests'
 *   }, {
 *       text: 'Account Settings'
 *   }, {
 *       text: 'Support'
 *   }, {
 *       text: 'Log Out'
 *   }];
 * }
 * ```
 */
var DropDownButtonComponent = /** @class */ (function (_super) {
    __extends(DropDownButtonComponent, _super);
    function DropDownButtonComponent(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr) {
        var _this = _super.call(this, focusService, navigationService, wrapperRef, zone, localization, cdr) || this;
        _this.popupService = popupService;
        _this.elRef = elRef;
        /**
         * Defines the name of an existing icon in a Kendo UI theme.
         */
        _this.icon = '';
        /**
         * Defines the list of CSS classes which are used for styling the Button with custom icons.
         */
        _this.iconClass = '';
        /**
         * Defines a URL for styling the button with a custom image.
         */
        _this.imageUrl = '';
        /**
         * The size property specifies the padding of the DropDownButton
         * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-size)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `null`
         */
        _this.size = 'medium';
        /**
         * The shape property specifies if the DropDownButton will be a square or rectangle.
         * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-shape)).
         *
         * The possible values are:
         * * `'rectangle'` (default)
         * * `'square'`
         * * `null`
         */
        _this.shape = 'rectangle';
        /**
         * The rounded property specifies the border radius of the DropDownButton
         * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-rounded)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `'full'`
         * * `null`
         */
        _this.rounded = 'medium';
        /**
         * The DropDownButton allows you to specify predefined theme colors.
         * The theme color will be applied as a background and border color while also amending the text color accordingly
         * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-themeColor)).
         *
         * The possible values are:
         * * `base` &mdash;Applies coloring based on the `base` theme color. (default)
         * * `primary` &mdash;Applies coloring based on the `primary` theme color.
         * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.
         * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.
         * * `info`&mdash;Applies coloring based on the `info` theme color.
         * * `success`&mdash; Applies coloring based on the `success` theme color.
         * * `warning`&mdash; Applies coloring based on the `warning` theme color.
         * * `error`&mdash; Applies coloring based on the `error` theme color.
         * * `dark`&mdash; Applies coloring based on the `dark` theme color.
         * * `light`&mdash; Applies coloring based on the `light` theme color.
         * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.
         * * `null` &mdash;Removes the default CSS class (no class would be rendered).
         */
        _this.themeColor = 'base';
        /**
         * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        _this.tabIndex = 0;
        /**
         * Fires each time the user clicks on a drop-down list item. The event data contains the data item bound to the clicked list item.
         */
        _this.itemClick = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel the event, the popup will remain closed.
         */
        _this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel the event, the popup will remain open.
         */
        _this.close = new EventEmitter();
        /**
         * Fires each time the DropDownButton gets focused.
         */
        _this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the DropDownButton gets blurred.
         */
        _this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        _this.listId = guid();
        _this._fillMode = 'solid';
        _this._itemClick = _this.itemClick;
        _this._blur = _this.onBlur;
        return _this;
    }
    Object.defineProperty(DropDownButtonComponent.prototype, "popupSettings", {
        get: function () {
            return this._popupSettings;
        },
        /**
         * Configures the popup of the DropDownButton.
         *
         * The available options are:
         * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
         * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
         * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
         * - `align: "left" | "center" | "right"`&mdash;Specifies the alignment of the popup.
         */
        set: function (settings) {
            this._popupSettings = Object.assign({ animate: true, popupClass: '' }, settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "disabled", {
        get: function () {
            return this._disabled;
        },
        /**
         * Sets the disabled state of the DropDownButton.
         */
        set: function (value) {
            if (value && this.openState) {
                this.openState = false;
            }
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "data", {
        get: function () {
            return this._data;
        },
        /**
         * Sets or gets the data of the DropDownButton.
         *
         * > The data has to be provided in an array-like list.
         */
        set: function (data) {
            this._data = data || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "fillMode", {
        get: function () {
            return this._fillMode;
        },
        /**
         * The fillMode property specifies the background and border styles of the DropDownButton
         * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-fillMode)).
         *
         * The available values are:
         * * `solid` (default)
         * * `flat`
         * * `outline`
         * * `link`
         * * `null`
         */
        set: function (fillMode) {
            this._fillMode = fillMode === 'clear' ? 'flat' : fillMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "openState", {
        /**
         * @hidden
         */
        get: function () {
            return this._open;
        },
        /**
         * @hidden
         */
        set: function (open) {
            if (this.disabled) {
                return;
            }
            var eventArgs = new PreventableEvent();
            if (open) {
                this.open.emit(eventArgs);
            }
            else {
                this.close.emit(eventArgs);
            }
            if (eventArgs.isDefaultPrevented()) {
                return;
            }
            this._toggle(open);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "componentTabIndex", {
        /**
         * @hidden
         */
        get: function () {
            return this.disabled ? (-1) : this.tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "appendTo", {
        get: function () {
            var appendTo = this.popupSettings.appendTo;
            if (!appendTo || appendTo === 'root') {
                return undefined;
            }
            return appendTo === 'component' ? this.container : appendTo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "focused", {
        get: function () {
            return this._isFocused && !this._disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "widgetClasses", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "active", {
        /**
         * @hidden
         */
        get: function () {
            return this._active;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DropDownButtonComponent.prototype.keydown = function (event) {
        this.keyDownHandler(event);
        if (event.keyCode === Keys.Space) {
            this._active = true;
        }
    };
    /**
     * @hidden
     */
    DropDownButtonComponent.prototype.keypress = function (event) {
        this.keyPressHandler(event);
    };
    /**
     * @hidden
     */
    DropDownButtonComponent.prototype.keyup = function (event) {
        this.keyUpHandler(event);
        this._active = false;
    };
    /**
     * @hidden
     */
    DropDownButtonComponent.prototype.mousedown = function (event) {
        if (this._disabled) {
            event.preventDefault();
        }
        this._active = true;
    };
    /**
     * @hidden
     */
    DropDownButtonComponent.prototype.mouseup = function (event) {
        if (this._disabled) {
            event.preventDefault();
        }
        this._active = false;
    };
    /**
     * @hidden
     */
    DropDownButtonComponent.prototype.openPopup = function () {
        this.togglePopupVisibility();
    };
    /**
     * @hidden
     */
    DropDownButtonComponent.prototype.onButtonBlur = function () {
        if (!this.isOpen) {
            this.blurWrapper();
        }
    };
    Object.defineProperty(DropDownButtonComponent.prototype, "anchorAlign", {
        /**
         * @hidden
         */
        get: function () {
            var align = { horizontal: this.popupSettings.align || 'left', vertical: 'bottom' };
            if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {
                align.horizontal = 'right';
            }
            return align;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownButtonComponent.prototype, "popupAlign", {
        /**
         * @hidden
         */
        get: function () {
            var align = { horizontal: this.popupSettings.align || 'left', vertical: 'top' };
            if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {
                align.horizontal = 'right';
            }
            return align;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Focuses the DropDownButton component.
     */
    DropDownButtonComponent.prototype.focus = function () {
        if (isDocumentAvailable()) {
            this.button.nativeElement.focus();
        }
    };
    /**
     * Blurs the DropDownButton component.
     */
    DropDownButtonComponent.prototype.blur = function () {
        if (isDocumentAvailable()) {
            this.button.nativeElement.blur();
            this.blurWrapper();
        }
    };
    DropDownButtonComponent.prototype.ngOnChanges = function (changes) {
        if (isChanged("popupSettings", changes) && isPresent(this.popupRef)) {
            var popup = this.popupRef.popup.instance;
            var newSettings = changes.popupSettings.currentValue;
            popup.popupClass = newSettings.popupClass;
            popup.animate = newSettings.animate;
            popup.popupAlign = this.popupAlign;
        }
    };
    DropDownButtonComponent.prototype.ngOnDestroy = function () {
        _super.prototype.ngOnDestroy.call(this);
        this.destroyPopup();
    };
    /**
     * Toggles the visibility of the popup.
     * If the `toggle` method is used to open or close the popup, the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    DropDownButtonComponent.prototype.toggle = function (open) {
        var _this = this;
        if (this.disabled) {
            return;
        }
        tick(function () { return (_this._toggle((open === undefined) ? !_this._open : open)); });
    };
    Object.defineProperty(DropDownButtonComponent.prototype, "isOpen", {
        /**
         * Returns the current open state of the popup.
         */
        get: function () {
            return this.openState;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DropDownButtonComponent.prototype.handleFocus = function () {
        if (!this._disabled && !this._isFocused) {
            this._isFocused = true;
            this.onFocus.emit();
        }
    };
    /**
     * @hidden
     */
    DropDownButtonComponent.prototype.wrapperContains = function (element) {
        return this.wrapper === element
            || this.wrapper.contains(element)
            || (this.popupRef && this.popupRef.popupElement.contains(element));
    };
    DropDownButtonComponent.prototype.subscribeNavigationEvents = function () {
        this.navigationSubscription = this.navigationService.navigate
            .subscribe(this.onArrowKeyNavigate.bind(this));
        this.enterUpSubscription = this.navigationService.enterup.subscribe(this.onNavigationEnterUp.bind(this));
        this.openSubscription = this.navigationService.open.subscribe(this.onNavigationOpen.bind(this));
        this.closeSubscription = merge(this.navigationService.close, this.navigationService.esc).subscribe(this.onNavigationClose.bind(this));
    };
    DropDownButtonComponent.prototype.onNavigationEnterUp = function () {
        if (!this._disabled && !this.openState) {
            this._active = false;
        }
        if (this.openState) {
            var focused = this.focusService.focused;
            if (isPresent(focused) && focused !== -1) {
                this.emitItemClickHandler(focused);
            }
        }
        this.togglePopupVisibility();
        if (!this.openState && isDocumentAvailable()) {
            this.button.nativeElement.focus();
        }
    };
    DropDownButtonComponent.prototype.onNavigationOpen = function () {
        if (!this._disabled && !this.openState) {
            this.togglePopupVisibility();
        }
    };
    DropDownButtonComponent.prototype.onNavigationClose = function () {
        if (this.openState) {
            this.togglePopupVisibility();
            if (isDocumentAvailable()) {
                this.button.nativeElement.focus();
            }
        }
    };
    DropDownButtonComponent.prototype.onArrowKeyNavigate = function (index) {
        this.focusService.focus(index);
    };
    DropDownButtonComponent.prototype._toggle = function (open) {
        if (this._open === open) {
            return;
        }
        this._open = open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    };
    DropDownButtonComponent.prototype.createPopup = function () {
        var _this = this;
        this.popupRef = this.popupService.open({
            anchor: this.elRef,
            anchorAlign: this.anchorAlign,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupAlign: this.popupAlign,
            popupClass: this.popupClasses
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(function () { return _this.openState = false; });
        this.popupRef.popupOpen.subscribe(this.focusFirstItem.bind(this));
    };
    DropDownButtonComponent.prototype.destroyPopup = function () {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownButtonComponent.prototype, "icon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownButtonComponent.prototype, "iconClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownButtonComponent.prototype, "imageUrl", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DropDownButtonComponent.prototype, "popupSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownButtonComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], DropDownButtonComponent.prototype, "disabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DropDownButtonComponent.prototype, "data", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownButtonComponent.prototype, "size", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownButtonComponent.prototype, "shape", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownButtonComponent.prototype, "rounded", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], DropDownButtonComponent.prototype, "fillMode", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownButtonComponent.prototype, "themeColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DropDownButtonComponent.prototype, "buttonClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DropDownButtonComponent.prototype, "tabIndex", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownButtonComponent.prototype, "itemClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownButtonComponent.prototype, "open", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownButtonComponent.prototype, "close", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], DropDownButtonComponent.prototype, "onFocus", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], DropDownButtonComponent.prototype, "onBlur", void 0);
    __decorate([
        HostBinding('class.k-focus'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DropDownButtonComponent.prototype, "focused", null);
    __decorate([
        HostBinding('class.k-dropdown-button'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DropDownButtonComponent.prototype, "widgetClasses", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], DropDownButtonComponent.prototype, "dir", null);
    __decorate([
        ContentChild(ButtonItemTemplateDirective, { static: false }),
        __metadata("design:type", ButtonItemTemplateDirective)
    ], DropDownButtonComponent.prototype, "itemTemplate", void 0);
    __decorate([
        ViewChild('button', { static: true }),
        __metadata("design:type", ElementRef)
    ], DropDownButtonComponent.prototype, "button", void 0);
    __decorate([
        ViewChild('buttonList', { static: false }),
        __metadata("design:type", ListComponent)
    ], DropDownButtonComponent.prototype, "buttonList", void 0);
    __decorate([
        ViewChild('popupTemplate', { static: true }),
        __metadata("design:type", TemplateRef)
    ], DropDownButtonComponent.prototype, "popupTemplate", void 0);
    __decorate([
        ViewChild('container', { read: ViewContainerRef, static: true }),
        __metadata("design:type", ViewContainerRef)
    ], DropDownButtonComponent.prototype, "container", void 0);
    __decorate([
        HostListener('keydown', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], DropDownButtonComponent.prototype, "keydown", null);
    __decorate([
        HostListener('keypress', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], DropDownButtonComponent.prototype, "keypress", null);
    __decorate([
        HostListener('keyup', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], DropDownButtonComponent.prototype, "keyup", null);
    __decorate([
        HostListener('mousedown', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], DropDownButtonComponent.prototype, "mousedown", null);
    __decorate([
        HostListener('mouseup', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], DropDownButtonComponent.prototype, "mouseup", null);
    DropDownButtonComponent = __decorate([
        Component({
            exportAs: 'kendoDropDownButton',
            providers: [
                FocusService,
                NavigationService,
                NAVIGATION_SETTINGS_PROVIDER$1,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.dropdownbutton'
                }
            ],
            selector: 'kendo-dropdownbutton',
            template: "\n        <button kendoButton #button\n            role=\"menu\"\n            type=\"button\"\n            [tabindex]=\"componentTabIndex\"\n            [class.k-active]=\"active\"\n            [disabled]=\"disabled\"\n            [icon]=\"icon\"\n            [iconClass]=\"iconClass\"\n            [imageUrl]=\"imageUrl\"\n            [ngClass]=\"buttonClass\"\n            [size]=\"size\"\n            [shape]=\"shape\"\n            [rounded]=\"rounded\"\n            [fillMode]=\"fillMode\"\n            [themeColor]=\"fillMode ? themeColor : null\"\n            (click)=\"openPopup()\"\n            (focus)=\"handleFocus()\"\n            (blur)=\"onButtonBlur()\"\n            [attr.aria-disabled]=\"disabled\"\n            [attr.aria-expanded]=\"openState\"\n            [attr.aria-haspopup]=\"true\"\n            [attr.aria-owns]=\"listId\"\n        >\n            <ng-content></ng-content>\n        </button>\n        <ng-template #popupTemplate>\n            <kendo-button-list\n                #buttonList\n                [id]=\"listId\"\n                [data]=\"data\"\n                [textField]=\"textField\"\n                [itemTemplate]=\"itemTemplate\"\n                (onItemClick)=\"onItemClick($event)\"\n                (keydown)=\"keyDownHandler($event)\"\n                (keypress)=\"keyPressHandler($event)\"\n                (keyup)=\"keyUpHandler($event)\"\n                [attr.dir]=\"dir\"\n                [size]=\"size\"\n            >\n            </kendo-button-list>\n        </ng-template>\n        <ng-container #container></ng-container>\n    "
        }),
        __metadata("design:paramtypes", [FocusService,
            NavigationService,
            ElementRef,
            NgZone,
            PopupService,
            ElementRef,
            LocalizationService,
            ChangeDetectorRef])
    ], DropDownButtonComponent);
    return DropDownButtonComponent;
}(ListButton));

/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `DropDownButtonComponent`&mdash;The DropDownButtonComponent component class.
 */
var DropDownButtonModule = /** @class */ (function () {
    function DropDownButtonModule() {
    }
    DropDownButtonModule = __decorate([
        NgModule({
            declarations: [DropDownButtonComponent],
            exports: [DropDownButtonComponent, ListModule],
            imports: [CommonModule, PopupModule, ListModule, ButtonModule]
        })
    ], DropDownButtonModule);
    return DropDownButtonModule;
}());

/**
 * Displays a Chip that represents an input, attribute or an action.
 */
var ChipComponent = /** @class */ (function () {
    function ChipComponent(element, renderer, ngZone, localizationService) {
        this.element = element;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.localizationService = localizationService;
        /**
         * Specifies the selected state of the Chip.
         * @default false
         */
        this.selected = false;
        /**
         * Specifies if the Chip will be removable or not.
         * If the property is set to `true`, the Chip renders a remove icon.
         * @default false
         */
        this.removable = false;
        /**
         * If set to `true`, the Chip will be disabled.
         * @default false
         */
        this.disabled = false;
        /**
         * Fires each time the user clicks the remove icon of the Chip.
         */
        this.remove = new EventEmitter();
        /**
         * Fires each time the user clicks the content of the Chip.
         */
        this.contentClick = new EventEmitter();
        this.tabIndex = 0;
        this.hostClass = true;
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        this._themeColor = 'base';
        this.focused = false;
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    Object.defineProperty(ChipComponent.prototype, "size", {
        get: function () {
            return this._size;
        },
        /**
         * The size property specifies the padding of the Chip
         * ([see example]({% slug appearance_chip %}#toc-size)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `null`
         */
        set: function (size) {
            this.handleClasses(size, 'size');
            this._size = size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "rounded", {
        get: function () {
            return this._rounded;
        },
        /**
         * The rounded property specifies the border radius of the Chip
         * ([see example]({% slug appearance_chip %}#toc-rounded)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `'full'`
         * * `null`
         */
        set: function (rounded) {
            this.handleClasses(rounded, 'rounded');
            this._rounded = rounded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "fillMode", {
        get: function () {
            return this._fillMode;
        },
        /**
         * The fillMode property specifies the background and border styles of the Chip
         * ([see example]({% slug appearance_chip %}#toc-fillMode)).
         *
         * The possible values are:
         * * `'solid'` (default)
         * * `'outline'`
         * * `null`
         */
        set: function (fillMode) {
            this.handleClasses(fillMode, 'fillMode');
            this._fillMode = fillMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "themeColor", {
        get: function () {
            return this._themeColor;
        },
        /**
         * The Chip allows you to specify predefined theme colors.
         * The theme color will be applied as a background and border color while also amending the text color accordingly
         * ([see example]({% slug appearance_chip %}#toc-themeColor)).
         *
         * The possible values are:
         * * `'base'` (default)
         * * `'info'`
         * * `'success'`
         * * `'warning'`
         * * `'error'`
         * * `null`
         */
        set: function (themeColor) {
            this.handleThemeColor(themeColor);
            this._themeColor = themeColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "ariaChecked", {
        get: function () {
            return this.selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "hasIconClass", {
        get: function () {
            return this.icon || this.iconClass || this.avatarClass ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "disabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "selectedClass", {
        get: function () {
            return this.selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "focusedClass", {
        get: function () {
            return this.focused;
        },
        enumerable: true,
        configurable: true
    });
    ChipComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.dynamicRTLSubscription = this.localizationService.changes
            .subscribe(function (_a) {
            var rtl = _a.rtl;
            return _this.direction = rtl ? 'rtl' : 'ltr';
        });
    };
    ChipComponent.prototype.ngOnDestroy = function () {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
        if (this.detachDomEvents) {
            this.detachDomEvents();
        }
    };
    ChipComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var chip = this.element.nativeElement;
        var stylingOptions = ['size', 'rounded', 'fillMode'];
        stylingOptions.forEach(function (input) {
            _this.handleClasses(_this[input], input);
        });
        this.attachElementEventHandlers(chip);
    };
    Object.defineProperty(ChipComponent.prototype, "kendoIconClass", {
        /**
         * @hidden
         */
        get: function () {
            this.verifyIconSettings([this.iconClass, this.avatarClass]);
            return "k-i-" + this.icon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "customIconClass", {
        /**
         * @hidden
         */
        get: function () {
            this.verifyIconSettings([this.icon, this.avatarClass]);
            return "" + this.iconClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "chipAvatarClass", {
        /**
         * @hidden
         */
        get: function () {
            this.verifyIconSettings([this.icon, this.iconClass]);
            return "" + this.avatarClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipComponent.prototype, "removeIconClass", {
        /**
         * @hidden
         */
        get: function () {
            if (this.removeIcon) {
                return "" + this.removeIcon;
            }
            return "k-i-close-circle";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Focuses the Chip component.
     */
    ChipComponent.prototype.focus = function () {
        if (isDocumentAvailable()) {
            this.element.nativeElement.focus();
        }
    };
    /**
     * Blurs the Chip component.
     */
    ChipComponent.prototype.blur = function () {
        if (isDocumentAvailable()) {
            this.element.nativeElement.blur();
        }
    };
    /**
     * @hidden
     */
    ChipComponent.prototype.onRemoveClick = function (e) {
        if (this.removable) {
            this.remove.emit({ sender: this, originalEvent: e });
        }
    };
    ChipComponent.prototype.attachElementEventHandlers = function (chip) {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            var focusListener = _this.renderer.listen(chip, 'focus', function () {
                _this.renderer.addClass(chip, 'k-focus');
            });
            var blurListener = _this.renderer.listen(chip, 'blur', function () {
                _this.renderer.removeClass(chip, 'k-focus');
            });
            var contentClickListener = _this.renderer.listen(chip, 'click', function (e) {
                var isRemoveClicked = closest(e.target, '.k-chip-remove-action');
                if (!isRemoveClicked) {
                    _this.ngZone.run(function () {
                        _this.contentClick.emit({ sender: _this, originalEvent: e });
                    });
                }
            });
            _this.detachDomEvents = function () {
                focusListener();
                blurListener();
                contentClickListener();
            };
        });
    };
    /**
     * @hidden
     */
    ChipComponent.prototype.verifyIconSettings = function (iconsToCheck) {
        if (isDevMode()) {
            if (iconsToCheck.filter(function (icon) { return icon !== null && icon !== undefined; }).length > 0) {
                this.renderer.removeClass(this.element.nativeElement, 'k-chip-has-icon');
                throw new Error('Invalid configuration: Having multiple icons is not supported. Only a single icon on a chip can be displayed.');
            }
        }
    };
    ChipComponent.prototype.handleClasses = function (value, input) {
        var elem = this.element.nativeElement;
        var classes = getStylingClasses('chip', input, this[input], value);
        if (input === 'fillMode') {
            this.handleThemeColor(this.themeColor, this[input], value);
        }
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    };
    ChipComponent.prototype.handleThemeColor = function (value, prevFillMode, fillMode) {
        var elem = this.element.nativeElement;
        var removeFillMode = prevFillMode ? prevFillMode : this.fillMode;
        var addFillMode = fillMode ? fillMode : this.fillMode;
        var themeColorClass = getThemeColorClasses('chip', removeFillMode, addFillMode, this.themeColor, value);
        this.renderer.removeClass(elem, themeColorClass.toRemove);
        if (addFillMode !== null && fillMode !== null) {
            if (themeColorClass.toAdd) {
                this.renderer.addClass(elem, themeColorClass.toAdd);
            }
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ChipComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ChipComponent.prototype, "icon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ChipComponent.prototype, "iconClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ChipComponent.prototype, "avatarClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ChipComponent.prototype, "selected", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ChipComponent.prototype, "removable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ChipComponent.prototype, "removeIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ChipComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ChipComponent.prototype, "size", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ChipComponent.prototype, "rounded", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ChipComponent.prototype, "fillMode", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ChipComponent.prototype, "themeColor", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ChipComponent.prototype, "remove", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ChipComponent.prototype, "contentClick", void 0);
    __decorate([
        HostBinding('attr.tabindex'),
        __metadata("design:type", Number)
    ], ChipComponent.prototype, "tabIndex", void 0);
    __decorate([
        HostBinding('attr.aria-checked'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ChipComponent.prototype, "ariaChecked", null);
    __decorate([
        HostBinding('class.k-chip'),
        __metadata("design:type", Boolean)
    ], ChipComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('class.k-chip-has-icon'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ChipComponent.prototype, "hasIconClass", null);
    __decorate([
        HostBinding('attr.aria-disabled'),
        HostBinding('class.k-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ChipComponent.prototype, "disabledClass", null);
    __decorate([
        HostBinding('class.k-selected'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ChipComponent.prototype, "selectedClass", null);
    __decorate([
        HostBinding('class.k-focus'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ChipComponent.prototype, "focusedClass", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], ChipComponent.prototype, "direction", void 0);
    ChipComponent = __decorate([
        Component({
            selector: 'kendo-chip',
            template: "\n        <span\n            *ngIf=\"icon\"\n            class=\"k-chip-icon k-icon\"\n            [ngClass]=\"kendoIconClass\"\n        >\n        </span>\n\n        <span\n            *ngIf=\"iconClass\"\n            class=\"k-chip-icon\"\n            [ngClass]=\"customIconClass\"\n        >\n        </span>\n\n        <span\n            *ngIf=\"avatarClass\"\n            class=\"k-chip-avatar k-avatar k-rounded-full\"\n        >\n            <span class=\"k-avatar-image\" [ngClass]=\"chipAvatarClass\"></span>\n        </span>\n\n        <span class=\"k-chip-content\">\n            <span class=\"k-chip-label\" *ngIf=\"label\">\n                {{ label }}\n            </span>\n            <ng-content *ngIf=\"!label\"></ng-content>\n        </span>\n\n        <span class=\"k-chip-actions\">\n            <span class=\"k-chip-action k-chip-remove-action\"\n                *ngIf=\"removable\"\n                (click)=\"onRemoveClick($event)\"\n                >\n                <span\n                    class=\"k-icon\"\n                    [ngClass]=\"removeIconClass\"\n                >\n                </span>\n            </span>\n        </span>\n    ",
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.chip'
                }
            ]
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            NgZone,
            LocalizationService])
    ], ChipComponent);
    return ChipComponent;
}());

var ChipListComponent = /** @class */ (function () {
    function ChipListComponent(localizationService, renderer, element) {
        this.localizationService = localizationService;
        this.renderer = renderer;
        this.element = element;
        this.hostClass = true;
        /**
         * Sets the selection mode of the ChipList.
         *
         * The available values are:
         * * `none` (default)
         * * `single`
         * * `multiple`
         */
        this.selection = 'none';
        /**
         * Fires each time when the ChipList selection is changed.
         */
        this.selectedChange = new EventEmitter();
        /**
         * Fires each time the user clicks on the remove icon of the Chip.
         */
        this.remove = new EventEmitter();
        this.role = 'listbox';
        this._size = 'medium';
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    Object.defineProperty(ChipListComponent.prototype, "size", {
        get: function () {
            return this._size;
        },
        /**
         * The size property specifies the gap between the Chips in the ChipList
         * ([see example]({% slug appearance_chiplist %}#toc-size)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `null`
         */
        set: function (size) {
            this.handleClasses(size, 'size');
            this._size = size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipListComponent.prototype, "single", {
        get: function () {
            return this.selection === 'single';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChipListComponent.prototype, "multiple", {
        get: function () {
            return this.selection === 'multiple';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    ChipListComponent.prototype.onClick = function ($event) {
        var target = $event.target;
        var isRemoveClicked = closest(target, '.k-chip-remove-action');
        var clickedChip = closest(target, '.k-chip');
        var chip = this.chips.find(function (chip) { return clickedChip === chip.element.nativeElement; });
        if (isRemoveClicked && clickedChip) {
            var removeEventArgs = { sender: this, originalEvent: $event, removedChip: chip };
            this.remove.emit(removeEventArgs);
        }
        if (this.selection !== 'none' && clickedChip && !isRemoveClicked) {
            this.setSelection(chip);
        }
    };
    ChipListComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.dynamicRTLSubscription = this.localizationService.changes
            .subscribe(function (_a) {
            var rtl = _a.rtl;
            return _this.direction = rtl ? 'rtl' : 'ltr';
        });
    };
    ChipListComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var stylingInputs = ['size'];
        stylingInputs.forEach(function (input) {
            _this.handleClasses(_this[input], input);
        });
    };
    ChipListComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.chips.forEach(function (chip) {
            _this.renderer.setAttribute(chip.element.nativeElement, 'role', 'option');
        });
    };
    ChipListComponent.prototype.ngOnDestroy = function () {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    };
    ChipListComponent.prototype.selectedChips = function () {
        return this.chips.reduce(function (acc, cur, idx) { return cur.selected ? acc.concat(idx) : acc; }, []);
    };
    /**
     * Updates the selection on click of a Chip. Emits events.
     */
    ChipListComponent.prototype.setSelection = function (chip) {
        if (this.selection === 'single') {
            this.clearSelection(chip);
        }
        chip.selected = !chip.selected;
        this.selectedChange.emit(this.selectedChips());
    };
    ChipListComponent.prototype.clearSelection = function (chip) {
        this.chips.forEach(function (c) {
            if (chip !== c) {
                c.selected = false;
            }
        });
    };
    ChipListComponent.prototype.handleClasses = function (value, input) {
        var elem = this.element.nativeElement;
        var classes = getStylingClasses('chip-list', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    };
    __decorate([
        HostBinding('class.k-chip-list'),
        __metadata("design:type", Boolean)
    ], ChipListComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], ChipListComponent.prototype, "direction", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ChipListComponent.prototype, "selection", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], ChipListComponent.prototype, "size", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ChipListComponent.prototype, "selectedChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ChipListComponent.prototype, "remove", void 0);
    __decorate([
        ContentChildren(ChipComponent),
        __metadata("design:type", QueryList)
    ], ChipListComponent.prototype, "chips", void 0);
    __decorate([
        HostBinding('class.k-selection-single'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ChipListComponent.prototype, "single", null);
    __decorate([
        HostBinding('class.k-selection-multiple'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ChipListComponent.prototype, "multiple", null);
    __decorate([
        HostBinding('attr.role'),
        __metadata("design:type", String)
    ], ChipListComponent.prototype, "role", void 0);
    __decorate([
        HostListener('click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], ChipListComponent.prototype, "onClick", null);
    ChipListComponent = __decorate([
        Component({
            selector: 'kendo-chiplist, kendo-chip-list',
            template: "\n        <ng-content></ng-content>\n    ",
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.chiplist'
                }
            ]
        }),
        __metadata("design:paramtypes", [LocalizationService,
            Renderer2,
            ElementRef])
    ], ChipListComponent);
    return ChipListComponent;
}());

var exportedModules = [
    ChipComponent,
    ChipListComponent
];
var declarations = exportedModules.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Chip and ChipList components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Chip module
 * import { ChipModule } from '@progress/kendo-angular-buttons';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, ChipModule], // import Chip module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * ```
 */
var ChipModule = /** @class */ (function () {
    function ChipModule() {
    }
    ChipModule = __decorate([
        NgModule({
            declarations: [declarations],
            exports: [exportedModules],
            imports: [CommonModule]
        })
    ], ChipModule);
    return ChipModule;
}());

/**
 * @hidden
 */
function getAnchorAlign(fabAlign, rtl) {
    var align = { horizontal: (rtl ? 'right' : 'left'), vertical: 'bottom' };
    if (fabAlign.horizontal === 'end') {
        align.horizontal = rtl ? 'left' : 'right';
    }
    if (fabAlign.vertical === 'bottom') {
        align.vertical = 'top';
    }
    if (fabAlign.vertical === 'bottom' && fabAlign.horizontal === 'end') {
        align.horizontal = rtl ? 'left' : 'right';
        align.vertical = 'top';
    }
    return align;
}
/**
 * @hidden
 */
function getPopupAlign(fabAlign, rtl) {
    var align = { horizontal: (rtl ? 'right' : 'left'), vertical: 'top' };
    if (fabAlign.horizontal === 'end') {
        align.horizontal = rtl ? 'left' : 'right';
    }
    if (fabAlign.vertical === 'bottom') {
        align.vertical = 'bottom';
    }
    if (fabAlign.vertical === 'bottom' && fabAlign.horizontal === 'end') {
        align.horizontal = rtl ? 'left' : 'right';
        align.vertical = 'bottom';
    }
    return align;
}

/**
 * @hidden
 */
function openAnimation(animationSettings) {
    var isBottom = animationSettings.align.vertical === 'bottom';
    var duration = animationSettings.duration;
    var gap = animationSettings.gap;
    return sequence([
        query(".k-fab-item", [
            style({ opacity: 0, transform: "translateY(" + (isBottom ? '8px' : '-8px') + ")" }),
            stagger(gap, [animate(duration + "ms ease-in", style({ opacity: '*', transform: 'translateY(0)' }))])
        ], { optional: true })
    ]);
}
/**
 * @hidden
 */
function closeAnimation(animationSettings) {
    var isBottom = animationSettings.align.vertical === 'bottom';
    var duration = animationSettings.duration;
    var gap = animationSettings.gap;
    return sequence([
        query(".k-fab-item", [
            style({ opacity: '*', transform: 'translateY(0)' }),
            stagger(-gap, [animate(duration + "ms ease-in", style({ opacity: 0, transform: "translateY(" + (isBottom ? '8px' : '-8px') + ")" }))])
        ], { optional: true })
    ]);
}

/**
 * Represents a template that defines the content of the whole dial item.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDialItemTemplate` directive inside the `<kendo-floatingactionbutton>` tag
 * ([see example]({% slug templates_floatingactionbutton %}#toc-dial-item-template)).
 */
var DialItemTemplateDirective = /** @class */ (function () {
    function DialItemTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DialItemTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDialItemTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], DialItemTemplateDirective);
    return DialItemTemplateDirective;
}());

/**
 * Represents a template that defines the content of the FloatingActionButton.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoFloatingActionButtonTemplate` directive inside the `<kendo-floatingactionbutton>` tag
 * ([see example]({% slug templates_floatingactionbutton %}#toc-floatingactionbutton-template)).
 */
var FloatingActionButtonTemplateDirective = /** @class */ (function () {
    function FloatingActionButtonTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    FloatingActionButtonTemplateDirective = __decorate([
        Directive({
            selector: '[kendoFloatingActionButtonTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], FloatingActionButtonTemplateDirective);
    return FloatingActionButtonTemplateDirective;
}());

var NAVIGATION_SETTINGS$2 = {
    useLeftRightArrows: false
};
var Éµ0$2 = NAVIGATION_SETTINGS$2;
var NAVIGATION_SETTINGS_PROVIDER$2 = {
    provide: NAVIGATION_CONFIG,
    useValue: Éµ0$2
};
var SIZE_CLASSES = {
    small: 'k-fab-sm',
    medium: 'k-fab-md',
    large: 'k-fab-lg'
};
var SHAPE_CLASSES = {
    rectangle: 'k-fab-rectangle',
    square: 'k-fab-square'
};
var ROUNDED_CLASSES = {
    small: 'k-rounded-sm',
    medium: 'k-rounded-md',
    large: 'k-rounded-lg',
    full: 'k-rounded-full'
};
var FILLMODE_CLASS = 'k-fab-solid';
var DEFAULT_DURATION = 180;
var DEFAULT_ITEM_GAP = 90;
var DEFAULT_OFFSET = '16px';
/**
 *
 * Represents the [Kendo UI FloatingActionButton component for Angular]({% slug overview_floatingactionbutton %}).
 * Used to specify the primary or the most common action in an application.
 *
 */
var FloatingActionButtonComponent = /** @class */ (function () {
    function FloatingActionButtonComponent(renderer, element, focusService, navigationService, ngZone, popupService, builder, localizationService) {
        var _this = this;
        this.renderer = renderer;
        this.element = element;
        this.focusService = focusService;
        this.navigationService = navigationService;
        this.ngZone = ngZone;
        this.popupService = popupService;
        this.builder = builder;
        this.localizationService = localizationService;
        /**
         * Specifies the positionMode of the FloatingActionButton
         * ([see example]({% slug positioning_floatingactionbutton %}#toc-positionMode)).
         *
         * * The possible values are:
         * * `absolute`&mdash;Positions the FloatingActionButton absolutely to its first positioned parent element.
         * * `fixed` (Default)&mdash;Positions the FloatingActionButton relative to the viewport. It always stays in the same place even if the page is scrolled.
         */
        this.positionMode = 'fixed';
        /**
         * Specifies the animation settings of the FloatingActionButton dial items.
         * ([see example]({% slug dialitems_floatingactionbutton %}#toc-animation)).
         *
         * The possible values are:
         * * Boolean
         *    * (Default) `true`&mdash;Applies the default [`DialItemAnimation`]({% slug api_buttons_dialitemanimation %}) settings.
         *    * `false`
         * * `DialItemAnimation`
         *    * `duration`&mdash;Specifies the animation duration in milliseconds for each dial item. Defaults to `180ms`.
         *    * `gap`&mdash;Specifies the animation duration gap in milliseconds after each dial item is animated. Defaults to `90ms`.
         */
        this.dialItemAnimation = true;
        /**
         * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the FloatingActionButton.
         */
        this.tabIndex = 0;
        /**
         * Specifies the collection of the dial items that will be rendered in the FloatingActionButton popup.
         */
        this.dialItems = [];
        /**
         * Fires each time the FloatingActionButton gets blurred.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the FloatingActionButton gets focused.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time a dial item is clicked.
         */
        this.dialItemClick = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel the event, the popup will remain closed
         * ([more information and example]({% slug overview_floatingactionbutton %}#toc-events)).
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel the event, the popup will remain open
         * ([more information and example]({% slug overview_floatingactionbutton %}#toc-events)).
         */
        this.close = new EventEmitter();
        /**
         * @hidden
         */
        this.id = "k-" + guid();
        this._themeColor = 'primary';
        this._size = 'medium';
        this._shape = 'rectangle';
        this._disabled = false;
        this._align = { horizontal: 'end', vertical: 'bottom' };
        this._offset = { x: DEFAULT_OFFSET, y: DEFAULT_OFFSET };
        this._rounded = 'full';
        this.subscriptions = new Subscription();
        this.rtl = false;
        this.animationEnd = new EventEmitter();
        this.initialSetup = true;
        validatePackage(packageMetadata);
        this.subscribeNavigationEvents();
        this.subscriptions.add(this.localizationService.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.rtl = rtl;
            _this.direction = _this.rtl ? 'rtl' : 'ltr';
        }));
    }
    Object.defineProperty(FloatingActionButtonComponent.prototype, "fixedClass", {
        get: function () {
            return this.positionMode === 'fixed';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "absoluteClass", {
        get: function () {
            return this.positionMode === 'absolute';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "themeColor", {
        get: function () {
            return this._themeColor;
        },
        /**
         * Specifies the theme color of the FloatingActionButton
         * ([see example]({% slug appearance_floatingactionbutton %}#toc-themeColor)).
         * The theme color will be applied as background color of the component.
         *
         * The possible values are:
         * * `'primary'` (Default)&mdash;Applies coloring based on the `primary` theme color.
         * * `'secondary'`&mdash;Applies coloring based on the `secondary` theme color.
         * * `'tertiary'`&mdash; Applies coloring based on the `tertiary` theme color.
         * * `'info'`&mdash;Applies coloring based on the `info` theme color.
         * * `'success'`&mdash; Applies coloring based on the `success` theme color.
         * * `'warning'`&mdash; Applies coloring based on the `warning` theme color.
         * * `'error'`&mdash; Applies coloring based on the `error` theme color.
         * * `'dark'`&mdash; Applies coloring based on the `dark` theme color.
         * * `'light'`&mdash; Applies coloring based on the `light` theme color.
         * * `'inverse'`&mdash; Applies coloring based on the `inverse` theme color.
         */
        set: function (themeColor) {
            this.handleClasses(themeColor, 'themeColor');
            this._themeColor = themeColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "size", {
        get: function () {
            return this._size;
        },
        /**
         * Specifies the size of the FloatingActionButton
         * ([see example]({% slug appearance_floatingactionbutton %}#toc-size)).
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (Default)
         * * `'large'`
         */
        set: function (size) {
            this.handleClasses(size, 'size');
            this._size = size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "rounded", {
        get: function () {
            return this._rounded;
        },
        /**
         * The rounded property specifies the border radius of the FloatingActionButton.
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'`
         * * `'large'`
         * * `'full'` (default)
         * * `null`
         */
        set: function (rounded) {
            this.handleClasses(rounded, 'rounded');
            this._rounded = rounded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "shape", {
        get: function () {
            return this._shape;
        },
        /**
         * Specifies the shape of the FloatingActionButton
         * ([see example]({% slug appearance_floatingactionbutton %}#toc-shape)).
         *
         * The possible values are:
         * * `rectangle` (Default)&mdash;Applies rectangular shape on the FloatingActionButton.
         * * `square`&mdash;Applies square shape on the FloatingActionButton.
         *
         */
        set: function (shape) {
            this.handleClasses(shape, 'shape');
            this._shape = shape;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "disabled", {
        get: function () {
            return this._disabled;
        },
        /**
         * Specifies whether the FloatingActionButton is disabled.
         */
        set: function (disabled) {
            this._disabled = disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "align", {
        get: function () {
            return this._align;
        },
        /**
         * Specifies the horizontal and vertical alignment of the FloatingActionButton
         * ([see example]({% slug positioning_floatingactionbutton %}#toc-align)).
         *
         * The possible values are:
         * * `{ horizontal: 'start'|'center'|'end', vertical: 'top'|'middle'|'bottom' }`
         *
         * The default value is:
         * * `{ horizontal: 'end', vertical: 'bottom' }`
         *
         */
        set: function (align) {
            this._align = Object.assign(this._align, align);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "offset", {
        get: function () {
            return this._offset;
        },
        /**
         * Specifies the horizontal and vertical offset position of the FloatingActionButton
         * ([see example]({% slug positioning_floatingactionbutton %}#toc-offset)).
         *
         * * The default value is:
         * * `{ x: '16px', y: '16px' }`
         */
        set: function (offset) {
            this._offset = Object.assign(this._offset, offset);
            this.offsetStyles();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "componentTabIndex", {
        /**
         * @hidden
         */
        get: function () {
            return this.disabled ? (-1) : this.tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    FloatingActionButtonComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        ['shape', 'size', 'rounded', 'themeColor'].forEach(function (option) { return _this.handleClasses(_this[option], option); });
        this.renderer.addClass(this.element.nativeElement, this.alignClass());
        this.offsetStyles();
        this.initialSetup = false;
    };
    FloatingActionButtonComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    Object.defineProperty(FloatingActionButtonComponent.prototype, "isOpen", {
        /**
         * Indicates whether the FloatingActionButton is currently open.
         */
        get: function () { return isPresent(this.popupRef); },
        enumerable: true,
        configurable: true
    });
    /**
     * Focuses the FloatingActionButton.
     */
    FloatingActionButtonComponent.prototype.focus = function () {
        if (isDocumentAvailable()) {
            this.button.nativeElement.focus();
        }
    };
    /**
     * Blurs the FloatingActionButton.
     */
    FloatingActionButtonComponent.prototype.blur = function () {
        if (isDocumentAvailable()) {
            this.button.nativeElement.blur();
        }
    };
    /**
     * Toggles the visibility of the FloatingActionButton dial items popup.
     *
     * If you use the `toggleDial` method to open or close the dial items,
     * the `open` and `close` events do not fire ([more information and examples]({% slug openstate_floatingactionbutton %}#toc-events)).
     *
     * @param open - The state of dial items popup.
     */
    FloatingActionButtonComponent.prototype.toggleDial = function (open) {
        var _this = this;
        if (this.disabled || !this.hasDialItems) {
            return;
        }
        var shouldOpen = isPresent(open) ? open : !this.isOpen;
        if (this.disabled || shouldOpen === this.isOpen) {
            return;
        }
        shouldOpen ? setTimeout(function () { return _this.openDial(); }) : this.closeDial();
    };
    Object.defineProperty(FloatingActionButtonComponent.prototype, "role", {
        /**
         * @hidden
         */
        get: function () {
            return (this.dialItems && this.dialItems.length) ? 'menubutton' : 'button';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "ariaExpanded", {
        /**
         * @hidden
         */
        get: function () {
            return isPresent(this.isOpen);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "ariaHasPopup", {
        /**
         * @hidden
         */
        get: function () {
            return isPresent(this.isOpen);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "iconClasses", {
        /**
         * @hidden
         */
        get: function () {
            var classes = [];
            if (this.iconClass) {
                classes.push("" + this.iconClass);
            }
            if (this.icon) {
                classes.push("k-fab-icon k-icon k-i-" + this.icon);
            }
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    FloatingActionButtonComponent.prototype.clickHandler = function () {
        var _this = this;
        if (this.disabled || !this.hasDialItems) {
            return;
        }
        this.ngZone.run(function () {
            var shouldOpen = !_this.isOpen;
            _this.toggleDialWithEvents(shouldOpen);
        });
    };
    /**
     * @hidden
     */
    FloatingActionButtonComponent.prototype.keyDownHandler = function (event) {
        this.keyHandler(event);
    };
    /**
     * @hidden
     */
    FloatingActionButtonComponent.prototype.keyHandler = function (event, keyEvent) {
        if (this.disabled) {
            return;
        }
        var focused = this.focusService.focused || 0;
        var keyCode = event.keyCode;
        var action = this.navigationService.process({
            altKey: event.altKey,
            current: focused,
            keyCode: keyCode,
            keyEvent: keyEvent,
            max: this.dialItems ? this.dialItems.length - 1 : 0,
            min: 0,
            flipNavigation: this.align.vertical === 'bottom'
        });
        if (action !== NavigationAction.Undefined &&
            action !== NavigationAction.Tab) {
            event.preventDefault();
        }
    };
    /**
     * @hidden
     */
    FloatingActionButtonComponent.prototype.onItemClick = function (event) {
        var item = closest(event.target, '.k-fab-item');
        if (!item) {
            return;
        }
        var index = item.getAttribute('data-fab-item-index');
        this.emitItemClick(index);
    };
    /**
     * @hidden
     */
    FloatingActionButtonComponent.prototype.focusHandler = function () {
        if (!this.disabled) {
            this.onFocus.emit();
        }
    };
    /**
     * @hidden
     */
    FloatingActionButtonComponent.prototype.blurHandler = function () {
        this.onBlur.emit();
        this.toggleDialWithEvents(false);
    };
    FloatingActionButtonComponent.prototype.handleClasses = function (inputValue, input) {
        if (isPresent(this.button) && (this[input] !== inputValue || this.initialSetup)) {
            var button = this.button.nativeElement;
            var classesToRemove = {
                themeColor: FILLMODE_CLASS + "-" + this.themeColor,
                size: SIZE_CLASSES[this.size],
                shape: SHAPE_CLASSES[this.shape],
                rounded: ROUNDED_CLASSES[this.rounded]
            };
            var classesToAdd = {
                themeColor: inputValue ? FILLMODE_CLASS + "-" + inputValue : null,
                size: SIZE_CLASSES[inputValue],
                shape: SHAPE_CLASSES[inputValue],
                rounded: ROUNDED_CLASSES[inputValue]
            };
            this.renderer.removeClass(button, classesToRemove[input]);
            if (classesToAdd[input]) {
                this.renderer.addClass(button, classesToAdd[input]);
            }
        }
    };
    FloatingActionButtonComponent.prototype.onEnterPressed = function () {
        var index = this.focusService.focused;
        this.emitItemClick(index);
    };
    FloatingActionButtonComponent.prototype.emitItemClick = function (index) {
        var item = this.dialItems[index];
        if (item && !item.disabled) {
            var clickEventArgs = { item: item, index: index };
            this.dialItemClick.emit(clickEventArgs);
            this.toggleDialWithEvents(false);
        }
    };
    FloatingActionButtonComponent.prototype.subscribeNavigationEvents = function () {
        this.subscriptions.add(this.navigationService.navigate.subscribe(this.onArrowKeyNavigate.bind(this)));
        this.subscriptions.add(this.navigationService.enter.subscribe(this.onNavigationEnterPress.bind(this)));
        this.subscriptions.add(merge(this.navigationService.close, this.navigationService.esc).subscribe(this.onNavigationClose.bind(this)));
    };
    FloatingActionButtonComponent.prototype.onArrowKeyNavigate = function (index) {
        this.focusService.focus(index);
    };
    FloatingActionButtonComponent.prototype.onNavigationEnterPress = function () {
        var _this = this;
        this.ngZone.run(function () {
            if (_this.isOpen) {
                var focusedIndex = _this.focusService.focused;
                var focusedItem = _this.dialItems[focusedIndex];
                if (focusedItem && focusedItem.disabled) {
                    return;
                }
                if (isPresent(focusedIndex) && focusedIndex !== -1) {
                    _this.onEnterPressed();
                    return;
                }
            }
            if (!_this.isOpen && isDocumentAvailable()) {
                _this.toggleDialWithEvents(true);
                _this.button.nativeElement.focus();
            }
        });
    };
    FloatingActionButtonComponent.prototype.onNavigationClose = function () {
        var _this = this;
        if (this.isOpen) {
            this.ngZone.run(function () {
                _this.toggleDialWithEvents(false);
                if (isDocumentAvailable()) {
                    _this.button.nativeElement.focus();
                }
            });
        }
    };
    FloatingActionButtonComponent.prototype.alignClass = function () {
        return "k-pos-" + this.align.vertical + "-" + this.align.horizontal;
    };
    FloatingActionButtonComponent.prototype.toggleDialWithEvents = function (open) {
        if (open === this.isOpen) {
            return;
        }
        var event = new PreventableEvent();
        open ? this.open.emit(event) : this.close.emit(event);
        if (event.isDefaultPrevented()) {
            return;
        }
        open ? this.openDial() : this.closeDial();
    };
    FloatingActionButtonComponent.prototype.openPopup = function () {
        var _this = this;
        if (this.isOpen) {
            return;
        }
        var isIconFab = this.icon && !this.text;
        var rtl = this.rtl;
        var align = this.align;
        this.popupRef = this.popupService.open({
            anchor: this.element.nativeElement,
            animate: false,
            content: this.popupTemplate,
            anchorAlign: getAnchorAlign(align, rtl),
            popupAlign: getPopupAlign(align, rtl),
            popupClass: 'k-fab-popup k-popup-transparent'
        });
        var popupElement = this.popupRef.popupElement;
        this.renderer.setStyle(popupElement, 'box-shadow', 'none');
        if (isIconFab) {
            this.subscriptions.add(this.popupRef.popupOpen.subscribe(function () { return _this.positionPopup(); }));
        }
        this.ngZone.runOutsideAngular(function () {
            _this.popupMouseDownListener = _this.renderer.listen(popupElement, 'mousedown', function (event) {
                event.preventDefault();
            });
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(function () { return _this.toggleDialWithEvents(false); });
    };
    FloatingActionButtonComponent.prototype.closePopup = function () {
        if (this.isOpen) {
            if (this.popupMouseDownListener) {
                this.popupMouseDownListener();
            }
            this.popupRef.close();
            this.popupRef = null;
        }
    };
    FloatingActionButtonComponent.prototype.openDial = function () {
        this.openPopup();
        this.focusService.focus(0);
        if (this.dialItemAnimation && this.isValidAnimation()) {
            this.playAnimation(true);
        }
    };
    FloatingActionButtonComponent.prototype.closeDial = function () {
        var _this = this;
        if (this.dialItemAnimation && this.isValidAnimation()) {
            this.playAnimation(false);
            this.animationEnd.pipe(take(1)).subscribe(function () { return _this.closePopup(); });
        }
        else {
            this.closePopup();
        }
    };
    FloatingActionButtonComponent.prototype.isValidAnimation = function () {
        var animation = this.dialItemAnimation;
        if (typeof animation !== 'boolean') {
            return animation.duration !== 0;
        }
        return true;
    };
    FloatingActionButtonComponent.prototype.positionPopup = function () {
        if (this.dialItemTemplate) {
            return;
        }
        var fab = this.element.nativeElement;
        var fabWidth = fab.getBoundingClientRect().width;
        var popupEl = this.popupRef.popupElement;
        var icon = popupEl.querySelector('.k-fab-item-icon');
        if (!icon) {
            return;
        }
        var iconWidth = icon.getBoundingClientRect().width;
        var left = (fabWidth / 2) - (iconWidth / 2);
        var popupLeft = popupEl.getBoundingClientRect().left;
        var isEndAlign = this.align.horizontal === 'end';
        var leftValue = isEndAlign ? (popupLeft - left) : (left + popupLeft);
        var rtlLeftValue = isEndAlign ? (left + popupLeft) : (popupLeft - left);
        popupEl.style.left = this.rtl ? rtlLeftValue + "px" : leftValue + "px";
    };
    FloatingActionButtonComponent.prototype.offsetStyles = function () {
        var hostElement = this.element.nativeElement;
        this.renderer.setStyle(hostElement, this.horizontalPosition, this.horizontalOffset);
        this.renderer.setStyle(hostElement, this.verticalPosition, this.verticalOffset);
    };
    Object.defineProperty(FloatingActionButtonComponent.prototype, "hasDialItems", {
        get: function () {
            return isPresent(this.dialItems) && this.dialItems.length !== 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "verticalPosition", {
        /**
         * Gets the CSS prop name of the selected vertical position (`top`/`bottom`);
         */
        get: function () {
            return {
                top: 'top',
                middle: 'top',
                bottom: 'bottom'
            }[this.align.vertical];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "verticalOffset", {
        /**
         * Gets the offset according to the selected vertical position.
         */
        get: function () {
            if (this.align.vertical === 'middle') {
                return this.offset.y === DEFAULT_OFFSET ? '50%' : "calc(50% + " + this.offset.y + ")";
            }
            return this.offset.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "horizontalPosition", {
        /**
         * Gets the CSS prop name of the selected horizontal position (`left`/`right`);
         */
        get: function () {
            var horizontal = this.align.horizontal;
            return {
                end: this.rtl ? 'left' : 'right',
                center: 'left',
                start: this.rtl ? 'right' : 'left'
            }[horizontal];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FloatingActionButtonComponent.prototype, "horizontalOffset", {
        /**
         * Gets the offset according to the selected horizontal position.
         */
        get: function () {
            if (this.align.horizontal === 'center') {
                return this.offset.x === DEFAULT_OFFSET ? '50%' : "calc(50% + " + this.offset.x + ")";
            }
            return this.offset.x;
        },
        enumerable: true,
        configurable: true
    });
    FloatingActionButtonComponent.prototype.playerFor = function (element, animation) {
        var factory = this.builder.build(animation);
        return factory.create(element);
    };
    FloatingActionButtonComponent.prototype.playAnimation = function (open) {
        var _this = this;
        var durationSettings = this.durationSettings();
        var animationSettings = {
            duration: durationSettings.duration,
            gap: durationSettings.gap,
            align: this.align
        };
        var animation = open ? openAnimation(animationSettings) : closeAnimation(animationSettings);
        var player = this.playerFor(this.popupRef.popupElement, animation);
        player.play();
        player.onDone(function () {
            if (player) {
                _this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
    };
    FloatingActionButtonComponent.prototype.durationSettings = function () {
        return {
            duration: this.animationDuration(),
            gap: this.animationGap()
        };
    };
    FloatingActionButtonComponent.prototype.animationGap = function () {
        var animation = this.dialItemAnimation;
        if (typeof animation !== 'boolean' && isPresent(animation.gap)) {
            return animation.gap;
        }
        return DEFAULT_ITEM_GAP;
    };
    FloatingActionButtonComponent.prototype.animationDuration = function () {
        var animation = this.dialItemAnimation;
        if (typeof animation !== 'boolean' && isPresent(animation.duration)) {
            return animation.duration;
        }
        return DEFAULT_DURATION;
    };
    __decorate([
        HostBinding('class.k-pos-fixed'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], FloatingActionButtonComponent.prototype, "fixedClass", null);
    __decorate([
        HostBinding('class.k-pos-absolute'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], FloatingActionButtonComponent.prototype, "absoluteClass", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], FloatingActionButtonComponent.prototype, "direction", void 0);
    __decorate([
        ViewChild('button', { static: true }),
        __metadata("design:type", ElementRef)
    ], FloatingActionButtonComponent.prototype, "button", void 0);
    __decorate([
        ViewChild('popupTemplate', { static: true }),
        __metadata("design:type", TemplateRef)
    ], FloatingActionButtonComponent.prototype, "popupTemplate", void 0);
    __decorate([
        ContentChild(DialItemTemplateDirective, { static: false }),
        __metadata("design:type", DialItemTemplateDirective)
    ], FloatingActionButtonComponent.prototype, "dialItemTemplate", void 0);
    __decorate([
        ContentChild(FloatingActionButtonTemplateDirective, { static: false }),
        __metadata("design:type", FloatingActionButtonTemplateDirective)
    ], FloatingActionButtonComponent.prototype, "fabTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], FloatingActionButtonComponent.prototype, "themeColor", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], FloatingActionButtonComponent.prototype, "size", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], FloatingActionButtonComponent.prototype, "rounded", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], FloatingActionButtonComponent.prototype, "shape", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], FloatingActionButtonComponent.prototype, "disabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], FloatingActionButtonComponent.prototype, "align", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], FloatingActionButtonComponent.prototype, "offset", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FloatingActionButtonComponent.prototype, "positionMode", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FloatingActionButtonComponent.prototype, "icon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FloatingActionButtonComponent.prototype, "iconClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FloatingActionButtonComponent.prototype, "buttonClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FloatingActionButtonComponent.prototype, "dialClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FloatingActionButtonComponent.prototype, "text", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FloatingActionButtonComponent.prototype, "dialItemAnimation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], FloatingActionButtonComponent.prototype, "tabIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], FloatingActionButtonComponent.prototype, "dialItems", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], FloatingActionButtonComponent.prototype, "onBlur", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], FloatingActionButtonComponent.prototype, "onFocus", void 0);
    __decorate([
        Output('dialItemClick'),
        __metadata("design:type", EventEmitter)
    ], FloatingActionButtonComponent.prototype, "dialItemClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], FloatingActionButtonComponent.prototype, "open", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], FloatingActionButtonComponent.prototype, "close", void 0);
    FloatingActionButtonComponent = __decorate([
        Component({
            selector: 'kendo-floatingactionbutton',
            providers: [
                FocusService,
                NavigationService,
                NAVIGATION_SETTINGS_PROVIDER$2,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.floatingactionbutton'
                }
            ],
            template: "\n        <button\n            #button\n            [attr.id]=\"id\"\n            [attr.role]=\"role\"\n            [tabIndex]=\"componentTabIndex\"\n            type=\"button\"\n            class=\"k-fab k-fab-solid\"\n            [class.k-disabled]=\"disabled\"\n            [ngClass]=\"buttonClass\"\n            [disabled]=\"disabled\"\n            [attr.aria-disabled]=\"disabled\"\n            [attr.aria-expanded]=\"ariaExpanded\"\n            [attr.aria-haspopup]=\"ariaHasPopup\"\n            (focus)=\"focusHandler()\"\n            (blur)=\"blurHandler()\"\n            [kendoEventsOutsideAngular]=\"{\n                keydown: keyDownHandler,\n                click: clickHandler\n            }\"\n            [scope]=\"this\"\n        >\n            <ng-template *ngIf=\"fabTemplate\"\n                [ngTemplateOutlet]=\"fabTemplate?.templateRef\"\n            >\n            </ng-template>\n\n            <ng-container *ngIf=\"!fabTemplate\">\n                <span *ngIf=\"icon || iconClass\" [ngClass]=\"iconClasses\"></span>\n                <span *ngIf=\"text\" class=\"k-fab-text\">{{ text }}</span>\n            </ng-container>\n        </button>\n\n        <ng-template #popupTemplate>\n            <ul\n                kendoDialList\n                [ngClass]=\"dialClass\"\n                [dialItems]=\"dialItems\"\n                [dialItemTemplate]='dialItemTemplate?.templateRef'\n                [align]=\"align\"\n                [attr.aria-labelledby]=\"id\"\n                (click)=\"onItemClick($event)\"\n            >\n            </ul>\n        </ng-template>\n    "
        }),
        __metadata("design:paramtypes", [Renderer2,
            ElementRef,
            FocusService,
            NavigationService,
            NgZone,
            PopupService,
            AnimationBuilder,
            LocalizationService])
    ], FloatingActionButtonComponent);
    return FloatingActionButtonComponent;
}());

/**
 * @hidden
 */
var DialListComponent = /** @class */ (function () {
    function DialListComponent(focusService, cdr) {
        var _this = this;
        this.focusService = focusService;
        this.cdr = cdr;
        this.hostClass = true;
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.focusService.onFocus.subscribe(function () { return _this.cdr.detectChanges(); }));
    }
    Object.defineProperty(DialListComponent.prototype, "bottomClass", {
        get: function () {
            return this.align.vertical === 'top' || this.align.vertical === 'middle';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DialListComponent.prototype, "topClass", {
        get: function () {
            return this.align.vertical === 'bottom';
        },
        enumerable: true,
        configurable: true
    });
    DialListComponent.prototype.isFocused = function (index) {
        return this.focusService.isFocused(index);
    };
    DialListComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    __decorate([
        HostBinding('class.k-fab-items'),
        __metadata("design:type", Boolean)
    ], DialListComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('class.k-fab-items-bottom'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DialListComponent.prototype, "bottomClass", null);
    __decorate([
        HostBinding('class.k-fab-items-top'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DialListComponent.prototype, "topClass", null);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], DialListComponent.prototype, "dialItems", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], DialListComponent.prototype, "dialItemTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DialListComponent.prototype, "align", void 0);
    DialListComponent = __decorate([
        Component({
            selector: '[kendoDialList]',
            template: "\n        <ng-container *ngFor='let item of dialItems; let idx = index'>\n            <li\n                kendoButtonFocusable\n                kendoDialItem\n                [item]=\"dialItems[idx]\"\n                [index]=\"idx\"\n                [dialItemTemplate]=\"dialItemTemplate\"\n                [isFocused]=\"isFocused(idx)\"\n                [ngClass]='item.cssClass'\n                [ngStyle]='item.cssStyle'\n                [align]=\"align\"\n            >\n            </li>\n        </ng-container>\n    "
        }),
        __metadata("design:paramtypes", [FocusService, ChangeDetectorRef])
    ], DialListComponent);
    return DialListComponent;
}());

/**
 * @hidden
 */
var DialItemComponent = /** @class */ (function () {
    function DialItemComponent(element, renderer, localisationService) {
        this.element = element;
        this.renderer = renderer;
        this.localisationService = localisationService;
        this.hostClass = true;
        this.role = 'menuitem';
    }
    Object.defineProperty(DialItemComponent.prototype, "disabledClass", {
        get: function () {
            return this.item.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DialItemComponent.prototype, "title", {
        get: function () {
            var label = this.item.label;
            return label ? label : this.itemTitle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DialItemComponent.prototype, "indexAttr", {
        get: function () {
            return this.index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DialItemComponent.prototype, "iconClasses", {
        get: function () {
            var classes = [];
            if (this.item.iconClass) {
                classes.push("" + this.item.iconClass);
            }
            if (this.item.icon) {
                classes.push("k-fab-item-icon k-icon k-i-" + this.item.icon);
            }
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DialItemComponent.prototype, "itemTitle", {
        get: function () {
            var icon = this.item.icon;
            var itemTitle = this.item.itemTitle;
            return (icon && itemTitle) ? itemTitle : icon;
        },
        enumerable: true,
        configurable: true
    });
    DialItemComponent.prototype.ngAfterViewInit = function () {
        var element = this.element.nativeElement;
        var rtl = this.localisationService.rtl;
        var hAlign = this.align.horizontal;
        this.renderer.addClass(element, this.getTextDirectionClass(rtl, hAlign));
    };
    DialItemComponent.prototype.getTextDirectionClass = function (rtl, hAlign) {
        var dir = rtl ? 'rtl' : 'ltr';
        var align = hAlign === 'end' ? 'end' : 'start';
        var directions = {
            rtl: { end: 'k-text-left', start: 'k-text-right' },
            ltr: { start: 'k-text-left', end: 'k-text-right' }
        };
        return directions[dir][align];
    };
    __decorate([
        HostBinding('class.k-fab-item'),
        __metadata("design:type", Boolean)
    ], DialItemComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('attr.role'),
        __metadata("design:type", String)
    ], DialItemComponent.prototype, "role", void 0);
    __decorate([
        HostBinding('attr.aria-disabled'),
        HostBinding('class.k-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DialItemComponent.prototype, "disabledClass", null);
    __decorate([
        HostBinding('attr.title'),
        HostBinding('attr.aria-label'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], DialItemComponent.prototype, "title", null);
    __decorate([
        HostBinding('attr.data-fab-item-index'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], DialItemComponent.prototype, "indexAttr", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DialItemComponent.prototype, "cssClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DialItemComponent.prototype, "cssStyle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DialItemComponent.prototype, "isFocused", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DialItemComponent.prototype, "index", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DialItemComponent.prototype, "item", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], DialItemComponent.prototype, "dialItemTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DialItemComponent.prototype, "align", void 0);
    DialItemComponent = __decorate([
        Component({
            selector: '[kendoDialItem]',
            template: "\n        <ng-template *ngIf=\"dialItemTemplate\"\n            [ngTemplateOutlet]=\"dialItemTemplate\"\n            [ngTemplateOutletContext]=\"{ $implicit: item, index: index, isFocused: isFocused }\"\n        >\n        </ng-template>\n\n        <ng-container *ngIf=\"!dialItemTemplate\">\n            <span *ngIf=\"item.label\" class=\"k-fab-item-text\">{{ item.label }}</span>\n            <span *ngIf=\"item.icon || item.iconClass\" [ngClass]=\"iconClasses\"></span>\n        </ng-container>\n    "
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            LocalizationService])
    ], DialItemComponent);
    return DialItemComponent;
}());

var exportedModules$1 = [
    FloatingActionButtonComponent,
    DialItemTemplateDirective,
    FloatingActionButtonTemplateDirective
];
var declarations$1 = exportedModules$1.concat([
    DialListComponent,
    DialItemComponent
]);
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the FloatingActionButton component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the FloatingActionButton module
 * import { FloatingActionButtonModule } from '@progress/kendo-angular-buttons';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, FloatingActionButtonModule], // import FloatingActionButton module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * ```
 */
var FloatingActionButtonModule = /** @class */ (function () {
    function FloatingActionButtonModule() {
    }
    FloatingActionButtonModule = __decorate([
        NgModule({
            declarations: [declarations$1],
            exports: [exportedModules$1],
            imports: [CommonModule, PopupModule, ListModule, EventsModule]
        })
    ], FloatingActionButtonModule);
    return FloatingActionButtonModule;
}());

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmodules'] }})
 * definition for the Buttons components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Buttons module
 * import { ButtonsModule } from '@progress/kendo-angular-buttons';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, ButtonsModule], // import Buttons module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var ButtonsModule = /** @class */ (function () {
    function ButtonsModule() {
    }
    ButtonsModule = __decorate([
        NgModule({
            exports: [ButtonGroupModule, ButtonModule, SplitButtonModule, DropDownButtonModule, ChipModule, FloatingActionButtonModule]
        })
    ], ButtonsModule);
    return ButtonsModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { KendoButtonService, DialItemComponent, DialListComponent, FocusService, FocusableDirective, ButtonItemTemplateDirective, ListButton, ListComponent, ListModule, TemplateContextDirective, NAVIGATION_CONFIG, NavigationService, LocalizedSplitButtonMessagesDirective, Messages, ButtonDirective, ButtonDirective as Button, ButtonGroupComponent, ButtonGroupComponent as ButtonGroup, ButtonGroupModule, ButtonModule, ButtonsModule, SplitButtonComponent, SplitButtonComponent as SplitButton, SplitButtonModule, SplitButtonCustomMessagesComponent, DropDownButtonComponent, DropDownButtonComponent as DropDownButton, DropDownButtonModule, ChipComponent, ChipListComponent, ChipModule, FloatingActionButtonModule, FloatingActionButtonComponent, FloatingActionButtonTemplateDirective, DialItemTemplateDirective };
