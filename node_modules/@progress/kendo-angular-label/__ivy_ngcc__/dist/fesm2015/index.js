/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata } from 'tslib';
import { Input, HostBinding, Directive, ElementRef, Renderer2, NgZone, forwardRef, Component, NgModule, EventEmitter, isDevMode, Output, ContentChild, ChangeDetectorRef, ViewChild } from '@angular/core';
import { isDocumentAvailable, guid, hasObservers, KendoInput } from '@progress/kendo-angular-common';
import { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { CommonModule } from '@angular/common';
import { NgControl } from '@angular/forms';
import { validatePackage } from '@progress/kendo-licensing';
import { Observable, Subscription } from 'rxjs';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';

function FloatingLabelComponent_label_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("(", ctx_r1.textFor("optional"), ")");
} }
function FloatingLabelComponent_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵtemplate(2, FloatingLabelComponent_label_2_span_2_Template, 2, 1, "span", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.labelCssClass)("ngStyle", ctx_r0.labelCssStyle)("for", ctx_r0.id);
    ɵngcc0.ɵɵattribute("id", ctx_r0.labelId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.text, "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.optional);
} }
const _c2 = ["*"];
function LabelComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("(", ctx_r0.textFor("optional"), ")");
} }
const isUploadComponent = (component) => component.wrapper && (component.wrapper.tagName === 'KENDO-UPLOAD' || component.wrapper.tagName === 'KENDO-FILESELECT');
/**
 * @hidden
 */
const isInputElement = (component) => component instanceof HTMLElement;
/**
 * @hidden
 */
const inputElementHasAttr = (element, attribute) => element.hasAttribute(attribute);
/**
 * @hidden
 */
const getWrappedNativeInput = (element) => element.querySelector('kendo-label > input, kendo-label > textarea, kendo-label > select');
/**
 * @hidden
 */
const getRootElement = (element) => {
    if (!element) {
        return null;
    }
    let rootElement = element;
    while (rootElement.parentElement) {
        rootElement = rootElement.parentElement;
    }
    return rootElement;
};

/**
 * Represents the [Kendo UI Label directive for Angular]({% slug overview_label %}).
 * The Label associates a focusable Angular component or an HTML element
 * with a `label` tag by using the `[for]` property binding.
 *
 * To associate a component by using the `label` element, either:
 * * Set the `[for]` property binding to a
 * [template reference variable]({{ site.data.urls.angular['templatesyntax'] }}#template-reference-variables--var-), or
 * * Set the `[for]` property binding to an `id` HTML string value.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <div class="row example-wrapper" style="min-height: 450px;">
 *    <div class="col-xs-12 col-md-6 example-col">
 *      <label [for]="datepicker">DatePicker: </label>
 *      <kendo-datepicker #datepicker></kendo-datepicker>
 *    </div>
 *
 *    <div class="col-xs-12 col-md-6 example-col">
 *      <label for="input">Input: </label>
 *      <input id="input" />
 *    </div>
 *  </div>
 * `
 * })
 * class AppComponent { }
 * ```
 */
let LabelDirective = class LabelDirective {
    constructor(label, renderer, zone) {
        this.label = label;
        this.renderer = renderer;
        this.zone = zone;
        this.labelClass = true;
        this.handleClick = () => {
            const component = this.getFocusableComponent();
            if (!component) {
                return;
            }
            if (isUploadComponent(component)) {
                component.fileSelect.nativeElement.click();
            }
            if (component.focus) {
                component.focus();
            }
        };
    }
    get labelFor() {
        if (typeof this.for === 'string') {
            return this.for;
        }
        if (!isDocumentAvailable()) {
            return null;
        }
        const component = this.getFocusableComponent() || {};
        if (isInputElement(component) && !inputElementHasAttr(component, 'id')) {
            this.renderer.setAttribute(component, 'id', `k-${guid()}`);
        }
        return component.focusableId || component.id || null;
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.setAriaLabelledby();
        this.zone.runOutsideAngular(() => this.clickListener = this.renderer.listen(this.label.nativeElement, 'click', this.handleClick));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.clickListener) {
            this.clickListener();
        }
    }
    /**
     * @hidden
     */
    setAriaLabelledby() {
        if (!isDocumentAvailable()) {
            return;
        }
        const component = this.getFocusableComponent();
        if (component && component.focusableId) {
            const rootElement = getRootElement(this.label.nativeElement);
            const labelTarget = rootElement.querySelector(`#${component.focusableId}`);
            if (!labelTarget) {
                return;
            }
            const labelElement = this.label.nativeElement;
            const id = labelElement.id || `k-${guid()}`;
            if (!labelElement.getAttribute('id')) {
                this.renderer.setAttribute(labelElement, 'id', id);
            }
            this.renderer.setAttribute(labelTarget, 'aria-labelledby', id);
        }
    }
    getFocusableComponent() {
        const target = this.for;
        return target && target.focus !== undefined ? target : null;
    }
};
LabelDirective.ɵfac = function LabelDirective_Factory(t) { return new (t || LabelDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
LabelDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LabelDirective, selectors: [["label", "for", ""]], hostVars: 3, hostBindings: function LabelDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("for", ctx.labelFor);
        ɵngcc0.ɵɵclassProp("k-label", ctx.labelClass);
    } }, inputs: { for: "for" } });
__decorate([
    Input(),
    __metadata("design:type", Object)
], LabelDirective.prototype, "for", void 0);
__decorate([
    HostBinding('attr.for'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], LabelDirective.prototype, "labelFor", null);
__decorate([
    HostBinding('class.k-label'),
    __metadata("design:type", Boolean)
], LabelDirective.prototype, "labelClass", void 0);
LabelDirective = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, NgZone])
], LabelDirective);

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = /*@__PURE__*/ function () { let ɵMessages_BaseFactory; return function Messages_Factory(t) { return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages)))(t || Messages); }; }();
Messages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: Messages, inputs: { optional: "optional" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "optional", void 0);

var LocalizedMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedMessagesDirective = LocalizedMessagesDirective_1 = class LocalizedMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) { return new (t || LocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedMessagesDirective, selectors: [["", "kendoLabelLocalizedMessages", ""], ["", "kendoFloatingLabelLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedMessagesDirective_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedMessagesDirective = LocalizedMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedMessagesDirective);

var CustomMessagesComponent_1;
/**
 * Custom component messages override default component messages
 * ([see example]({% slug label_globalization %}#toc-localization)).
 */
let CustomMessagesComponent = CustomMessagesComponent_1 = class CustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) { return new (t || CustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
CustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CustomMessagesComponent, selectors: [["kendo-label-messages"], ["kendo-floatinglabel-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => CustomMessagesComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
CustomMessagesComponent = CustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], CustomMessagesComponent);

const SHARED_DIRECTIVES = [
    LocalizedMessagesDirective,
    CustomMessagesComponent
];
/**
 * @hidden
 */
let SharedDirectivesModule = class SharedDirectivesModule {
};
SharedDirectivesModule.ɵfac = function SharedDirectivesModule_Factory(t) { return new (t || SharedDirectivesModule)(); };
SharedDirectivesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SharedDirectivesModule });
SharedDirectivesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-label',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1646219058,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * @hidden
 */
class FloatingLabelInputAdapter {
    constructor(component, formControl) {
        this.component = component;
        const isObservableOrEventEmitter = (event) => event instanceof Observable || event instanceof EventEmitter;
        if (isObservableOrEventEmitter(component.onFocus)) {
            this.onFocus = component.onFocus;
        }
        if (isObservableOrEventEmitter(component.autoFillStart)) {
            this.autoFillStart = component.autoFillStart;
        }
        if (isObservableOrEventEmitter(component.autoFillEnd)) {
            this.autoFillEnd = component.autoFillEnd;
        }
        if (isObservableOrEventEmitter(component.onBlur)) {
            this.onBlur = component.onBlur;
        }
        if (formControl) {
            this.onValueChange = formControl.valueChanges;
        }
        else if (component.onValueChange) {
            this.onValueChange = component.onValueChange;
        }
    }
    get focusableId() {
        const component = this.component;
        if ('focusableId' in component) {
            return component.focusableId;
        }
        else if ('id' in component) {
            return component.id;
        }
        return "";
    }
    set focusableId(value) {
        const component = this.component;
        if ('focusableId' in component) {
            component.focusableId = value;
        }
        else if ('id' in component) {
            component.id = value;
        }
    }
}

const isFunction = (x) => Object.prototype.toString.call(x) === '[object Function]';
/**
 * Represents the [Kendo UI FloatingLabel component for Angular]({% slug overview_floatinglabel %}).
 * Provides floating labels to `input` elements.
 *
 * The FloatingLabel supports both Template and Reactive Forms and
 * [can contain Kendo UI for Angular Input components such as `kendo-combobox` and `kendo-numerictextbox`,
 * or HTML Input elements with the `kendoTextBox` directive applied]({% slug overview_floatinglabel %}#toc-implementing-floating-labels).
 *
 * @example
 * ```ts
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-floatinglabel text="First name">
 *       <input [(ngModel)]="name" kendoTextBox />
 *     </kendo-floatinglabel>
 *   `
 * })
 * class AppComponent {
 *     public name = 'John';
 * }
 *
 * ```
 */
let FloatingLabelComponent = class FloatingLabelComponent {
    constructor(elementRef, renderer, changeDetectorRef, localization) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.changeDetectorRef = changeDetectorRef;
        this.localization = localization;
        this.hostClasses = true;
        /**
         * Fires after the floating label position is changed.
         */
        this.positionChange = new EventEmitter();
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.empty = true;
        /**
         * @hidden
         */
        this.invalid = false;
        /**
         * @hidden
         */
        this.labelId = `k-${guid()}`;
        this.autoFillStarted = false;
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.renderer.removeAttribute(this.elementRef.nativeElement, "id");
    }
    /**
     * Represents the current floating label position.
     */
    get labelPosition() {
        if (!this.empty) {
            return 'Out';
        }
        return this.focused ? 'Out' : 'In';
    }
    get focusedClass() {
        return this.focused;
    }
    get invalidClass() {
        return this.invalid;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.validateSetup();
        const control = new FloatingLabelInputAdapter(this.kendoInput || this.formControl.valueAccessor, this.formControl);
        this.addHandlers(control);
        this.setLabelFor(control);
    }
    ngAfterViewInit() {
        if (this.kendoInput) {
            this.setAriaLabelledby(this.kendoInput);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    subscribe(control, eventName, handler) {
        if (control[eventName] instanceof EventEmitter) {
            const subscription = control[eventName].subscribe(handler);
            if (!this.subscription) {
                this.subscription = subscription;
            }
            else {
                this.subscription.add(subscription);
            }
        }
    }
    updateState() {
        const empty = value => {
            // zero is not an empty value (e.g., NumericTextBox)
            if (value === 0 || value === false) {
                return false;
            }
            // empty arrays are an empty value (e.g., MultiSelect)
            if (Array.isArray(value) && !value.length) {
                return true;
            }
            return !value;
        };
        const formControl = this.formControl;
        if (formControl) {
            const valueAccessor = formControl.valueAccessor;
            if (isFunction(valueAccessor.isEmpty)) {
                this.empty = valueAccessor.isEmpty();
            }
            else {
                this.empty = empty(formControl.value);
            }
            this.invalid = formControl.invalid && (formControl.touched || formControl.dirty);
        }
        else {
            this.empty = isFunction(this.kendoInput.isEmpty) ?
                this.kendoInput.isEmpty() : empty(this.kendoInput.value);
        }
        if (this.empty) {
            this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');
        }
        this.changeDetectorRef.markForCheck();
    }
    setAriaLabelledby(component) {
        const componentId = component.focusableId || component.id;
        if (componentId) {
            const focusableElement = this.elementRef.nativeElement.querySelector(`#${componentId}`);
            this.renderer.setAttribute(focusableElement, 'aria-labelledby', this.labelId);
        }
    }
    setLabelFor(control) {
        const controlId = control.focusableId || control.id;
        if (this.id && controlId) {
            // input wins
            this.id = controlId;
        }
        else if (this.id) {
            control.focusableId = this.id;
        }
        else if (controlId) {
            this.id = controlId;
        }
        else {
            const id = `k-${guid()}`;
            control.focusableId = id;
            this.id = id;
        }
    }
    handleAutofill(control) {
        this.subscribe(control, 'autoFillStart', () => {
            this.autoFillStarted = true;
            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');
        });
        this.subscribe(control, 'autoFillEnd', () => {
            if (this.autoFillStarted) {
                this.autoFillStarted = false;
                if (this.empty) {
                    this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');
                }
            }
        });
    }
    addHandlers(control) {
        const setFocus = (isFocused) => () => {
            this.focused = isFocused;
            this.updateState();
            if (!this.empty) {
                return;
            }
            if (hasObservers(this.positionChange)) {
                this.positionChange.emit(isFocused ? 'Out' : 'In');
            }
        };
        this.subscribe(control, 'onFocus', setFocus(true));
        this.subscribe(control, 'onBlur', setFocus(false));
        this.handleAutofill(control);
        const updateState = () => this.updateState();
        updateState();
        this.subscribe(control, 'onValueChange', updateState);
    }
    validateSetup() {
        if (!this.formControl && !this.kendoInput) {
            if (isDevMode()) {
                throw new Error("The FloatingLabelComponent requires a Kendo Input component" +
                    " or a forms-bound component to function properly.");
            }
            return;
        }
    }
};
FloatingLabelComponent.ɵfac = function FloatingLabelComponent_Factory(t) { return new (t || FloatingLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
FloatingLabelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FloatingLabelComponent, selectors: [["kendo-floatinglabel"]], contentQueries: function FloatingLabelComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, KendoInput, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.formControl = _t.first);
    } }, hostVars: 7, hostBindings: function FloatingLabelComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-floating-label-container", ctx.hostClasses)("k-state-focused", ctx.focusedClass)("k-state-invalid", ctx.invalidClass);
    } }, inputs: { id: "id", labelCssStyle: "labelCssStyle", labelCssClass: "labelCssClass", text: "text", optional: "optional" }, outputs: { positionChange: "positionChange" }, exportAs: ["kendoFloatingLabel"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.floatinglabel'
            }
        ])], ngContentSelectors: _c2, decls: 3, vars: 1, consts: function () { let i18n_0; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text for the optional segment of a FloatingLabel component
         * @meaning kendo.floatinglabel.optional
         */
        const MSG_EXTERNAL_356911862062553631$$DIST_FESM2015_INDEX_JS_1 = goog.getMsg("Optional");
        i18n_0 = MSG_EXTERNAL_356911862062553631$$DIST_FESM2015_INDEX_JS_1;
    }
    else {
        i18n_0 = $localize `:kendo.floatinglabel.optional|The text for the optional segment of a FloatingLabel component␟d6b1dd6fb7530bd600b430042425d10b22163d1f␟356911862062553631:Optional`;
    } return [["kendoFloatingLabelLocalizedMessages", "", "optional", i18n_0], ["class", "k-label", 3, "ngClass", "ngStyle", "for", 4, "ngIf"], [1, "k-label", 3, "ngClass", "ngStyle", "for"], ["class", "k-label-optional", 4, "ngIf"], [1, "k-label-optional"]]; }, template: function FloatingLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, FloatingLabelComponent_label_2_Template, 3, 6, "label", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.text);
    } }, directives: [LocalizedMessagesDirective, ɵngcc2.NgIf, ɵngcc2.NgClass, ɵngcc2.NgStyle], encapsulation: 2 });
__decorate([
    HostBinding('class.k-floating-label-container'),
    __metadata("design:type", Boolean)
], FloatingLabelComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-state-focused'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FloatingLabelComponent.prototype, "focusedClass", null);
__decorate([
    HostBinding('class.k-state-invalid'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FloatingLabelComponent.prototype, "invalidClass", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], FloatingLabelComponent.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FloatingLabelComponent.prototype, "labelCssStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FloatingLabelComponent.prototype, "labelCssClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FloatingLabelComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FloatingLabelComponent.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FloatingLabelComponent.prototype, "optional", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FloatingLabelComponent.prototype, "positionChange", void 0);
__decorate([
    ContentChild(KendoInput, { static: false }),
    __metadata("design:type", Object)
], FloatingLabelComponent.prototype, "kendoInput", void 0);
__decorate([
    ContentChild(NgControl, { static: false }),
    __metadata("design:type", NgControl)
], FloatingLabelComponent.prototype, "formControl", void 0);
FloatingLabelComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ChangeDetectorRef,
        LocalizationService])
], FloatingLabelComponent);

const COMPONENT_DIRECTIVES = [FloatingLabelComponent];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TextBox directive.
 *
 * @example
 *
 * ```ts-no-run
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, FloatingLabelModule], // import FloatingLabel module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let FloatingLabelModule = class FloatingLabelModule {
};
FloatingLabelModule.ɵfac = function FloatingLabelModule_Factory(t) { return new (t || FloatingLabelModule)(); };
FloatingLabelModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: FloatingLabelModule });
FloatingLabelModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, SharedDirectivesModule], SharedDirectivesModule] });

/**
 * Represents the [Kendo UI Label component for Angular]({% slug label_basic %}).
 *
 * Associates a label with input elements or components.
 *
 * @example
 * ```ts
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-label [for]="input" text="First name">
 *       <input [(ngModel)]="name" kendoTextBox #input />
 *     </kendo-label>
 *   `
 * })
 * class AppComponent {
 *     public name = 'John';
 * }
 *
 * ```
 */
let LabelComponent = class LabelComponent {
    constructor(elementRef, renderer, localization) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.localization = localization;
        this.subscriptions = new Subscription();
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.renderer.removeAttribute(this.elementRef.nativeElement, 'id');
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.for) {
            this.control = this.for;
            return;
        }
        const wrappedNativeInput = getWrappedNativeInput(this.elementRef.nativeElement);
        if (wrappedNativeInput) {
            if (!wrappedNativeInput.hasAttribute('id')) {
                this.renderer.setAttribute(wrappedNativeInput, 'id', `k-${guid()}`);
            }
            this.control = wrappedNativeInput;
            return;
        }
        this.control = this.kendoInput;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        }));
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.labelDirective.setAriaLabelledby();
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
};
LabelComponent.ɵfac = function LabelComponent_Factory(t) { return new (t || LabelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LabelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LabelComponent, selectors: [["kendo-label"]], contentQueries: function LabelComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, KendoInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
    } }, viewQuery: function LabelComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(LabelDirective, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelDirective = _t.first);
    } }, hostVars: 1, hostBindings: function LabelComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
    } }, inputs: { text: "text", for: "for", optional: "optional" }, exportAs: ["kendoLabel"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.label'
            }
        ])], ngContentSelectors: _c2, decls: 5, vars: 5, consts: function () { let i18n_3; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text for the optional segment of a Label component
         * @meaning kendo.label.optional
         */
        const MSG_EXTERNAL_3476218486854814180$$DIST_FESM2015_INDEX_JS_4 = goog.getMsg("Optional");
        i18n_3 = MSG_EXTERNAL_3476218486854814180$$DIST_FESM2015_INDEX_JS_4;
    }
    else {
        i18n_3 = $localize `:kendo.label.optional|The text for the optional segment of a Label component␟a1cd4a8f359a22151d7e73f2887fbb2967cd389a␟3476218486854814180:Optional`;
    } return [["kendoLabelLocalizedMessages", "", "optional", i18n_3], [3, "for"], ["class", "k-label-optional", 4, "ngIf"], [1, "k-label-optional"]]; }, template: function LabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "label", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵtemplate(3, LabelComponent_span_3_Template, 2, 1, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("k-label-empty", !ctx.text);
        ɵngcc0.ɵɵproperty("for", ctx.control);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.text, "");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.optional);
    } }, directives: [LocalizedMessagesDirective, LabelDirective, ɵngcc2.NgIf], encapsulation: 2 });
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], LabelComponent.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LabelComponent.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LabelComponent.prototype, "for", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], LabelComponent.prototype, "optional", void 0);
__decorate([
    ViewChild(LabelDirective, { static: true }),
    __metadata("design:type", LabelDirective)
], LabelComponent.prototype, "labelDirective", void 0);
__decorate([
    ContentChild(KendoInput, { static: true }),
    __metadata("design:type", Object)
], LabelComponent.prototype, "kendoInput", void 0);
LabelComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        LocalizationService])
], LabelComponent);

const COMPONENT_DIRECTIVES$1 = [
    LabelDirective,
    LabelComponent
];
/**
 * The exported package module.
 *
 * The package exports:
 * - `LabelDirective`&mdash;The Label directive class.
 * - `LabelComponent`&mdash;The Label component class
 * - `FLoatingLabel`&mdash;The FloatingLabel component class.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Label module
 * import { LabelModule } from '@progress/kendo-angular-label';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, LabelModule], // import Label module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let LabelModule = class LabelModule {
};
LabelModule.ɵfac = function LabelModule_Factory(t) { return new (t || LabelModule)(); };
LabelModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: LabelModule });
LabelModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, SharedDirectivesModule], FloatingLabelModule, SharedDirectivesModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LabelDirective, [{
        type: Directive,
        args: [{
                selector: 'label[for]' //tslint:disable-line:directive-selector
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { labelClass: [{
            type: HostBinding,
            args: ['class.k-label']
        }], labelFor: [{
            type: HostBinding,
            args: ['attr.for']
        }], for: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => LocalizedMessagesDirective_1)
                    }
                ],
                selector: `
      [kendoLabelLocalizedMessages],
      [kendoFloatingLabelLocalizedMessages]
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => CustomMessagesComponent_1)
                    }
                ],
                selector: 'kendo-label-messages, kendo-floatinglabel-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SharedDirectivesModule, [{
        type: NgModule,
        args: [{
                declarations: [SHARED_DIRECTIVES],
                exports: [SHARED_DIRECTIVES]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedDirectivesModule, { declarations: [LocalizedMessagesDirective, CustomMessagesComponent], exports: [LocalizedMessagesDirective, CustomMessagesComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FloatingLabelComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-floatinglabel',
                exportAs: 'kendoFloatingLabel',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.floatinglabel'
                    }
                ],
                template: `
        <ng-container kendoFloatingLabelLocalizedMessages
            i18n-optional="kendo.floatinglabel.optional|The text for the optional segment of a FloatingLabel component"
            optional="Optional"
         >
        </ng-container>
        <ng-content></ng-content>
        <label *ngIf="text" [ngClass]="labelCssClass" [ngStyle]="labelCssStyle" [for]="id" [attr.id]="labelId" class="k-label">
            {{ text }}<span *ngIf="optional" class="k-label-optional">({{textFor('optional')}})</span>
        </label>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.LocalizationService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-floating-label-container']
        }], positionChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], focusedClass: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], invalidClass: [{
            type: HostBinding,
            args: ['class.k-state-invalid']
        }], id: [{
            type: Input
        }], labelCssStyle: [{
            type: Input
        }], labelCssClass: [{
            type: Input
        }], text: [{
            type: Input
        }], optional: [{
            type: Input
        }], kendoInput: [{
            type: ContentChild,
            args: [KendoInput, { static: false }]
        }], formControl: [{
            type: ContentChild,
            args: [NgControl, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FloatingLabelModule, [{
        type: NgModule,
        args: [{
                declarations: [...COMPONENT_DIRECTIVES],
                exports: [...COMPONENT_DIRECTIVES, SharedDirectivesModule],
                imports: [CommonModule, SharedDirectivesModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FloatingLabelModule, { declarations: function () { return [FloatingLabelComponent]; }, imports: function () { return [CommonModule, SharedDirectivesModule]; }, exports: function () { return [FloatingLabelComponent, SharedDirectivesModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LabelComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-label',
                exportAs: 'kendoLabel',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.label'
                    }
                ],
                template: `
        <ng-container kendoLabelLocalizedMessages
            i18n-optional="kendo.label.optional|The text for the optional segment of a Label component"
            optional="Optional"
         >
        </ng-container>
        <label
            [for]="control"
            [class.k-label-empty]="!text">
            {{ text }}<span *ngIf="optional" class="k-label-optional">({{textFor('optional')}})</span>
        </label>
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }]; }, { direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], text: [{
            type: Input
        }], for: [{
            type: Input
        }], optional: [{
            type: Input
        }], labelDirective: [{
            type: ViewChild,
            args: [LabelDirective, { static: true }]
        }], kendoInput: [{
            type: ContentChild,
            args: [KendoInput, { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LabelModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, SharedDirectivesModule],
                declarations: [...COMPONENT_DIRECTIVES$1],
                exports: [...COMPONENT_DIRECTIVES$1, FloatingLabelModule, SharedDirectivesModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LabelModule, { declarations: function () { return [LabelDirective, LabelComponent]; }, imports: function () { return [CommonModule, SharedDirectivesModule]; }, exports: function () { return [LabelDirective, LabelComponent, FloatingLabelModule, SharedDirectivesModule]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { LocalizedMessagesDirective, Messages, SharedDirectivesModule, LabelDirective, LabelModule, FloatingLabelModule, FloatingLabelComponent, LabelComponent, CustomMessagesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7bUNBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRKQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tEQUFFO0FBQ0Ysd0VBYUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt5SkFBRTtBQUNGLGtFQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O3dFQU0yQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29IQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQXVCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Z0pBT3dCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0dBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkF5Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b1hBT2dCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIxIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBJbnB1dCwgSG9zdEJpbmRpbmcsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgUmVuZGVyZXIyLCBOZ1pvbmUsIGZvcndhcmRSZWYsIENvbXBvbmVudCwgTmdNb2R1bGUsIEV2ZW50RW1pdHRlciwgaXNEZXZNb2RlLCBPdXRwdXQsIENvbnRlbnRDaGlsZCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNEb2N1bWVudEF2YWlsYWJsZSwgZ3VpZCwgaGFzT2JzZXJ2ZXJzLCBLZW5kb0lucHV0IH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY29tbW9uJztcbmltcG9ydCB7IENvbXBvbmVudE1lc3NhZ2VzLCBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IHZhbGlkYXRlUGFja2FnZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1saWNlbnNpbmcnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1VwbG9hZENvbXBvbmVudCA9IChjb21wb25lbnQpID0+IGNvbXBvbmVudC53cmFwcGVyICYmIChjb21wb25lbnQud3JhcHBlci50YWdOYW1lID09PSAnS0VORE8tVVBMT0FEJyB8fCBjb21wb25lbnQud3JhcHBlci50YWdOYW1lID09PSAnS0VORE8tRklMRVNFTEVDVCcpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzSW5wdXRFbGVtZW50ID0gKGNvbXBvbmVudCkgPT4gY29tcG9uZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaW5wdXRFbGVtZW50SGFzQXR0ciA9IChlbGVtZW50LCBhdHRyaWJ1dGUpID0+IGVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2V0V3JhcHBlZE5hdGl2ZUlucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQucXVlcnlTZWxlY3Rvcigna2VuZG8tbGFiZWwgPiBpbnB1dCwga2VuZG8tbGFiZWwgPiB0ZXh0YXJlYSwga2VuZG8tbGFiZWwgPiBzZWxlY3QnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBnZXRSb290RWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgcm9vdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHdoaWxlIChyb290RWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIHJvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RFbGVtZW50O1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgTGFiZWwgZGlyZWN0aXZlIGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2xhYmVsICV9KS5cbiAqIFRoZSBMYWJlbCBhc3NvY2lhdGVzIGEgZm9jdXNhYmxlIEFuZ3VsYXIgY29tcG9uZW50IG9yIGFuIEhUTUwgZWxlbWVudFxuICogd2l0aCBhIGBsYWJlbGAgdGFnIGJ5IHVzaW5nIHRoZSBgW2Zvcl1gIHByb3BlcnR5IGJpbmRpbmcuXG4gKlxuICogVG8gYXNzb2NpYXRlIGEgY29tcG9uZW50IGJ5IHVzaW5nIHRoZSBgbGFiZWxgIGVsZW1lbnQsIGVpdGhlcjpcbiAqICogU2V0IHRoZSBgW2Zvcl1gIHByb3BlcnR5IGJpbmRpbmcgdG8gYVxuICogW3RlbXBsYXRlIHJlZmVyZW5jZSB2YXJpYWJsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsndGVtcGxhdGVzeW50YXgnXSB9fSN0ZW1wbGF0ZS1yZWZlcmVuY2UtdmFyaWFibGVzLS12YXItKSwgb3JcbiAqICogU2V0IHRoZSBgW2Zvcl1gIHByb3BlcnR5IGJpbmRpbmcgdG8gYW4gYGlkYCBIVE1MIHN0cmluZyB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGRpdiBjbGFzcz1cInJvdyBleGFtcGxlLXdyYXBwZXJcIiBzdHlsZT1cIm1pbi1oZWlnaHQ6IDQ1MHB4O1wiPlxuICogICAgPGRpdiBjbGFzcz1cImNvbC14cy0xMiBjb2wtbWQtNiBleGFtcGxlLWNvbFwiPlxuICogICAgICA8bGFiZWwgW2Zvcl09XCJkYXRlcGlja2VyXCI+RGF0ZVBpY2tlcjogPC9sYWJlbD5cbiAqICAgICAgPGtlbmRvLWRhdGVwaWNrZXIgI2RhdGVwaWNrZXI+PC9rZW5kby1kYXRlcGlja2VyPlxuICogICAgPC9kaXY+XG4gKlxuICogICAgPGRpdiBjbGFzcz1cImNvbC14cy0xMiBjb2wtbWQtNiBleGFtcGxlLWNvbFwiPlxuICogICAgICA8bGFiZWwgZm9yPVwiaW5wdXRcIj5JbnB1dDogPC9sYWJlbD5cbiAqICAgICAgPGlucHV0IGlkPVwiaW5wdXRcIiAvPlxuICogICAgPC9kaXY+XG4gKiAgPC9kaXY+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICogYGBgXG4gKi9cbmxldCBMYWJlbERpcmVjdGl2ZSA9IGNsYXNzIExhYmVsRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCwgcmVuZGVyZXIsIHpvbmUpIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMubGFiZWxDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldEZvY3VzYWJsZUNvbXBvbmVudCgpO1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNVcGxvYWRDb21wb25lbnQoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maWxlU2VsZWN0Lm5hdGl2ZUVsZW1lbnQuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGxhYmVsRm9yKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldEZvY3VzYWJsZUNvbXBvbmVudCgpIHx8IHt9O1xuICAgICAgICBpZiAoaXNJbnB1dEVsZW1lbnQoY29tcG9uZW50KSAmJiAhaW5wdXRFbGVtZW50SGFzQXR0cihjb21wb25lbnQsICdpZCcpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShjb21wb25lbnQsICdpZCcsIGBrLSR7Z3VpZCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnQuZm9jdXNhYmxlSWQgfHwgY29tcG9uZW50LmlkIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc2V0QXJpYUxhYmVsbGVkYnkoKTtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuY2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMubGFiZWwubmF0aXZlRWxlbWVudCwgJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljaykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXRBcmlhTGFiZWxsZWRieSgpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldEZvY3VzYWJsZUNvbXBvbmVudCgpO1xuICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5mb2N1c2FibGVJZCkge1xuICAgICAgICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBnZXRSb290RWxlbWVudCh0aGlzLmxhYmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxUYXJnZXQgPSByb290RWxlbWVudC5xdWVyeVNlbGVjdG9yKGAjJHtjb21wb25lbnQuZm9jdXNhYmxlSWR9YCk7XG4gICAgICAgICAgICBpZiAoIWxhYmVsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFiZWxFbGVtZW50ID0gdGhpcy5sYWJlbC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgaWQgPSBsYWJlbEVsZW1lbnQuaWQgfHwgYGstJHtndWlkKCl9YDtcbiAgICAgICAgICAgIGlmICghbGFiZWxFbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKGxhYmVsRWxlbWVudCwgJ2lkJywgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUobGFiZWxUYXJnZXQsICdhcmlhLWxhYmVsbGVkYnknLCBpZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Rm9jdXNhYmxlQ29tcG9uZW50KCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmZvcjtcbiAgICAgICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQuZm9jdXMgIT09IHVuZGVmaW5lZCA/IHRhcmdldCA6IG51bGw7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExhYmVsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmZvcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIExhYmVsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsYWJlbEZvclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWxhYmVsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMYWJlbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGFiZWxDbGFzc1wiLCB2b2lkIDApO1xuTGFiZWxEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ2xhYmVsW2Zvcl0nIC8vdHNsaW50OmRpc2FibGUtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3JcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIFJlbmRlcmVyMiwgTmdab25lXSlcbl0sIExhYmVsRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcIm9wdGlvbmFsXCIsIHZvaWQgMCk7XG5cbnZhciBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBjbGFzcyBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufTtcbkxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiBgXG4gICAgICBba2VuZG9MYWJlbExvY2FsaXplZE1lc3NhZ2VzXSxcbiAgICAgIFtrZW5kb0Zsb2F0aW5nTGFiZWxMb2NhbGl6ZWRNZXNzYWdlc11cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlKTtcblxudmFyIEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzE7XG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXNcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbGFiZWxfZ2xvYmFsaXphdGlvbiAlfSN0b2MtbG9jYWxpemF0aW9uKSkuXG4gKi9cbmxldCBDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBjbGFzcyBDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbkN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tbGFiZWwtbWVzc2FnZXMsIGtlbmRvLWZsb2F0aW5nbGFiZWwtbWVzc2FnZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpO1xuXG5jb25zdCBTSEFSRURfRElSRUNUSVZFUyA9IFtcbiAgICBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSxcbiAgICBDdXN0b21NZXNzYWdlc0NvbXBvbmVudFxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2hhcmVkRGlyZWN0aXZlc01vZHVsZSA9IGNsYXNzIFNoYXJlZERpcmVjdGl2ZXNNb2R1bGUge1xufTtcblNoYXJlZERpcmVjdGl2ZXNNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW1NIQVJFRF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgZXhwb3J0czogW1NIQVJFRF9ESVJFQ1RJVkVTXVxuICAgIH0pXG5dLCBTaGFyZWREaXJlY3RpdmVzTW9kdWxlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhY2thZ2VNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbGFiZWwnLFxuICAgIHByb2R1Y3ROYW1lOiAnS2VuZG8gVUkgZm9yIEFuZ3VsYXInLFxuICAgIHByb2R1Y3RDb2RlczogWydLRU5ET1VJQU5HVUxBUicsICdLRU5ET1VJQ09NUExFVEUnXSxcbiAgICBwdWJsaXNoRGF0ZTogMTY0NjIxOTA1OCxcbiAgICB2ZXJzaW9uOiAnJyxcbiAgICBsaWNlbnNpbmdEb2NzVXJsOiAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9teS1saWNlbnNlLz91dG1fbWVkaXVtPXByb2R1Y3QmdXRtX3NvdXJjZT1rZW5kb2FuZ3VsYXImdXRtX2NhbXBhaWduPWtlbmRvLXVpLWFuZ3VsYXItcHVyY2hhc2UtbGljZW5zZS1rZXlzLXdhcm5pbmcnXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmxvYXRpbmdMYWJlbElucHV0QWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50LCBmb3JtQ29udHJvbCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgY29uc3QgaXNPYnNlcnZhYmxlT3JFdmVudEVtaXR0ZXIgPSAoZXZlbnQpID0+IGV2ZW50IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSB8fCBldmVudCBpbnN0YW5jZW9mIEV2ZW50RW1pdHRlcjtcbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9yRXZlbnRFbWl0dGVyKGNvbXBvbmVudC5vbkZvY3VzKSkge1xuICAgICAgICAgICAgdGhpcy5vbkZvY3VzID0gY29tcG9uZW50Lm9uRm9jdXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9yRXZlbnRFbWl0dGVyKGNvbXBvbmVudC5hdXRvRmlsbFN0YXJ0KSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvRmlsbFN0YXJ0ID0gY29tcG9uZW50LmF1dG9GaWxsU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9yRXZlbnRFbWl0dGVyKGNvbXBvbmVudC5hdXRvRmlsbEVuZCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0ZpbGxFbmQgPSBjb21wb25lbnQuYXV0b0ZpbGxFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9yRXZlbnRFbWl0dGVyKGNvbXBvbmVudC5vbkJsdXIpKSB7XG4gICAgICAgICAgICB0aGlzLm9uQmx1ciA9IGNvbXBvbmVudC5vbkJsdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1Db250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UgPSBmb3JtQ29udHJvbC52YWx1ZUNoYW5nZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Lm9uVmFsdWVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZSA9IGNvbXBvbmVudC5vblZhbHVlQ2hhbmdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmb2N1c2FibGVJZCgpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIGlmICgnZm9jdXNhYmxlSWQnIGluIGNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5mb2N1c2FibGVJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnaWQnIGluIGNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgc2V0IGZvY3VzYWJsZUlkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICBpZiAoJ2ZvY3VzYWJsZUlkJyBpbiBjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5mb2N1c2FibGVJZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdpZCcgaW4gY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQuaWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgaXNGdW5jdGlvbiA9ICh4KSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBGbG9hdGluZ0xhYmVsIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19mbG9hdGluZ2xhYmVsICV9KS5cbiAqIFByb3ZpZGVzIGZsb2F0aW5nIGxhYmVscyB0byBgaW5wdXRgIGVsZW1lbnRzLlxuICpcbiAqIFRoZSBGbG9hdGluZ0xhYmVsIHN1cHBvcnRzIGJvdGggVGVtcGxhdGUgYW5kIFJlYWN0aXZlIEZvcm1zIGFuZFxuICogW2NhbiBjb250YWluIEtlbmRvIFVJIGZvciBBbmd1bGFyIElucHV0IGNvbXBvbmVudHMgc3VjaCBhcyBga2VuZG8tY29tYm9ib3hgIGFuZCBga2VuZG8tbnVtZXJpY3RleHRib3hgLFxuICogb3IgSFRNTCBJbnB1dCBlbGVtZW50cyB3aXRoIHRoZSBga2VuZG9UZXh0Qm94YCBkaXJlY3RpdmUgYXBwbGllZF0oeyUgc2x1ZyBvdmVydmlld19mbG9hdGluZ2xhYmVsICV9I3RvYy1pbXBsZW1lbnRpbmctZmxvYXRpbmctbGFiZWxzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8a2VuZG8tZmxvYXRpbmdsYWJlbCB0ZXh0PVwiRmlyc3QgbmFtZVwiPlxuICogICAgICAgPGlucHV0IFsobmdNb2RlbCldPVwibmFtZVwiIGtlbmRvVGV4dEJveCAvPlxuICogICAgIDwva2VuZG8tZmxvYXRpbmdsYWJlbD5cbiAqICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgcHVibGljIG5hbWUgPSAnSm9obic7XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBGbG9hdGluZ0xhYmVsQ29tcG9uZW50ID0gY2xhc3MgRmxvYXRpbmdMYWJlbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZiwgcmVuZGVyZXIsIGNoYW5nZURldGVjdG9yUmVmLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmID0gY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGFmdGVyIHRoZSBmbG9hdGluZyBsYWJlbCBwb3NpdGlvbiBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbXB0eSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFiZWxJZCA9IGBrLSR7Z3VpZCgpfWA7XG4gICAgICAgIHRoaXMuYXV0b0ZpbGxTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJpZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyB0aGUgY3VycmVudCBmbG9hdGluZyBsYWJlbCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgbGFiZWxQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gJ091dCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZCA/ICdPdXQnIDogJ0luJztcbiAgICB9XG4gICAgZ2V0IGZvY3VzZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZDtcbiAgICB9XG4gICAgZ2V0IGludmFsaWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVNldHVwKCk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2wgPSBuZXcgRmxvYXRpbmdMYWJlbElucHV0QWRhcHRlcih0aGlzLmtlbmRvSW5wdXQgfHwgdGhpcy5mb3JtQ29udHJvbC52YWx1ZUFjY2Vzc29yLCB0aGlzLmZvcm1Db250cm9sKTtcbiAgICAgICAgdGhpcy5hZGRIYW5kbGVycyhjb250cm9sKTtcbiAgICAgICAgdGhpcy5zZXRMYWJlbEZvcihjb250cm9sKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5rZW5kb0lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLnNldEFyaWFMYWJlbGxlZGJ5KHRoaXMua2VuZG9JbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRleHRGb3Ioa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoa2V5KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKGNvbnRyb2wsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoY29udHJvbFtldmVudE5hbWVdIGluc3RhbmNlb2YgRXZlbnRFbWl0dGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjb250cm9sW2V2ZW50TmFtZV0uc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24uYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IGVtcHR5ID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgLy8gemVybyBpcyBub3QgYW4gZW1wdHkgdmFsdWUgKGUuZy4sIE51bWVyaWNUZXh0Qm94KVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtcHR5IGFycmF5cyBhcmUgYW4gZW1wdHkgdmFsdWUgKGUuZy4sIE11bHRpU2VsZWN0KVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmICF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZvcm1Db250cm9sID0gdGhpcy5mb3JtQ29udHJvbDtcbiAgICAgICAgaWYgKGZvcm1Db250cm9sKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUFjY2Vzc29yID0gZm9ybUNvbnRyb2wudmFsdWVBY2Nlc3NvcjtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlQWNjZXNzb3IuaXNFbXB0eSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtcHR5ID0gdmFsdWVBY2Nlc3Nvci5pc0VtcHR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtcHR5ID0gZW1wdHkoZm9ybUNvbnRyb2wudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkID0gZm9ybUNvbnRyb2wuaW52YWxpZCAmJiAoZm9ybUNvbnRyb2wudG91Y2hlZCB8fCBmb3JtQ29udHJvbC5kaXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtcHR5ID0gaXNGdW5jdGlvbih0aGlzLmtlbmRvSW5wdXQuaXNFbXB0eSkgP1xuICAgICAgICAgICAgICAgIHRoaXMua2VuZG9JbnB1dC5pc0VtcHR5KCkgOiBlbXB0eSh0aGlzLmtlbmRvSW5wdXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnay1zdGF0ZS1lbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2stc3RhdGUtZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBzZXRBcmlhTGFiZWxsZWRieShjb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50SWQgPSBjb21wb25lbnQuZm9jdXNhYmxlSWQgfHwgY29tcG9uZW50LmlkO1xuICAgICAgICBpZiAoY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKGAjJHtjb21wb25lbnRJZH1gKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKGZvY3VzYWJsZUVsZW1lbnQsICdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLmxhYmVsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldExhYmVsRm9yKGNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgY29udHJvbElkID0gY29udHJvbC5mb2N1c2FibGVJZCB8fCBjb250cm9sLmlkO1xuICAgICAgICBpZiAodGhpcy5pZCAmJiBjb250cm9sSWQpIHtcbiAgICAgICAgICAgIC8vIGlucHV0IHdpbnNcbiAgICAgICAgICAgIHRoaXMuaWQgPSBjb250cm9sSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pZCkge1xuICAgICAgICAgICAgY29udHJvbC5mb2N1c2FibGVJZCA9IHRoaXMuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udHJvbElkKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gY29udHJvbElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBgay0ke2d1aWQoKX1gO1xuICAgICAgICAgICAgY29udHJvbC5mb2N1c2FibGVJZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUF1dG9maWxsKGNvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoY29udHJvbCwgJ2F1dG9GaWxsU3RhcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF1dG9GaWxsU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnay1zdGF0ZS1lbXB0eScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoY29udHJvbCwgJ2F1dG9GaWxsRW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0ZpbGxTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvRmlsbFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnay1zdGF0ZS1lbXB0eScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZEhhbmRsZXJzKGNvbnRyb2wpIHtcbiAgICAgICAgY29uc3Qgc2V0Rm9jdXMgPSAoaXNGb2N1c2VkKSA9PiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSBpc0ZvY3VzZWQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMucG9zaXRpb25DaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZS5lbWl0KGlzRm9jdXNlZCA/ICdPdXQnIDogJ0luJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKGNvbnRyb2wsICdvbkZvY3VzJywgc2V0Rm9jdXModHJ1ZSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZShjb250cm9sLCAnb25CbHVyJywgc2V0Rm9jdXMoZmFsc2UpKTtcbiAgICAgICAgdGhpcy5oYW5kbGVBdXRvZmlsbChjb250cm9sKTtcbiAgICAgICAgY29uc3QgdXBkYXRlU3RhdGUgPSAoKSA9PiB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKGNvbnRyb2wsICdvblZhbHVlQ2hhbmdlJywgdXBkYXRlU3RhdGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVNldHVwKCkge1xuICAgICAgICBpZiAoIXRoaXMuZm9ybUNvbnRyb2wgJiYgIXRoaXMua2VuZG9JbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEZsb2F0aW5nTGFiZWxDb21wb25lbnQgcmVxdWlyZXMgYSBLZW5kbyBJbnB1dCBjb21wb25lbnRcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIG9yIGEgZm9ybXMtYm91bmQgY29tcG9uZW50IHRvIGZ1bmN0aW9uIHByb3Blcmx5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1mbG9hdGluZy1sYWJlbC1jb250YWluZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZsb2F0aW5nTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1mb2N1c2VkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEZsb2F0aW5nTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0YXRlLWludmFsaWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRmxvYXRpbmdMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW52YWxpZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZsb2F0aW5nTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRmxvYXRpbmdMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxDc3NTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRmxvYXRpbmdMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxDc3NDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmxvYXRpbmdMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZsb2F0aW5nTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBGbG9hdGluZ0xhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25hbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEZsb2F0aW5nTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcInBvc2l0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoS2VuZG9JbnB1dCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBGbG9hdGluZ0xhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJrZW5kb0lucHV0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoTmdDb250cm9sLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE5nQ29udHJvbClcbl0sIEZsb2F0aW5nTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1Db250cm9sXCIsIHZvaWQgMCk7XG5GbG9hdGluZ0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1mbG9hdGluZ2xhYmVsJyxcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0Zsb2F0aW5nTGFiZWwnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5mbG9hdGluZ2xhYmVsJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvRmxvYXRpbmdMYWJlbExvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLW9wdGlvbmFsPVwia2VuZG8uZmxvYXRpbmdsYWJlbC5vcHRpb25hbHxUaGUgdGV4dCBmb3IgdGhlIG9wdGlvbmFsIHNlZ21lbnQgb2YgYSBGbG9hdGluZ0xhYmVsIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBvcHRpb25hbD1cIk9wdGlvbmFsXCJcbiAgICAgICAgID5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPGxhYmVsICpuZ0lmPVwidGV4dFwiIFtuZ0NsYXNzXT1cImxhYmVsQ3NzQ2xhc3NcIiBbbmdTdHlsZV09XCJsYWJlbENzc1N0eWxlXCIgW2Zvcl09XCJpZFwiIFthdHRyLmlkXT1cImxhYmVsSWRcIiBjbGFzcz1cImstbGFiZWxcIj5cbiAgICAgICAgICAgIHt7IHRleHQgfX08c3BhbiAqbmdJZj1cIm9wdGlvbmFsXCIgY2xhc3M9XCJrLWxhYmVsLW9wdGlvbmFsXCI+KHt7dGV4dEZvcignb3B0aW9uYWwnKX19KTwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIEZsb2F0aW5nTGFiZWxDb21wb25lbnQpO1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyA9IFtGbG9hdGluZ0xhYmVsQ29tcG9uZW50XTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIFRleHRCb3ggZGlyZWN0aXZlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIEZsb2F0aW5nTGFiZWxNb2R1bGVdLCAvLyBpbXBvcnQgRmxvYXRpbmdMYWJlbCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBGbG9hdGluZ0xhYmVsTW9kdWxlID0gY2xhc3MgRmxvYXRpbmdMYWJlbE1vZHVsZSB7XG59O1xuRmxvYXRpbmdMYWJlbE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbLi4uQ09NUE9ORU5UX0RJUkVDVElWRVNdLFxuICAgICAgICBleHBvcnRzOiBbLi4uQ09NUE9ORU5UX0RJUkVDVElWRVMsIFNoYXJlZERpcmVjdGl2ZXNNb2R1bGVdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBTaGFyZWREaXJlY3RpdmVzTW9kdWxlXVxuICAgIH0pXG5dLCBGbG9hdGluZ0xhYmVsTW9kdWxlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgTGFiZWwgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIGxhYmVsX2Jhc2ljICV9KS5cbiAqXG4gKiBBc3NvY2lhdGVzIGEgbGFiZWwgd2l0aCBpbnB1dCBlbGVtZW50cyBvciBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxrZW5kby1sYWJlbCBbZm9yXT1cImlucHV0XCIgdGV4dD1cIkZpcnN0IG5hbWVcIj5cbiAqICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cIm5hbWVcIiBrZW5kb1RleHRCb3ggI2lucHV0IC8+XG4gKiAgICAgPC9rZW5kby1sYWJlbD5cbiAqICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgcHVibGljIG5hbWUgPSAnSm9obic7XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBMYWJlbENvbXBvbmVudCA9IGNsYXNzIExhYmVsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCByZW5kZXJlciwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmZvcjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVkTmF0aXZlSW5wdXQgPSBnZXRXcmFwcGVkTmF0aXZlSW5wdXQodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAod3JhcHBlZE5hdGl2ZUlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIXdyYXBwZWROYXRpdmVJbnB1dC5oYXNBdHRyaWJ1dGUoJ2lkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh3cmFwcGVkTmF0aXZlSW5wdXQsICdpZCcsIGBrLSR7Z3VpZCgpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250cm9sID0gd3JhcHBlZE5hdGl2ZUlucHV0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMua2VuZG9JbnB1dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5sYWJlbERpcmVjdGl2ZS5zZXRBcmlhTGFiZWxsZWRieSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0ZXh0Rm9yKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KGtleSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImZvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25hbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKExhYmVsRGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTGFiZWxEaXJlY3RpdmUpXG5dLCBMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxEaXJlY3RpdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChLZW5kb0lucHV0LCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImtlbmRvSW5wdXRcIiwgdm9pZCAwKTtcbkxhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1sYWJlbCcsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9MYWJlbCcsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmxhYmVsJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvTGFiZWxMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1vcHRpb25hbD1cImtlbmRvLmxhYmVsLm9wdGlvbmFsfFRoZSB0ZXh0IGZvciB0aGUgb3B0aW9uYWwgc2VnbWVudCBvZiBhIExhYmVsIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBvcHRpb25hbD1cIk9wdGlvbmFsXCJcbiAgICAgICAgID5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgW2Zvcl09XCJjb250cm9sXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLWxhYmVsLWVtcHR5XT1cIiF0ZXh0XCI+XG4gICAgICAgICAgICB7eyB0ZXh0IH19PHNwYW4gKm5nSWY9XCJvcHRpb25hbFwiIGNsYXNzPVwiay1sYWJlbC1vcHRpb25hbFwiPih7e3RleHRGb3IoJ29wdGlvbmFsJyl9fSk8L3NwYW4+XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgTGFiZWxDb21wb25lbnQpO1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyQxID0gW1xuICAgIExhYmVsRGlyZWN0aXZlLFxuICAgIExhYmVsQ29tcG9uZW50XG5dO1xuLyoqXG4gKiBUaGUgZXhwb3J0ZWQgcGFja2FnZSBtb2R1bGUuXG4gKlxuICogVGhlIHBhY2thZ2UgZXhwb3J0czpcbiAqIC0gYExhYmVsRGlyZWN0aXZlYCZtZGFzaDtUaGUgTGFiZWwgZGlyZWN0aXZlIGNsYXNzLlxuICogLSBgTGFiZWxDb21wb25lbnRgJm1kYXNoO1RoZSBMYWJlbCBjb21wb25lbnQgY2xhc3NcbiAqIC0gYEZMb2F0aW5nTGFiZWxgJm1kYXNoO1RoZSBGbG9hdGluZ0xhYmVsIGNvbXBvbmVudCBjbGFzcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBMYWJlbCBtb2R1bGVcbiAqIGltcG9ydCB7IExhYmVsTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbGFiZWwnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBMYWJlbE1vZHVsZV0sIC8vIGltcG9ydCBMYWJlbCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBMYWJlbE1vZHVsZSA9IGNsYXNzIExhYmVsTW9kdWxlIHtcbn07XG5MYWJlbE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgU2hhcmVkRGlyZWN0aXZlc01vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogWy4uLkNPTVBPTkVOVF9ESVJFQ1RJVkVTJDFdLFxuICAgICAgICBleHBvcnRzOiBbLi4uQ09NUE9ORU5UX0RJUkVDVElWRVMkMSwgRmxvYXRpbmdMYWJlbE1vZHVsZSwgU2hhcmVkRGlyZWN0aXZlc01vZHVsZV1cbiAgICB9KVxuXSwgTGFiZWxNb2R1bGUpO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLCBNZXNzYWdlcywgU2hhcmVkRGlyZWN0aXZlc01vZHVsZSwgTGFiZWxEaXJlY3RpdmUsIExhYmVsTW9kdWxlLCBGbG9hdGluZ0xhYmVsTW9kdWxlLCBGbG9hdGluZ0xhYmVsQ29tcG9uZW50LCBMYWJlbENvbXBvbmVudCwgQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgfTtcbiJdfQ==