/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param, __assign, __extends } from 'tslib';
import { EventEmitter, Injectable, Directive, Optional, TemplateRef, forwardRef, isDevMode, HostBinding, ViewChild, ViewContainerRef, Input, Output, ContentChild, Component, ChangeDetectionStrategy, ElementRef, ChangeDetectorRef, NgZone, Renderer2, ComponentFactoryResolver, Host, NgModule } from '@angular/core';
import { isDocumentAvailable, Keys, anyChanged, hasObservers, isChanged, guid } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { Subject, of, BehaviorSubject, Subscription, EMPTY, merge } from 'rxjs';
import { validatePackage } from '@progress/kendo-licensing';
import { getter, setter } from '@progress/kendo-common';
import { trigger, transition, style, animate } from '@angular/animations';
import { filter, catchError, tap, finalize, switchMap, take, map, delay, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import Draggable from '@telerik/kendo-draggable';
import { InputsModule } from '@progress/kendo-angular-inputs';

/**
 * @hidden
 */
var packageMetadata = {
    name: '@progress/kendo-angular-treeview',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1646219256,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * @hidden
 */
var DataChangeNotificationService = /** @class */ (function () {
    function DataChangeNotificationService() {
        this.changes = new EventEmitter();
    }
    DataChangeNotificationService.prototype.notify = function () {
        this.changes.emit();
    };
    return DataChangeNotificationService;
}());

/**
 * @hidden
 */
var hasChildren = function () { return false; };
/**
 * @hidden
 */
var isChecked = function () { return 'none'; };
/**
 * @hidden
 */
var isDisabled = function () { return false; };
/**
 * @hidden
 */
var isExpanded = function () { return true; };
/**
 * @hidden
 */
var isSelected = function () { return false; };
/**
 * @hidden
 */
var isVisible = function () { return true; };
/**
 * @hidden
 */
var trackBy = function (_, item) { return item; };

/**
 * @hidden
 */
var ExpandStateService = /** @class */ (function () {
    function ExpandStateService() {
        this.changes = new Subject();
    }
    ExpandStateService.prototype.expand = function (index, dataItem) {
        this.changes.next({ dataItem: dataItem, index: index, expand: true });
    };
    ExpandStateService.prototype.collapse = function (index, dataItem) {
        this.changes.next({ dataItem: dataItem, index: index, expand: false });
    };
    ExpandStateService = __decorate([
        Injectable()
    ], ExpandStateService);
    return ExpandStateService;
}());

/**
 * @hidden
 */
var IndexBuilderService = /** @class */ (function () {
    function IndexBuilderService() {
        this.INDEX_SEPARATOR = '_';
    }
    IndexBuilderService.prototype.nodeIndex = function (index, parentIndex) {
        if (index === void 0) { index = ''; }
        if (parentIndex === void 0) { parentIndex = ''; }
        return "" + parentIndex + (parentIndex ? this.INDEX_SEPARATOR : '') + index;
    };
    IndexBuilderService.prototype.indexForLevel = function (index, level) {
        return index.split(this.INDEX_SEPARATOR).slice(0, level).join(this.INDEX_SEPARATOR);
    };
    IndexBuilderService.prototype.lastLevelIndex = function (index) {
        if (index === void 0) { index = ''; }
        var parts = index.split(this.INDEX_SEPARATOR);
        if (!parts.length) {
            return NaN;
        }
        return parseInt(parts[parts.length - 1], 10);
    };
    IndexBuilderService.prototype.level = function (index) {
        return index.split(this.INDEX_SEPARATOR).length;
    };
    IndexBuilderService = __decorate([
        Injectable()
    ], IndexBuilderService);
    return IndexBuilderService;
}());

/**
 * @hidden
 */
var LoadingNotificationService = /** @class */ (function () {
    function LoadingNotificationService() {
        this.changes = new Subject();
    }
    LoadingNotificationService.prototype.notifyLoaded = function (index) {
        this.changes.next(index);
    };
    LoadingNotificationService = __decorate([
        Injectable()
    ], LoadingNotificationService);
    return LoadingNotificationService;
}());

var focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
/**
 * @hidden
 */
var match = function (element, selector) {
    var matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
    if (!matcher) {
        return false;
    }
    return matcher.call(element, selector);
};
/**
 * @hidden
 */
var closestWithMatch = function (element, selector) {
    if (!document.documentElement.contains(element)) {
        return null;
    }
    var parent = element;
    while (parent !== null && parent.nodeType === 1) {
        if (match(parent, selector)) {
            return parent;
        }
        parent = parent.parentElement || parent.parentNode;
    }
    return null;
};
/**
 * @hidden
 */
var noop = function () { };
/**
 * @hidden
 */
var isPresent = function (value) { return value !== null && value !== undefined; };
/**
 * @hidden
 */
var isBlank = function (value) { return value === null || value === undefined; };
/**
 * @hidden
 */
var isArray = function (value) { return Array.isArray(value); };
/**
 * @hidden
 */
var isNullOrEmptyString = function (value) { return isBlank(value) || value.trim().length === 0; };
/**
 * @hidden
 */
var isBoolean = function (value) { return typeof value === 'boolean'; };
/**
 * @hidden
 */
var closestNode = function (element) {
    var selector = 'li.k-treeview-item';
    if (!isDocumentAvailable()) {
        return null;
    }
    if (element.closest) {
        return element.closest(selector);
    }
    else {
        return closestWithMatch(element, selector);
    }
};
/**
 * @hidden
 */
var isFocusable = function (element) {
    if (element.tagName) {
        var tagName = element.tagName.toLowerCase();
        var tabIndex = element.getAttribute('tabIndex');
        var skipTab = tabIndex === '-1';
        var focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
var isContent = function (element) {
    var scopeSelector = '.k-treeview-leaf:not(.k-treeview-load-more-button),.k-treeview-item,.k-treeview';
    if (!isDocumentAvailable()) {
        return null;
    }
    var node = element;
    while (node && !match(node, scopeSelector)) {
        node = node.parentNode;
    }
    if (node) {
        return match(node, '.k-treeview-leaf:not(.k-treeview-load-more-button)');
    }
};
/**
 * @hidden
 *
 * Returns the nested .k-treeview-leaf:not(.k-treeview-load-more-button) element.
 * If the passed parent item is itself a content node, it is returned.
 */
var getContentElement = function (parent) {
    if (!isPresent(parent)) {
        return null;
    }
    var selector = '.k-treeview-leaf:not(.k-treeview-load-more-button)';
    if (match(parent, selector)) {
        return parent;
    }
    return parent.querySelector(selector);
};
/**
 * @hidden
 */
var isLoadMoreButton = function (element) {
    return isPresent(closestWithMatch(element, '.k-treeview-leaf.k-treeview-load-more-button'));
};
/**
 * @hidden
 */
var closest = function (node, predicate) {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
var hasParent = function (element, container) {
    return Boolean(closest(element, function (node) { return node === container; }));
};
/**
 * @hidden
 */
var focusableNode = function (element) { return element.nativeElement.querySelector('li[tabindex="0"]'); };
/**
 * @hidden
 */
var nodeId = function (node) { return node ? node.getAttribute('data-treeindex') : ''; };
/**
 * @hidden
 */
var nodeIndex = function (item) { return (item || {}).index; };
/**
 * @hidden
 */
var dataItemsEqual = function (first, second) {
    if (!isPresent(first) && !isPresent(second)) {
        return true;
    }
    return isPresent(first) && isPresent(second) && first.item.dataItem === second.item.dataItem;
};
/**
 * @hidden
 */
var getDataItem = function (lookup) {
    if (!isPresent(lookup)) {
        return lookup;
    }
    return lookup.item.dataItem;
};
/**
 * @hidden
 */
var isArrayWithAtLeastOneItem = function (v) { return v && Array.isArray(v) && v.length !== 0; };
/**
 * @hidden
 * A recursive tree-filtering algorithm that returns:
 * - all child nodes of matching nodes
 * - a chain parent nodes from the match to the root node
 */
var filterTree = function (items, term, _a, textField, depth) {
    var operator = _a.operator, ignoreCase = _a.ignoreCase, mode = _a.mode;
    if (depth === void 0) { depth = 0; }
    var field = typeof textField === "string" ? textField : textField[depth];
    items.forEach(function (wrapper) {
        var matcher = typeof operator === "string" ? matchByFieldAndCase(field, operator, ignoreCase) : operator;
        var isMatch = matcher(wrapper.dataItem, term);
        wrapper.isMatch = isMatch;
        wrapper.visible = isMatch;
        wrapper.containsMatches = false;
        if (isMatch) {
            setParentChain(wrapper.parent);
        }
        if (wrapper.children && wrapper.children.length > 0) {
            if (mode === "strict" || !isMatch) {
                filterTree(wrapper.children, term, { operator: operator, ignoreCase: ignoreCase, mode: mode }, textField, depth + 1);
            }
            else {
                makeAllVisible(wrapper.children);
            }
        }
    });
};
var setParentChain = function (node) {
    if (!isPresent(node)) {
        return;
    }
    node.containsMatches = true;
    node.visible = true;
    if (isPresent(node.parent) && !node.parent.containsMatches) {
        setParentChain(node.parent);
    }
};
var makeAllVisible = function (nodes) {
    nodes.forEach(function (node) {
        node.visible = true;
        if (node.children) {
            makeAllVisible(node.children);
        }
    });
};
var ɵ2 = function (a, b) { return a.indexOf(b) >= 0; }, ɵ3 = function (a, b) { return a.indexOf(b) === -1; }, ɵ4 = function (a, b) { return a.lastIndexOf(b, 0) === 0; }, ɵ5 = function (a, b) { return a.lastIndexOf(b, 0) === -1; }, ɵ6 = function (a, b) { return a.indexOf(b, a.length - b.length) >= 0; }, ɵ7 = function (a, b) { return a.indexOf(b, a.length - b.length) < 0; };
var operators = {
    contains: ɵ2,
    doesnotcontain: ɵ3,
    startswith: ɵ4,
    doesnotstartwith: ɵ5,
    endswith: ɵ6,
    doesnotendwith: ɵ7
};
var matchByCase = function (matcher, ignoreCase) { return function (a, b) {
    if (ignoreCase) {
        return matcher(a.toLowerCase(), b.toLowerCase());
    }
    return matcher(a, b);
}; };
var matchByFieldAndCase = function (field, operator, ignoreCase) { return function (dataItem, term) { return matchByCase(operators[operator], ignoreCase)(getter(field)(dataItem), term); }; };
/**
 * @hidden
 */
var buildTreeIndex = function (parentIndex, itemIndex) {
    return [parentIndex, itemIndex].filter(function (part) { return isPresent(part); }).join('_');
};
/**
 * @hidden
 */
var buildTreeItem = function (dataItem, currentLevelIndex, parentIndex) {
    if (!isPresent(dataItem)) {
        return null;
    }
    return {
        dataItem: dataItem,
        index: buildTreeIndex(parentIndex, currentLevelIndex)
    };
};
/**
 * @hidden
 *
 * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.
 */
var fetchLoadedDescendants = function (lookup, filterExpression) {
    if (!isPresent(lookup) || lookup.children.length === 0) {
        return [];
    }
    var descendants = lookup.children;
    if (isPresent(filterExpression)) {
        descendants = descendants.filter(filterExpression);
    }
    descendants.forEach(function (child) {
        return descendants = descendants.concat(fetchLoadedDescendants(child, filterExpression));
    });
    return descendants;
};
/**
 * @hidden
 *
 * Compares two Seets to determine whether all unique elements in one, are present in the other.
 * Important:
 *  - it disregards the element order
 */
var sameValues = function (as, bs) {
    if (as.size !== bs.size) {
        return false;
    }
    return Array.from(as).every(function (v) { return bs.has(v); });
};
/**
 * @hidden
 * Returns the size class based on the component and size input.
 */
var getSizeClass = function (component, size) {
    var SIZE_CLASSES = {
        'small': "k-" + component + "-sm",
        'medium': "k-" + component + "-md",
        'large': "k-" + component + "-lg"
    };
    return SIZE_CLASSES[size];
};

var safe = function (node) { return (node || {}); };
var safeChildren = function (node) { return (safe(node).children || []); };
var lastVisibleNode = function (nodes) {
    if (!Array.isArray(nodes) || nodes.length === 0) {
        return null;
    }
    var nodesCount = nodes.length;
    var lastIndex = nodesCount - 1;
    for (var index = lastIndex; index >= 0; index -= 1) {
        var node = nodes[index];
        if (node.visible) {
            return node;
        }
    }
    return null;
};
/**
 * @hidden
 */
var NavigationModel = /** @class */ (function () {
    function NavigationModel() {
        this.ib = new IndexBuilderService();
        this.nodes = [];
    }
    NavigationModel.prototype.firstVisibleNode = function () {
        return (this.nodes || []).find(function (node) { return node.visible; });
    };
    NavigationModel.prototype.lastVisibleNode = function () {
        var node = lastVisibleNode(this.nodes);
        while (isPresent(node) && safeChildren(node).length > 0) {
            var children = safeChildren(node);
            var lastVisibleChild = lastVisibleNode(children);
            if (!isPresent(lastVisibleChild)) {
                return node;
            }
            node = lastVisibleChild;
        }
        return node;
    };
    NavigationModel.prototype.closestNode = function (index) {
        var prev = safe(this.findNode(index)).prev;
        var sibling = prev || this.firstVisibleNode();
        return safe(sibling).index === index ? this.visibleSibling(sibling, 1) : sibling;
    };
    NavigationModel.prototype.firstFocusableNode = function () {
        return this.nodes.find(function (node) {
            return !node.disabled && node.visible;
        });
    };
    NavigationModel.prototype.findNode = function (index) {
        return this.find(index, this.nodes);
    };
    NavigationModel.prototype.findParent = function (index) {
        var parentLevel = this.ib.level(index) - 1;
        return this.findNode(this.ib.indexForLevel(index, parentLevel));
    };
    NavigationModel.prototype.findVisibleChild = function (index) {
        var node = this.findNode(index);
        var children = safeChildren(node);
        return children.find(function (child) { return child.visible; });
    };
    NavigationModel.prototype.findVisiblePrev = function (item) {
        var index = item.index;
        var parent = this.findParent(index);
        var levelIndex = this.ib.lastLevelIndex(index);
        var prevNodes = this.container(parent).slice(0, levelIndex);
        var prevNodesHidden = prevNodes.every(function (node) { return !node.visible; });
        if (levelIndex === 0 || prevNodesHidden) {
            return parent;
        }
        var currentNode = this.findNode(index);
        var prev = this.visibleSibling(currentNode, -1);
        if (prev) {
            var children = this.container(prev);
            while (children.length > 0 && children.some(function (node) { return node.visible; })) {
                prev = lastVisibleNode(children);
                children = this.container(prev);
            }
        }
        return prev;
    };
    NavigationModel.prototype.findVisibleNext = function (item) {
        var children = this.container(item);
        var hasVisibleChildren = children.some(function (child) { return child.visible; });
        if (children.length === 0 || !hasVisibleChildren) {
            return this.visibleSibling(item, 1);
        }
        return children.find(function (child) { return child.visible; });
    };
    NavigationModel.prototype.registerItem = function (id, index, disabled, loadMoreButton, visible) {
        if (loadMoreButton === void 0) { loadMoreButton = false; }
        if (visible === void 0) { visible = true; }
        var children = [];
        var level = this.ib.level(index);
        var parent = this.findParent(index);
        if (parent || level === 1) {
            var node = { id: id, children: children, index: index, parent: parent, disabled: disabled, loadMoreButton: loadMoreButton, visible: visible };
            this.insert(node, parent);
        }
    };
    NavigationModel.prototype.unregisterItem = function (id, index) {
        var node = this.find(index, this.nodes);
        if (!node || node.id !== id) {
            return;
        }
        var children = this.container(node.parent);
        children.splice(children.indexOf(node), 1);
    };
    NavigationModel.prototype.childLevel = function (nodes) {
        var children = nodes.filter(function (node) { return isPresent(node); });
        if (!children || !children.length) {
            return 1;
        }
        return this.ib.level(children[0].index);
    };
    NavigationModel.prototype.container = function (node) {
        return node ? node.children : this.nodes;
    };
    NavigationModel.prototype.find = function (index, nodes) {
        var childLevel = this.childLevel(nodes);
        var indexToMatch = this.ib.indexForLevel(index, childLevel);
        var isLeaf = childLevel === this.ib.level(index);
        var node = nodes.find(function (n) { return n && n.index === indexToMatch; });
        if (!node) {
            return null;
        }
        return isLeaf ? node : this.find(index, node.children);
    };
    NavigationModel.prototype.insert = function (node, parent) {
        var nodes = this.container(parent);
        nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);
    };
    NavigationModel.prototype.visibleSibling = function (node, offset) {
        if (!node) {
            return null;
        }
        var parent = this.findParent(node.index);
        var container = this.container(parent);
        var nextItemIndex = container.indexOf(node) + offset;
        var nextItem = container[nextItemIndex];
        while (isPresent(nextItem)) {
            if (nextItem.visible) {
                return nextItem;
            }
            nextItemIndex += offset;
            nextItem = container[nextItemIndex];
        }
        return this.visibleSibling(parent, offset);
    };
    return NavigationModel;
}());

/**
 * @hidden
 */
var NavigationService = /** @class */ (function () {
    function NavigationService(localization) {
        var _this = this;
        var _a;
        this.localization = localization;
        this.expands = new Subject();
        this.moves = new Subject();
        this.checks = new Subject();
        this.selects = new Subject();
        this.loadMore = new Subject();
        this.navigable = true;
        this.actions = (_a = {},
            _a[Keys.ArrowUp] = function () { return _this.activate(_this.model.findVisiblePrev(_this.focusableItem), true); },
            _a[Keys.ArrowDown] = function () { return _this.activate(_this.model.findVisibleNext(_this.focusableItem), true); },
            _a[Keys.ArrowLeft] = function () { return !_this.isLoadMoreButton && (_this.expand({
                expand: _this.localization.rtl,
                intercept: _this.localization.rtl ? _this.moveToFirstVisibleChild : _this.moveToParent
            })); },
            _a[Keys.ArrowRight] = function () { return !_this.isLoadMoreButton && (_this.expand({
                expand: !_this.localization.rtl,
                intercept: _this.localization.rtl ? _this.moveToParent : _this.moveToFirstVisibleChild
            })); },
            _a[Keys.Home] = function () { return _this.activate(_this.model.firstVisibleNode(), true); },
            _a[Keys.End] = function () { return _this.activate(_this.model.lastVisibleNode(), true); },
            _a[Keys.Enter] = function () { return _this.handleEnter(); },
            _a[Keys.Space] = function () { return _this.handleSpace(); },
            _a);
        this.isFocused = false;
        this.shouldScroll = false;
        this._model = new NavigationModel();
        this.moveToFirstVisibleChild = this.moveToFirstVisibleChild.bind(this);
        this.moveToParent = this.moveToParent.bind(this);
    }
    Object.defineProperty(NavigationService.prototype, "model", {
        get: function () {
            return this._model;
        },
        set: function (model) {
            this._model = model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "activeIndex", {
        get: function () {
            return nodeIndex(this.activeItem) || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "isActiveExpanded", {
        get: function () {
            return this.activeItem && this.activeItem.children.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "isLoadMoreButton", {
        get: function () {
            return this.activeItem && this.activeItem.loadMoreButton;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "focusableItem", {
        get: function () {
            return this.activeItem || this.model.firstFocusableNode();
        },
        enumerable: true,
        configurable: true
    });
    NavigationService.prototype.activate = function (item, shouldScroll) {
        if (shouldScroll === void 0) { shouldScroll = false; }
        if (!this.navigable || !item || this.isActive(nodeIndex(item))) {
            return;
        }
        this.isFocused = true;
        this.activeItem = item || this.activeItem;
        this.shouldScroll = shouldScroll;
        this.notifyMove();
    };
    NavigationService.prototype.activateParent = function (index) {
        this.activate(this.model.findParent(index));
    };
    NavigationService.prototype.activateIndex = function (index) {
        if (!index) {
            return;
        }
        this.activate(this.model.findNode(index));
    };
    NavigationService.prototype.activateClosest = function (index) {
        if (!index || nodeIndex(this.focusableItem) !== index) {
            return;
        }
        this.activeItem = this.model.closestNode(index);
        this.notifyMove();
    };
    NavigationService.prototype.activateFocusable = function () {
        if (this.activeItem) {
            return;
        }
        this.activeItem = this.model.firstVisibleNode();
        this.notifyMove();
    };
    NavigationService.prototype.deactivate = function () {
        if (!this.navigable || !this.isFocused) {
            return;
        }
        this.isFocused = false;
        this.notifyMove();
    };
    NavigationService.prototype.checkIndex = function (index) {
        if (!this.isDisabled(index)) {
            this.checks.next(index);
        }
    };
    NavigationService.prototype.selectIndex = function (index) {
        if (!this.isDisabled(index)) {
            this.selects.next(index);
        }
    };
    NavigationService.prototype.notifyLoadMore = function (index) {
        if (!isPresent(index)) {
            return;
        }
        this.loadMore.next(index);
    };
    NavigationService.prototype.isActive = function (index) {
        if (!index) {
            return false;
        }
        return this.isFocused && this.activeIndex === index;
    };
    NavigationService.prototype.isFocusable = function (index) {
        return nodeIndex(this.focusableItem) === index;
    };
    NavigationService.prototype.isDisabled = function (index) {
        return this.model.findNode(index).disabled;
    };
    NavigationService.prototype.registerItem = function (id, index, disabled, loadMoreButton, visible) {
        if (loadMoreButton === void 0) { loadMoreButton = false; }
        if (visible === void 0) { visible = true; }
        var itemAtIndex = this.model.findNode(index);
        if (isPresent(itemAtIndex)) {
            this.model.unregisterItem(itemAtIndex.id, itemAtIndex.index);
            if (this.isActive(index)) {
                this.deactivate();
            }
        }
        this.model.registerItem(id, index, disabled, loadMoreButton, visible);
    };
    NavigationService.prototype.unregisterItem = function (id, index) {
        if (this.isActive(index)) {
            this.activateParent(index);
        }
        this.model.unregisterItem(id, index);
    };
    NavigationService.prototype.move = function (e) {
        if (!this.navigable) {
            return;
        }
        var moveAction = this.actions[e.keyCode];
        if (!moveAction) {
            return;
        }
        moveAction();
        e.preventDefault();
    };
    NavigationService.prototype.expand = function (_a) {
        var expand = _a.expand, intercept = _a.intercept;
        var index = nodeIndex(this.activeItem);
        if (!index || intercept(index)) {
            return;
        }
        this.notifyExpand(expand);
    };
    NavigationService.prototype.moveToParent = function () {
        if (this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findParent(nodeIndex(this.activeItem)));
        return true;
    };
    NavigationService.prototype.moveToFirstVisibleChild = function () {
        if (!this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findVisibleChild(nodeIndex(this.activeItem)));
        return true;
    };
    NavigationService.prototype.notifyExpand = function (expand) {
        this.expands.next(this.navigationState(expand));
    };
    NavigationService.prototype.notifyMove = function () {
        this.moves.next(this.navigationState());
    };
    NavigationService.prototype.navigationState = function (expand) {
        if (expand === void 0) { expand = false; }
        return ({ expand: expand, index: this.activeIndex, isFocused: this.isFocused, shouldScroll: this.shouldScroll });
    };
    NavigationService.prototype.handleEnter = function () {
        if (!this.navigable) {
            return;
        }
        if (this.isLoadMoreButton) {
            this.notifyLoadMore(this.activeIndex);
        }
        else {
            this.selectIndex(this.activeIndex);
        }
    };
    NavigationService.prototype.handleSpace = function () {
        if (!this.navigable) {
            return;
        }
        if (this.isLoadMoreButton) {
            this.notifyLoadMore(this.activeIndex);
        }
        else {
            this.checkIndex(this.activeIndex);
        }
    };
    NavigationService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [LocalizationService])
    ], NavigationService);
    return NavigationService;
}());

/**
 * @hidden
 */
var NodeChildrenService = /** @class */ (function () {
    function NodeChildrenService() {
        this.changes = new Subject();
    }
    NodeChildrenService.prototype.childrenLoaded = function (item, children) {
        this.changes.next({ item: item, children: children });
    };
    NodeChildrenService = __decorate([
        Injectable()
    ], NodeChildrenService);
    return NodeChildrenService;
}());

/**
 * Represents the template for the TreeView nodes ([more information and example]({% slug nodetemplate_treeview %})).
 * The template helps to customize the content of the nodes. To define the node template, nest an `<ng-template>`
 * tag with the `kendoTreeViewNodeTemplate` directive inside a `<kendo-treeview>` tag.
 *
 *
 * The node data item and its hierarchical index are available as context variables:
 *
 * - `let-dataItem` (`any`) - available as implicit context variable
 * - `let-index="index"` (`string`)
 *
 *
 * @example
 * ```ts
 *
 *  import { Component } from '@angular/core';
 *  @Component({
 *      selector: 'my-app',
 *      template: `
 *      <kendo-treeview
 *          [nodes]="data"
 *          kendoTreeViewExpandable
 *
 *          kendoTreeViewHierarchyBinding
 *          childrenField="items">
 *        <ng-template kendoTreeViewNodeTemplate let-dataItem let-index="index">
 *          <span [style.fontWeight]="dataItem.items ? 'bolder': 'normal' ">{{ index }}: {{ dataItem.text }}</span>
 *        </ng-template>
 *      </kendo-treeview>
 *    `
 *  })
 *  export class AppComponent {
 *      public data: any[] = [
 *          {
 *              text: "Inbox",
 *              items: [{ text: "Read Mail" }]
 *          },
 *          {
 *              text: "Drafts"
 *          },
 *          {
 *              text: "Search Folders",
 *              items: [
 *                  { text: "Categorized Mail" },
 *                  { text: "Large Mail" },
 *                  { text: "Unread Mail"}
 *              ]
 *          },
 *          { text: "Settings" }
 *      ];
 *  }
 *
 * ```
 */
var NodeTemplateDirective = /** @class */ (function () {
    function NodeTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    NodeTemplateDirective = __decorate([
        Directive({
            selector: '[kendoTreeViewNodeTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], NodeTemplateDirective);
    return NodeTemplateDirective;
}());

/**
 * Represents the template for the TreeView load more buttons.
 * To define a button template, nest an `<ng-template>`
 * tag with the `kendoTreeViewLoadMoreButtonTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug loadmorebutton_treeview %}#toc-button-template)).
 *
 * The hierarchical index of the load more button node is available as a context variable:
 *
 * - `let-index="index"` (`string`)
 */
var LoadMoreButtonTemplateDirective = /** @class */ (function () {
    function LoadMoreButtonTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    LoadMoreButtonTemplateDirective = __decorate([
        Directive({
            selector: '[kendoTreeViewLoadMoreButtonTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], LoadMoreButtonTemplateDirective);
    return LoadMoreButtonTemplateDirective;
}());

/**
 * @hidden
 *
 * An injection token used by the data binding directives to interface with
 * the TreeView or the DropDownTree components.
 */
var DataBoundComponent = /** @class */ (function () {
    function DataBoundComponent() {
    }
    DataBoundComponent = __decorate([
        Injectable()
    ], DataBoundComponent);
    return DataBoundComponent;
}());

/**
 * @hidden
 *
 * An injection token used by the expand-directive to interface with
 * the TreeView or the DropDownTree components.
 */
var ExpandableComponent = /** @class */ (function () {
    function ExpandableComponent() {
    }
    ExpandableComponent = __decorate([
        Injectable()
    ], ExpandableComponent);
    return ExpandableComponent;
}());

/**
 * @hidden
 */
var SelectionService = /** @class */ (function () {
    function SelectionService() {
        this.changes = new Subject();
    }
    SelectionService.prototype.isFirstSelected = function (index) {
        return this.firstIndex === index;
    };
    SelectionService.prototype.setFirstSelected = function (index, selected) {
        if (this.firstIndex === index && selected === false) {
            this.firstIndex = null;
        }
        else if (!this.firstIndex && selected) {
            this.firstIndex = index;
        }
    };
    SelectionService.prototype.select = function (index, dataItem) {
        this.changes.next({ dataItem: dataItem, index: index });
    };
    SelectionService = __decorate([
        Injectable()
    ], SelectionService);
    return SelectionService;
}());

var INDEX_REGEX = /\d+$/;
/**
 * @hidden
 */
var TreeViewLookupService = /** @class */ (function () {
    function TreeViewLookupService() {
        this.map = new Map();
    }
    TreeViewLookupService.prototype.reset = function () {
        this.map.clear();
    };
    TreeViewLookupService.prototype.registerItem = function (item, parent) {
        var currentLookup = {
            children: [],
            item: item,
            parent: this.item(nodeIndex(parent))
        };
        this.map.set(item.index, currentLookup);
    };
    TreeViewLookupService.prototype.registerChildren = function (index, children) {
        var item = this.item(index);
        if (!item) {
            return;
        }
        item.children = children;
    };
    TreeViewLookupService.prototype.unregisterItem = function (index, dataItem) {
        var current = this.item(index);
        if (current && current.item.dataItem === dataItem) {
            this.map.delete(index);
            if (current.parent && current.parent.children) {
                current.parent.children = current.parent.children.filter(function (item) { return item.dataItem !== dataItem; });
            }
        }
    };
    TreeViewLookupService.prototype.replaceItem = function (index, item, parent) {
        if (!item) {
            return;
        }
        this.unregisterItem(index, item.dataItem);
        this.registerItem(item, parent);
        this.addToParent(item, parent);
    };
    TreeViewLookupService.prototype.itemLookup = function (index) {
        var item = this.item(index);
        if (!item) {
            return null;
        }
        return {
            children: this.mapChildren(item.children),
            item: item.item,
            parent: item.parent
        };
    };
    TreeViewLookupService.prototype.hasItem = function (index) {
        return this.map.has(index);
    };
    TreeViewLookupService.prototype.item = function (index) {
        return this.map.get(index) || null;
    };
    TreeViewLookupService.prototype.addToParent = function (item, parent) {
        if (parent) {
            var parentItem = this.item(parent.index);
            var index = parseInt(INDEX_REGEX.exec(item.index)[0], 10);
            parentItem.children = parentItem.children || [];
            parentItem.children.splice(index, 0, item);
        }
    };
    TreeViewLookupService.prototype.mapChildren = function (children) {
        var _this = this;
        if (children === void 0) { children = []; }
        return children.map(function (c) {
            var _a = _this.item(c.index), item = _a.item, parent = _a.parent, children = _a.children;
            return {
                children: _this.mapChildren(children),
                item: item,
                parent: parent
            };
        });
    };
    TreeViewLookupService = __decorate([
        Injectable()
    ], TreeViewLookupService);
    return TreeViewLookupService;
}());

var LOAD_MORE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';
var providers = [
    ExpandStateService,
    IndexBuilderService,
    TreeViewLookupService,
    LoadingNotificationService,
    NodeChildrenService,
    NavigationService,
    SelectionService,
    DataChangeNotificationService,
    LocalizationService,
    {
        provide: L10N_PREFIX,
        useValue: 'kendo.treeview'
    },
    {
        provide: DataBoundComponent,
        useExisting: forwardRef(function () { return TreeViewComponent; })
    },
    {
        provide: ExpandableComponent,
        useExisting: forwardRef(function () { return TreeViewComponent; })
    }
];
/* tslint:disable:member-ordering */
/**
 * Represents the [Kendo UI TreeView component for Angular]({% slug overview_treeview %}).
 *
 * @example
 * {% meta height:450 %}
 * {% embed_file get-started/app.component.ts preview %}
 * {% embed_file get-started/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% endmeta %}
 */
var TreeViewComponent = /** @class */ (function () {
    function TreeViewComponent(element, changeDetectorRef, expandService, navigationService, nodeChildrenService, selectionService, treeViewLookupService, ngZone, renderer, dataChangeNotification, localization) {
        var _this = this;
        this.element = element;
        this.changeDetectorRef = changeDetectorRef;
        this.expandService = expandService;
        this.navigationService = navigationService;
        this.nodeChildrenService = nodeChildrenService;
        this.selectionService = selectionService;
        this.treeViewLookupService = treeViewLookupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.dataChangeNotification = dataChangeNotification;
        this.localization = localization;
        this.classNames = true;
        this.role = 'tree';
        /**
         * The hint which is displayed when the component is empty.
         */
        this.filterInputPlaceholder = "";
        /** @hidden */
        this.fetchNodes = function () { return _this.data; };
        /**
         * Fires when the children of the expanded node are loaded.
         */
        this.childrenLoaded = new EventEmitter();
        /**
         * Fires when the user blurs the component.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires when the user focuses the component.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires when the user expands a TreeView node.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the user collapses a TreeView node.
         */
        this.collapse = new EventEmitter();
        /**
         * Fires just before the dragging of the node starts ([see example]({% slug draganddrop_treeview %}#toc-setup)). This event is preventable.
         * If you prevent the event default, no drag hint will be created and the subsequent drag-related events will not be fired.
         */
        this.nodeDragStart = new EventEmitter();
        /**
         * Fires when an item is being dragged ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         */
        this.nodeDrag = new EventEmitter();
        /**
         * Emits when the built-in filtering mechanism in the data-binding directives updates the node's visibility.
         * Used for the built-in auto-expand functionalities of the component and available for custom implementations.
         */
        this.filterStateChange = new EventEmitter();
        /**
         * Fires on the target TreeView when a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * This event is preventable. If you prevent the event default (`event.preventDefualt()`) or invalidate its state (`event.setValid(false)`),
         * the `addItem` and `removeItem` events will not be triggered.
         *
         * Both operations cancel the default drop operation, but the indication to the user is different. `event.setValid(false)` indicates that the operation was
         * unsuccessful by animating the drag clue to its original position. `event.preventDefault()` simply removes the clue, as if it has been dropped successfully.
         * As a general rule, use `preventDefault` to manually handle the add and remove operations, and `setValid(false)` to indicate the operation was unsuccessful.
         */
        this.nodeDrop = new EventEmitter();
        /**
         * Fires on the source TreeView after the dragged item has been dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         */
        this.nodeDragEnd = new EventEmitter();
        /**
         * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * Called on the TreeView where the item is dropped.
         */
        this.addItem = new EventEmitter();
        /**
         * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * Called on the TreeView from where the item is dragged.
         */
        this.removeItem = new EventEmitter();
        /**
         * Fires when the user selects a TreeView node checkbox
         * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
         */
        this.checkedChange = new EventEmitter();
        /**
         * Fires when the user selects a TreeView node
         * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires when the value of the built-in filter input element changes.
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires when the user clicks a TreeView node.
         */
        this.nodeClick = new EventEmitter();
        /**
         * Fires when the user double clicks a TreeView node.
         */
        this.nodeDblClick = new EventEmitter();
        /**
         * A function that defines how to track node changes.
         * By default, the TreeView tracks the nodes by data item object reference.
         *
         * @example
         * ```ts
         *  @Component({
         *      selector: 'my-app',
         *      template: `
         *          <kendo-treeview
         *              [nodes]="data"
         *              textField="text"
         *              [trackBy]="trackBy"
         *          >
         *          </kendo-treeview>
         *      `
         *  })
         *  export class AppComponent {
         *      public data: any[] = [
         *          { text: "Furniture" },
         *          { text: "Decor" }
         *      ];
         *
         *      public trackBy(index: number, item: any): any {
         *          return item.text;
         *      }
         *  }
         * ```
         */
        this.trackBy = trackBy;
        /**
         * A function which determines if a specific node is disabled.
         */
        this.isDisabled = isDisabled;
        /**
         * A callback which determines whether a TreeView node should be rendered as hidden. The utility .k-display-none class is used to hide the nodes.
         * Useful for custom filtering implementations.
         */
        this.isVisible = isVisible;
        /**
         * Determines whether the TreeView keyboard navigable is enabled.
         */
        this.navigable = true;
        /**
         * A function which provides the child nodes for a given parent node
         * ([see example]({% slug databinding_treeview %})).
         */
        this.children = function () { return of([]); };
        /**
         * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.
         * @default true
         */
        this.loadOnDemand = true;
        /**
         * Renders the built-in input element for filtering the TreeView.
         * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the TreeView manually]({% slug filtering_treeview %}#toc-manual-filtering).
         * A built-in filtering implementation is available to use with the [`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %}) and [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %}) directives.
         */
        this.filterable = false;
        /**
         * Sets an initial value of the built-in input element used for filtering.
         */
        this.filter = '';
        this.checkboxes = false;
        this.expandIcons = false;
        this.selectable = false;
        this.touchActions = true;
        this.isActive = false;
        this.data = new BehaviorSubject([]);
        this._animate = true;
        this._size = 'medium';
        this.subscriptions = new Subscription();
        this.domSubscriptions = [];
        validatePackage(packageMetadata);
    }
    Object.defineProperty(TreeViewComponent.prototype, "direction", {
        /** @hidden */
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "animate", {
        get: function () {
            return !this._animate;
        },
        /**
         * Determines whether the content animation is enabled.
         */
        set: function (value) {
            this._animate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "nodeTemplateRef", {
        get: function () {
            return this._nodeTemplateRef || this.nodeTemplateQuery;
        },
        /**
         * @hidden
         *
         * Defines the template for each node.
         * Takes precedence over nested templates in the TreeView tag.
         */
        set: function (template) {
            this._nodeTemplateRef = template;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "loadMoreButtonTemplateRef", {
        get: function () {
            return this._loadMoreButtonTemplateRef || this.loadMoreButtonTemplateQuery;
        },
        /**
         * @hidden
         *
         * Defines the template for each load-more button.
         * Takes precedence over nested templates in the TreeView tag.
         */
        set: function (template) {
            this._loadMoreButtonTemplateRef = template;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "nodes", {
        get: function () {
            return this.data.value;
        },
        /**
         * The nodes which will be displayed by the TreeView
         * ([see example]({% slug databinding_treeview %})).
         */
        set: function (value) {
            this.data.next(value || []);
            this.dataChangeNotification.notify();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "hasChildren", {
        /**
         * A function which determines if a specific node has child nodes
         * ([see example]({% slug databinding_treeview %})).
         */
        get: function () {
            return this._hasChildren || hasChildren;
        },
        set: function (callback) {
            this._hasChildren = callback;
            this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "isChecked", {
        /**
         * A function which determines if a specific node is checked
         * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
         */
        get: function () {
            return this._isChecked || isChecked;
        },
        set: function (callback) {
            this._isChecked = callback;
            this.checkboxes = Boolean(this._isChecked);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "isExpanded", {
        /**
         * A function which determines if a specific node is expanded.
         */
        get: function () {
            return this._isExpanded || isExpanded;
        },
        set: function (callback) {
            this._isExpanded = callback;
            this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "isSelected", {
        /**
         * A function which determines if a specific node is selected
         * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
         */
        get: function () {
            return this._isSelected || isSelected;
        },
        set: function (callback) {
            this._isSelected = callback;
            this.selectable = Boolean(this._isSelected);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "size", {
        get: function () {
            return this._size;
        },
        /**
         * Sets the size of the component.
         *
         * The possible values are:
         * * `'small'`
         * * `'medium'` (default)
         * * `'large'`
         * * `null`
         *
         */
        set: function (size) {
            this.renderer.removeClass(this.element.nativeElement, getSizeClass('treeview', this.size));
            if (size) {
                this.renderer.addClass(this.element.nativeElement, getSizeClass('treeview', size));
            }
            this._size = size;
        },
        enumerable: true,
        configurable: true
    });
    TreeViewComponent.prototype.ngOnChanges = function (changes) {
        this.navigationService.navigable = Boolean(this.navigable);
        // TODO: should react to changes.loadOnDemand as well - should preload the data or clear the already cached items
        if (anyChanged(['nodes', 'children', 'hasChildren', 'loadOnDemand'], changes, false) && !this.loadOnDemand) {
            this.preloadChildNodes();
        }
    };
    TreeViewComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        this.domSubscriptions.forEach(function (subscription) { return subscription(); });
    };
    TreeViewComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscriptions.add(this.nodeChildrenService
            .changes
            .subscribe(function (x) { return _this.childrenLoaded.emit(x); }));
        this.subscriptions.add(this.expandService.changes
            .subscribe(function (_a) {
            var index = _a.index, dataItem = _a.dataItem, expand = _a.expand;
            return expand
                ? _this.expand.emit({ index: index, dataItem: dataItem })
                : _this.collapse.emit({ index: index, dataItem: dataItem });
        }));
        this.subscriptions.add(this.navigationService.checks
            .subscribe(function (x) {
            return _this.checkedChange.emit(_this.treeViewLookupService.itemLookup(x));
        }));
        this.subscriptions.add(this.selectionService.changes
            .subscribe(function (x) {
            if (hasObservers(_this.selectionChange)) {
                _this.ngZone.run(function () {
                    _this.selectionChange.emit(x);
                });
            }
        }));
        if (this.element) {
            this.ngZone.runOutsideAngular(function () {
                _this.attachDomHandlers();
            });
        }
        if (this.size) {
            this.renderer.addClass(this.element.nativeElement, getSizeClass('treeview', this.size));
        }
    };
    /**
     * Blurs the focused TreeView item.
     */
    TreeViewComponent.prototype.blur = function () {
        if (!isDocumentAvailable()) {
            return;
        }
        var target = focusableNode(this.element);
        if (document.activeElement === target) {
            target.blur();
        }
    };
    /**
     * Focuses the first focusable item in the TreeView component if no hierarchical index is provided.
     *
     * @example
     * ```ts
     * import { Component } from '@angular/core';
     *
     *  @Component({
     *      selector: 'my-app',
     *      template: `
     *      <button (click)="treeview.focus('1')">Focuses the second node</button>
     *      <kendo-treeview
     *          #treeview
     *          [nodes]="data"
     *          textField="text"
     *      >
     *      </kendo-treeview>
     *  `
     *  })
     *  export class AppComponent {
     *      public data: any[] = [
     *          { text: "Furniture" },
     *          { text: "Decor" }
     *      ];
     *  }
     * ```
     */
    TreeViewComponent.prototype.focus = function (index) {
        var focusIndex = index || nodeIndex(this.navigationService.focusableItem);
        this.navigationService.activateIndex(focusIndex);
        var target = focusableNode(this.element);
        if (target) {
            target.focus();
        }
    };
    /**
     * Based on the specified index, returns the TreeItemLookup node.
     *
     * @param index - The index of the node.
     * @returns {TreeItemLookup} - The item that was searched (looked up).
     */
    TreeViewComponent.prototype.itemLookup = function (index) {
        return this.treeViewLookupService.itemLookup(index);
    };
    /**
     * Triggers the [`children`]({% slug api_treeview_treeviewcomponent %}#toc-children) function for every expanded node,
     * causing all rendered child nodes to be fetched again.
     */
    TreeViewComponent.prototype.rebindChildren = function () {
        this.dataChangeNotification.notify();
    };
    /**
     * Triggers the `expand` event for the provided node and displays it's loading indicator.
     */
    TreeViewComponent.prototype.expandNode = function (item, index) {
        this.expandService.expand(index, item);
    };
    /**
     * Triggers the `collapse` event for the provided node.
     */
    TreeViewComponent.prototype.collapseNode = function (item, index) {
        this.expandService.collapse(index, item);
    };
    /**
     * Gets the current page size of the checked data item children collection
     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).
     *
     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to get its page size.
     *
     * @param dataItem {any} - The parent data item of the targeted collection.
     * @returns {number} - The page size of the checked data item children collection.
     */
    TreeViewComponent.prototype.getNodePageSize = function (dataItem) {
        this.verifyLoadMoreService();
        return this.loadMoreService.getGroupSize(dataItem);
    };
    /**
     * Sets the page size of the targeted data item children collection
     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).
     *
     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to target its page size.
     *
     * @param dataItem {any} - The parent data item of the targeted collection.
     * @param pageSize {number} - The new page size.
     */
    TreeViewComponent.prototype.setNodePageSize = function (dataItem, pageSize) {
        this.verifyLoadMoreService();
        this.loadMoreService.setGroupSize(dataItem, pageSize);
    };
    /**
     * @hidden
     *
     * Clears the current TreeViewLookupService node map and re-registers all nodes anew.
     * Child nodes are acquired through the provided `children` callback.
     */
    TreeViewComponent.prototype.preloadChildNodes = function () {
        this.treeViewLookupService.reset();
        this.registerLookupItems(this.nodes);
    };
    TreeViewComponent.prototype.attachDomHandlers = function () {
        var element = this.element.nativeElement;
        this.clickHandler = this.clickHandler.bind(this);
        this.domSubscriptions.push(this.renderer.listen(element, 'contextmenu', this.clickHandler), this.renderer.listen(element, 'click', this.clickHandler), this.renderer.listen(element, 'dblclick', this.clickHandler), this.renderer.listen(element, 'focusin', this.focusHandler.bind(this)), this.renderer.listen(element, 'focusout', this.blurHandler.bind(this)), this.renderer.listen(element, 'keydown', this.keydownHandler.bind(this)));
    };
    TreeViewComponent.prototype.focusHandler = function (e) {
        var _this = this;
        var focusItem;
        if (match(e.target, '.k-treeview-item')) {
            focusItem = e.target;
        }
        else if (!isFocusable(e.target)) { // with compliments to IE
            focusItem = closestNode(e.target);
        }
        if (focusItem) {
            this.navigationService.activateIndex(nodeId(e.target));
            if (!this.isActive && hasObservers(this.onFocus)) {
                this.ngZone.run(function () {
                    _this.onFocus.emit();
                });
            }
            this.isActive = true;
        }
    };
    TreeViewComponent.prototype.blurHandler = function (e) {
        var _this = this;
        if (this.isActive && match(e.target, '.k-treeview-item') &&
            (!e.relatedTarget || !match(e.relatedTarget, '.k-treeview-item') || !hasParent(e.relatedTarget, this.element.nativeElement))) {
            this.navigationService.deactivate();
            this.isActive = false;
            if (hasObservers(this.onBlur)) {
                this.ngZone.run(function () {
                    _this.onBlur.emit();
                });
            }
        }
    };
    TreeViewComponent.prototype.clickHandler = function (e) {
        var _this = this;
        var target = e.target;
        if ((e.type === 'contextmenu' && !hasObservers(this.nodeClick)) ||
            (e.type === 'click' && !hasObservers(this.nodeClick) && !hasObservers(this.selectionChange) && !isLoadMoreButton(target)) ||
            (e.type === 'dblclick' && !hasObservers(this.nodeDblClick)) || isFocusable(target) ||
            (!isContent(target) && !isLoadMoreButton(target)) || !hasParent(target, this.element.nativeElement)) {
            return;
        }
        var index = nodeId(closestNode(target));
        // the disabled check is probably not needed due to the k-disabled styles
        if (!index || this.navigationService.isDisabled(index)) {
            return;
        }
        this.ngZone.run(function () {
            // record this value before emitting selectionChange (`this.navigationService.selectIndex`), as the treeview state may be changed on its emission
            var lookup = _this.treeViewLookupService.itemLookup(index);
            if (e.type === 'click') {
                var loadMoreButton = _this.navigationService.model.findNode(index).loadMoreButton;
                if (loadMoreButton) {
                    _this.navigationService.notifyLoadMore(index);
                    return;
                }
                else {
                    _this.navigationService.selectIndex(index);
                }
            }
            var emitter = e.type === 'dblclick' ? _this.nodeDblClick : _this.nodeClick;
            emitter.emit({
                item: lookup.item,
                originalEvent: e,
                type: e.type
            });
        });
    };
    TreeViewComponent.prototype.keydownHandler = function (e) {
        var _this = this;
        if (this.isActive && this.navigable) {
            this.ngZone.run(function () {
                _this.navigationService.move(e);
            });
        }
    };
    TreeViewComponent.prototype.verifyLoadMoreService = function () {
        if (isDevMode() && !isPresent(this.loadMoreService)) {
            throw new Error("To use the TreeView paging functionality, you need to assign the `kendoTreeViewLoadMore` directive. See " + LOAD_MORE_DOC_LINK + ".");
        }
    };
    TreeViewComponent.prototype.registerLookupItems = function (data, parentItem) {
        var _this = this;
        if (parentItem === void 0) { parentItem = null; }
        if (!isPresent(data) || data.length === 0) {
            return;
        }
        var parentIndex = nodeIndex(parentItem);
        var treeItems = data.map(function (node, index) {
            return buildTreeItem(node, index, parentIndex);
        });
        if (isPresent(parentItem)) {
            this.treeViewLookupService.registerChildren(parentIndex, treeItems);
        }
        treeItems.forEach(function (item) {
            _this.treeViewLookupService.registerItem(item, parentItem);
            if (_this.hasChildren(item.dataItem)) {
                _this.children(item.dataItem)
                    .subscribe(function (children) {
                    return _this.registerLookupItems(children, item);
                });
            }
        });
    };
    __decorate([
        HostBinding("class.k-treeview"),
        __metadata("design:type", Boolean)
    ], TreeViewComponent.prototype, "classNames", void 0);
    __decorate([
        HostBinding("attr.role"),
        __metadata("design:type", String)
    ], TreeViewComponent.prototype, "role", void 0);
    __decorate([
        HostBinding("attr.dir"),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TreeViewComponent.prototype, "direction", null);
    __decorate([
        ViewChild('assetsContainer', { read: ViewContainerRef, static: true }),
        __metadata("design:type", ViewContainerRef)
    ], TreeViewComponent.prototype, "assetsContainer", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TreeViewComponent.prototype, "filterInputPlaceholder", void 0);
    __decorate([
        Input(),
        HostBinding('@.disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], TreeViewComponent.prototype, "animate", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "childrenLoaded", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "onBlur", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "onFocus", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "expand", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "collapse", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "nodeDragStart", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "nodeDrag", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "filterStateChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "nodeDrop", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "nodeDragEnd", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "addItem", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "removeItem", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "checkedChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "selectionChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "filterChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "nodeClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TreeViewComponent.prototype, "nodeDblClick", void 0);
    __decorate([
        ContentChild(NodeTemplateDirective, { static: false }),
        __metadata("design:type", NodeTemplateDirective)
    ], TreeViewComponent.prototype, "nodeTemplateQuery", void 0);
    __decorate([
        Input('nodeTemplate'),
        __metadata("design:type", NodeTemplateDirective),
        __metadata("design:paramtypes", [NodeTemplateDirective])
    ], TreeViewComponent.prototype, "nodeTemplateRef", null);
    __decorate([
        ContentChild(LoadMoreButtonTemplateDirective, { static: false }),
        __metadata("design:type", LoadMoreButtonTemplateDirective)
    ], TreeViewComponent.prototype, "loadMoreButtonTemplateQuery", void 0);
    __decorate([
        Input('loadMoreButtonTemplate'),
        __metadata("design:type", LoadMoreButtonTemplateDirective),
        __metadata("design:paramtypes", [LoadMoreButtonTemplateDirective])
    ], TreeViewComponent.prototype, "loadMoreButtonTemplateRef", null);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewComponent.prototype, "trackBy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], TreeViewComponent.prototype, "nodes", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeViewComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], TreeViewComponent.prototype, "hasChildren", null);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], TreeViewComponent.prototype, "isChecked", null);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewComponent.prototype, "isDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], TreeViewComponent.prototype, "isExpanded", null);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], TreeViewComponent.prototype, "isSelected", null);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewComponent.prototype, "isVisible", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewComponent.prototype, "navigable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewComponent.prototype, "children", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewComponent.prototype, "loadOnDemand", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewComponent.prototype, "filterable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TreeViewComponent.prototype, "filter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], TreeViewComponent.prototype, "size", null);
    TreeViewComponent = __decorate([
        Component({
            changeDetection: ChangeDetectionStrategy.Default,
            exportAs: 'kendoTreeView',
            providers: providers,
            selector: 'kendo-treeview',
            template: "\n        <span\n            class=\"k-treeview-filter\"\n            *ngIf=\"filterable\"\n        >\n            <kendo-textbox\n                [size]=\"size\"\n                [value]=\"filter\"\n                [clearButton]=\"true\"\n                (valueChange)=\"filterChange.emit($event)\"\n                [placeholder]=\"filterInputPlaceholder\"\n            >\n                <ng-template kendoTextBoxPrefixTemplate>\n                    <span class=\"k-input-icon k-icon k-i-search\"></span>\n                </ng-template>\n            </kendo-textbox>\n        </span>\n        <ul class=\"k-treeview-lines\"\n            kendoTreeViewGroup\n            role=\"group\"\n            [size]=\"size\"\n            [loadOnDemand]=\"loadOnDemand\"\n            [checkboxes]=\"checkboxes\"\n            [expandIcons]=\"expandIcons\"\n            [selectable]=\"selectable\"\n            [touchActions]=\"touchActions\"\n            [children]=\"children\"\n            [hasChildren]=\"hasChildren\"\n            [isChecked]=\"isChecked\"\n            [isDisabled]=\"isDisabled\"\n            [isExpanded]=\"isExpanded\"\n            [isSelected]=\"isSelected\"\n            [isVisible]=\"isVisible\"\n            [nodeTemplateRef]=\"nodeTemplateRef?.templateRef\"\n            [loadMoreButtonTemplateRef]=\"loadMoreButtonTemplateRef?.templateRef\"\n            [textField]=\"textField\"\n            [nodes]=\"fetchNodes\"\n            [loadMoreService]=\"loadMoreService\"\n            [trackBy]=\"trackBy\"\n        >\n        </ul>\n        <ng-container #assetsContainer></ng-container>\n    "
        }),
        __metadata("design:paramtypes", [ElementRef,
            ChangeDetectorRef,
            ExpandStateService,
            NavigationService,
            NodeChildrenService,
            SelectionService,
            TreeViewLookupService,
            NgZone,
            Renderer2,
            DataChangeNotificationService,
            LocalizationService])
    ], TreeViewComponent);
    return TreeViewComponent;
}());

/**
 * @hidden
 */
var TreeViewGroupComponent = /** @class */ (function () {
    function TreeViewGroupComponent(expandService, loadingService, indexBuilder, treeViewLookupService, navigationService, nodeChildrenService, dataChangeNotification, changeDetectorRef) {
        this.expandService = expandService;
        this.loadingService = loadingService;
        this.indexBuilder = indexBuilder;
        this.treeViewLookupService = treeViewLookupService;
        this.navigationService = navigationService;
        this.nodeChildrenService = nodeChildrenService;
        this.dataChangeNotification = dataChangeNotification;
        this.changeDetectorRef = changeDetectorRef;
        this.kGroupClass = true;
        this.role = 'group';
        this.loadOnDemand = true;
        this.textField = "";
        this.size = 'medium';
        this.initialNodesLoaded = false;
        this.loadingMoreNodes = false;
        this._data = [];
        this.singleRecordSubscriptions = new Subscription();
        this.isChecked = function () { return 'none'; };
        this.isDisabled = function () { return false; };
        this.isExpanded = function () { return false; };
        this.isVisible = function () { return true; };
        this.isSelected = function () { return false; };
        this.children = function () { return of([]); };
        this.hasChildren = function () { return false; };
    }
    Object.defineProperty(TreeViewGroupComponent.prototype, "moreNodesAvailable", {
        get: function () {
            if (!isPresent(this.loadMoreService) || this.data.length === 0) {
                return false;
            }
            return this.pageSize < this.totalNodesCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "pageSize", {
        get: function () {
            if (!isPresent(this.loadMoreService)) {
                return null;
            }
            return this.loadMoreService.getGroupSize(this.parentDataItem);
        },
        set: function (pageSize) {
            this.loadMoreService.setGroupSize(this.parentDataItem, pageSize);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "data", {
        get: function () {
            if (isPresent(this.pageSize)) {
                var normalizedSizeValue = this.pageSize > 0 ? this.pageSize : 0;
                return this._data.slice(0, normalizedSizeValue);
            }
            return this._data;
        },
        set: function (data) {
            this._data = data;
            this.registerLoadedNodes(this.data);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "loadMoreButtonIndex", {
        get: function () {
            if (!this.loadMoreService) {
                return null;
            }
            return this.nodeIndex(this.data.length);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "totalNodesCount", {
        /**
         * Represents the total number of nodes for the current level.
         */
        get: function () {
            if (!this.loadMoreService) {
                return this.data.length;
            }
            return this.loadMoreService.getTotalNodesCount(this.parentDataItem, this._data.length);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "hasTemplate", {
        get: function () {
            return isPresent(this.nodeTemplateRef);
        },
        enumerable: true,
        configurable: true
    });
    TreeViewGroupComponent.prototype.expandNode = function (index, dataItem, expand) {
        if (expand) {
            this.expandService.expand(index, dataItem);
        }
        else {
            this.expandService.collapse(index, dataItem);
        }
    };
    TreeViewGroupComponent.prototype.checkNode = function (index) {
        this.navigationService.checkIndex(index);
        this.navigationService.activateIndex(index);
    };
    TreeViewGroupComponent.prototype.nodeIndex = function (index) {
        return this.indexBuilder.nodeIndex(index.toString(), this.parentIndex);
    };
    TreeViewGroupComponent.prototype.nodeText = function (dataItem) {
        var textField = isArray(this.textField) ? this.textField[0] : this.textField;
        return getter(textField)(dataItem);
    };
    TreeViewGroupComponent.prototype.ngOnDestroy = function () {
        if (isPresent(this.nodesSubscription)) {
            this.nodesSubscription.unsubscribe();
        }
        if (isPresent(this.loadMoreNodesSubscription)) {
            this.loadMoreNodesSubscription.unsubscribe();
        }
        this.singleRecordSubscriptions.unsubscribe();
    };
    TreeViewGroupComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscribeToNodesChange();
        this.singleRecordSubscriptions.add(this.dataChangeNotification
            .changes
            .subscribe(this.subscribeToNodesChange.bind(this)));
        this.singleRecordSubscriptions.add(this.navigationService.loadMore
            .pipe(filter(function (index) { return index === _this.loadMoreButtonIndex; }))
            .subscribe(this.loadMoreNodes.bind(this)));
    };
    TreeViewGroupComponent.prototype.ngOnChanges = function (changes) {
        if (changes.parentIndex && this.loadOnDemand) {
            this.setNodeChildren(this.mapToTreeItem(this.data));
        }
    };
    TreeViewGroupComponent.prototype.fetchChildren = function (node, index) {
        var _this = this;
        return this.children(node)
            .pipe(catchError(function () {
            _this.loadingService.notifyLoaded(index);
            return EMPTY;
        }), tap(function () { return _this.loadingService.notifyLoaded(index); }));
    };
    Object.defineProperty(TreeViewGroupComponent.prototype, "nextFields", {
        get: function () {
            if (isArray(this.textField)) {
                return this.textField.length > 1 ? this.textField.slice(1) : this.textField;
            }
            return [this.textField];
        },
        enumerable: true,
        configurable: true
    });
    TreeViewGroupComponent.prototype.loadMoreNodes = function () {
        if (isPresent(this.loadMoreService.loadMoreNodes)) {
            this.fetchMoreNodes();
        }
        else {
            this.loadMoreLocalNodes();
        }
    };
    TreeViewGroupComponent.prototype.loadMoreLocalNodes = function () {
        var initialLoadMoreButtonIndex = this.loadMoreButtonIndex;
        this.pageSize += this.loadMoreService.getInitialPageSize(this.parentDataItem);
        this.registerLoadedNodes(this.data);
        // forces the new items to be registered before the focus is changed
        this.changeDetectorRef.detectChanges();
        this.reselectItemAt(initialLoadMoreButtonIndex);
    };
    TreeViewGroupComponent.prototype.fetchMoreNodes = function () {
        var _this = this;
        if (this.loadingMoreNodes) {
            return;
        }
        this.loadingMoreNodes = true;
        if (isPresent(this.loadMoreNodesSubscription)) {
            this.loadMoreNodesSubscription.unsubscribe();
        }
        this.loadMoreNodesSubscription = this.loadMoreService
            .loadMoreNodes({
            dataItem: this.parentDataItem,
            skip: this.data.length,
            take: this.loadMoreService.getInitialPageSize(this.parentDataItem)
        })
            .pipe(finalize(function () { return _this.loadingMoreNodes = false; }))
            .subscribe(function (items) {
            if (!(Array.isArray(items) && items.length > 0)) {
                return;
            }
            var initialLoadMoreButtonIndex = _this.loadMoreButtonIndex;
            _this.pageSize += items.length;
            _this.data = _this.data.concat(items);
            if (_this.navigationService.isActive(initialLoadMoreButtonIndex)) {
                // forces the new items to be registered before the focus is changed
                _this.changeDetectorRef.detectChanges();
                _this.reselectItemAt(initialLoadMoreButtonIndex);
            }
        });
    };
    TreeViewGroupComponent.prototype.setNodeChildren = function (children) {
        this.treeViewLookupService.registerChildren(this.parentIndex, children);
    };
    TreeViewGroupComponent.prototype.mapToTreeItem = function (data) {
        var _this = this;
        if (!this.parentIndex) {
            return [];
        }
        return data.map(function (dataItem, idx) { return ({ dataItem: dataItem, index: _this.nodeIndex(idx) }); });
    };
    TreeViewGroupComponent.prototype.emitChildrenLoaded = function (children) {
        if (!this.parentIndex) {
            return;
        }
        // ignores the registered load-more button
        var contentChildren = children.filter(function (item) { return item.dataItem; });
        this.nodeChildrenService.childrenLoaded({ dataItem: this.parentDataItem, index: this.parentIndex }, contentChildren);
    };
    TreeViewGroupComponent.prototype.subscribeToNodesChange = function () {
        var _this = this;
        if (this.nodesSubscription) {
            this.nodesSubscription.unsubscribe();
        }
        this.nodesSubscription = this.nodes(this.parentDataItem, this.parentIndex)
            .subscribe(function (data) {
            _this.data = data;
            _this.initialNodesLoaded = true;
        });
    };
    TreeViewGroupComponent.prototype.reselectItemAt = function (index) {
        if (!isPresent(index)) {
            return;
        }
        // make sure the old index is cleared first
        this.navigationService.deactivate();
        this.navigationService.activateIndex(index);
    };
    TreeViewGroupComponent.prototype.registerLoadedNodes = function (nodes) {
        if (nodes === void 0) { nodes = []; }
        var mappedChildren = this.mapToTreeItem(nodes);
        if (this.loadOnDemand) {
            this.setNodeChildren(mappedChildren);
        }
        this.emitChildrenLoaded(mappedChildren);
    };
    __decorate([
        HostBinding("class.k-treeview-group"),
        __metadata("design:type", Boolean)
    ], TreeViewGroupComponent.prototype, "kGroupClass", void 0);
    __decorate([
        HostBinding("attr.role"),
        __metadata("design:type", String)
    ], TreeViewGroupComponent.prototype, "role", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewGroupComponent.prototype, "checkboxes", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewGroupComponent.prototype, "expandIcons", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewGroupComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewGroupComponent.prototype, "selectable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewGroupComponent.prototype, "touchActions", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewGroupComponent.prototype, "loadOnDemand", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewGroupComponent.prototype, "trackBy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewGroupComponent.prototype, "nodes", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeViewGroupComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeViewGroupComponent.prototype, "parentDataItem", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TreeViewGroupComponent.prototype, "parentIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], TreeViewGroupComponent.prototype, "nodeTemplateRef", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], TreeViewGroupComponent.prototype, "loadMoreButtonTemplateRef", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeViewGroupComponent.prototype, "loadMoreService", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TreeViewGroupComponent.prototype, "size", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewGroupComponent.prototype, "isChecked", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewGroupComponent.prototype, "isDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewGroupComponent.prototype, "isExpanded", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewGroupComponent.prototype, "isVisible", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewGroupComponent.prototype, "isSelected", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewGroupComponent.prototype, "children", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewGroupComponent.prototype, "hasChildren", void 0);
    TreeViewGroupComponent = __decorate([
        Component({
            animations: [
                trigger('toggle', [
                    transition('void => *', [
                        style({ height: 0 }),
                        animate('0.1s ease-in', style({ height: "*" }))
                    ]),
                    transition('* => void', [
                        style({ height: "*" }),
                        animate('0.1s ease-in', style({ height: 0 }))
                    ])
                ])
            ],
            selector: '[kendoTreeViewGroup]',
            template: "\n        <li\n            *ngFor=\"let node of data; let index = index; trackBy: trackBy\"\n            class=\"k-treeview-item\"\n            [class.k-display-none]=\"!isVisible(node, nodeIndex(index))\"\n            kendoTreeViewItem\n            [attr.aria-setsize]=\"totalNodesCount\"\n            [dataItem]=\"node\"\n            [index]=\"nodeIndex(index)\"\n            [parentDataItem]=\"parentDataItem\"\n            [parentIndex]=\"parentIndex\"\n            [loadOnDemand]=\"loadOnDemand\"\n            [checkable]=\"checkboxes\"\n            [isChecked]=\"isChecked(node, nodeIndex(index))\"\n            [isDisabled]=\"disabled || isDisabled(node, nodeIndex(index))\"\n            [isVisible]=\"isVisible(node, nodeIndex(index))\"\n            [expandable]=\"expandIcons && hasChildren(node)\"\n            [isExpanded]=\"isExpanded(node, nodeIndex(index))\"\n            [selectable]=\"selectable\"\n            [isSelected]=\"isSelected(node, nodeIndex(index))\"\n            [attr.data-treeindex]=\"nodeIndex(index)\"\n        >\n            <div class=\"k-treeview-mid\">\n                <span\n                    class=\"k-treeview-toggle\"\n                    [kendoTreeViewLoading]=\"nodeIndex(index)\"\n                    (click)=\"expandNode(nodeIndex(index), node, !isExpanded(node, nodeIndex(index)))\"\n                    *ngIf=\"expandIcons && hasChildren(node)\"\n                >\n                    <span\n                        class=\"k-icon\"\n                        [class.k-i-collapse]=\"isExpanded(node, nodeIndex(index))\"\n                        [class.k-i-expand]=\"!isExpanded(node, nodeIndex(index))\"\n                    >\n                    </span>\n                </span>\n                <kendo-checkbox\n                    *ngIf=\"checkboxes\"\n                    [size]=\"size\"\n                    [node]=\"node\"\n                    [index]=\"nodeIndex(index)\"\n                    [isChecked]=\"isChecked\"\n                    (checkStateChange)=\"checkNode(nodeIndex(index))\"\n                    tabindex=\"-1\"\n                ></kendo-checkbox>\n                <span kendoTreeViewItemContent\n                    [attr.data-treeindex]=\"nodeIndex(index)\"\n                    [dataItem]=\"node\"\n                    [index]=\"nodeIndex(index)\"\n                    [initialSelection]=\"isSelected(node, nodeIndex(index))\"\n                    [isSelected]=\"isSelected\"\n                    class=\"k-treeview-leaf\"\n                    [style.touch-action]=\"touchActions ? '' : 'none'\"\n                >\n                    <span class=\"k-treeview-leaf-text\">\n                        <ng-container [ngSwitch]=\"hasTemplate\">\n                            <ng-container *ngSwitchCase=\"true\">\n                                <ng-template\n                                    [ngTemplateOutlet]=\"nodeTemplateRef\"\n                                    [ngTemplateOutletContext]=\"{\n                                        $implicit: node,\n                                        index: nodeIndex(index)\n                                    }\"\n                                >\n                                </ng-template>\n                            </ng-container>\n                            <ng-container *ngSwitchDefault>\n                                {{nodeText(node)}}\n                            </ng-container>\n                        </ng-container>\n                    </span>\n                </span>\n            </div>\n            <ul\n                *ngIf=\"isExpanded(node, nodeIndex(index)) && hasChildren(node)\"\n                kendoTreeViewGroup\n                role=\"group\"\n                [nodes]=\"fetchChildren\"\n                [loadOnDemand]=\"loadOnDemand\"\n                [checkboxes]=\"checkboxes\"\n                [expandIcons]=\"expandIcons\"\n                [selectable]=\"selectable\"\n                [touchActions]=\"touchActions\"\n                [children]=\"children\"\n                [hasChildren]=\"hasChildren\"\n                [isChecked]=\"isChecked\"\n                [isDisabled]=\"isDisabled\"\n                [disabled]=\"disabled || isDisabled(node, nodeIndex(index))\"\n                [isExpanded]=\"isExpanded\"\n                [isSelected]=\"isSelected\"\n                [isVisible]=\"isVisible\"\n                [nodeTemplateRef]=\"nodeTemplateRef\"\n                [loadMoreButtonTemplateRef]=\"loadMoreButtonTemplateRef\"\n                [parentIndex]=\"nodeIndex(index)\"\n                [parentDataItem]=\"node\"\n                [textField]=\"nextFields\"\n                [loadMoreService]=\"loadMoreService\"\n                [@toggle]=\"true\"\n                [trackBy]=\"trackBy\"\n            >\n            </ul>\n        </li>\n        <li\n            *ngIf=\"initialNodesLoaded && moreNodesAvailable\"\n            class=\"k-treeview-item\"\n            [class.k-treeview-load-more-checkboxes-container]=\"checkboxes\"\n            kendoTreeViewItem\n            role=\"button\"\n            [selectable]=\"false\"\n            [checkable]=\"false\"\n            [expandable]=\"false\"\n            [index]=\"loadMoreButtonIndex\"\n            [parentDataItem]=\"parentDataItem\"\n            [parentIndex]=\"parentIndex\"\n            [attr.data-treeindex]=\"loadMoreButtonIndex\"\n        >\n            <div class=\"k-treeview-mid\">\n                <span\n                    *ngIf=\"loadingMoreNodes\"\n                    class=\"k-icon k-i-loading k-i-expand\"\n                >\n                </span>\n                <span\n                    class=\"k-treeview-leaf k-treeview-load-more-button\"\n                    [attr.data-treeindex]=\"loadMoreButtonIndex\"\n                    kendoTreeViewItemContent\n                    [index]=\"loadMoreButtonIndex\"\n                >\n                    <span class=\"k-treeview-leaf-text\">\n                        <ng-template\n                            *ngIf=\"loadMoreButtonTemplateRef\"\n                            [ngTemplateOutlet]=\"loadMoreButtonTemplateRef\"\n                            [ngTemplateOutletContext]=\"{\n                                index: loadMoreButtonIndex\n                            }\"\n                        >\n                        </ng-template>\n                        <ng-container *ngIf=\"!loadMoreButtonTemplateRef\">\n                            Load more\n                        </ng-container>\n                    </span>\n                </span>\n            </div>\n        </li>\n    "
        }),
        __metadata("design:paramtypes", [ExpandStateService,
            LoadingNotificationService,
            IndexBuilderService,
            TreeViewLookupService,
            NavigationService,
            NodeChildrenService,
            DataChangeNotificationService,
            ChangeDetectorRef])
    ], TreeViewGroupComponent);
    return TreeViewGroupComponent;
}());

var indexChecked = function (keys, index) { return keys.filter(function (k) { return k === index; }).length > 0; };
var matchKey = function (index) { return function (k) {
    if (index === k) {
        return true;
    }
    if (!k.split) {
        return false;
    }
    return k.split('_').reduce(function (_a, part) {
        var key = _a.key, result = _a.result;
        key += part;
        if (index === key || result) {
            return { result: true };
        }
        key += "_";
        return { key: key, result: false };
    }, { key: "", result: false }).result;
}; };
/**
 * A directive which manages the in-memory checked state of the TreeView node
 * ([see example]({% slug checkboxes_treeview %})).
 */
var CheckDirective = /** @class */ (function () {
    function CheckDirective(treeView, zone) {
        var _this = this;
        this.treeView = treeView;
        this.zone = zone;
        /**
         * Fires when the `checkedKeys` collection was updated.
         */
        this.checkedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this.checkActions = {
            'multiple': function (e) { return _this.checkMultiple(e); },
            'single': function (e) { return _this.checkSingle(e); }
        };
        /**
         * Reflectes the internal `checkedKeys` state.
         */
        this.state = new Set();
        this.subscriptions.add(this.treeView.checkedChange
            .subscribe(function (e) { return _this.check(e); }));
        var expandedItems = [];
        this.subscriptions.add(this.treeView.childrenLoaded
            .pipe(filter(function () { return _this.options.checkChildren && _this.treeView.loadOnDemand; }), tap(function (item) { return expandedItems.push(item); }), switchMap(function () { return _this.zone.onStable.pipe(take(1)); }))
            .subscribe(function () { return _this.addCheckedItemsChildren(expandedItems); }));
        this.treeView.isChecked = this.isItemChecked.bind(this);
    }
    Object.defineProperty(CheckDirective.prototype, "isChecked", {
        /**
         * @hidden
         */
        set: function (value) {
            this.treeView.isChecked = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckDirective.prototype, "options", {
        get: function () {
            var defaultOptions = {
                checkChildren: true,
                checkParents: true,
                enabled: true,
                mode: "multiple"
            };
            if (!isPresent(this.checkable) || typeof this.checkable === 'string') {
                return defaultOptions;
            }
            var checkSettings = isBoolean(this.checkable)
                ? { enabled: this.checkable }
                : this.checkable;
            return Object.assign(defaultOptions, checkSettings);
        },
        enumerable: true,
        configurable: true
    });
    CheckDirective.prototype.ngOnChanges = function (changes) {
        if (changes.checkable) {
            this.treeView.checkboxes = this.options.enabled;
            this.toggleCheckOnClick();
        }
        if (isChanged('checkedKeys', changes, false) && changes.checkedKeys.currentValue !== this.lastChange) {
            this.state = new Set(changes.checkedKeys.currentValue);
        }
    };
    CheckDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        this.unsubscribeClick();
    };
    CheckDirective.prototype.isItemChecked = function (dataItem, index) {
        if (!this.checkKey) {
            return this.isIndexChecked(index);
        }
        var hasKey = this.state.has(this.itemKey({ dataItem: dataItem, index: index }));
        return hasKey ? 'checked' : 'none';
    };
    CheckDirective.prototype.isIndexChecked = function (index) {
        var checkedKeys = Array.from(this.state).filter(matchKey(index));
        if (indexChecked(checkedKeys, index)) {
            return 'checked';
        }
        var _a = this.options, mode = _a.mode, checkParents = _a.checkParents;
        if (mode === 'multiple' && checkParents && checkedKeys.length) {
            return 'indeterminate';
        }
        return 'none';
    };
    CheckDirective.prototype.itemKey = function (item) {
        if (!isPresent(this.checkKey)) {
            return item.index;
        }
        if (typeof this.checkKey === "string" && isPresent(item.dataItem)) {
            return item.dataItem[this.checkKey];
        }
        if (typeof this.checkKey === "function") {
            return this.checkKey(item);
        }
    };
    CheckDirective.prototype.check = function (e) {
        var _a = this.options, enabled = _a.enabled, mode = _a.mode;
        var performSelection = this.checkActions[mode] || noop;
        if (!enabled) {
            return;
        }
        performSelection(e);
    };
    CheckDirective.prototype.checkSingle = function (node) {
        var key = this.itemKey(node.item);
        var hasKey = this.state.has(key);
        this.state.clear();
        if (!hasKey) {
            this.state.add(key);
        }
        this.notify();
    };
    CheckDirective.prototype.checkMultiple = function (node) {
        this.checkNode(node);
        if (this.options.checkParents) {
            this.checkParents(node.parent);
        }
        this.notify();
    };
    CheckDirective.prototype.toggleCheckOnClick = function () {
        var _this = this;
        this.unsubscribeClick();
        if (this.options.checkOnClick) {
            this.clickSubscription = this.treeView.nodeClick.subscribe(function (args) {
                if (args.type === 'click') {
                    var lookup = _this.treeView.itemLookup(args.item.index);
                    _this.check(lookup);
                }
            });
        }
    };
    CheckDirective.prototype.unsubscribeClick = function () {
        if (this.clickSubscription) {
            this.clickSubscription.unsubscribe();
            this.clickSubscription = null;
        }
    };
    CheckDirective.prototype.checkNode = function (node) {
        var _this = this;
        if (!isPresent(node.item.dataItem) || this.treeView.isDisabled(node.item.dataItem, node.item.index)) {
            return;
        }
        var currentKey = this.itemKey(node.item);
        if (!isPresent(currentKey)) {
            return;
        }
        var pendingCheck = [currentKey];
        if (this.options.checkChildren) {
            var descendants = fetchLoadedDescendants(node, function (_a) {
                var item = _a.item;
                return _this.treeView.isVisible(item.dataItem, item.index) &&
                    !_this.treeView.isDisabled(item.dataItem, item.index);
            })
                .map(function (_a) {
                var item = _a.item;
                return _this.itemKey(item);
            });
            pendingCheck.push.apply(pendingCheck, descendants);
        }
        var shouldCheck = !this.state.has(currentKey);
        pendingCheck.forEach(function (key) {
            if (shouldCheck) {
                _this.state.add(key);
            }
            else {
                _this.state.delete(key);
            }
        });
    };
    CheckDirective.prototype.checkParents = function (parent) {
        var _this = this;
        if (!isPresent(parent)) {
            return;
        }
        var currentParent = parent;
        while (currentParent) {
            var parentKey = this.itemKey(currentParent.item);
            var allChildrenSelected = currentParent.children.every(function (item) { return _this.state.has(_this.itemKey(item)); });
            if (allChildrenSelected) {
                this.state.add(parentKey);
            }
            else {
                this.state.delete(parentKey);
            }
            currentParent = currentParent.parent;
        }
    };
    CheckDirective.prototype.notify = function () {
        this.lastChange = Array.from(this.state);
        this.checkedKeysChange.emit(this.lastChange);
    };
    CheckDirective.prototype.addCheckedItemsChildren = function (lookups) {
        var _this = this;
        if (!isPresent(lookups) || lookups.length === 0) {
            return;
        }
        var initiallyCheckedItemsCount = this.state.size;
        lookups.forEach(function (lookup) {
            var itemKey = _this.itemKey(lookup.item);
            if (!_this.state.has(itemKey)) {
                return;
            }
            lookup.children.forEach(function (item) {
                // ensure both the parent item and each child node is enabled
                if (!_this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index) &&
                    !_this.treeView.isDisabled(item.dataItem, item.index)) {
                    _this.state.add(_this.itemKey(item));
                }
            });
        });
        var hasNewlyCheckedItems = initiallyCheckedItemsCount !== this.state.size;
        if (hasNewlyCheckedItems) {
            this.zone.run(function () { return _this.notify(); });
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], CheckDirective.prototype, "isChecked", null);
    __decorate([
        Input("checkBy"),
        __metadata("design:type", Object)
    ], CheckDirective.prototype, "checkKey", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CheckDirective.prototype, "checkedKeys", void 0);
    __decorate([
        Input('kendoTreeViewCheckable'),
        __metadata("design:type", Object)
    ], CheckDirective.prototype, "checkable", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], CheckDirective.prototype, "checkedKeysChange", void 0);
    CheckDirective = __decorate([
        Directive({ selector: '[kendoTreeViewCheckable]' }),
        __metadata("design:paramtypes", [TreeViewComponent,
            NgZone])
    ], CheckDirective);
    return CheckDirective;
}());

/**
 * A directive which manages the disabled in-memory state of the TreeView node
 * ([see example]({% slug disabledstate_treeview %})).
 */
var DisableDirective = /** @class */ (function () {
    function DisableDirective(treeView, cdr) {
        var _this = this;
        this.treeView = treeView;
        this.cdr = cdr;
        /**
         * Defines the collection that will store the disabled keys.
         */
        this.disabledKeys = [];
        this.treeView.isDisabled = function (dataItem, index) { return (_this.disabledKeys.indexOf(_this.itemKey({ dataItem: dataItem, index: index })) > -1); };
    }
    Object.defineProperty(DisableDirective.prototype, "isDisabled", {
        /**
         * @hidden
         */
        set: function (value) {
            this.treeView.isDisabled = value;
        },
        enumerable: true,
        configurable: true
    });
    DisableDirective.prototype.ngOnChanges = function (changes) {
        if (changes === void 0) { changes = {}; }
        var disabledKeys = changes.disabledKeys;
        if (disabledKeys && !disabledKeys.firstChange) {
            this.cdr.markForCheck();
        }
    };
    DisableDirective.prototype.itemKey = function (e) {
        if (!this.disableKey) {
            return e.index;
        }
        if (typeof this.disableKey === "string") {
            return e.dataItem[this.disableKey];
        }
        if (typeof this.disableKey === "function") {
            return this.disableKey(e);
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], DisableDirective.prototype, "isDisabled", null);
    __decorate([
        Input("kendoTreeViewDisable"),
        __metadata("design:type", Object)
    ], DisableDirective.prototype, "disableKey", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], DisableDirective.prototype, "disabledKeys", void 0);
    DisableDirective = __decorate([
        Directive({ selector: '[kendoTreeViewDisable]' }),
        __metadata("design:paramtypes", [TreeViewComponent,
            ChangeDetectorRef])
    ], DisableDirective);
    return DisableDirective;
}());

var DEFAULT_FILTER_EXPAND_SETTINGS = {
    maxAutoExpandResults: -1,
    expandMatches: false,
    expandedOnClear: "none"
};
/**
 * A directive which manages the expanded state of the TreeView.
 * ([see example]({% slug expandedstate_treeview %})).
 */
var ExpandDirective = /** @class */ (function () {
    function ExpandDirective(component) {
        var _this = this;
        this.component = component;
        /**
         * Whether or not to auto-expand the nodes leading from the root node to each filter result.
         * To fine-tune this behavior, pass a [`FilterExpandSettings`]({% slug api_treeview_filterexpandsettings %}) object to this input.
         * @default false
         */
        this.expandOnFilter = false;
        /**
         * Fires when the `expandedKeys` collection was updated.
         */
        this.expandedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        /**
         * Reflectes the internal `expandedKeys` state.
         */
        this.state = new Set();
        this.originalExpandedKeys = new Set();
        this.isFiltered = false;
        /**
         * Fills array with the correct expand keys according to wrapper metadata.
         */
        this.updateExpandedNodes = function (collection, node, autoExpandMatches) {
            if (node.containsMatches || node.isMatch && autoExpandMatches && isArrayWithAtLeastOneItem(node.children)) {
                collection.push(_this.itemKey({ dataItem: node.dataItem, index: node.index }));
            }
            if (isArrayWithAtLeastOneItem(node.children)) {
                node.children.forEach(function (child) {
                    _this.updateExpandedNodes(collection, child, autoExpandMatches);
                });
            }
        };
        /**
         * Fills array with the expand key of every node.
         */
        this.getEveryExpandKey = function (collection, node) {
            if (isArrayWithAtLeastOneItem(node.children)) {
                collection.push(_this.itemKey({ dataItem: node.dataItem, index: node.index }));
            }
            if (isArrayWithAtLeastOneItem(node.children)) {
                node.children.forEach(function (child) {
                    _this.getEveryExpandKey(collection, child);
                });
            }
        };
        this.subscriptions.add(merge(this.component.expand.pipe(map(function (e) { return (__assign({ expand: true }, e)); })), this.component.collapse.pipe(map(function (e) { return (__assign({ expand: false }, e)); }))).subscribe(this.toggleExpand.bind(this)));
        if (this.component.filterStateChange) {
            this.subscriptions.add(this.component.filterStateChange.subscribe(this.handleAutoExpand.bind(this)));
        }
        this.component.isExpanded = function (dataItem, index) {
            return _this.state.has(_this.itemKey({ dataItem: dataItem, index: index }));
        };
    }
    Object.defineProperty(ExpandDirective.prototype, "isExpanded", {
        /**
         * @hidden
         */
        set: function (value) {
            this.component.isExpanded = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExpandDirective.prototype, "filterExpandSettings", {
        get: function () {
            var settings = isBoolean(this.expandOnFilter) ? { enabled: this.expandOnFilter } : __assign({}, this.expandOnFilter, { enabled: true });
            return Object.assign({}, DEFAULT_FILTER_EXPAND_SETTINGS, settings);
        },
        enumerable: true,
        configurable: true
    });
    ExpandDirective.prototype.ngOnChanges = function (changes) {
        if (isChanged('expandedKeys', changes, false) && changes.expandedKeys.currentValue !== this.lastChange) {
            this.state = new Set(changes.expandedKeys.currentValue);
        }
    };
    ExpandDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    /**
     * @hidden
     */
    ExpandDirective.prototype.itemKey = function (e) {
        if (this.expandKey) {
            if (typeof this.expandKey === "string") {
                return e.dataItem[this.expandKey];
            }
            if (typeof this.expandKey === "function") {
                return this.expandKey(e);
            }
        }
        return e.index;
    };
    ExpandDirective.prototype.toggleExpand = function (_a) {
        var index = _a.index, dataItem = _a.dataItem, expand = _a.expand;
        var key = this.itemKey({ index: index, dataItem: dataItem });
        var isExpanded = this.state.has(key);
        var notify = false;
        if (isExpanded && !expand) {
            this.state.delete(key);
            notify = true;
        }
        else if (!isExpanded && expand) {
            this.state.add(key);
            notify = true;
        }
        if (notify) {
            this.notify();
        }
    };
    ExpandDirective.prototype.handleAutoExpand = function (_a) {
        var _this = this;
        var nodes = _a.nodes, matchCount = _a.matchCount, term = _a.term;
        if (!this.filterExpandSettings.enabled) {
            return;
        }
        var _b = this.filterExpandSettings, maxAutoExpandResults = _b.maxAutoExpandResults, autoExpandMatches = _b.expandMatches, expandedOnClear = _b.expandedOnClear;
        if (!this.isFiltered) {
            this.originalExpandedKeys = new Set(this.state);
        }
        var exitingFilteredState = this.isFiltered && !term;
        var maxExceeded = maxAutoExpandResults !== -1 && matchCount > maxAutoExpandResults;
        var exitAutoExpandedState = exitingFilteredState || maxExceeded;
        if (exitAutoExpandedState) {
            switch (expandedOnClear) {
                case "initial": {
                    if (!sameValues(this.state, this.originalExpandedKeys)) {
                        this.state = this.originalExpandedKeys;
                        this.notify();
                    }
                    break;
                }
                case "all": {
                    this.state = new Set(nodes.reduce(function (acc, rootNode) {
                        _this.getEveryExpandKey(acc, rootNode);
                        return acc;
                    }, []));
                    this.notify();
                    break;
                }
                case "unchanged": {
                    break;
                }
                case "none":
                default: {
                    if (this.state.size !== 0) {
                        this.state.clear();
                        this.notify();
                    }
                    break;
                }
            }
            this.isFiltered = false;
            return;
        }
        var indicesToExpand = new Set(nodes.reduce(function (acc, rootNode) {
            _this.updateExpandedNodes(acc, rootNode, autoExpandMatches);
            return acc;
        }, []));
        if (!sameValues(this.state, indicesToExpand)) {
            this.state = indicesToExpand;
            this.notify();
        }
        this.isFiltered = true;
    };
    ExpandDirective.prototype.notify = function () {
        this.lastChange = Array.from(this.state);
        this.expandedKeysChange.emit(this.lastChange);
    };
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], ExpandDirective.prototype, "isExpanded", null);
    __decorate([
        Input("expandBy"),
        __metadata("design:type", Object)
    ], ExpandDirective.prototype, "expandKey", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ExpandDirective.prototype, "expandOnFilter", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ExpandDirective.prototype, "expandedKeysChange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ExpandDirective.prototype, "expandedKeys", void 0);
    ExpandDirective = __decorate([
        Directive({ selector: '[kendoTreeViewExpandable]' }),
        __metadata("design:paramtypes", [ExpandableComponent])
    ], ExpandDirective);
    return ExpandDirective;
}());

/**
 * A directive which manages the in-memory selection state of the TreeView node
 * ([see example]({% slug selection_treeview %})).
 */
var SelectDirective = /** @class */ (function () {
    function SelectDirective(treeView) {
        var _this = this;
        this.treeView = treeView;
        /**
         * Fires when the `selectedKeys` collection was updated.
         */
        this.selectedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this.selectActions = {
            'multiple': function (e) { return _this.selectMultiple(e); },
            'single': function (e) { return _this.selectSingle(e); }
        };
        /**
         * Reflectes the internal `selectedKeys` state.
         */
        this.state = new Set();
        this.subscriptions.add(this.treeView.selectionChange.subscribe(this.select.bind(this)));
        this.treeView.isSelected = function (dataItem, index) { return (_this.state.has(_this.itemKey({ dataItem: dataItem, index: index }))); };
    }
    Object.defineProperty(SelectDirective.prototype, "isSelected", {
        /**
         * @hidden
         */
        set: function (value) {
            this.treeView.isSelected = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectDirective.prototype, "getAriaMultiselectable", {
        get: function () {
            return this.options.mode === 'multiple';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectDirective.prototype, "options", {
        get: function () {
            var defaultOptions = {
                enabled: true,
                mode: 'single'
            };
            if (!isPresent(this.selection) || typeof this.selection === 'string') {
                return defaultOptions;
            }
            var selectionSettings = isBoolean(this.selection) ? { enabled: this.selection } : this.selection;
            return Object.assign(defaultOptions, selectionSettings);
        },
        enumerable: true,
        configurable: true
    });
    SelectDirective.prototype.ngOnChanges = function (changes) {
        if (isChanged('selectedKeys', changes, false) && changes.selectedKeys.currentValue !== this.lastChange) {
            this.state = new Set(changes.selectedKeys.currentValue);
        }
    };
    SelectDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    SelectDirective.prototype.itemKey = function (e) {
        if (!this.selectKey) {
            return e.index;
        }
        if (typeof this.selectKey === 'string') {
            return e.dataItem[this.selectKey];
        }
        if (typeof this.selectKey === 'function') {
            return this.selectKey(e);
        }
    };
    SelectDirective.prototype.select = function (e) {
        var _a = this.options, enabled = _a.enabled, mode = _a.mode;
        var performSelection = this.selectActions[mode] || noop;
        if (!enabled) {
            return;
        }
        performSelection(e);
    };
    SelectDirective.prototype.selectSingle = function (node) {
        var key = this.itemKey(node);
        if (!this.state.has(key)) {
            this.state.clear();
            this.state.add(key);
            this.notify();
        }
    };
    SelectDirective.prototype.selectMultiple = function (node) {
        var key = this.itemKey(node);
        var isSelected = this.state.has(key);
        if (!isPresent(key)) {
            return;
        }
        if (isSelected) {
            this.state.delete(key);
        }
        else {
            this.state.add(key);
        }
        this.notify();
    };
    SelectDirective.prototype.notify = function () {
        this.lastChange = Array.from(this.state);
        this.selectedKeysChange.emit(this.lastChange);
    };
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], SelectDirective.prototype, "isSelected", null);
    __decorate([
        Input('selectBy'),
        __metadata("design:type", Object)
    ], SelectDirective.prototype, "selectKey", void 0);
    __decorate([
        Input('kendoTreeViewSelectable'),
        __metadata("design:type", Object)
    ], SelectDirective.prototype, "selection", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SelectDirective.prototype, "selectedKeys", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SelectDirective.prototype, "selectedKeysChange", void 0);
    __decorate([
        HostBinding('attr.aria-multiselectable'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SelectDirective.prototype, "getAriaMultiselectable", null);
    SelectDirective = __decorate([
        Directive({ selector: '[kendoTreeViewSelectable]' }),
        __metadata("design:paramtypes", [TreeViewComponent])
    ], SelectDirective);
    return SelectDirective;
}());

/**
 * Describes the attempted drop action during dragging.
 * Passed as `action` value to the [`kendoTreeViewDragClueTemplate`]({% slug api_treeview_dragcluetemplatedirective %}) directive.
 * By default, this value defines the rendered icon in the drag clue.
 */
var DropAction;
(function (DropAction) {
    DropAction[DropAction["Add"] = 0] = "Add";
    DropAction[DropAction["InsertTop"] = 1] = "InsertTop";
    DropAction[DropAction["InsertBottom"] = 2] = "InsertBottom";
    DropAction[DropAction["InsertMiddle"] = 3] = "InsertMiddle";
    DropAction[DropAction["Invalid"] = 4] = "Invalid";
})(DropAction || (DropAction = {}));

/**
 * Describes where the dragged item is dropped relative to the drop target item.
 */
var DropPosition;
(function (DropPosition) {
    DropPosition[DropPosition["Over"] = 0] = "Over";
    DropPosition[DropPosition["Before"] = 1] = "Before";
    DropPosition[DropPosition["After"] = 2] = "After";
})(DropPosition || (DropPosition = {}));

/**
 * @hidden
 */
var ScrollDirection;
(function (ScrollDirection) {
    ScrollDirection[ScrollDirection["Up"] = -1] = "Up";
    ScrollDirection[ScrollDirection["Down"] = 1] = "Down";
})(ScrollDirection || (ScrollDirection = {}));

/**
 * @hidden
 */
var PreventableEvent = /** @class */ (function () {
    function PreventableEvent() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    PreventableEvent.prototype.preventDefault = function () {
        this.prevented = true;
    };
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    PreventableEvent.prototype.isDefaultPrevented = function () {
        return this.prevented;
    };
    return PreventableEvent;
}());

/**
 * Arguments for the TreeView [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop) event.
 */
var TreeItemDropEvent = /** @class */ (function (_super) {
    __extends(TreeItemDropEvent, _super);
    /**
     * @hidden
     */
    function TreeItemDropEvent(initializer, originalEvent) {
        var _this = _super.call(this) || this;
        /**
         * @hidden
         */
        _this.isValid = true;
        Object.assign(_this, initializer);
        _this.originalEvent = originalEvent;
        return _this;
    }
    /**
     * Specifies if the drop action should be marked as valid.
     * If set to `false`, the [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
     * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events will not be fired and the drag clue
     * will be animated back to the source item to indicate the action is marked as invalid.
     */
    TreeItemDropEvent.prototype.setValid = function (isValid) {
        this.isValid = isValid;
    };
    return TreeItemDropEvent;
}(PreventableEvent));

/**
 * Arguments for the TreeView [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart) event.
 */
var TreeItemDragStartEvent = /** @class */ (function (_super) {
    __extends(TreeItemDragStartEvent, _super);
    /**
     * @hidden
     */
    function TreeItemDragStartEvent(initializer) {
        var _this = _super.call(this) || this;
        Object.assign(_this, initializer);
        return _this;
    }
    return TreeItemDragStartEvent;
}(PreventableEvent));

/**
 * Arguments for the TreeView [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag) and
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend) events.
 */
var TreeItemDragEvent = /** @class */ (function () {
    function TreeItemDragEvent() {
    }
    return TreeItemDragEvent;
}());

var ɵ0$3 = function () {
    if (!(isDocumentAvailable() && isPresent(document.body))) {
        return false;
    }
    var top = 10;
    var parent = document.createElement("div");
    parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
    parent.innerHTML = "<div style=\"position: fixed; top: " + top + "px;\">child</div>";
    document.body.appendChild(parent);
    var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
};
/**
 * Checks if the browser supports relative stacking context.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 */
var hasRelativeStackingContext = memoize(ɵ0$3);
/**
 * Stores the result of the passed function's first invokation and returns it instead of invoking it again afterwards.
 */
function memoize(fn) {
    var result;
    var called = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (called) {
            return result;
        }
        result = fn.apply(void 0, args);
        called = true;
        return result;
    };
}
/**
 * @hidden
 *
 * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.
 * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 *
 * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;
 */
var getContainerOffset = function (element) {
    if (!(element && hasRelativeStackingContext())) {
        return { left: 0, top: 0 };
    }
    var offsetParent = element.parentElement;
    while (offsetParent) {
        if (window.getComputedStyle(offsetParent).transform !== 'none') {
            break;
        }
        offsetParent = offsetParent.parentElement;
    }
    if (offsetParent) {
        var rect = offsetParent.getBoundingClientRect();
        return {
            left: rect.left - offsetParent.scrollLeft,
            top: rect.top - offsetParent.scrollTop
        };
    }
    return { left: 0, top: 0 };
};
/**
 * @hidden
 */
var getDropAction = function (dropPosition, dropTarget) {
    if (!(isPresent(dropPosition) && isPresent(dropTarget))) {
        return DropAction.Invalid;
    }
    switch (dropPosition) {
        case DropPosition.Over:
            return DropAction.Add;
        case DropPosition.Before:
            return isPresent(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;
        case DropPosition.After:
            return isPresent(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;
        default:
            return DropAction.Invalid;
    }
};
/**
 * @hidden
 */
var getDropPosition = function (draggedItem, target, clientY, targetTreeView, containerOffset) {
    if (!(isPresent(draggedItem) && isPresent(target) && isPresent(targetTreeView) && isPresent(containerOffset))) {
        return;
    }
    // the .k-treeview-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right
    var item = closestWithMatch(target, '.k-treeview-mid');
    if (!isPresent(item)) {
        return;
    }
    // the content element (.k-treeview-leaf:not(.k-treeview-load-more-button)) holds just the treeview item text
    var content = getContentElement(item);
    var targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));
    if (!isPresent(content) || (content === draggedItem) || targetChildOfDraggedItem) {
        return;
    }
    var itemViewPortCoords = content.getBoundingClientRect();
    /*
        if the user is hovering a treeview item, split the item height into four parts:
            - dropping into the top quarter should insert the dragged item before the drop target
            - dropping into the bottom quarter should insert the dragged item after the drop target
            - dropping into the second or third quarter should add the item as child node of the drop target

        if the user is NOT hovering a treeview item (he's dragging somewhere on the right), split the item height to just two parts:
            - dropping should insert before or after
    */
    var itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2);
    // clear any possible container offset created by parent elements with `transform` css property set
    var pointerPosition = clientY - containerOffset.top;
    var itemTop = itemViewPortCoords.top - containerOffset.top;
    if (pointerPosition < itemTop + itemDivisionHeight) {
        return DropPosition.Before;
    }
    if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
        return DropPosition.After;
    }
    return DropPosition.Over;
};
/**
 * @hidden
 */
var treeItemFromEventTarget = function (treeView, dropTarget) {
    if (!(isPresent(treeView) && isPresent(dropTarget))) {
        return null;
    }
    var node = closestNode(dropTarget);
    var index = nodeId(node);
    var lookup = treeView.itemLookup(index);
    if (!(isPresent(lookup) && isPresent(lookup.item.dataItem))) {
        return null;
    }
    return lookup;
};
/**
 * @hidden
 *
 * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.
 */
var collapseEmptyParent = function (parent, parentNodes, treeview) {
    if (isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {
        treeview.collapseNode(parent.item.dataItem, parent.item.index);
    }
};
/**
 * @hidden
 *
 * Expands the node if it's dropped into and it's not yet expanded.
 */
var expandDropTarget = function (dropTarget, treeView) {
    if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {
        treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);
    }
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
var getDropTarget = function (event) {
    if (!(isDocumentAvailable() && isPresent(document.elementFromPoint))) {
        return event.target;
    }
    return document.elementFromPoint(event.clientX, event.clientY);
};
/**
 * @hidden
 *
 * Checks if the original index is before the new one and corrects the new one by decrementing the index for the level, where the original item stood.
 */
var updateMovedItemIndex = function (newIndex, originalIndex) {
    var movedItemNewIndexParts = newIndex.split('_');
    var originalItemIndexParts = originalIndex.split('_');
    // if the original item was moved from a deeper level, there's no need for index correction
    // e.g. 4_0_1 is moved to 5_0 => removing 4_0_1 will not cause 5_0 to be moved
    if (movedItemNewIndexParts.length < originalItemIndexParts.length) {
        return newIndex;
    }
    // check if the parent item paths are the same - index correction is not required when the original item path differs from the path of the moved item - they belong to different hierarchies
    // e.g. 4_1 is moved to 5_1 - the parent item paths are differen (4 compared to 5) => removing 4_1 will not cause 5_1 to be moved
    // e.g 4_1 is moved to 4_3 - the parent paths are the same (both 4) => removing 4_1 will cause 4_3 to be moved
    var originalItemParentPathLength = originalItemIndexParts.length - 1;
    var originalItemParentPath = originalItemIndexParts.slice(0, originalItemParentPathLength).join('_');
    var movedItemParentPath = movedItemNewIndexParts.slice(0, originalItemParentPathLength).join('_');
    // check if the the index of the level where the original item is taken from is greater than the one of the moved item
    // e.g. 4_5 is moved to 4_1 (comapre 5 and 1) => removing 4_5 will not cause 4_1 to be moved
    // e.g. 4_1 is moved to 4_5 (comapre 1 and 5) => removing 4_1 will cause 4_5 to be moved
    var originalItemIndexLevel = originalItemIndexParts.length - 1;
    var originalItemLevelIndex = Number(originalItemIndexParts[originalItemIndexLevel]);
    var movedItemLevelIndex = Number(movedItemNewIndexParts[originalItemIndexLevel]);
    if ((originalItemParentPath === movedItemParentPath) && (movedItemLevelIndex > originalItemLevelIndex)) {
        // if the removed item causes the dropped item to be moved a position up - decrement the index at that level
        movedItemNewIndexParts[originalItemIndexLevel] = String(movedItemLevelIndex - 1);
        return movedItemNewIndexParts.join('_');
    }
    return newIndex;
};
/**
 * @hidden
 */
var SCROLLBAR_REG_EXP = new RegExp('(auto|scroll)');
/**
 * @hidden
 *
 * Retrives the first scrollable element starting the search from the provided one, traversing to the top of the DOM tree.
 */
var getScrollableContainer = function (node) {
    while (isPresent(node) && node.nodeName !== 'HTML') {
        var hasOverflow = node.scrollHeight > node.clientHeight;
        var hasScrollbar = SCROLLBAR_REG_EXP.test(getComputedStyle(node).overflowY);
        if (hasOverflow && hasScrollbar) {
            return node;
        }
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 *
 * Checks if the top of the scrollable element is reached.
 * Floors the scrollTop value.
 */
var isTopReached = function (element) { return Math.floor(element.scrollTop) <= 0; };
/**
 * @hidden
 *
 * Checks if the bottom of the scrollable element is reached.
 * Ceils the scrollTop value.
 */
var isBottomReached = function (element) { return Math.ceil(element.scrollTop) >= element.scrollHeight - element.clientHeight; };
/**
 * @hidden
 *
 * Scrolls the element in the given direction by the provided step.
 *
 * If the targeted scroll incrementation doesn't yield any result due to device pixel ratio issues (https://github.com/dimitar-pechev/RenderingIndependentScrollOffsets#readme),
 * increments the step with 1px and again attempts to change the scrollTop of the element, until the content is actually scrolled.
 *
 * Cuts the operation short after 20 unsuccessful attempts to prevent infinite loops in possible corner-case scenarios.
 */
var scrollElementBy = function (element, step, direction) {
    if (!(isPresent(element) && isDocumentAvailable())) {
        return;
    }
    var initialScrollTop = element.scrollTop;
    var currentStep = step;
    var iterations = 0;
    while (initialScrollTop === element.scrollTop &&
        !(direction === ScrollDirection.Up && isTopReached(element)) &&
        !(direction === ScrollDirection.Down && isBottomReached(element)) &&
        iterations < 20 // as the bulgarian saying goes - to ties our underpants
    ) {
        element.scrollTop += (currentStep * direction);
        currentStep += 1;
        iterations += 1;
    }
};

/**
 * @hidden
 */
var copyPageSize = function (treeview, source, target) {
    if (!isPresent(treeview.loadMoreService)) {
        return;
    }
    var sourceGroupSize = treeview.getNodePageSize(source);
    treeview.setNodePageSize(target, sourceGroupSize);
};
/**
 * @hidden
 */
var incrementPageSize = function (treeview, dataItem) {
    if (!isPresent(treeview.loadMoreService)) {
        return;
    }
    var currentPageSize = treeview.getNodePageSize(dataItem);
    treeview.setNodePageSize(dataItem, currentPageSize + 1);
};
/**
 * @hidden
 */
var decrementPageSize = function (treeview, dataItem) {
    if (!isPresent(treeview.loadMoreService)) {
        return;
    }
    var currentPageSize = treeview.getNodePageSize(dataItem);
    treeview.setNodePageSize(dataItem, currentPageSize - 1);
};

/**
 * @hidden
 */
var HierarchyEditingService = /** @class */ (function () {
    function HierarchyEditingService(hierarchyBinding) {
        this.hierarchyBinding = hierarchyBinding;
    }
    HierarchyEditingService.prototype.add = function (_a) {
        var sourceItem = _a.sourceItem, destinationItem = _a.destinationItem, dropPosition = _a.dropPosition, sourceTree = _a.sourceTree, destinationTree = _a.destinationTree;
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        var clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            var destinationChildren = this.childrenFor(getDataItem(destinationItem));
            // add the moved node just before the load more button if load more is enabled
            var targetIndex = isPresent(destinationTree.loadMoreService) ?
                Math.min(destinationTree.loadMoreService.getGroupSize(getDataItem(destinationItem)), destinationChildren.length) : // the page size might be greater than the actual children array length
                destinationChildren.length;
            destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);
            setter(this.hierarchyBinding.childrenField)(getDataItem(destinationItem), destinationChildren);
            this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, targetIndex);
        }
        else {
            var destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);
            var shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            var targetIndex = destinationParentNodes.indexOf(getDataItem(destinationItem)) + shiftIndex;
            destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);
            var parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;
            this.movedItemNewIndex = buildTreeIndex(parentIndex, targetIndex);
        }
        // increment the parent page size => an item is moved into it
        var updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
        incrementPageSize(destinationTree, updatedParent);
        // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference
        copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
        // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different
        if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {
            destinationTree.preloadChildNodes();
        }
        // if the source and destination trees are the same, focusing the moved item here will not have the desired effect
        // as the `remove` handler has not yet kicked-in to remove the item from its old position
        if (sourceTree !== destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            destinationTree.focus(this.movedItemNewIndex);
        }
    };
    HierarchyEditingService.prototype.remove = function (_a) {
        var sourceItem = _a.sourceItem, sourceTree = _a.sourceTree, destinationTree = _a.destinationTree;
        var sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);
        var sourceItemIndex = sourceParentNodes.indexOf(getDataItem(sourceItem));
        sourceParentNodes.splice(sourceItemIndex, 1);
        // emit collapse for the parent node if its last child node was spliced
        collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);
        // decrement source item parent page size => an item has been removed from it
        decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
        // reload the treeview nodes
        if (!sourceTree.loadOnDemand) {
            sourceTree.preloadChildNodes();
        }
        // if the source and destination trees are different we want to focus only the moved item in the destination tree
        if (sourceTree === destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            // after the source item is removed from its original position, the candidate index might have to be corrected
            var index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);
            destinationTree.focus(index);
        }
    };
    HierarchyEditingService.prototype.getParentNodes = function (node, treeView) {
        return isPresent(node.parent) ?
            this.childrenFor(getDataItem(node.parent)) :
            treeView.nodes;
    };
    HierarchyEditingService.prototype.childrenFor = function (dataItem) {
        return getter(this.hierarchyBinding.childrenField)(dataItem) || [];
    };
    return HierarchyEditingService;
}());

/**
 * @hidden
 */
var DragClueComponent = /** @class */ (function () {
    function DragClueComponent(cdr) {
        this.cdr = cdr;
        this.hostClasses = true;
        this.posistionStyle = 'fixed';
    }
    Object.defineProperty(DragClueComponent.prototype, "statusIconClass", {
        get: function () {
            switch (this.action) {
                case DropAction.Add: return 'k-i-plus';
                case DropAction.InsertTop: return 'k-i-insert-up';
                case DropAction.InsertBottom: return 'k-i-insert-down';
                case DropAction.InsertMiddle: return 'k-i-insert-middle';
                case DropAction.Invalid:
                default: return 'k-i-cancel';
            }
        },
        enumerable: true,
        configurable: true
    });
    // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
    DragClueComponent.prototype.detectChanges = function () {
        this.cdr.detectChanges();
    };
    __decorate([
        HostBinding('class.k-header'),
        HostBinding('class.k-drag-clue'),
        __metadata("design:type", Boolean)
    ], DragClueComponent.prototype, "hostClasses", void 0);
    __decorate([
        HostBinding('style.position'),
        __metadata("design:type", String)
    ], DragClueComponent.prototype, "posistionStyle", void 0);
    DragClueComponent = __decorate([
        Component({
            changeDetection: ChangeDetectionStrategy.OnPush,
            selector: 'kendo-treeview-drag-clue',
            template: "\n        <ng-container *ngIf=\"!template\">\n            <span class=\"k-icon {{statusIconClass}} k-drag-status\"></span>\n            <span>{{text}}</span>\n        </ng-container>\n\n        <ng-template\n            *ngIf=\"template\"\n            [ngTemplateOutlet]=\"template\"\n            [ngTemplateOutletContext]=\"{\n                text: text,\n                action: action,\n                sourceItem: sourceItem,\n                destinationItem: destinationItem\n            }\"\n        >\n        </ng-template>\n    "
        }),
        __metadata("design:paramtypes", [ChangeDetectorRef])
    ], DragClueComponent);
    return DragClueComponent;
}());

/**
 * @hidden
 */
var DragAndDropAssetService = /** @class */ (function () {
    function DragAndDropAssetService() {
    }
    Object.defineProperty(DragAndDropAssetService.prototype, "componentRef", {
        get: function () {
            if (!isPresent(this._componentRef)) {
                throw new Error('The `initalize` method must be called before calling other service methods.');
            }
            return this._componentRef;
        },
        set: function (componentRef) {
            this._componentRef = componentRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragAndDropAssetService.prototype, "element", {
        get: function () {
            return this.componentRef.location.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    DragAndDropAssetService.prototype.ngOnDestroy = function () {
        if (!isPresent(this._componentRef)) {
            return;
        }
        this.element.parentElement.removeChild(this.element);
        this.componentRef.destroy();
        this.componentRef = null;
    };
    DragAndDropAssetService.prototype.show = function () {
        this.element.style.display = '';
    };
    DragAndDropAssetService.prototype.hide = function () {
        this.element.style.display = 'none';
    };
    DragAndDropAssetService.prototype.move = function (left, top, offset) {
        if (offset === void 0) { offset = 0; }
        this.element.style.left = left + offset + "px";
        this.element.style.top = top + offset + "px";
    };
    return DragAndDropAssetService;
}());

/**
 * @hidden
 */
var CLUE_OFFSET = 10;
/**
 * @hidden
 */
var RETURN_ANIMATION_DURATION = 200;
/**
 * @hidden
 */
var DragClueService = /** @class */ (function (_super) {
    __extends(DragClueService, _super);
    function DragClueService(componentFactoryResolver) {
        var _this = _super.call(this) || this;
        _this.componentFactoryResolver = componentFactoryResolver;
        return _this;
    }
    DragClueService.prototype.initialize = function (container, template) {
        if (isPresent(this._componentRef)) {
            this.ngOnDestroy();
        }
        var clueComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DragClueComponent);
        this.componentRef = container.createComponent(clueComponentFactory);
        this.hide();
        this.componentRef.instance.template = template;
        this.componentRef.changeDetectorRef.detectChanges();
    };
    DragClueService.prototype.ngOnDestroy = function () {
        this.cancelReturnAnimation();
        this.cancelScroll();
        _super.prototype.ngOnDestroy.call(this);
    };
    DragClueService.prototype.move = function (left, top) {
        _super.prototype.move.call(this, left, top, CLUE_OFFSET);
    };
    DragClueService.prototype.animateDragClueToElementPosition = function (target) {
        var _this = this;
        if (!(isPresent(target) && isPresent(this.element.animate))) {
            this.hide();
            return;
        }
        var targetElementViewPortCoords = target.getBoundingClientRect();
        var clueElementViewPortCoords = this.element.getBoundingClientRect();
        this.returnAnimation = this.element.animate([
            { transform: 'translate(0, 0)' },
            { transform: "translate(" + (targetElementViewPortCoords.left - clueElementViewPortCoords.left) + "px, " + (targetElementViewPortCoords.top - clueElementViewPortCoords.top) + "px)" }
        ], RETURN_ANIMATION_DURATION);
        this.returnAnimation.onfinish = function () { return _this.hide(); };
    };
    DragClueService.prototype.cancelReturnAnimation = function () {
        if (!isPresent(this.returnAnimation)) {
            return;
        }
        this.returnAnimation.cancel();
        this.returnAnimation = null;
    };
    DragClueService.prototype.updateDragClueData = function (action, sourceItem, destinationItem) {
        var dragClue = this.componentRef.instance;
        if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {
            return;
        }
        dragClue.action = action;
        dragClue.sourceItem = sourceItem;
        dragClue.destinationItem = destinationItem;
        dragClue.detectChanges();
    };
    DragClueService.prototype.updateText = function (text) {
        if (text === this.componentRef.instance.text) {
            return;
        }
        this.componentRef.instance.text = text;
        this.componentRef.instance.detectChanges();
    };
    /**
     * Triggers the first scrollable parent to scroll upwards or downwards.
     * Uses setInterval, so should be called outside the angular zone.
     */
    DragClueService.prototype.scrollIntoView = function (_a) {
        var step = _a.step, interval = _a.interval;
        this.cancelScroll();
        var scrollableContainer = getScrollableContainer(this.element);
        if (!isPresent(scrollableContainer)) {
            return;
        }
        var containerRect = scrollableContainer.getBoundingClientRect();
        var clueRect = this.element.getBoundingClientRect();
        // if the beginning of the scrollable container is above the current viewport, fall-back to 0
        var firstVisibleClientTopPart = Math.max(containerRect.top, 0);
        // start scrolling up when the first visible item is dragged over
        var topLimit = firstVisibleClientTopPart + clueRect.height;
        // if the end of the scrollable container is beneath the current viewport, fall-back to its client height
        // add the distance from the start of the viewport to the beginning of the container to ensure scrolling bottom begins when the actual end of the container is reached
        var bottomLimit = firstVisibleClientTopPart + Math.min(containerRect.bottom, scrollableContainer.clientHeight);
        if (clueRect.top < topLimit) {
            this.scrollInterval = setInterval(function () {
                return scrollElementBy(scrollableContainer, step, ScrollDirection.Up);
            }, interval);
        }
        else if (clueRect.bottom > bottomLimit) {
            this.scrollInterval = setInterval(function () {
                return scrollElementBy(scrollableContainer, step, ScrollDirection.Down);
            }, interval);
        }
    };
    /**
     * Cancels out the on-going scroll animation, if present.
     */
    DragClueService.prototype.cancelScroll = function () {
        if (isPresent(this.scrollInterval)) {
            clearInterval(this.scrollInterval);
            this.scrollInterval = null;
        }
    };
    DragClueService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [ComponentFactoryResolver])
    ], DragClueService);
    return DragClueService;
}(DragAndDropAssetService));

/**
 * @hidden
 */
var DropHintComponent = /** @class */ (function () {
    function DropHintComponent(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.hostClass = true;
        this.position = 'fixed';
        this.pointerEvents = 'none';
    }
    // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
    DropHintComponent.prototype.detectChanges = function () {
        this.changeDetectorRef.detectChanges();
    };
    __decorate([
        HostBinding('class.k-drop-hint-container'),
        __metadata("design:type", Boolean)
    ], DropHintComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('style.position'),
        __metadata("design:type", String)
    ], DropHintComponent.prototype, "position", void 0);
    __decorate([
        HostBinding('style.pointer-events'),
        __metadata("design:type", String)
    ], DropHintComponent.prototype, "pointerEvents", void 0);
    DropHintComponent = __decorate([
        Component({
            changeDetection: ChangeDetectionStrategy.OnPush,
            selector: 'kendo-treeview-drop-hint',
            template: "\n        <div\n            *ngIf=\"!template\"\n            class=\"k-drop-hint k-drop-hint-h\"\n        >\n            <div class='k-drop-hint-start'></div>\n            <div class='k-drop-hint-line'></div>\n        </div>\n\n        <ng-template\n            *ngIf=\"template\"\n            [ngTemplateOutlet]=\"template\"\n            [ngTemplateOutletContext]=\"{\n                action: action,\n                sourceItem: sourceItem,\n                destinationItem: destinationItem\n            }\"\n        >\n        <ng-template>\n    "
        }),
        __metadata("design:paramtypes", [ChangeDetectorRef])
    ], DropHintComponent);
    return DropHintComponent;
}());

/**
 * @hidden
 */
var DropHintService = /** @class */ (function (_super) {
    __extends(DropHintService, _super);
    function DropHintService(componentFactoryResolver) {
        var _this = _super.call(this) || this;
        _this.componentFactoryResolver = componentFactoryResolver;
        return _this;
    }
    DropHintService.prototype.initialize = function (container, template) {
        if (isPresent(this._componentRef)) {
            this.ngOnDestroy();
        }
        var hintComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DropHintComponent);
        this.componentRef = container.createComponent(hintComponentFactory);
        this.hide();
        this.componentRef.instance.template = template;
        this.componentRef.changeDetectorRef.detectChanges();
    };
    DropHintService.prototype.updateDropHintData = function (action, sourceItem, destinationItem) {
        var dropHint = this.componentRef.instance;
        if (action === dropHint.action && dataItemsEqual(sourceItem, dropHint.sourceItem) && dataItemsEqual(destinationItem, dropHint.destinationItem)) {
            return;
        }
        dropHint.action = action;
        dropHint.sourceItem = sourceItem;
        dropHint.destinationItem = destinationItem;
        dropHint.detectChanges();
    };
    DropHintService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [ComponentFactoryResolver])
    ], DropHintService);
    return DropHintService;
}(DragAndDropAssetService));

/**
 * Represents the template for the TreeView drag clue when an item is dragged. To define the clue template,
 * nest an `<ng-template>` tag with the `kendoTreeViewDragClueTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug draganddrop_treeview %}#toc-templates)).
 *
 *
 * The text, attempted drop action, source item and destination item are available as context variables in the template:
 *
 *
 * - `let-text="text"` (`string`)
 * - `let-action="action"` ([`DropAction`]({% slug api_treeview_dropaction %}))
 * - `let-sourceItem="sourceItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 * - `let-destinationItem="destinationItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 */
var DragClueTemplateDirective = /** @class */ (function () {
    function DragClueTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DragClueTemplateDirective = __decorate([
        Directive({
            selector: '[kendoTreeViewDragClueTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], DragClueTemplateDirective);
    return DragClueTemplateDirective;
}());

/**
 * Represents the template for the TreeView drop hint when an item is dragged. To define the hint template,
 * nest an `<ng-template>` tag with the `kendoTreeViewDropHintTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug draganddrop_treeview %}#toc-templates)).
 *
 * The attempted drop action, source item and destination item are available as context variables in the template:
 *
 * - `let-action="action"` ([`DropAction`]({% slug api_treeview_dropaction %}))
 * - `let-sourceItem="sourceItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 * - `let-destinationItem="destinationItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 */
var DropHintTemplateDirective = /** @class */ (function () {
    function DropHintTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DropHintTemplateDirective = __decorate([
        Directive({
            selector: '[kendoTreeViewDropHintTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], DropHintTemplateDirective);
    return DropHintTemplateDirective;
}());

var DEFAULT_SCROLL_SETTINGS = {
    enabled: true,
    step: 1,
    interval: 1
};
/**
 * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances
 * ([see example]({% slug draganddrop_treeview %})).
 *
 * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),
 * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),
 * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
 * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * events when the corresponding actions occur on the respective TreeView instance.
 */
var DragAndDropDirective = /** @class */ (function () {
    function DragAndDropDirective(element, zone, treeview, dragClueService, dropHintService) {
        this.element = element;
        this.zone = zone;
        this.treeview = treeview;
        this.dragClueService = dragClueService;
        this.dropHintService = dropHintService;
        /**
         * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.
         * If enabled, the `removeItem` event will not be fired on the source TreeView
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         *
         * @default false
         */
        this.allowCopy = false;
        /**
         * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         */
        this.dropZoneTreeViews = [];
        /**
         * Specifies the distance in pixels from the initial item pointerdown event, before the dragging is initiated.
         * The `nodeDragStart` and all consequent TreeView drag events will not be fired until the actual dragging begins.
         *
         * @default 5
         */
        this.startDragAfter = 5;
        /**
         * Controlls the auto-scrolling behavior during drag-and-drop ([see example]({% slug draganddrop_treeview %}#toc-auto-scrolling)).
         * Enbaled by default. To turn the auto-scrolling off, set this prop to `false`.
         *
         * By default, the scrolling will be performed by 1 pixel at every 1 millisecond, when the dragged item reaches the top or the bottom of the scrollable container.
         * The `step` and `interval` can be overridden by providing a `DragAndDropScrollSettings` object to this prop.
         *
         * @default true
         */
        this.autoScroll = true;
        /**
         * @hidden
         */
        this.userSelectStyle = 'none';
        /**
         * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.
         * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.
         * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
         */
        this.containerOffset = { top: 0, left: 0 };
        this.treeview.touchActions = false;
    }
    Object.defineProperty(DragAndDropDirective.prototype, "scrollSettings", {
        get: function () {
            var userProvidedSettings = typeof this.autoScroll === 'boolean' ?
                { enabled: this.autoScroll } :
                this.autoScroll;
            return Object.assign({}, DEFAULT_SCROLL_SETTINGS, userProvidedSettings);
        },
        enumerable: true,
        configurable: true
    });
    DragAndDropDirective.prototype.ngAfterContentInit = function () {
        this.initalizeDraggable();
        this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);
        this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);
    };
    DragAndDropDirective.prototype.ngOnDestroy = function () {
        this.draggable.destroy();
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handlePress = function (_a) {
        var originalEvent = _a.originalEvent;
        if (!isContent(originalEvent.target)) {
            return;
        }
        // store the drag target on press, show it only when it's actually dragged
        this.draggedItem = closestWithMatch(originalEvent.target, '.k-treeview-leaf');
        // record the current pointer down coords - copared to the `startDragAfter` value to calculate whether to initiate dragging
        this.pendingDragStartEvent = originalEvent;
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handleDrag = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent, clientX = _a.clientX, clientY = _a.clientY;
        if (this.shouldInitiateDragStart({ clientX: clientX, clientY: clientY })) {
            this.initiateDragStart();
        }
        if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {
            return;
        }
        var dropTarget = getDropTarget(originalEvent);
        if (hasObservers(this.treeview.nodeDrag)) {
            this.zone.run(function () { return _this.notifyDrag(originalEvent, dropTarget); });
        }
        var targetTreeView = this.getTargetTreeView(dropTarget);
        var dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);
        var dropHintAnchor = closestWithMatch(dropTarget, '.k-treeview-mid');
        var dropAction = getDropAction(dropPosition, dropTarget);
        var sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);
        var destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);
        this.updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem);
        this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);
        if (this.scrollSettings.enabled) {
            this.dragClueService.scrollIntoView(this.scrollSettings);
        }
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handleRelease = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent, clientY = _a.clientY;
        if (this.scrollSettings.enabled) {
            this.dragClueService.cancelScroll();
        }
        if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {
            this.pendingDragStartEvent = null;
            this.draggedItem = null;
            return;
        }
        var dropTarget = getDropTarget(originalEvent);
        var sourceTree = this.treeview;
        var destinationTree = this.getTargetTreeView(dropTarget);
        var dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);
        var sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);
        var destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);
        if (isPresent(destinationItem) && isPresent(dropPosition)) {
            this.zone.run(function () { return _this.notifyDrop({ sourceItem: sourceItem, destinationItem: destinationItem, dropPosition: dropPosition, sourceTree: sourceTree, destinationTree: destinationTree }, originalEvent); });
        }
        else {
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
        if (hasObservers(this.treeview.nodeDragEnd)) {
            this.zone.run(function () { return _this.notifyDragEnd({ sourceItem: sourceItem, destinationItem: destinationItem, originalEvent: originalEvent }); });
        }
        this.dropHintService.hide();
        this.draggedItem = null;
    };
    DragAndDropDirective.prototype.updateDropHintState = function (dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem) {
        if (!isPresent(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent(dropPosition)) {
            this.dropHintService.hide();
            return;
        }
        var anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();
        var insertBefore = dropPosition === DropPosition.Before;
        var top = insertBefore ? anchorViewPortCoords.top : (anchorViewPortCoords.top + anchorViewPortCoords.height);
        this.dropHintService.updateDropHintData(dropAction, sourceItem, destinationItem);
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);
        this.dropHintService.show();
    };
    DragAndDropDirective.prototype.updateDragClueState = function (dropAction, clientX, clientY, sourceItem, destinationItem) {
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);
        this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);
        this.dragClueService.show();
    };
    DragAndDropDirective.prototype.initalizeDraggable = function () {
        var _this = this;
        this.draggable = new Draggable({
            press: this.handlePress.bind(this),
            drag: this.handleDrag.bind(this),
            release: this.handleRelease.bind(this)
        });
        this.zone.runOutsideAngular(function () { return _this.draggable.bindTo(_this.element.nativeElement); });
    };
    DragAndDropDirective.prototype.notifyDragStart = function (originalEvent, dropTarget) {
        var sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);
        var event = new TreeItemDragStartEvent({ sourceItem: sourceItem, originalEvent: originalEvent });
        this.treeview.nodeDragStart.emit(event);
        return event;
    };
    DragAndDropDirective.prototype.notifyDrag = function (originalEvent, dropTarget) {
        var dragEvent = {
            sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),
            destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),
            originalEvent: originalEvent
        };
        this.treeview.nodeDrag.emit(dragEvent);
    };
    DragAndDropDirective.prototype.notifyDrop = function (args, originalEvent) {
        var event = new TreeItemDropEvent(args, originalEvent);
        args.destinationTree.nodeDrop.emit(event);
        // disable the animations on drop and restore them afterwards (if they were initially turned on)
        this.disableAnimationsForNextTick(args.destinationTree);
        if (args.sourceTree !== args.destinationTree) {
            this.disableAnimationsForNextTick(args.sourceTree);
        }
        if (!event.isDefaultPrevented() && event.isValid) {
            this.dragClueService.hide();
            // order matters in a flat data binding scenario (first add, then remove)
            args.destinationTree.addItem.emit(args);
            if (!(originalEvent.ctrlKey && this.allowCopy)) {
                args.sourceTree.removeItem.emit(args);
            }
        }
        else if (event.isDefaultPrevented()) {
            // directly hide the clue if the default is prevented
            this.dragClueService.hide();
        }
        else if (!event.isValid) {
            // animate the clue back to the source item position if marked as invalid
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
    };
    DragAndDropDirective.prototype.notifyDragEnd = function (dragEndEvent) {
        this.treeview.nodeDragEnd.emit(dragEndEvent);
    };
    DragAndDropDirective.prototype.getTargetTreeView = function (dropTarget) {
        var treeViewTagName = this.treeview.element.nativeElement.tagName;
        var targetTreeView = closestWithMatch(dropTarget, treeViewTagName);
        return [this.treeview].concat(this.dropZoneTreeViews).find(function (treeView) {
            return isPresent(treeView) && treeView.element.nativeElement === targetTreeView;
        });
    };
    DragAndDropDirective.prototype.disableAnimationsForNextTick = function (treeView) {
        // the treeView.animate getter returns `true` when the animations are turned off
        // confusing, but seems on purpose (the `animate` prop sets the value of the @.disabled host-bound attribute)
        if (treeView.animate) {
            return;
        }
        treeView.animate = false;
        this.zone.runOutsideAngular(function () {
            return setTimeout(function () { return treeView.animate = true; });
        });
    };
    DragAndDropDirective.prototype.shouldInitiateDragStart = function (currentPointerCoords) {
        if (!isPresent(this.pendingDragStartEvent)) {
            return false;
        }
        var distanceFromPointerDown = Math.sqrt(Math.pow((this.pendingDragStartEvent.clientX - currentPointerCoords.clientX), 2) +
            Math.pow((this.pendingDragStartEvent.clientY - currentPointerCoords.clientY), 2));
        return distanceFromPointerDown >= this.startDragAfter;
    };
    DragAndDropDirective.prototype.initiateDragStart = function () {
        var _this = this;
        if (hasObservers(this.treeview.nodeDragStart)) {
            var dragStartEvent = this.zone.run(function () {
                return _this.notifyDragStart(_this.pendingDragStartEvent, getDropTarget(_this.pendingDragStartEvent));
            });
            if (dragStartEvent.isDefaultPrevented()) {
                this.pendingDragStartEvent = null;
                this.draggedItem = null;
                return;
            }
        }
        this.dragClueService.cancelReturnAnimation();
        this.dragClueService.updateText(this.draggedItem.innerText);
        this.containerOffset = getContainerOffset(this.draggedItem);
        this.pendingDragStartEvent = null;
    };
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DragAndDropDirective.prototype, "allowCopy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], DragAndDropDirective.prototype, "dropZoneTreeViews", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DragAndDropDirective.prototype, "startDragAfter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DragAndDropDirective.prototype, "autoScroll", void 0);
    __decorate([
        ContentChild(DragClueTemplateDirective, { static: false }),
        __metadata("design:type", DragClueTemplateDirective)
    ], DragAndDropDirective.prototype, "dragClueTemplate", void 0);
    __decorate([
        ContentChild(DropHintTemplateDirective, { static: false }),
        __metadata("design:type", DropHintTemplateDirective)
    ], DragAndDropDirective.prototype, "dropHintTemplate", void 0);
    __decorate([
        HostBinding('style.user-select'),
        HostBinding('style.-ms-user-select'),
        HostBinding('style.-moz-user-select'),
        HostBinding('style.-webkit-user-select'),
        __metadata("design:type", String)
    ], DragAndDropDirective.prototype, "userSelectStyle", void 0);
    DragAndDropDirective = __decorate([
        Directive({
            selector: '[kendoTreeViewDragAndDrop]',
            providers: [
                DragClueService,
                DropHintService
            ]
        }),
        __metadata("design:paramtypes", [ElementRef,
            NgZone,
            TreeViewComponent,
            DragClueService,
            DropHintService])
    ], DragAndDropDirective);
    return DragAndDropDirective;
}());

/**
 * @hidden
 */
var DEFAULT_FILTER_SETTINGS = {
    operator: 'contains',
    ignoreCase: true,
    mode: "lenient"
};

/**
 * @hidden
 */
var FilteringBase = /** @class */ (function () {
    function FilteringBase(component) {
        this.component = component;
        this.visibleNodes = new Set();
        this._filterSettings = DEFAULT_FILTER_SETTINGS;
    }
    Object.defineProperty(FilteringBase.prototype, "filterSettings", {
        get: function () {
            return this._filterSettings;
        },
        /**
         * The settings which are applied when performing a filter on the component's data.
         */
        set: function (settings) {
            this._filterSettings = __assign({}, DEFAULT_FILTER_SETTINGS, settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilteringBase.prototype, "filter", {
        /**
         * Applies a filter and changes the visibility of the component's nodes accordingly.
         */
        set: function (term) {
            this.handleFilterChange(term);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    FilteringBase.prototype.handleFilterChange = function (term) {
        if (!this.filterData) {
            return;
        }
        this.resetNodesVisibility(this.filterData);
        if (term) {
            filterTree(this.filterData, term, this.filterSettings, this.component.textField);
        }
        this.updateVisibleNodes(this.filterData);
        if (isPresent(this.component.filterStateChange)) {
            this.component.filterStateChange.emit({
                nodes: this.filterData,
                matchCount: this.visibleNodes.size,
                term: term,
                filterSettings: this.filterSettings
            });
        }
    };
    FilteringBase.prototype.updateVisibleNodes = function (items) {
        var _this = this;
        items.forEach(function (wrapper) {
            if (wrapper.visible) {
                _this.visibleNodes.add(wrapper.dataItem);
            }
            if (wrapper.children) {
                _this.updateVisibleNodes(wrapper.children);
            }
        });
    };
    FilteringBase.prototype.resetNodesVisibility = function (items) {
        var _this = this;
        this.visibleNodes.clear();
        items.forEach(function (wrapper) {
            wrapper.visible = true;
            if (wrapper.children) {
                _this.resetNodesVisibility(wrapper.children);
            }
        });
    };
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], FilteringBase.prototype, "filterSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], FilteringBase.prototype, "filter", null);
    return FilteringBase;
}());

var indexBuilder = new IndexBuilderService();
var mapToWrappers = function (currentLevelNodes, childrenField, parent, parentIndex) {
    if (parent === void 0) { parent = null; }
    if (parentIndex === void 0) { parentIndex = ''; }
    if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {
        return [];
    }
    return currentLevelNodes.map(function (node, idx) {
        var index = indexBuilder.nodeIndex(idx.toString(), parentIndex);
        var wrapper = {
            dataItem: node,
            index: index,
            parent: parent,
            visible: true
        };
        wrapper.children = mapToWrappers(getter(childrenField)(node), childrenField, wrapper, index);
        return wrapper;
    });
};
/**
 * A directive which encapsulates the retrieval of child nodes.
 */
var HierarchyBindingDirective = /** @class */ (function (_super) {
    __extends(HierarchyBindingDirective, _super);
    function HierarchyBindingDirective(component, dragAndDropDirective) {
        var _this = _super.call(this, component) || this;
        _this.component = component;
        _this.dragAndDropDirective = dragAndDropDirective;
        /**
         * @hidden
         */
        _this.loadOnDemand = true;
        _this.originalData = [];
        var shouldFilter = !isPresent(_this.dragAndDropDirective);
        _this.component.isVisible = shouldFilter ? function (node) { return _this.visibleNodes.has(node); } : isVisible;
        return _this;
    }
    Object.defineProperty(HierarchyBindingDirective.prototype, "childrenField", {
        /**
         * The field name which holds the data items of the child component.
         */
        get: function () {
            return this._childrenField;
        },
        /**
         * The field name which holds the data items of the child component.
         */
        set: function (value) {
            if (!value) {
                throw new Error("'childrenField' cannot be empty");
            }
            this._childrenField = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HierarchyBindingDirective.prototype, "nodes", {
        /**
         * The nodes which will be displayed by the TreeView.
         */
        set: function (values) {
            this.originalData = values || [];
            this.filterData = mapToWrappers(values, this.childrenField) || [];
            this.updateVisibleNodes(this.filterData);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HierarchyBindingDirective.prototype, "isVisible", {
        /**
         * @hidden
         * A callback which determines whether a TreeView node should be rendered as hidden.
         */
        set: function (fn) {
            this.component.isVisible = fn;
        },
        enumerable: true,
        configurable: true
    });
    HierarchyBindingDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (isPresent(this.childrenField)) {
            this.component.children = function (item) { return of(getter(_this.childrenField)(item)); };
            this.component.hasChildren = function (item) {
                var children = getter(_this.childrenField)(item);
                return Boolean(children && children.length);
            };
            this.component.editService = new HierarchyEditingService(this);
            this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
            if (this.component.filter) {
                this.handleFilterChange(this.component.filter);
            }
            if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {
                this.component.preloadChildNodes();
            }
        }
    };
    HierarchyBindingDirective.prototype.ngOnChanges = function (changes) {
        if (isChanged('childrenField', changes, false)) {
            this.nodes = this.originalData;
        }
        // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items
        if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {
            this.component.preloadChildNodes();
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], HierarchyBindingDirective.prototype, "childrenField", null);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], HierarchyBindingDirective.prototype, "nodes", null);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], HierarchyBindingDirective.prototype, "isVisible", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HierarchyBindingDirective.prototype, "loadOnDemand", void 0);
    HierarchyBindingDirective = __decorate([
        Directive({ selector: '[kendoTreeViewHierarchyBinding]' }),
        __param(1, Optional()), __param(1, Host()),
        __metadata("design:paramtypes", [DataBoundComponent,
            DragAndDropDirective])
    ], HierarchyBindingDirective);
    return HierarchyBindingDirective;
}(FilteringBase));

/**
 * @hidden
 */
var LoadingIndicatorDirective = /** @class */ (function () {
    function LoadingIndicatorDirective(expandService, loadingService, cd) {
        this.expandService = expandService;
        this.loadingService = loadingService;
        this.cd = cd;
        this._loading = false;
    }
    Object.defineProperty(LoadingIndicatorDirective.prototype, "loading", {
        get: function () {
            return this._loading;
        },
        set: function (value) {
            this._loading = value;
            this.cd.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    LoadingIndicatorDirective.prototype.ngOnInit = function () {
        var _this = this;
        var loadingNotifications = this.loadingService
            .changes
            .pipe(filter(function (index) { return index === _this.index; }));
        this.subscription = this.expandService
            .changes
            .pipe(filter(function (_a) {
            var index = _a.index;
            return index === _this.index;
        }), tap(function (_a) {
            var expand = _a.expand;
            if (!expand && _this.loading) {
                _this.loading = false;
            }
        }), filter(function (_a) {
            var expand = _a.expand;
            return expand;
        }), switchMap(function (x) { return of(x).pipe(delay(100), takeUntil(loadingNotifications)); }))
            .subscribe(function () { return _this.loading = true; });
        this.subscription.add(loadingNotifications.subscribe(function () { return _this.loading = false; }));
    };
    LoadingIndicatorDirective.prototype.ngOnDestroy = function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    __decorate([
        HostBinding("class.k-i-loading"),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], LoadingIndicatorDirective.prototype, "loading", null);
    __decorate([
        Input("kendoTreeViewLoading"),
        __metadata("design:type", String)
    ], LoadingIndicatorDirective.prototype, "index", void 0);
    LoadingIndicatorDirective = __decorate([
        Directive({ selector: '[kendoTreeViewLoading]' }),
        __metadata("design:paramtypes", [ExpandStateService,
            LoadingNotificationService,
            ChangeDetectorRef])
    ], LoadingIndicatorDirective);
    return LoadingIndicatorDirective;
}());

/**
 * @hidden
 * Performs the right-to-left function composition. Functions must have a unary.
 */
var compose = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (data) { return args.reduceRight(function (acc, curr) { return curr(acc); }, data); };
};

/**
 * @hidden
 */
var FlatEditingService = /** @class */ (function () {
    function FlatEditingService(flatBinding) {
        this.flatBinding = flatBinding;
    }
    FlatEditingService.prototype.add = function (_a) {
        var sourceItem = _a.sourceItem, destinationItem = _a.destinationItem, dropPosition = _a.dropPosition, sourceTree = _a.sourceTree, destinationTree = _a.destinationTree;
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        var clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            var destinationItemId = getter(this.flatBinding.idField)(getDataItem(destinationItem));
            setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemId);
            var lastChildNodeIndex = this.getLastVisibleChildNodeIndex(destinationTree, this.flatBinding.originalData, getDataItem(destinationItem));
            // insert after the last visible child
            var targetIndex = lastChildNodeIndex + 1;
            this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
            // rebind the treeview data before searching for the focus target index
            this.rebindData();
            var focusTarget = this.fetchChildNodes(getDataItem(destinationItem), destinationTree).indexOf(clonedSourceDataItem);
            this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, focusTarget);
        }
        else {
            var shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            var targetIndex = this.flatBinding.originalData.indexOf(getDataItem(destinationItem)) + shiftIndex;
            this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
            var destinationItemParentId = getter(this.flatBinding.parentIdField)(getDataItem(destinationItem));
            setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemParentId);
            // rebind the treeview data before searching for the focus target index
            this.rebindData();
            var parentIndex = destinationItem.parent ?
                destinationItem.parent.item.index :
                null;
            var parentContainer = destinationItem.parent ?
                this.fetchChildNodes(getDataItem(destinationItem.parent), destinationTree) :
                destinationTree.nodes;
            var focusTarget = parentContainer.indexOf(clonedSourceDataItem);
            this.movedItemNewIndex = buildTreeIndex(parentIndex, focusTarget);
        }
        if (sourceTree !== destinationTree) {
            this.addChildNodes(clonedSourceDataItem, sourceTree);
        }
        // increment the parent page size => an item is moved into it
        var updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
        incrementPageSize(destinationTree, updatedParent);
        // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference
        copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
        // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different
        if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {
            destinationTree.preloadChildNodes();
        }
        // if the source and destination trees are the same, focusing the moved item here will not have the desired effect
        // as the `remove` handler has not yet kicked-in to remove the item from its old position
        if (sourceTree !== destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            destinationTree.focus(this.movedItemNewIndex);
        }
    };
    FlatEditingService.prototype.remove = function (_a) {
        var sourceItem = _a.sourceItem, sourceTree = _a.sourceTree, destinationTree = _a.destinationTree;
        var sourceDataItem = getDataItem(sourceItem);
        var sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);
        this.flatBinding.originalData.splice(sourceItemIndex, 1);
        if (sourceTree !== destinationTree) {
            this.removeChildNodes(sourceDataItem, sourceTree);
        }
        this.rebindData();
        // emit collapse for the parent node if its last child node was spliced
        var parentChildren = sourceItem.parent ? sourceItem.parent.children : [];
        collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree);
        // decrement source item parent page size => an item has been removed from it
        decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
        // reload the treeview nodes
        if (!sourceTree.loadOnDemand) {
            sourceTree.preloadChildNodes();
        }
        // if the source and destination trees are different we want to focus only the moved item in the destination tree
        if (sourceTree === destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            // after the source item is removed from its original position, the candidate index might have to be corrected
            var index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);
            destinationTree.focus(index);
        }
    };
    FlatEditingService.prototype.addChildNodes = function (dataItem, source) {
        var _a;
        var itemChildren = this.fetchAllDescendantNodes(dataItem, source);
        (_a = this.flatBinding.originalData).push.apply(_a, itemChildren);
    };
    FlatEditingService.prototype.removeChildNodes = function (dataItem, source) {
        var _this = this;
        var sourceChildren = this.fetchAllDescendantNodes(dataItem, source);
        sourceChildren.forEach(function (item) {
            var index = _this.flatBinding.originalData.indexOf(item);
            _this.flatBinding.originalData.splice(index, 1);
        });
    };
    FlatEditingService.prototype.fetchAllDescendantNodes = function (node, treeview) {
        var _this = this;
        var nodes = this.fetchChildNodes(node, treeview);
        nodes.forEach(function (node) { return nodes = nodes.concat(_this.fetchAllDescendantNodes(node, treeview) || []); });
        return nodes;
    };
    FlatEditingService.prototype.fetchChildNodes = function (node, treeview) {
        if (!node) {
            return [];
        }
        var nodes = [];
        treeview
            .children(node)
            .pipe(take(1))
            .subscribe(function (children) { return nodes = nodes.concat(children || []); });
        return nodes;
    };
    FlatEditingService.prototype.getLastVisibleChildNodeIndex = function (treeview, data, node) {
        if (!isPresent(treeview.loadMoreService) || !treeview.hasChildren(node)) {
            return data.length;
        }
        var visibleNodesCount = treeview.loadMoreService.getGroupSize(node);
        var visibleChildren = this.fetchChildNodes(node, treeview).slice(0, visibleNodesCount);
        var lastNode = visibleChildren[visibleChildren.length - 1];
        var lastNodeIndex = data.indexOf(lastNode);
        return lastNodeIndex;
    };
    FlatEditingService.prototype.rebindData = function () {
        this.flatBinding.nodes = this.flatBinding.originalData;
    };
    return FlatEditingService;
}());

var findChildren = function (prop, nodes, value) { return nodes.filter(function (x) { return prop(x) === value; }); };
var indexBuilder$1 = new IndexBuilderService();
var mapToTree = function (currentLevelNodes, allNodes, parentIdField, idField, parent, parentIndex) {
    if (parent === void 0) { parent = null; }
    if (parentIndex === void 0) { parentIndex = ''; }
    if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {
        return [];
    }
    return currentLevelNodes.map(function (node, idx) {
        var index = indexBuilder$1.nodeIndex(idx.toString(), parentIndex);
        var wrapper = {
            dataItem: node,
            index: index,
            parent: parent,
            visible: true
        };
        wrapper.children = mapToTree(findChildren(getter(parentIdField), allNodes || [], getter(idField)(node)), allNodes, parentIdField, idField, wrapper, index);
        return wrapper;
    });
};
/**
 * A directive which encapsulates the retrieval of the child nodes.
 */
var FlatDataBindingDirective = /** @class */ (function (_super) {
    __extends(FlatDataBindingDirective, _super);
    function FlatDataBindingDirective(component) {
        var _this = _super.call(this, component) || this;
        _this.component = component;
        /**
         * @hidden
         */
        _this.loadOnDemand = true;
        /**
         * @hidden
         */
        _this.originalData = [];
        _this.component.isVisible = function (node) { return _this.visibleNodes.has(node); };
        return _this;
    }
    Object.defineProperty(FlatDataBindingDirective.prototype, "nodes", {
        /**
         * The nodes which will be displayed by the TreeView.
         */
        set: function (values) {
            this.originalData = values || [];
            if (!isNullOrEmptyString(this.parentIdField)) {
                var prop = getter(this.parentIdField);
                this.component.nodes = this.originalData.filter(compose(isBlank, prop));
                this.filterData = mapToTree(this.component.nodes, this.originalData, this.parentIdField, this.idField);
                this.updateVisibleNodes(this.filterData);
            }
            else {
                this.component.nodes = this.originalData.slice(0);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlatDataBindingDirective.prototype, "isVisible", {
        /**
         * @hidden
         * A callback which determines whether a TreeView node should be rendered as hidden.
         */
        set: function (fn) {
            this.component.isVisible = fn;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    FlatDataBindingDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (isPresent(this.parentIdField) && isPresent(this.idField)) {
            var fetchChildren_1 = function (node) {
                return findChildren(getter(_this.parentIdField), _this.originalData || [], getter(_this.idField)(node));
            };
            this.component.hasChildren = function (node) {
                return fetchChildren_1(node).length > 0;
            };
            this.component.children = function (node) { return of(fetchChildren_1(node)); };
            this.component.editService = new FlatEditingService(this);
            this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
            if (this.component.filter) {
                this.handleFilterChange(this.component.filter);
            }
            if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {
                this.component.preloadChildNodes();
            }
        }
    };
    /**
     * @hidden
     */
    FlatDataBindingDirective.prototype.ngOnChanges = function (changes) {
        if (isChanged('parentIdField', changes, false)) {
            this.nodes = this.originalData;
        }
        // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items
        if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {
            this.component.preloadChildNodes();
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], FlatDataBindingDirective.prototype, "nodes", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FlatDataBindingDirective.prototype, "parentIdField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FlatDataBindingDirective.prototype, "idField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], FlatDataBindingDirective.prototype, "loadOnDemand", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], FlatDataBindingDirective.prototype, "isVisible", null);
    FlatDataBindingDirective = __decorate([
        Directive({ selector: "[kendoTreeViewFlatDataBinding]" }),
        __metadata("design:paramtypes", [DataBoundComponent])
    ], FlatDataBindingDirective);
    return FlatDataBindingDirective;
}(FilteringBase));

var buildItem = function (index, dataItem) { return ({ dataItem: dataItem, index: index }); };
var id = 0;
var TREE_ITEM_ROLE = 'treeitem';
var BUTTON_ROLE = 'button';
/**
 * @hidden
 *
 * A directive which manages the expanded state of the TreeView.
 */
var TreeViewItemDirective = /** @class */ (function () {
    function TreeViewItemDirective(element, expandService, navigationService, selectionService, lookupService, renderer, ib) {
        this.element = element;
        this.expandService = expandService;
        this.navigationService = navigationService;
        this.selectionService = selectionService;
        this.lookupService = lookupService;
        this.renderer = renderer;
        this.ib = ib;
        this.role = TREE_ITEM_ROLE;
        this.loadOnDemand = true;
        this.isDisabled = false;
        this.isVisible = true;
        this.ariaChecked = 'false';
        this.id = id++;
        this.isInitialized = false;
        this.subscriptions = [];
        this.subscribe();
    }
    Object.defineProperty(TreeViewItemDirective.prototype, "isChecked", {
        set: function (checked) {
            if (checked === 'checked') {
                this.ariaChecked = 'true';
            }
            else if (checked === 'indeterminate') {
                this.ariaChecked = 'mixed';
            }
            else {
                this.ariaChecked = 'false';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "isExpanded", {
        get: function () {
            return this._isExpanded || false;
        },
        set: function (isExpanded) {
            this._isExpanded = isExpanded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "isSelected", {
        get: function () {
            return this._isSelected || false;
        },
        set: function (isSelected) {
            this._isSelected = isSelected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "isButton", {
        get: function () {
            return this.role === BUTTON_ROLE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "treeItem", {
        get: function () {
            return buildItem(this.index, this.dataItem);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "parentTreeItem", {
        get: function () {
            return this.parentDataItem ? buildItem(this.parentIndex, this.parentDataItem) : null;
        },
        enumerable: true,
        configurable: true
    });
    TreeViewItemDirective.prototype.ngOnInit = function () {
        if (this.loadOnDemand && !this.isButton) {
            this.lookupService.registerItem(this.treeItem, this.parentTreeItem);
        }
        this.registerNavigationItem();
        this.isInitialized = true;
        this.setAttribute('role', this.role);
        this.setAriaAttributes();
        this.setDisabledClass();
        this.updateTabIndex();
    };
    TreeViewItemDirective.prototype.ngOnChanges = function (changes) {
        var index = changes.index, isDisabled = changes.isDisabled;
        if (anyChanged(['index', 'checkable', 'isChecked', 'expandable', 'isExpanded', 'selectable', 'isSelected'], changes)) {
            this.setAriaAttributes();
        }
        if (isDisabled) {
            this.setDisabledClass();
        }
        if (this.loadOnDemand && !this.isButton) {
            this.moveLookupItem(changes);
        }
        this.moveNavigationItem(index);
        if (anyChanged(['isDisabled', 'isVisible'], changes)) {
            this.updateNodeAvailability();
        }
    };
    TreeViewItemDirective.prototype.ngOnDestroy = function () {
        this.navigationService.unregisterItem(this.id, this.index);
        if (this.loadOnDemand && !this.isButton) {
            this.lookupService.unregisterItem(this.index, this.dataItem);
        }
        this.subscriptions = this.subscriptions.reduce(function (list, callback) { return (callback.unsubscribe(), list); }, []);
    };
    TreeViewItemDirective.prototype.subscribe = function () {
        var _this = this;
        this.subscriptions = [
            this.navigationService.moves
                .subscribe(function (navState) {
                _this.updateTabIndex();
                _this.focusItem(navState.shouldScroll);
            }),
            this.navigationService.expands
                .pipe(filter(function (_a) {
                var index = _a.index;
                return index === _this.index && !_this.isDisabled;
            }))
                .subscribe(function (_a) {
                var expand = _a.expand;
                return _this.expand(expand);
            })
        ];
    };
    TreeViewItemDirective.prototype.registerNavigationItem = function () {
        this.navigationService.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);
        this.activateItem();
    };
    TreeViewItemDirective.prototype.activateItem = function () {
        if (this.isDisabled) {
            return;
        }
        var navigationService = this.navigationService;
        var selectionService = this.selectionService;
        var index = this.index;
        selectionService.setFirstSelected(index, this.isSelected);
        if (!navigationService.isActive(index) && selectionService.isFirstSelected(index)) {
            navigationService.activateIndex(index);
        }
    };
    TreeViewItemDirective.prototype.expand = function (shouldExpand) {
        this.expandService[shouldExpand ? 'expand' : 'collapse'](this.index, this.dataItem);
    };
    TreeViewItemDirective.prototype.isFocusable = function () {
        return !this.isDisabled && this.navigationService.isFocusable(this.index);
    };
    TreeViewItemDirective.prototype.focusItem = function (scrollIntoView) {
        if (scrollIntoView === void 0) { scrollIntoView = false; }
        if (this.isInitialized && this.navigationService.isActive(this.index)) {
            this.element.nativeElement.focus({ preventScroll: !scrollIntoView });
        }
    };
    TreeViewItemDirective.prototype.moveLookupItem = function (changes) {
        if (changes === void 0) { changes = {}; }
        var dataItem = changes.dataItem, index = changes.index, parentDataItem = changes.parentDataItem, parentIndex = changes.parentIndex;
        if ((index && index.firstChange) || //skip first change
            (!dataItem && !index && !parentDataItem && !parentIndex)) {
            return;
        }
        var oldIndex = (index || {}).previousValue || this.index;
        this.lookupService.replaceItem(oldIndex, this.treeItem, this.parentTreeItem);
    };
    TreeViewItemDirective.prototype.moveNavigationItem = function (indexChange) {
        if (indexChange === void 0) { indexChange = {}; }
        var currentValue = indexChange.currentValue, firstChange = indexChange.firstChange, previousValue = indexChange.previousValue;
        if (!firstChange && isPresent(currentValue) && isPresent(previousValue)) {
            this.navigationService.unregisterItem(this.id, previousValue);
            this.navigationService.registerItem(this.id, currentValue, this.isDisabled, this.isButton);
        }
    };
    TreeViewItemDirective.prototype.updateNodeAvailability = function () {
        var service = this.navigationService;
        if (this.isDisabled || !this.isVisible) {
            service.activateClosest(this.index); // activate before unregister the item
        }
        else {
            service.activateFocusable();
        }
        service.unregisterItem(this.id, this.index);
        service.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);
    };
    TreeViewItemDirective.prototype.setAriaAttributes = function () {
        this.setAttribute('aria-level', this.ib.level(this.index).toString());
        // don't render attributes when the component configuration doesn't allow the specified state
        this.setAttribute('aria-expanded', this.expandable ? this.isExpanded.toString() : null);
        this.setAttribute('aria-selected', this.selectable ? this.isSelected.toString() : null);
        this.setAttribute('aria-checked', this.checkable ? this.ariaChecked : null);
    };
    TreeViewItemDirective.prototype.setDisabledClass = function () {
        this.setClass('k-disabled', this.isDisabled);
    };
    TreeViewItemDirective.prototype.setClass = function (className, toggle) {
        var action = toggle ? 'addClass' : 'removeClass';
        this.renderer[action](this.element.nativeElement, className);
    };
    TreeViewItemDirective.prototype.updateTabIndex = function () {
        this.setAttribute('tabIndex', this.isFocusable() ? '0' : '-1');
    };
    TreeViewItemDirective.prototype.setAttribute = function (attr, value) {
        if (!isPresent(value)) {
            this.renderer.removeAttribute(this.element.nativeElement, attr);
            return;
        }
        this.renderer.setAttribute(this.element.nativeElement, attr, value);
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeViewItemDirective.prototype, "dataItem", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TreeViewItemDirective.prototype, "index", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeViewItemDirective.prototype, "parentDataItem", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TreeViewItemDirective.prototype, "parentIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TreeViewItemDirective.prototype, "role", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewItemDirective.prototype, "loadOnDemand", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewItemDirective.prototype, "checkable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewItemDirective.prototype, "selectable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewItemDirective.prototype, "expandable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], TreeViewItemDirective.prototype, "isChecked", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewItemDirective.prototype, "isDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewItemDirective.prototype, "isVisible", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], TreeViewItemDirective.prototype, "isExpanded", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], TreeViewItemDirective.prototype, "isSelected", null);
    TreeViewItemDirective = __decorate([
        Directive({ selector: '[kendoTreeViewItem]' }),
        __metadata("design:paramtypes", [ElementRef,
            ExpandStateService,
            NavigationService,
            SelectionService,
            TreeViewLookupService,
            Renderer2,
            IndexBuilderService])
    ], TreeViewItemDirective);
    return TreeViewItemDirective;
}());

/**
 * @hidden
 *
 * A directive which manages the expanded state of the TreeView.
 */
var TreeViewItemContentDirective = /** @class */ (function () {
    function TreeViewItemContentDirective(element, navigationService, selectionService, renderer) {
        var _this = this;
        this.element = element;
        this.navigationService = navigationService;
        this.selectionService = selectionService;
        this.renderer = renderer;
        this.initialSelection = false;
        this.isSelected = isSelected;
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.navigationService.moves
            .subscribe(this.updateFocusClass.bind(this)));
        this.subscriptions.add(this.navigationService.selects
            .pipe(filter(function (index) { return index === _this.index; }))
            .subscribe(function (index) {
            return _this.selectionService.select(index, _this.dataItem);
        }));
        this.subscriptions.add(this.selectionService.changes
            .subscribe(function () {
            _this.updateSelectionClass(_this.isSelected(_this.dataItem, _this.index));
        }));
    }
    TreeViewItemContentDirective.prototype.ngOnChanges = function (changes) {
        if (changes.initialSelection) {
            this.updateSelectionClass(this.initialSelection);
        }
        if (changes.index) {
            this.updateFocusClass();
        }
    };
    TreeViewItemContentDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    TreeViewItemContentDirective.prototype.updateFocusClass = function () {
        this.render(this.navigationService.isActive(this.index), 'k-focus');
    };
    TreeViewItemContentDirective.prototype.updateSelectionClass = function (selected) {
        this.render(selected, 'k-selected');
    };
    TreeViewItemContentDirective.prototype.render = function (addClass, className) {
        var action = addClass ? 'addClass' : 'removeClass';
        this.renderer[action](this.element.nativeElement, className);
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeViewItemContentDirective.prototype, "dataItem", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TreeViewItemContentDirective.prototype, "index", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeViewItemContentDirective.prototype, "initialSelection", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], TreeViewItemContentDirective.prototype, "isSelected", void 0);
    TreeViewItemContentDirective = __decorate([
        Directive({ selector: '[kendoTreeViewItemContent]' }),
        __metadata("design:paramtypes", [ElementRef,
            NavigationService,
            SelectionService,
            Renderer2])
    ], TreeViewItemContentDirective);
    return TreeViewItemContentDirective;
}());

/**
 * @hidden
 *
 * Represents the CheckBox component of the Kendo UI TreeView for Angular.
 *
 */
var CheckBoxComponent = /** @class */ (function () {
    function CheckBoxComponent(element, renderer, changeDetector) {
        this.element = element;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        /**
         * Specifies the [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id) of the component.
         */
        this.id = "_" + guid();
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Specifies the size of the component.
         */
        this.size = 'medium';
        /**
         * Fires when the user changes the check state of the component.
         */
        this.checkStateChange = new EventEmitter();
        this.checkState = 'none';
    }
    Object.defineProperty(CheckBoxComponent.prototype, "classWrapper", {
        //XXX: implement ComponentValueAccessor
        //XXX: focus/blur methods
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckBoxComponent.prototype, "indeterminate", {
        get: function () {
            return this.checkState === 'indeterminate';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckBoxComponent.prototype, "checked", {
        get: function () {
            return this.checkState === 'checked';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckBoxComponent.prototype, "checkBoxClasses", {
        get: function () {
            return "k-checkbox " + (this.size ? getSizeClass('checkbox', this.size) : '') + " k-rounded-md";
        },
        enumerable: true,
        configurable: true
    });
    CheckBoxComponent.prototype.ngOnInit = function () {
        this.renderer.removeAttribute(this.element.nativeElement, "tabindex");
    };
    CheckBoxComponent.prototype.ngDoCheck = function () {
        this.checkState = this.isChecked(this.node, this.index);
    };
    CheckBoxComponent.prototype.handleChange = function (e) {
        var state = e.target.checked ? 'checked' : 'none';
        // update the View State so that Angular updates the input if the isChecked value is the same
        this.checkState = state;
        this.changeDetector.detectChanges();
        this.checkStateChange.emit(state);
    };
    __decorate([
        HostBinding('class.k-checkbox-wrapper'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CheckBoxComponent.prototype, "classWrapper", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CheckBoxComponent.prototype, "id", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CheckBoxComponent.prototype, "isChecked", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CheckBoxComponent.prototype, "node", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CheckBoxComponent.prototype, "index", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CheckBoxComponent.prototype, "labelText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], CheckBoxComponent.prototype, "tabindex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CheckBoxComponent.prototype, "size", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], CheckBoxComponent.prototype, "checkStateChange", void 0);
    CheckBoxComponent = __decorate([
        Component({
            selector: 'kendo-checkbox',
            template: "\n        <input\n            type=\"checkbox\"\n            [class]=\"checkBoxClasses\"\n            [id]=\"id\"\n            [checked]=\"checked\"\n            [indeterminate]=\"indeterminate\"\n            [tabindex]=\"tabindex\"\n            (change)=\"handleChange($event)\"\n        />\n        <label\n            class=\"k-checkbox-label\"\n            tabindex=\"-1\"\n            [for]=\"id\"\n        >{{labelText}}</label>\n    "
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            ChangeDetectorRef])
    ], CheckBoxComponent);
    return CheckBoxComponent;
}());

var COMPONENT_DIRECTIVES = [
    CheckBoxComponent
];
/**
 * @hidden
 *
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the CheckBox component.
 */
var CheckBoxModule = /** @class */ (function () {
    function CheckBoxModule() {
    }
    CheckBoxModule = __decorate([
        NgModule({
            declarations: [COMPONENT_DIRECTIVES],
            exports: [COMPONENT_DIRECTIVES]
        })
    ], CheckBoxModule);
    return CheckBoxModule;
}());

/**
 * A directive which enables the update of the initially provided data array during drag-and-drop.
 *
 * Either use this directive in combination with one of the data binding directives ([`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %})
 * or [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %})) which set their own edit handlers, or provide
 * your own [`editService`]({% slug api_treeview_editservice %}) to this directive. The latter subscribes to and calls the
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * handlers when the corresponding events are triggered by the TreeView component.
 */
var DragAndDropEditingDirective = /** @class */ (function () {
    function DragAndDropEditingDirective(treeview) {
        this.treeview = treeview;
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.treeview.addItem.subscribe(this.handleAdd.bind(this)));
        this.subscriptions.add(this.treeview.removeItem.subscribe(this.handleRemove.bind(this)));
    }
    Object.defineProperty(DragAndDropEditingDirective.prototype, "editService", {
        /**
         * Specifies the handlers called on drag-and-drop [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem)
         * and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events.
         */
        set: function (service) {
            this.treeview.editService = service;
        },
        enumerable: true,
        configurable: true
    });
    DragAndDropEditingDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    DragAndDropEditingDirective.prototype.handleAdd = function (args) {
        if (!isPresent(this.treeview.editService)) {
            throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');
        }
        this.treeview.editService.add(args);
    };
    DragAndDropEditingDirective.prototype.handleRemove = function (args) {
        if (!isPresent(this.treeview.editService)) {
            throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');
        }
        this.treeview.editService.remove(args);
    };
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DragAndDropEditingDirective.prototype, "editService", null);
    DragAndDropEditingDirective = __decorate([
        Directive({
            selector: '[kendoTreeViewDragAndDropEditing]'
        }),
        __metadata("design:paramtypes", [TreeViewComponent])
    ], DragAndDropEditingDirective);
    return DragAndDropEditingDirective;
}());

var LOAD_MORE_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';
/**
 * A directive that enables the display of only a limited amount of nodes per level
 * ([see example]({% slug loadmorebutton_treeview %})).
 */
var LoadMoreDirective = /** @class */ (function () {
    function LoadMoreDirective(treeview) {
        this.treeview = treeview;
        /**
         * Keeps track of the current page size of each node over expand/collapse cycles.
         */
        this.pageSizes = new Map();
        /**
         * Used as an identifier for the root page size as the root collection of nodes is not associated with a data item.
         */
        this.rootLevelId = guid();
        this.treeview.loadMoreService = {
            getInitialPageSize: this.getInitalPageSize.bind(this),
            getGroupSize: this.getGroupSize.bind(this),
            setGroupSize: this.setGroupSize.bind(this),
            getTotalNodesCount: this.getTotalNodesCount.bind(this)
        };
    }
    Object.defineProperty(LoadMoreDirective.prototype, "loadMoreNodes", {
        /**
         * Specifies the callback that will be called when the load more button is clicked.
         * Providing a function is only required when additional nodes are fetched on demand
         * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).
         */
        set: function (loadMoreNodes) {
            if (typeof loadMoreNodes === 'string') {
                return;
            }
            this.treeview.loadMoreService.loadMoreNodes = loadMoreNodes;
        },
        enumerable: true,
        configurable: true
    });
    LoadMoreDirective.prototype.ngOnChanges = function () {
        this.verifySettings();
    };
    LoadMoreDirective.prototype.verifySettings = function () {
        if (!isDevMode()) {
            return;
        }
        if (!isPresent(this.pageSize)) {
            throw new Error("To use the TreeView `kendoTreeViewLoadMore` directive, you need to assign a `pageSize` value. See " + LOAD_MORE_DOC_LINK$1 + ".");
        }
        var loadMoreNodes = this.treeview.loadMoreService.loadMoreNodes;
        if (isPresent(loadMoreNodes) && typeof loadMoreNodes !== 'function') {
            throw new Error("The passed value to the `kendoTreeViewLoadMore` directive must be a function that retrieves additional nodes. See " + LOAD_MORE_DOC_LINK$1 + ".");
        }
        if (isPresent(loadMoreNodes) && !isPresent(this.totalField)) {
            throw new Error("When a function to fetch additional nodes is provided to the `kendoTreeViewLoadMore` directive, the `totalField` and `totalRootNodes` values must also be provided. See " + LOAD_MORE_DOC_LINK$1 + ".");
        }
    };
    LoadMoreDirective.prototype.getGroupSize = function (dataItem) {
        var itemKey = dataItem || this.rootLevelId;
        return this.pageSizes.has(itemKey) ? this.pageSizes.get(itemKey) : this.pageSize;
    };
    LoadMoreDirective.prototype.setGroupSize = function (dataItem, pageSize) {
        var itemKey = dataItem || this.rootLevelId;
        var normalizedSizeValue = pageSize > 0 ? pageSize : 0;
        this.pageSizes.set(itemKey, normalizedSizeValue);
    };
    LoadMoreDirective.prototype.getTotalNodesCount = function (dataItem, loadedNodesCount) {
        if (isPresent(dataItem) && isPresent(this.totalField)) {
            return dataItem[this.totalField];
        }
        else if (!isPresent(dataItem) && isPresent(this.totalRootNodes)) {
            return this.totalRootNodes;
        }
        else {
            return loadedNodesCount;
        }
    };
    LoadMoreDirective.prototype.getInitalPageSize = function () {
        return this.pageSize;
    };
    __decorate([
        Input('kendoTreeViewLoadMore'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], LoadMoreDirective.prototype, "loadMoreNodes", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LoadMoreDirective.prototype, "pageSize", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LoadMoreDirective.prototype, "totalRootNodes", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LoadMoreDirective.prototype, "totalField", void 0);
    LoadMoreDirective = __decorate([
        Directive({
            selector: '[kendoTreeViewLoadMore]'
        }),
        __metadata("design:paramtypes", [TreeViewComponent])
    ], LoadMoreDirective);
    return LoadMoreDirective;
}());

var COMPONENT_DIRECTIVES$1 = [
    TreeViewComponent,
    TreeViewGroupComponent,
    TreeViewItemDirective,
    TreeViewItemContentDirective,
    NodeTemplateDirective,
    CheckDirective,
    DisableDirective,
    ExpandDirective,
    SelectDirective,
    HierarchyBindingDirective,
    LoadingIndicatorDirective,
    FlatDataBindingDirective,
    DragAndDropDirective,
    DragClueTemplateDirective,
    DragClueComponent,
    DropHintTemplateDirective,
    DropHintComponent,
    DragAndDropEditingDirective,
    LoadMoreDirective,
    LoadMoreButtonTemplateDirective
];
/**
 * @hidden
 */
var SharedModule = /** @class */ (function () {
    function SharedModule() {
    }
    SharedModule = __decorate([
        NgModule({
            declarations: [COMPONENT_DIRECTIVES$1],
            exports: [COMPONENT_DIRECTIVES$1],
            imports: [
                CommonModule,
                CheckBoxModule,
                InputsModule
            ],
            entryComponents: [
                DragClueComponent,
                DropHintComponent
            ]
        })
    ], SharedModule);
    return SharedModule;
}());

var EXPORTS = [
    TreeViewComponent,
    NodeTemplateDirective,
    CheckDirective,
    DisableDirective,
    ExpandDirective,
    SelectDirective,
    HierarchyBindingDirective,
    FlatDataBindingDirective,
    DragAndDropDirective,
    DragClueTemplateDirective,
    DropHintTemplateDirective,
    DragAndDropEditingDirective,
    LoadMoreDirective,
    LoadMoreButtonTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the TreeView component.
 */
var TreeViewModule = /** @class */ (function () {
    function TreeViewModule() {
    }
    TreeViewModule = __decorate([
        NgModule({
            exports: [EXPORTS],
            imports: [SharedModule]
        })
    ], TreeViewModule);
    return TreeViewModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { CheckBoxComponent, CheckBoxModule, DataChangeNotificationService, DragClueComponent, DragClueService, DropHintComponent, DropHintService, DragAndDropAssetService, PreventableEvent, ExpandStateService, FilteringBase, IndexBuilderService, LoadingIndicatorDirective, LoadingNotificationService, NavigationService, NodeChildrenService, SelectionService, SharedModule, TreeViewGroupComponent, TreeViewItemContentDirective, TreeViewItemDirective, TreeViewLookupService, TreeViewComponent, TreeViewModule, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, DataBoundComponent, ExpandableComponent, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragAndDropEditingDirective, DropHintTemplateDirective, DragClueTemplateDirective, DropAction, DropPosition, TreeItemDropEvent, TreeItemDragStartEvent, TreeItemDragEvent, LoadMoreDirective, LoadMoreButtonTemplateDirective };
