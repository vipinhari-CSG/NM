/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Directive, EventEmitter, Input, Output, NgZone } from '@angular/core';
import { TreeViewComponent } from './treeview.component';
import { fetchLoadedDescendants, isBoolean, isPresent, noop } from './utils';
import { Subscription } from 'rxjs';
import { filter, take, switchMap, tap } from 'rxjs/operators';
import { isChanged } from '@progress/kendo-angular-common';
var indexChecked = function (keys, index) { return keys.filter(function (k) { return k === index; }).length > 0; };
var ɵ0 = indexChecked;
var matchKey = function (index) { return function (k) {
    if (index === k) {
        return true;
    }
    if (!k.split) {
        return false;
    }
    return k.split('_').reduce(function (_a, part) {
        var key = _a.key, result = _a.result;
        key += part;
        if (index === key || result) {
            return { result: true };
        }
        key += "_";
        return { key: key, result: false };
    }, { key: "", result: false }).result;
}; };
var ɵ1 = matchKey;
/**
 * A directive which manages the in-memory checked state of the TreeView node
 * ([see example]({% slug checkboxes_treeview %})).
 */
var CheckDirective = /** @class */ (function () {
    function CheckDirective(treeView, zone) {
        var _this = this;
        this.treeView = treeView;
        this.zone = zone;
        /**
         * Fires when the `checkedKeys` collection was updated.
         */
        this.checkedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this.checkActions = {
            'multiple': function (e) { return _this.checkMultiple(e); },
            'single': function (e) { return _this.checkSingle(e); }
        };
        /**
         * Reflectes the internal `checkedKeys` state.
         */
        this.state = new Set();
        this.subscriptions.add(this.treeView.checkedChange
            .subscribe(function (e) { return _this.check(e); }));
        var expandedItems = [];
        this.subscriptions.add(this.treeView.childrenLoaded
            .pipe(filter(function () { return _this.options.checkChildren && _this.treeView.loadOnDemand; }), tap(function (item) { return expandedItems.push(item); }), switchMap(function () { return _this.zone.onStable.pipe(take(1)); }))
            .subscribe(function () { return _this.addCheckedItemsChildren(expandedItems); }));
        this.treeView.isChecked = this.isItemChecked.bind(this);
    }
    Object.defineProperty(CheckDirective.prototype, "isChecked", {
        /**
         * @hidden
         */
        set: function (value) {
            this.treeView.isChecked = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckDirective.prototype, "options", {
        get: function () {
            var defaultOptions = {
                checkChildren: true,
                checkParents: true,
                enabled: true,
                mode: "multiple"
            };
            if (!isPresent(this.checkable) || typeof this.checkable === 'string') {
                return defaultOptions;
            }
            var checkSettings = isBoolean(this.checkable)
                ? { enabled: this.checkable }
                : this.checkable;
            return Object.assign(defaultOptions, checkSettings);
        },
        enumerable: true,
        configurable: true
    });
    CheckDirective.prototype.ngOnChanges = function (changes) {
        if (changes.checkable) {
            this.treeView.checkboxes = this.options.enabled;
            this.toggleCheckOnClick();
        }
        if (isChanged('checkedKeys', changes, false) && changes.checkedKeys.currentValue !== this.lastChange) {
            this.state = new Set(changes.checkedKeys.currentValue);
        }
    };
    CheckDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        this.unsubscribeClick();
    };
    CheckDirective.prototype.isItemChecked = function (dataItem, index) {
        if (!this.checkKey) {
            return this.isIndexChecked(index);
        }
        var hasKey = this.state.has(this.itemKey({ dataItem: dataItem, index: index }));
        return hasKey ? 'checked' : 'none';
    };
    CheckDirective.prototype.isIndexChecked = function (index) {
        var checkedKeys = Array.from(this.state).filter(matchKey(index));
        if (indexChecked(checkedKeys, index)) {
            return 'checked';
        }
        var _a = this.options, mode = _a.mode, checkParents = _a.checkParents;
        if (mode === 'multiple' && checkParents && checkedKeys.length) {
            return 'indeterminate';
        }
        return 'none';
    };
    CheckDirective.prototype.itemKey = function (item) {
        if (!isPresent(this.checkKey)) {
            return item.index;
        }
        if (typeof this.checkKey === "string" && isPresent(item.dataItem)) {
            return item.dataItem[this.checkKey];
        }
        if (typeof this.checkKey === "function") {
            return this.checkKey(item);
        }
    };
    CheckDirective.prototype.check = function (e) {
        var _a = this.options, enabled = _a.enabled, mode = _a.mode;
        var performSelection = this.checkActions[mode] || noop;
        if (!enabled) {
            return;
        }
        performSelection(e);
    };
    CheckDirective.prototype.checkSingle = function (node) {
        var key = this.itemKey(node.item);
        var hasKey = this.state.has(key);
        this.state.clear();
        if (!hasKey) {
            this.state.add(key);
        }
        this.notify();
    };
    CheckDirective.prototype.checkMultiple = function (node) {
        this.checkNode(node);
        if (this.options.checkParents) {
            this.checkParents(node.parent);
        }
        this.notify();
    };
    CheckDirective.prototype.toggleCheckOnClick = function () {
        var _this = this;
        this.unsubscribeClick();
        if (this.options.checkOnClick) {
            this.clickSubscription = this.treeView.nodeClick.subscribe(function (args) {
                if (args.type === 'click') {
                    var lookup = _this.treeView.itemLookup(args.item.index);
                    _this.check(lookup);
                }
            });
        }
    };
    CheckDirective.prototype.unsubscribeClick = function () {
        if (this.clickSubscription) {
            this.clickSubscription.unsubscribe();
            this.clickSubscription = null;
        }
    };
    CheckDirective.prototype.checkNode = function (node) {
        var _this = this;
        if (!isPresent(node.item.dataItem) || this.treeView.isDisabled(node.item.dataItem, node.item.index)) {
            return;
        }
        var currentKey = this.itemKey(node.item);
        if (!isPresent(currentKey)) {
            return;
        }
        var pendingCheck = [currentKey];
        if (this.options.checkChildren) {
            var descendants = fetchLoadedDescendants(node, function (_a) {
                var item = _a.item;
                return _this.treeView.isVisible(item.dataItem, item.index) &&
                    !_this.treeView.isDisabled(item.dataItem, item.index);
            })
                .map(function (_a) {
                var item = _a.item;
                return _this.itemKey(item);
            });
            pendingCheck.push.apply(pendingCheck, descendants);
        }
        var shouldCheck = !this.state.has(currentKey);
        pendingCheck.forEach(function (key) {
            if (shouldCheck) {
                _this.state.add(key);
            }
            else {
                _this.state.delete(key);
            }
        });
    };
    CheckDirective.prototype.checkParents = function (parent) {
        var _this = this;
        if (!isPresent(parent)) {
            return;
        }
        var currentParent = parent;
        while (currentParent) {
            var parentKey = this.itemKey(currentParent.item);
            var allChildrenSelected = currentParent.children.every(function (item) { return _this.state.has(_this.itemKey(item)); });
            if (allChildrenSelected) {
                this.state.add(parentKey);
            }
            else {
                this.state.delete(parentKey);
            }
            currentParent = currentParent.parent;
        }
    };
    CheckDirective.prototype.notify = function () {
        this.lastChange = Array.from(this.state);
        this.checkedKeysChange.emit(this.lastChange);
    };
    CheckDirective.prototype.addCheckedItemsChildren = function (lookups) {
        var _this = this;
        if (!isPresent(lookups) || lookups.length === 0) {
            return;
        }
        var initiallyCheckedItemsCount = this.state.size;
        lookups.forEach(function (lookup) {
            var itemKey = _this.itemKey(lookup.item);
            if (!_this.state.has(itemKey)) {
                return;
            }
            lookup.children.forEach(function (item) {
                // ensure both the parent item and each child node is enabled
                if (!_this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index) &&
                    !_this.treeView.isDisabled(item.dataItem, item.index)) {
                    _this.state.add(_this.itemKey(item));
                }
            });
        });
        var hasNewlyCheckedItems = initiallyCheckedItemsCount !== this.state.size;
        if (hasNewlyCheckedItems) {
            this.zone.run(function () { return _this.notify(); });
        }
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", [Function])
    ], CheckDirective.prototype, "isChecked", null);
    tslib_1.__decorate([
        Input("checkBy"),
        tslib_1.__metadata("design:type", Object)
    ], CheckDirective.prototype, "checkKey", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Array)
    ], CheckDirective.prototype, "checkedKeys", void 0);
    tslib_1.__decorate([
        Input('kendoTreeViewCheckable'),
        tslib_1.__metadata("design:type", Object)
    ], CheckDirective.prototype, "checkable", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], CheckDirective.prototype, "checkedKeysChange", void 0);
    CheckDirective = tslib_1.__decorate([
        Directive({ selector: '[kendoTreeViewCheckable]' }),
        tslib_1.__metadata("design:paramtypes", [TreeViewComponent,
            NgZone])
    ], CheckDirective);
    return CheckDirective;
}());
export { CheckDirective };
export { ɵ0, ɵ1 };
