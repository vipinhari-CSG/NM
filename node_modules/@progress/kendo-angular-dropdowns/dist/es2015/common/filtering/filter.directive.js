/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Directive, Input } from '@angular/core';
import { FilterableComponent } from './filterable-component';
import { getter, isArray, isPresent } from '../util';
const DEFAULT_FILTER_SETTINGS = {
    caseSensitive: false,
    operator: 'startsWith'
};
/**
 * Implements an event handler for the `filterChange` event of a DropDowns component
 * which performs simple data filtering.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-autocomplete
 *      [data]="data"
 *      kendoDropDownFilter
 *      placeholder="e.g. Andorra"
 *  >
 *  </kendo-autocomplete>
 * `
 * })
 * class AppComponent {
 *     public data: Array<string> = ["Albania", "Andorra", "Armenia", "Austria", "Azerbaijan"];
 * }
 * ```
 * > Currently, the built-in filtering does not work with [grouped data]({% slug api_kendo-data-query_groupby %}).
 */
let FilterDirective = class FilterDirective {
    constructor(component) {
        this.component = component;
        /**
         * @hidden
         *
         * Sets whether the filtering functionality is enabled on component init.
         */
        this.filterable = true;
        this._data = [];
    }
    /**
     * The initial data that will be used as a source array for the filtering operations.
     */
    set data(data) {
        this._data = data || [];
    }
    get data() {
        return this._data;
    }
    ngOnInit() {
        this.component.filterable = this.filterable;
        this.filterChangeSubscription = this.component.filterChange
            .subscribe(this.handleFilterChange.bind(this));
    }
    ngOnDestroy() {
        if (isPresent(this.filterChangeSubscription)) {
            this.filterChangeSubscription.unsubscribe();
        }
    }
    handleFilterChange(query) {
        this.component.data = this.data.filter(item => this.matchesAnyField(item, query));
    }
    matchesAnyField(item, query) {
        const normalizedQuery = this.normalizeValue(query);
        const { fields } = this.filterSettings;
        // if no filter fields are present, we are dealing with primitive data
        if (fields.length === 0) {
            return this.checkItem(item, normalizedQuery);
        }
        return fields.some(field => this.checkItem(getter(item, field), normalizedQuery));
    }
    checkItem(target, query) {
        target = this.normalizeValue(target);
        if (this.filterSettings.operator === 'contains') {
            return target.indexOf(query) !== -1;
        }
        else {
            return target.indexOf(query) === 0;
        }
    }
    normalizeValue(value) {
        const normalizedValue = isPresent(value) ? value.toString() : '';
        return this.filterSettings.caseSensitive ? normalizedValue : normalizedValue.toLowerCase();
    }
    getFilterFields(providedFields) {
        // ignore provided fields if the component deals with primitive data
        if (!this.component.textField && !this.component.valueField) {
            return [];
        }
        if (isArray(providedFields) && providedFields.length > 0) {
            return providedFields;
        }
        else {
            // the autocomplete uses `valueField` for text extraction
            const textField = this.component.textField || this.component.valueField;
            return [textField];
        }
    }
    get filterSettings() {
        const settings = this.rawSettings;
        const providedFields = isPresent(settings) && typeof settings === 'object' ? settings.fields : [];
        return Object.assign({}, DEFAULT_FILTER_SETTINGS, settings, { fields: this.getFilterFields(providedFields) });
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Array),
    tslib_1.__metadata("design:paramtypes", [Array])
], FilterDirective.prototype, "data", null);
tslib_1.__decorate([
    Input('kendoDropDownFilter'),
    tslib_1.__metadata("design:type", Object)
], FilterDirective.prototype, "rawSettings", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], FilterDirective.prototype, "filterable", void 0);
FilterDirective = tslib_1.__decorate([
    Directive({
        selector: '[kendoDropDownFilter]'
    }),
    tslib_1.__metadata("design:paramtypes", [FilterableComponent])
], FilterDirective);
export { FilterDirective };
