/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { DEFAULT_SCROLL_BEHAVIOR, DIRECTION_CLASSES } from './constants';
import { Injectable, NgZone } from '@angular/core';
import { hasObservers, isDocumentAvailable } from '@progress/kendo-angular-common';
import { Subject } from 'rxjs';
import { TabScrollEvent } from './events/tabscroll-event';
import { getActiveTab, isTablistHorizontal, mouseScrollEnabled } from './util';
/**
 * @hidden
 */
let ScrollService = class ScrollService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.position = 0;
        this.scrollButtonActiveStateChange = new Subject();
    }
    get tablistElement() {
        return this.owner.tablist.nativeElement;
    }
    get scrollButtonIconClass() {
        const tabStrip = this.owner;
        const defaultPrevIcon = isTablistHorizontal(tabStrip.tabPosition) ? DIRECTION_CLASSES.left : DIRECTION_CLASSES.up;
        const defaultNextIcon = isTablistHorizontal(tabStrip.tabPosition) ? DIRECTION_CLASSES.right : DIRECTION_CLASSES.down;
        if (typeof tabStrip.scrollable === 'object') {
            const prevIcon = typeof tabStrip.scrollable.prevButtonIcon === 'undefined' ? defaultPrevIcon : tabStrip.scrollable.prevButtonIcon;
            const nextIcon = typeof tabStrip.scrollable.nextButtonIcon === 'undefined' ? defaultNextIcon : tabStrip.scrollable.nextButtonIcon;
            return { prevScrollButton: prevIcon, nextScrollButton: nextIcon };
        }
        return { prevScrollButton: defaultPrevIcon, nextScrollButton: defaultNextIcon };
    }
    get tabstripSize() {
        const hostElement = this.owner.wrapper.nativeElement;
        const wrapperWidth = parseFloat(getComputedStyle(hostElement).width);
        const wrapperHeight = parseFloat(getComputedStyle(hostElement).height);
        return isTablistHorizontal(this.owner.tabPosition) ? wrapperWidth : wrapperHeight;
    }
    get tablistOverflowSize() {
        if (!isDocumentAvailable()) {
            return 0;
        }
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        const overflowSize = Math.floor(this.tablistElement[isHorizontal ? 'scrollWidth' : 'scrollHeight']
            - this.tablistElement.getBoundingClientRect()[isHorizontal ? 'width' : 'height']);
        return overflowSize < 0 ? 0 : overflowSize;
    }
    get tabsOverflow() {
        return this.tablistOverflowSize > 0;
    }
    get scrollButtonsSize() {
        if (!this.owner.hasScrollButtons) {
            return 0;
        }
        const prevRect = this.owner.prevScrollButton.hostBoundingClientRect;
        const prevSize = isTablistHorizontal(this.owner.tabPosition) ? prevRect.width : prevRect.height;
        const nextRect = this.owner.nextScrollButton.hostBoundingClientRect;
        const nextSize = isTablistHorizontal(this.owner.tabPosition) ? nextRect.width : nextRect.height;
        return prevSize + nextSize;
    }
    toggleScrollButtonsState() {
        const tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        const currentPrevButtonActive = !tabStrip.prevScrollButton.disabled;
        const currentNextButtonActive = !tabStrip.nextScrollButton.disabled;
        const calculatedPrevButtonActive = this.position > 0 && this.tablistOverflowSize > 0;
        const calculatedNextButtonActive = this.position < this.tablistOverflowSize + this.scrollButtonsSize && this.tablistOverflowSize > 0;
        if (calculatedPrevButtonActive !== currentPrevButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', calculatedPrevButtonActive));
        }
        if (calculatedNextButtonActive !== currentNextButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', calculatedNextButtonActive));
        }
    }
    scrollToSelectedTab() {
        if (!this.tabsOverflow) {
            return;
        }
        let { index: activeIndex } = getActiveTab(this.owner.tabs);
        if (activeIndex === -1) {
            return;
        }
        this.position += this.getScrollOffset(activeIndex);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
        const tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        const isFirstTabActive = activeIndex === 0;
        const isLastTabActive = activeIndex === this.owner.tabs.length - 1;
        if (isFirstTabActive && !tabStrip.prevScrollButton.disabled) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', false));
        }
        if (isLastTabActive && !tabStrip.nextScrollButton.disabled) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', false));
        }
    }
    getScrollOffset(activeIndex) {
        if (!isDocumentAvailable()) {
            return 0;
        }
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        this.tablistElement[`scroll${isHorizontal ? 'Left' : 'Top'}`] = this.position;
        const activeTabRect = this.tablistElement.children[activeIndex].getBoundingClientRect();
        const tablistRect = this.tablistElement.getBoundingClientRect();
        const end = isHorizontal ? 'right' : 'bottom';
        const start = isHorizontal ? 'left' : 'top';
        const activeTabStart = activeTabRect[start];
        const activeTabEnd = activeTabRect[end];
        const tablistStart = tablistRect[start];
        const tablistEnd = tablistRect[end];
        const tabEndIsInVisibleRange = activeTabEnd <= tablistEnd;
        const tabStartIsInVisibleRange = activeTabStart >= tablistStart;
        const isWholeTabVisible = tabEndIsInVisibleRange && tabStartIsInVisibleRange;
        if (isWholeTabVisible) {
            return 0;
        }
        if (!tabEndIsInVisibleRange) {
            return activeTabEnd - tablistEnd;
        }
        if (!tabStartIsInVisibleRange) {
            return activeTabStart - tablistStart;
        }
    }
    onMouseScroll(event) {
        event.preventDefault();
        if (!mouseScrollEnabled(this.owner.scrollable)) {
            return;
        }
        const direction = event.deltaY < 0 ? 'prev' : 'next';
        this.calculateListPosition(direction, this.owner.scrollable.mouseScrollSpeed);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
    }
    scrollTabs(direction) {
        this.calculateListPosition(direction, this.owner.scrollable.buttonScrollSpeed);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollTo({ left: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        else {
            this.tablistElement.scrollTo({ top: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        this.toggleScrollButtonsState();
    }
    calculateListPosition(direction, scrollSpeed) {
        const adjustedMaxScroll = this.tablistOverflowSize + this.scrollButtonsSize;
        if (direction === 'prev' && this.position > 0) {
            this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;
        }
        else if (direction === 'next' && this.position < adjustedMaxScroll) {
            if (this.position + scrollSpeed > adjustedMaxScroll) {
                this.position = adjustedMaxScroll;
                return;
            }
            this.position += scrollSpeed;
        }
    }
    emitScrollEvent(ev) {
        const scrollEvent = new TabScrollEvent({
            originalEvent: ev
        });
        if (hasObservers(this.owner.tabScroll)) {
            this.owner.tabScroll.emit(scrollEvent);
        }
        return scrollEvent;
    }
    restoreScrollPosition() {
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollTo({ left: this.position });
        }
        else {
            this.tablistElement.scrollTo({ top: this.position });
        }
        this.toggleScrollButtonsState();
    }
    toggleButtonActiveState(buttonType, active) {
        this.scrollButtonActiveStateChange.next({ buttonType, active });
    }
};
ScrollService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__metadata("design:paramtypes", [NgZone])
], ScrollService);
export { ScrollService };
