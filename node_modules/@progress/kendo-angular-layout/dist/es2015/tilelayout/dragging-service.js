/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Injectable, NgZone, Renderer2 } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { calculateCellFromPosition, getDropTarget, isRowItemPresent, normalizeValue, propsChanged, setElementStyles } from './util';
import { closestInScope } from '../common/dom-queries';
import { DRAGGED_ZINDEX, HINT_BORDERS_HEIGHT, OVERLAP_THRESHOLD, REVERSE_OVERLAP_THRESHOLD } from './constants';
import { TileLayoutReorderEvent } from './reorder-event';
import { TileLayoutResizeEvent } from './resize-event';
/**
 * @hidden
 */
let TileLayoutDraggingService = class TileLayoutDraggingService {
    constructor(zone, renderer, localization) {
        this.zone = zone;
        this.renderer = renderer;
        this.localization = localization;
        this.reorderable = new BehaviorSubject(null);
        this.resizable = new BehaviorSubject(null);
        this.reorder = new Subject();
        this.resize = new Subject();
        this.lastDragCursorOffset = {
            x: 0,
            y: 0
        };
        this.localizationSubscription = this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl);
    }
    get colStart() {
        return this.currentColStart;
    }
    get rowStart() {
        return this.currentRowStart;
    }
    get itemWrapper() {
        return this.draggedItemWrapper;
    }
    get order() {
        return this.targetOrder;
    }
    ngOnDestroy() {
        this.localizationSubscription.unsubscribe();
    }
    handlePress(originalEvent) {
        const resizing = !!originalEvent.target.classList.contains('k-resize-handle');
        const closestTile = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item'), this.tileLayoutSettings.tileLayoutElement);
        const closestHeader = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item-header'), this.tileLayoutSettings.tileLayoutElement);
        if (!closestTile) {
            return;
        }
        this.zone.run(() => {
            this.draggedItemWrapper = closestTile;
            this.draggedItem = this.tileLayoutSettings.items
                .find(item => item.order === +closestTile.style.order);
        });
        const reordering = !resizing && this.reorderable.getValue() && this.draggedItem.reorderable && closestHeader;
        if (!(reordering || resizing)) {
            return;
        }
        else {
            originalEvent.preventDefault();
        }
        this.zone.run(() => {
            this.reordering = reordering;
            this.resizing = resizing;
        });
        const tileRect = this.draggedItemWrapper.getBoundingClientRect();
        this.zone.run(() => {
            this.offset = {
                top: originalEvent.clientY - tileRect.top,
                left: originalEvent.clientX - tileRect.left,
                x: tileRect.x,
                y: tileRect.y,
                width: tileRect.width,
                height: tileRect.height
            };
            this.targetSize = {
                rowSpan: this.draggedItem.rowSpan,
                colSpan: this.draggedItem.colSpan
            };
            this.cellSize = {
                width: (tileRect.width - ((this.targetSize.colSpan - 1) * this.tileLayoutSettings.gap.columns)) / this.targetSize.colSpan,
                height: (tileRect.height - ((this.targetSize.rowSpan - 1) * this.tileLayoutSettings.gap.rows)) / this.targetSize.rowSpan
            };
            this.lastDragCursorOffset = {
                x: originalEvent.clientX,
                y: originalEvent.clientY
            };
        });
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            left: tileRect.left + window.pageXOffset + 'px',
            top: tileRect.top + window.pageYOffset + 'px',
            width: tileRect.width + 'px',
            height: tileRect.height + 'px',
            zIndex: DRAGGED_ZINDEX
        });
        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
            display: 'flex',
            height: (tileRect.height - HINT_BORDERS_HEIGHT) + 'px'
        });
        this.zone.run(() => this.targetOrder = this.draggedItem.order);
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            position: 'absolute'
        });
        if (this.reorderable.getValue() && !resizing) {
            this.zone.run(() => {
                this.currentColStart = this.draggedItem.colStart;
                this.currentRowStart = this.draggedItem.rowStart;
            });
            const headerEl = this.draggedItem.elem.nativeElement.querySelector('.k-tilelayout-item-header');
            this.renderer.addClass(headerEl, 'k-cursor-grabbing');
        }
        else if (this.resizable && resizing) {
            this.zone.run(() => {
                this.startingPoint = {
                    top: originalEvent.clientY,
                    left: originalEvent.clientX
                };
                this.currentResizingColSpan = this.draggedItem.colSpan;
                this.currentResizingRowSpan = this.draggedItem.rowSpan;
                if (this.draggedItem.col) {
                    this.currentColStart = this.draggedItem.col.toString();
                }
                if (this.draggedItem.row) {
                    this.currentRowStart = this.draggedItem.row.toString();
                }
                this.direction = originalEvent.target.classList[1];
            });
        }
    }
    handleDrag(originalEvent) {
        if (this.draggedItemWrapper) {
            if (this.reordering) {
                this.reorderItems(originalEvent);
            }
            else if (this.resizing) {
                this.resizeItem(originalEvent);
            }
            this.lastDragCursorOffset = {
                x: originalEvent.clientX,
                y: originalEvent.clientY
            };
        }
    }
    handleRelease(originalEvent) {
        originalEvent.preventDefault();
        if (this.reordering) {
            const initialOrder = this.draggedItem.order;
            const initialCol = this.draggedItem.col;
            const initialRow = this.draggedItem.row;
            const targetCol = normalizeValue(this.currentColStart);
            const targetRow = normalizeValue(this.currentRowStart);
            if (propsChanged([this.targetOrder, targetCol, targetRow], [initialOrder, initialCol, initialRow])) {
                const reorderEvent = new TileLayoutReorderEvent(this.draggedItem, this.tileLayoutSettings.items, this.targetOrder, initialOrder, normalizeValue(this.currentColStart), initialCol, targetRow, initialRow);
                this.reorder.next(reorderEvent);
                if (!reorderEvent.isDefaultPrevented()) {
                    if (this.targetOrder > initialOrder) {
                        this.zone.run(() => {
                            for (let i = initialOrder + 1; i <= this.targetOrder; i++) {
                                this.tileLayoutSettings.items.find(item => item.order === i).order = i - 1;
                            }
                        });
                    }
                    else {
                        this.zone.run(() => {
                            for (let i = this.targetOrder; i < initialOrder; i++) {
                                this.tileLayoutSettings.items.find(item => item.order === i).order = i + 1;
                            }
                        });
                    }
                    this.draggedItem.order = this.targetOrder;
                    if (this.draggedItem.col) {
                        this.draggedItem.col = +this.currentColStart;
                    }
                    if (this.draggedItem.row) {
                        this.draggedItem.row = +this.currentRowStart;
                    }
                }
            }
            this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
            this.zone.run(() => this.cleanUp());
        }
        else if (!this.reordering && this.resizing) {
            const initialRowSpan = this.draggedItem.rowSpan;
            const initialColSpan = this.draggedItem.colSpan;
            const { targetColSpan, targetRowSpan } = isRowItemPresent(this.tileLayoutSettings.items) ?
                this.targetSpan() :
                { targetColSpan: this.currentResizingColSpan, targetRowSpan: this.currentResizingRowSpan };
            if (propsChanged([initialRowSpan, initialColSpan], [targetRowSpan, targetColSpan])) {
                const resizeEvent = new TileLayoutResizeEvent(this.draggedItem, this.tileLayoutSettings.items, targetRowSpan, initialRowSpan, targetColSpan, initialColSpan);
                this.resize.next(resizeEvent);
                if (!resizeEvent.isDefaultPrevented()) {
                    this.draggedItem.colSpan = this.currentResizingColSpan;
                    this.draggedItem.rowSpan = this.currentResizingRowSpan;
                }
            }
            this.zone.run(() => this.cleanUp());
        }
    }
    reorderItems(event) {
        const targets = getDropTarget(event);
        const closestTile = targets.find(t => t !== this.draggedItemWrapper);
        let tileOrder = closestTile ? +closestTile.style.order : +this.draggedItemWrapper.style.order;
        if (this.tileLayoutSettings.autoFlow !== 'none') {
            const deltaX = event.clientX - this.lastDragCursorOffset.x;
            const deltaY = event.clientY - this.lastDragCursorOffset.y;
            const directionX = deltaX > 0 ? 'right' : deltaX < 0 ? 'left' : undefined;
            const directionY = deltaY > 0 ? 'down' : deltaX < 0 ? 'up' : undefined;
            const rect = this.draggedItemWrapper.getBoundingClientRect();
            const horizontalGap = this.tileLayoutSettings.gap.columns;
            const verticalGap = this.tileLayoutSettings.gap.rows;
            if (directionX && this.draggedItem.col) {
                const { col } = calculateCellFromPosition({
                    x: directionX === 'right' ? rect.right - horizontalGap : rect.left + horizontalGap,
                    y: event.clientY
                }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
                const targetStartCol = this.getTargetCol(col, directionX);
                this.currentColStart = targetStartCol.toString();
            }
            if (directionY && this.draggedItem.row) {
                const { row } = calculateCellFromPosition({
                    x: event.clientX,
                    y: directionY === 'down' ? rect.bottom - verticalGap : rect.top + verticalGap
                }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
                const targetStartRow = this.getTargetRow(row, directionY);
                this.currentRowStart = targetStartRow.toString();
            }
        }
        const hintBefore = tileOrder < this.targetOrder;
        const hintAfter = tileOrder > this.targetOrder;
        this.zone.run(() => this.targetOrder = tileOrder);
        if (hintBefore) {
            this.tileLayoutSettings.tileLayoutElement
                .insertBefore(this.tileLayoutSettings.hintElement, this.tileLayoutSettings.tileLayoutElement.firstChild);
        }
        else if (hintAfter) {
            this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
        }
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            top: (event.pageY - this.offset.top) + 'px',
            left: (event.pageX - this.offset.left) + 'px'
        });
    }
    resizeItem(event) {
        setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
            cursor: this.direction.split('k-cursor-')[1]
        });
        const currentWidth = this.rtl ?
            this.offset.width + (this.offset.x - event.clientX) :
            this.offset.width + (event.clientX - this.startingPoint.left);
        const currentHeight = this.offset.height + (event.clientY - this.startingPoint.top);
        const hintRect = this.tileLayoutSettings.hintElement.getBoundingClientRect();
        const hintWidth = hintRect.width;
        const hintHeight = hintRect.height;
        const horizontalDragDirection = event.clientX - this.lastDragCursorOffset.x;
        const verticalDragDirection = event.clientY - this.lastDragCursorOffset.y;
        const startCol = this.draggedItem.col ? this.draggedItem.col : calculateCellFromPosition({
            x: this.rtl ? hintRect.right : hintRect.x,
            y: hintRect.y
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl).col;
        const maxWidth = (this.tileLayoutSettings.columns - startCol) * (this.cellSize.width + this.tileLayoutSettings.gap.columns) + this.cellSize.width;
        const resizeHorizontally = () => {
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                width: Math.min(Math.max(currentWidth, this.cellSize.width), maxWidth) + 'px'
            });
            if (this.rtl && currentWidth > this.cellSize.width) {
                const totalWidth = this.tileLayoutSettings.columns * (this.cellSize.width + this.tileLayoutSettings.gap.columns);
                const leftBoundary = this.tileLayoutSettings.tileLayoutElement.getBoundingClientRect().right - totalWidth;
                setElementStyles(this.renderer, this.draggedItemWrapper, {
                    left: Math.max(event.clientX, leftBoundary) + 'px'
                });
            }
            const deltaX = currentWidth - hintWidth;
            const { x, y, right } = this.draggedItem.elem.nativeElement.getBoundingClientRect();
            const { col } = calculateCellFromPosition({ x: (this.rtl ? right : x), y: y }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
            const resizedColSpan = col + this.currentResizingColSpan;
            const expandingCondition = this.rtl ? horizontalDragDirection < 0 : horizontalDragDirection > 0;
            const shrinkingCondition = this.rtl ? horizontalDragDirection > 0 : horizontalDragDirection < 0;
            if (deltaX > OVERLAP_THRESHOLD * this.cellSize.width &&
                expandingCondition &&
                resizedColSpan <= this.tileLayoutSettings.columns) {
                this.currentResizingColSpan++;
            }
            else if (this.currentResizingColSpan > 1 &&
                shrinkingCondition &&
                deltaX < REVERSE_OVERLAP_THRESHOLD * this.cellSize.width) {
                this.currentResizingColSpan--;
            }
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                gridColumnEnd: `span ${this.currentResizingColSpan}`
            });
        };
        const resizeVertically = () => {
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                height: Math.max(currentHeight, this.cellSize.height) + 'px'
            });
            const deltaY = currentHeight - hintHeight;
            if (deltaY > OVERLAP_THRESHOLD * this.cellSize.height && verticalDragDirection > 0) {
                this.currentResizingRowSpan++;
            }
            else if (this.currentResizingRowSpan > 1 &&
                verticalDragDirection < 0 && deltaY < REVERSE_OVERLAP_THRESHOLD * this.cellSize.height) {
                this.currentResizingRowSpan--;
            }
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                gridRowEnd: `span ${this.currentResizingRowSpan}`
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                height: `${this.calculateHintHeight()}px`
            });
        };
        if (this.direction.indexOf('ew') > -1) {
            resizeHorizontally();
        }
        else if (this.direction.indexOf('ns') > -1) {
            resizeVertically();
        }
        else {
            resizeHorizontally();
            resizeVertically();
        }
    }
    cleanUp() {
        this.targetOrder = this.currentResizingColSpan = this.currentColStart = this.currentResizingRowSpan = this.currentRowStart = undefined;
        this.resizing = this.reordering = false;
        this.direction = null;
        if (this.draggedItemWrapper) {
            const grabHandle = this.draggedItemWrapper.querySelector('.k-cursor-grab');
            if (grabHandle) {
                this.renderer.removeClass(grabHandle, 'k-cursor-grabbing');
            }
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                top: '',
                left: '',
                display: '',
                width: '',
                height: '',
                zIndex: '',
                position: ''
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                display: 'none',
                height: 'auto'
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
                cursor: 'default'
            });
            this.draggedItemWrapper =
                this.offset =
                    this.draggedItem =
                        this.resizing =
                            this.reordering =
                                this.currentResizingColSpan =
                                    this.currentResizingRowSpan =
                                        this.startingPoint = undefined;
            this.lastDragCursorOffset = {
                x: 0,
                y: 0
            };
        }
    }
    targetSpan() {
        const itemRect = this.draggedItem.elem.nativeElement.getBoundingClientRect();
        const startingCell = calculateCellFromPosition({ x: this.rtl ? itemRect.right : itemRect.x, y: itemRect.y }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        const targetEndCell = calculateCellFromPosition({
            x: this.rtl ? itemRect.x + OVERLAP_THRESHOLD * this.cellSize.width : itemRect.right - OVERLAP_THRESHOLD * this.cellSize.width,
            y: itemRect.bottom - OVERLAP_THRESHOLD * this.cellSize.height
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        return {
            targetColSpan: targetEndCell.col - startingCell.col + 1,
            targetRowSpan: targetEndCell.row - startingCell.row + 1
        };
    }
    getTargetCol(col, direction) {
        if (this.rtl) {
            return direction === 'left' ? col - this.draggedItem.colSpan + 1 : col;
        }
        return direction === 'right' ? col - this.draggedItem.colSpan + 1 : col;
    }
    getTargetRow(row, direction) {
        return direction === 'down' ? row - this.draggedItem.rowSpan + 1 : row;
    }
    calculateHintHeight() {
        const totalHintCellsHeight = this.currentResizingRowSpan * this.cellSize.height;
        const totalHintGapsHeight = (this.currentResizingRowSpan - 1) * this.tileLayoutSettings.gap.rows;
        const hintHeight = totalHintCellsHeight + totalHintGapsHeight - HINT_BORDERS_HEIGHT;
        return hintHeight;
    }
};
TileLayoutDraggingService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__metadata("design:paramtypes", [NgZone,
        Renderer2,
        LocalizationService])
], TileLayoutDraggingService);
export { TileLayoutDraggingService };
